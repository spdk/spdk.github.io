<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.13">
  <title>SPDK: Vhost processing</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-sm-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://ci.spdk.io/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/roadmap/">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vhost_processing.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Vhost processing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="vhost_processing_toc"></a>
Table of Contents</h1>
<ul>
<li><a class="el" href="vhost_processing.html#vhost_processing_intro">Introduction</a></li>
<li><a class="el" href="vhost_processing.html#vhost_processing_qemu">QEMU</a></li>
<li><a class="el" href="vhost_processing.html#vhost_processing_init">Device initialization</a></li>
<li><a class="el" href="vhost_processing.html#vhost_processing_io_path">I/O path</a></li>
</ul>
<h1><a class="anchor" id="vhost_processing_intro"></a>
Introduction</h1>
<p>This document is intended to provide an overall high level insight into how Vhost works behind the scenes. It assumes you're already familiar with the basics of virtqueues and vrings from the <a href="http://docs.oasis-open.org/virtio/virtio/v1.0/virtio-v1.0.html">VIRTIO protocol</a>. Code snippets used in this document might have been simplified for the sake of readability and should not be used as an API or implementation reference.</p>
<p>vhost is a protocol for devices accessible via inter-process communication. It uses the same virtqueue and vring layout for I/O transport as VIRTIO to allow direct mapping to Virtio devices. The initial vhost implementation is a part of the Linux kernel and uses ioctl interface to communicate with userspace applications. What makes it possible for SPDK to expose a vhost device is Vhost-user protocol.</p>
<p>The <a href="https://git.qemu.org/?p=qemu.git;a=blob_plain;f=docs/interop/vhost-user.txt;hb=HEAD">Vhost-user specification</a> describes the protocol as follows:</p>
<div class="fragment"><div class="line">[Vhost-user protocol] is aiming to complement the ioctl interface used to</div><div class="line">control the vhost implementation in the Linux kernel. It implements the control</div><div class="line">plane needed to establish virtqueue sharing with a user space process on the</div><div class="line">same host. It uses communication over a Unix domain socket to share file</div><div class="line">descriptors in the ancillary data of the message.</div><div class="line"></div><div class="line">The protocol defines 2 sides of the communication, master and slave. Master is</div><div class="line">the application that shares its virtqueues, in our case QEMU. Slave is the</div><div class="line">consumer of the virtqueues.</div><div class="line"></div><div class="line">In the current implementation QEMU is the Master, and the Slave is intended to</div><div class="line">be a software Ethernet switch running in user space, such as Snabbswitch.</div><div class="line"></div><div class="line">Master and slave can be either a client (i.e. connecting) or server (listening)</div><div class="line">in the socket communication.</div></div><!-- fragment --><p>SPDK vhost is a Vhost-user slave server. It exposes Unix domain sockets and allows external applications to connect.</p>
<h1><a class="anchor" id="vhost_processing_qemu"></a>
QEMU</h1>
<p>One of major Vhost-user use cases is networking (DPDK) or storage (SPDK) offload in QEMU. The following diagram presents how QEMU-based VM communicates with SPDK Vhost-SCSI device.</p>
<div class="image">
<object type="image/svg+xml" data="qemu_vhost_data_flow.svg">qemu_vhost_data_flow.svg</object>
<div class="caption">
QEMU/SPDK vhost data flow</div></div>
<p> The irqfd mechanism isn't described in this document, as it KVM/QEMU-specific. Briefly speaking, doing an eventfd_write on the callfd descriptor will directly interrupt the guest because of irqfd.</p>
<h1><a class="anchor" id="vhost_processing_init"></a>
Device initialization</h1>
<p>All initialization and management information is exchanged via the Vhost-user messages. The connection always starts with the feature negotiation. Both the Master and the Slave exposes a list of their implemented features. Most of these features are implementation-related, but also regard e.g. multiqueue support or live migration. A feature will be used only if both sides support it.</p>
<p>After the negotiatiation Vhost-user driver shares its memory, so that the vhost device (SPDK) can access it directly. The memory can be fragmented into multiple physically-discontiguous regions, although Vhost-user specification enforces a limit on their number (currently 8). The driver sends a single message with the following data for each region:</p><ul>
<li>file descriptor - for mmap</li>
<li>user address - for memory translations in Vhost-user messages (e.g. translating vring addresses)</li>
<li>guest address - for buffers addresses translations in vrings (for QEMU this is a physical address inside the guest)</li>
<li>user offset - positive offset for the mmap</li>
<li>size</li>
</ul>
<p>The Master will send new memory regions after each memory change - usually hotplug/hotremove. The previous mappings will be removed.</p>
<p>Drivers may also request a device config, consisting of e.g. disk geometry. Vhost-SCSI drivers, however, don't need implement this functionality as they use common SCSI I/O to inquiry the underlying disk(s).</p>
<p>Afterwards, the driver requests the number of maximum supported queues and starts sending virtqueue data, which consists of:</p><ul>
<li>unique virtqueue id</li>
<li>index of the last processed vring descriptor</li>
<li>vring addresses (from user address space)</li>
<li>call descriptor (for interrupting the driver after I/O completions)</li>
<li>kick descriptor (to listen for I/O requests - unused by SPDK)</li>
</ul>
<p>If multiqueue feature has been negotiated, the driver has to send a specific <em>ENABLE</em> message for each extra queue it wants to be polled. Other queues are polled as soon as they're initialized.</p>
<h1><a class="anchor" id="vhost_processing_io_path"></a>
I/O path</h1>
<p>The Master sends I/O by allocating proper buffers in shared memory, filling the request data, and putting guest addresses of those buffers into virtqueues.</p>
<p>A Virtio-Block request looks as follows.</p>
<div class="fragment"><div class="line">struct virtio_blk_req {</div><div class="line">        uint32_t type; // READ, WRITE, FLUSH (read-only)</div><div class="line">        uint64_t offset; // offset in the disk (read-only)</div><div class="line">        struct iovec buffers[]; // scatter-gatter list (read/write)</div><div class="line">        uint8_t status; // I/O completion status (write-only)</div><div class="line">};</div></div><!-- fragment --><p> And a Virtio-SCSI request as follows.</p>
<div class="fragment"><div class="line">struct virtio_scsi_req_cmd {</div><div class="line">  struct virtio_scsi_cmd_req *req; // request data (read-only)</div><div class="line">  struct iovec read_only_buffers[]; // scatter-gatter list for WRITE I/Os</div><div class="line">  struct virtio_scsi_cmd_resp *resp; // response data (write-only)</div><div class="line">  struct iovec write_only_buffers[]; // scatter-gatter list for READ I/Os</div><div class="line">}</div></div><!-- fragment --><p>Virtqueue generally consists of an array of descriptors and each I/O needs to be converted into a chain of such descriptors. A descriptor can be either readable or writable, so each I/O request must consist of at least two descriptors (request + response).</p>
<div class="fragment"><div class="line">struct virtq_desc {</div><div class="line">        /* Address (guest-physical). */</div><div class="line">        le64 addr;</div><div class="line">        /* Length. */</div><div class="line">        le32 len;</div><div class="line"></div><div class="line">/* This marks a buffer as continuing via the next field. */</div><div class="line">#define VIRTQ_DESC_F_NEXT   1</div><div class="line">/* This marks a buffer as device write-only (otherwise device read-only). */</div><div class="line">#define VIRTQ_DESC_F_WRITE     2</div><div class="line">        /* The flags as indicated above. */</div><div class="line">        le16 flags;</div><div class="line">        /* Next field if flags &amp; NEXT */</div><div class="line">        le16 next;</div><div class="line">};</div></div><!-- fragment --><p>The device after polling this descriptor chain needs to translate and transform it back into the original request struct. It needs to know the request layout up-front, so each device backend (Vhost-Block/SCSI) has its own implementation for polling virtqueues. For each descriptor, the device performs a lookup in the Vhost-user memory region table and goes through a gpa_to_vva translation (guest physical address to vhost virtual address). SPDK enforces the request and response data to be contained within a single memory region. I/O buffers do not have such limitations and SPDK may automatically perform additional iovec splitting and gpa_to_vva translations if required. After forming request structs, SPDK forwards such I/O to the underlying drive and polls for the completion. Once I/O completes, SPDK vhost fills the response buffer with proper data and interrupts the guest by doing an eventfd_write on the call descriptor for proper virtqueue. There are multiple interrupt coalescing features involved, but they won't be discussed in this document. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
</div>
