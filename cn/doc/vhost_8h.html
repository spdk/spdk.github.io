<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.13">
  <title>SPDK: vhost.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-sm-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://ci.spdk.io/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/roadmap/">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vhost_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vhost.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>SPDK vhost.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8b37106ad173f20d05da87f89714700b"><td class="memItemLeft" align="right" valign="top"><a id="a8b37106ad173f20d05da87f89714700b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a8b37106ad173f20d05da87f89714700b">spdk_vhost_fini_cb</a>) (void)</td></tr>
<tr class="memdesc:a8b37106ad173f20d05da87f89714700b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback funcion for <a class="el" href="vhost_8h.html#af358eac95a16bd456349fcfaa00379bb" title="Clean up the environment of vhost after finishing the vhost application. ">spdk_vhost_fini()</a>. <br /></td></tr>
<tr class="separator:a8b37106ad173f20d05da87f89714700b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c4b62eaf6503e5f5e520394f9f9fe1"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a>) (struct spdk_vhost_dev *vdev, void *arg)</td></tr>
<tr class="memdesc:ac2c4b62eaf6503e5f5e520394f9f9fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronized vhost event used for user callbacks.  <a href="#ac2c4b62eaf6503e5f5e520394f9f9fe1">More...</a><br /></td></tr>
<tr class="separator:ac2c4b62eaf6503e5f5e520394f9f9fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a15921078a895d090283fbbeaaddee76c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a15921078a895d090283fbbeaaddee76c">spdk_vhost_set_socket_path</a> (const char *basename)</td></tr>
<tr class="memdesc:a15921078a895d090283fbbeaaddee76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the path to the directory where vhost sockets will be created.  <a href="#a15921078a895d090283fbbeaaddee76c">More...</a><br /></td></tr>
<tr class="separator:a15921078a895d090283fbbeaaddee76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38abeca2169a11feec2ecdce057f3263"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a38abeca2169a11feec2ecdce057f3263">spdk_vhost_init</a> (void)</td></tr>
<tr class="memdesc:a38abeca2169a11feec2ecdce057f3263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init vhost environment.  <a href="#a38abeca2169a11feec2ecdce057f3263">More...</a><br /></td></tr>
<tr class="separator:a38abeca2169a11feec2ecdce057f3263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af358eac95a16bd456349fcfaa00379bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#af358eac95a16bd456349fcfaa00379bb">spdk_vhost_fini</a> (<a class="el" href="vhost_8h.html#a8b37106ad173f20d05da87f89714700b">spdk_vhost_fini_cb</a> fini_cb)</td></tr>
<tr class="memdesc:af358eac95a16bd456349fcfaa00379bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up the environment of vhost after finishing the vhost application.  <a href="#af358eac95a16bd456349fcfaa00379bb">More...</a><br /></td></tr>
<tr class="separator:af358eac95a16bd456349fcfaa00379bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b809e050d9157d2b85cd01673bccb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a39b809e050d9157d2b85cd01673bccb9">spdk_vhost_config_json</a> (struct spdk_json_write_ctx *w, struct spdk_event *done_ev)</td></tr>
<tr class="memdesc:a39b809e050d9157d2b85cd01673bccb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write vhost subsystem configuration into provided JSON context.  <a href="#a39b809e050d9157d2b85cd01673bccb9">More...</a><br /></td></tr>
<tr class="separator:a39b809e050d9157d2b85cd01673bccb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7159f8eb1e0d65dad5bedaa6cc5e43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#afd7159f8eb1e0d65dad5bedaa6cc5e43">spdk_vhost_shutdown_cb</a> (void)</td></tr>
<tr class="memdesc:afd7159f8eb1e0d65dad5bedaa6cc5e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinit vhost application.  <a href="#afd7159f8eb1e0d65dad5bedaa6cc5e43">More...</a><br /></td></tr>
<tr class="separator:afd7159f8eb1e0d65dad5bedaa6cc5e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06efc0d096d4414de40ed5c0b394622"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#aa06efc0d096d4414de40ed5c0b394622">spdk_vhost_dev_get_name</a> (struct spdk_vhost_dev *vdev)</td></tr>
<tr class="memdesc:aa06efc0d096d4414de40ed5c0b394622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the vhost device.  <a href="#aa06efc0d096d4414de40ed5c0b394622">More...</a><br /></td></tr>
<tr class="separator:aa06efc0d096d4414de40ed5c0b394622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6002d25166c3003efd3b6edb51cb84c0"><td class="memItemLeft" align="right" valign="top">const struct spdk_cpuset *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a6002d25166c3003efd3b6edb51cb84c0">spdk_vhost_dev_get_cpumask</a> (struct spdk_vhost_dev *vdev)</td></tr>
<tr class="memdesc:a6002d25166c3003efd3b6edb51cb84c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cpuset of the vhost device.  <a href="#a6002d25166c3003efd3b6edb51cb84c0">More...</a><br /></td></tr>
<tr class="separator:a6002d25166c3003efd3b6edb51cb84c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8c054fdc8ed4ad573b2d0bcf2d4797"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a8b8c054fdc8ed4ad573b2d0bcf2d4797">spdk_vhost_set_coalescing</a> (struct spdk_vhost_dev *vdev, uint32_t delay_base_us, uint32_t iops_threshold)</td></tr>
<tr class="memdesc:a8b8c054fdc8ed4ad573b2d0bcf2d4797"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, events are generated when asked, but for high queue depth and high IOPS this prove to be inefficient both for guest kernel that have to handle a lot more IO completions and for SPDK vhost that need to make more syscalls.  <a href="#a8b8c054fdc8ed4ad573b2d0bcf2d4797">More...</a><br /></td></tr>
<tr class="separator:a8b8c054fdc8ed4ad573b2d0bcf2d4797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be392083ae01ad34cc05b1b5ce2b5e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a8be392083ae01ad34cc05b1b5ce2b5e0">spdk_vhost_get_coalescing</a> (struct spdk_vhost_dev *vdev, uint32_t *delay_base_us, uint32_t *iops_threshold)</td></tr>
<tr class="memdesc:a8be392083ae01ad34cc05b1b5ce2b5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get coalescing parameters.  <a href="#a8be392083ae01ad34cc05b1b5ce2b5e0">More...</a><br /></td></tr>
<tr class="separator:a8be392083ae01ad34cc05b1b5ce2b5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b54a11439216fb05196474e3ee20d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a01b54a11439216fb05196474e3ee20d1">spdk_vhost_scsi_dev_construct</a> (const char *name, const char *cpumask)</td></tr>
<tr class="memdesc:a01b54a11439216fb05196474e3ee20d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty vhost SCSI device.  <a href="#a01b54a11439216fb05196474e3ee20d1">More...</a><br /></td></tr>
<tr class="separator:a01b54a11439216fb05196474e3ee20d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546673fa252a8214efd14fc80b78dcb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a546673fa252a8214efd14fc80b78dcb9">spdk_vhost_scsi_dev_add_tgt</a> (struct spdk_vhost_dev *vdev, unsigned scsi_tgt_num, const char *bdev_name)</td></tr>
<tr class="memdesc:a546673fa252a8214efd14fc80b78dcb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and attach new SCSI target to the vhost SCSI device on given (unoccupied) slot.  <a href="#a546673fa252a8214efd14fc80b78dcb9">More...</a><br /></td></tr>
<tr class="separator:a546673fa252a8214efd14fc80b78dcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540442ab4b6ec0ba4157e514a09f2379"><td class="memItemLeft" align="right" valign="top">struct spdk_scsi_dev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a540442ab4b6ec0ba4157e514a09f2379">spdk_vhost_scsi_dev_get_tgt</a> (struct spdk_vhost_dev *vdev, uint8_t num)</td></tr>
<tr class="memdesc:a540442ab4b6ec0ba4157e514a09f2379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SCSI target from vhost SCSI device on given slot.  <a href="#a540442ab4b6ec0ba4157e514a09f2379">More...</a><br /></td></tr>
<tr class="separator:a540442ab4b6ec0ba4157e514a09f2379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ea27c8ae7616e92d916e5c6fc34231"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#ae1ea27c8ae7616e92d916e5c6fc34231">spdk_vhost_scsi_dev_remove_tgt</a> (struct spdk_vhost_dev *vdev, unsigned scsi_tgt_num, <a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ae1ea27c8ae7616e92d916e5c6fc34231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach and destruct SCSI target from a vhost SCSI device.  <a href="#ae1ea27c8ae7616e92d916e5c6fc34231">More...</a><br /></td></tr>
<tr class="separator:ae1ea27c8ae7616e92d916e5c6fc34231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec56730c6a42b0a186131526026e619"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a5ec56730c6a42b0a186131526026e619">spdk_vhost_blk_construct</a> (const char *name, const char *cpumask, const char *dev_name, bool readonly)</td></tr>
<tr class="memdesc:a5ec56730c6a42b0a186131526026e619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vhost blk device.  <a href="#a5ec56730c6a42b0a186131526026e619">More...</a><br /></td></tr>
<tr class="separator:a5ec56730c6a42b0a186131526026e619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6eba1ce0ac89c3287b755567795869b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#aa6eba1ce0ac89c3287b755567795869b">spdk_vhost_dev_remove</a> (struct spdk_vhost_dev *vdev)</td></tr>
<tr class="memdesc:aa6eba1ce0ac89c3287b755567795869b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a vhost device.  <a href="#aa6eba1ce0ac89c3287b755567795869b">More...</a><br /></td></tr>
<tr class="separator:aa6eba1ce0ac89c3287b755567795869b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549f9903be61ca447578b8bacf9eea81"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a549f9903be61ca447578b8bacf9eea81">spdk_vhost_blk_get_dev</a> (struct spdk_vhost_dev *ctrlr)</td></tr>
<tr class="memdesc:a549f9903be61ca447578b8bacf9eea81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get underlying SPDK bdev from vhost blk device.  <a href="#a549f9903be61ca447578b8bacf9eea81">More...</a><br /></td></tr>
<tr class="separator:a549f9903be61ca447578b8bacf9eea81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44001761e6a888ef1fb0475c4501497c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a44001761e6a888ef1fb0475c4501497c">spdk_vhost_call_external_event</a> (const char *vdev_name, <a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a> fn, void *arg)</td></tr>
<tr class="memdesc:a44001761e6a888ef1fb0475c4501497c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call function on reactor of given vhost device.  <a href="#a44001761e6a888ef1fb0475c4501497c">More...</a><br /></td></tr>
<tr class="separator:a44001761e6a888ef1fb0475c4501497c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041d593f592b76683c6a5f9f5efbc254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a041d593f592b76683c6a5f9f5efbc254">spdk_vhost_call_external_event_foreach</a> (<a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a> fn, void *arg)</td></tr>
<tr class="memdesc:a041d593f592b76683c6a5f9f5efbc254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call function for each available vhost device on it's reactor.  <a href="#a041d593f592b76683c6a5f9f5efbc254">More...</a><br /></td></tr>
<tr class="separator:a041d593f592b76683c6a5f9f5efbc254"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SPDK vhost. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac2c4b62eaf6503e5f5e520394f9f9fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c4b62eaf6503e5f5e520394f9f9fe1">&#9670;&nbsp;</a></span>spdk_vhost_event_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_vhost_event_fn) (struct spdk_vhost_dev *vdev, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronized vhost event used for user callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device. </td></tr>
    <tr><td class="paramname">arg</td><td>user-provided parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5ec56730c6a42b0a186131526026e619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec56730c6a42b0a186131526026e619">&#9670;&nbsp;</a></span>spdk_vhost_blk_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_blk_construct </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cpumask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dev_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readonly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a vhost blk device. </p>
<p>This will create a Unix domain socket together with a vhost-user slave server waiting for a connection on this socket. Creating the vdev does not start any I/O pollers and does not hog the CPU. I/O processing starts after receiving proper message on the created socket. See QEMU's vhost-user documentation for details. Vhost blk device is tightly associated with given SPDK bdev. Given bdev can not be changed, unless it has been hotremoved. This would result in all I/O failing with virtio <code>VIRTIO_BLK_S_IOERR</code> error code.</p>
<p>This function is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the vhost blk device. The name will also be used for socket name, which is exactly <code>socket_base_dir/name</code> </td></tr>
    <tr><td class="paramname">cpumask</td><td>string containing cpumask in hex. The leading <em>0x</em> is allowed but not required. The mask itself can be constructed as: ((1 &lt;&lt; cpu0) | (1 &lt;&lt; cpu1) | ... | (1 &lt;&lt; cpuN)). </td></tr>
    <tr><td class="paramname">dev_name</td><td>bdev name to associate with this vhost device </td></tr>
    <tr><td class="paramname">readonly</td><td>if set, all writes to the device will fail with <code>VIRTIO_BLK_S_IOERR</code> error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a549f9903be61ca447578b8bacf9eea81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549f9903be61ca447578b8bacf9eea81">&#9670;&nbsp;</a></span>spdk_vhost_blk_get_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a>* spdk_vhost_blk_get_dev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get underlying SPDK bdev from vhost blk device. </p>
<p>The bdev might be NULL, as it could have been hotremoved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>vhost blk device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPDK bdev associated with given vdev. </dd></dl>

</div>
</div>
<a id="a44001761e6a888ef1fb0475c4501497c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44001761e6a888ef1fb0475c4501497c">&#9670;&nbsp;</a></span>spdk_vhost_call_external_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_call_external_event </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vdev_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call function on reactor of given vhost device. </p>
<p>If device is not in use, the event will be called right away on the caller's thread.</p>
<p>This function is thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev_name</td><td>name of the vhost device to run this event on. </td></tr>
    <tr><td class="paramname">fn</td><td>function to be called. The first parameter of callback function is either actual spdk_vhost_dev pointer or NULL in case vdev with given name doesn't exist. The second param is user provided argument <em>arg</em>. </td></tr>
    <tr><td class="paramname">arg</td><td>parameter to be passed to <em>fn</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a041d593f592b76683c6a5f9f5efbc254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041d593f592b76683c6a5f9f5efbc254">&#9670;&nbsp;</a></span>spdk_vhost_call_external_event_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_call_external_event_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call function for each available vhost device on it's reactor. </p>
<p>This will call given function in a chain, meaning that each callback will be called after the previous one has finished. After given function has been called for all vdevs, it will be called once again with first param - vhost device- set to NULL.</p>
<p>This function is thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>function to be called for each vdev. The first param will be either vdev pointer or NULL. The second param is user provided argument <em>arg</em>. </td></tr>
    <tr><td class="paramname">arg</td><td>parameter to be passed to <em>fn</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39b809e050d9157d2b85cd01673bccb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b809e050d9157d2b85cd01673bccb9">&#9670;&nbsp;</a></span>spdk_vhost_config_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_config_json </td>
          <td>(</td>
          <td class="paramtype">struct spdk_json_write_ctx *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_event *&#160;</td>
          <td class="paramname"><em>done_ev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write vhost subsystem configuration into provided JSON context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>JSON write context </td></tr>
    <tr><td class="paramname">done_ev</td><td>call this event when done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6002d25166c3003efd3b6edb51cb84c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6002d25166c3003efd3b6edb51cb84c0">&#9670;&nbsp;</a></span>spdk_vhost_dev_get_cpumask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct spdk_cpuset* spdk_vhost_dev_get_cpumask </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get cpuset of the vhost device. </p>
<p>The cpuset is constant throughout the lifetime of a vdev. It is a subset of SPDK app cpuset vhost was started with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cpuset of the vdev. </dd></dl>

</div>
</div>
<a id="aa06efc0d096d4414de40ed5c0b394622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06efc0d096d4414de40ed5c0b394622">&#9670;&nbsp;</a></span>spdk_vhost_dev_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_vhost_dev_get_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the vhost device. </p>
<p>This is equal to the filename of socket file. The name is constant throughout the lifetime of a vdev.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the vdev. </dd></dl>

</div>
</div>
<a id="aa6eba1ce0ac89c3287b755567795869b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6eba1ce0ac89c3287b755567795869b">&#9670;&nbsp;</a></span>spdk_vhost_dev_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_dev_remove </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a vhost device. </p>
<p>The device must not have any open connections on it's socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost blk device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="af358eac95a16bd456349fcfaa00379bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af358eac95a16bd456349fcfaa00379bb">&#9670;&nbsp;</a></span>spdk_vhost_fini()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_fini </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vhost_8h.html#a8b37106ad173f20d05da87f89714700b">spdk_vhost_fini_cb</a>&#160;</td>
          <td class="paramname"><em>fini_cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up the environment of vhost after finishing the vhost application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fini_cb</td><td>Called when the cleanup operation completes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8be392083ae01ad34cc05b1b5ce2b5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be392083ae01ad34cc05b1b5ce2b5e0">&#9670;&nbsp;</a></span>spdk_vhost_get_coalescing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_get_coalescing </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>delay_base_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>iops_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get coalescing parameters. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vhost_8h.html#a8b8c054fdc8ed4ad573b2d0bcf2d4797" title="By default, events are generated when asked, but for high queue depth and high IOPS this prove to be ...">spdk_vhost_set_coalescing</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device. </td></tr>
    <tr><td class="paramname">delay_base_us</td><td>Optional pointer to store base delay time. </td></tr>
    <tr><td class="paramname">iops_threshold</td><td>Optional pointer to store IOPS threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38abeca2169a11feec2ecdce057f3263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38abeca2169a11feec2ecdce057f3263">&#9670;&nbsp;</a></span>spdk_vhost_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Init vhost environment. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a546673fa252a8214efd14fc80b78dcb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546673fa252a8214efd14fc80b78dcb9">&#9670;&nbsp;</a></span>spdk_vhost_scsi_dev_add_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_scsi_dev_add_tgt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>scsi_tgt_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bdev_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct and attach new SCSI target to the vhost SCSI device on given (unoccupied) slot. </p>
<p>The device will be created with a single LUN0 associated with given SPDK bdev. Currently only one LUN per device is supported.</p>
<p>If vhost SCSI device has an active socket connection, it is required that it has negotiated <code>VIRTIO_SCSI_F_HOTPLUG</code> feature flag. Otherwise an -ENOTSUP error code is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost SCSI device. </td></tr>
    <tr><td class="paramname">scsi_tgt_num</td><td>slot to attach to. </td></tr>
    <tr><td class="paramname">bdev_name</td><td>name of the SPDK bdev to associate with SCSI LUN0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a01b54a11439216fb05196474e3ee20d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b54a11439216fb05196474e3ee20d1">&#9670;&nbsp;</a></span>spdk_vhost_scsi_dev_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_scsi_dev_construct </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cpumask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty vhost SCSI device. </p>
<p>This will create a Unix domain socket together with a vhost-user slave server waiting for a connection on this socket. Creating the vdev does not start any I/O pollers and does not hog the CPU. I/O processing starts after receiving proper message on the created socket. See QEMU's vhost-user documentation for details. All physical devices have to be separately attached to this vdev via <code><a class="el" href="vhost_8h.html#a546673fa252a8214efd14fc80b78dcb9" title="Construct and attach new SCSI target to the vhost SCSI device on given (unoccupied) slot...">spdk_vhost_scsi_dev_add_tgt()</a></code>.</p>
<p>This function is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the vhost device. The name will also be used for socket name, which is exactly <code>socket_base_dir/name</code> </td></tr>
    <tr><td class="paramname">cpumask</td><td>string containing cpumask in hex. The leading <em>0x</em> is allowed but not required. The mask itself can be constructed as: ((1 &lt;&lt; cpu0) | (1 &lt;&lt; cpu1) | ... | (1 &lt;&lt; cpuN)).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a540442ab4b6ec0ba4157e514a09f2379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540442ab4b6ec0ba4157e514a09f2379">&#9670;&nbsp;</a></span>spdk_vhost_scsi_dev_get_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_scsi_dev* spdk_vhost_scsi_dev_get_tgt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SCSI target from vhost SCSI device on given slot. </p>
<p>Max number of available slots is defined by. <code>SPDK_VHOST_SCSI_CTRLR_MAX_DEVS</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost SCSI device. </td></tr>
    <tr><td class="paramname">num</td><td>slot id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SCSI device on given slot or NULL. </dd></dl>

</div>
</div>
<a id="ae1ea27c8ae7616e92d916e5c6fc34231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ea27c8ae7616e92d916e5c6fc34231">&#9670;&nbsp;</a></span>spdk_vhost_scsi_dev_remove_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_scsi_dev_remove_tgt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>scsi_tgt_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach and destruct SCSI target from a vhost SCSI device. </p>
<p>If vhost SCSI device has an active socket connection, it is required that it has negotiated <code>VIRTIO_SCSI_F_HOTPLUG</code> feature flag.Otherwise an -ENOTSUP error code is returned. If the flag has been negotiated, the device will be marked to be deleted. Actual deletion is deferred until after all pending I/O to this device has finished.</p>
<p>Once the target has been deleted (whether or not vhost SCSI device is in use) given callback will be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost SCSI device </td></tr>
    <tr><td class="paramname">scsi_tgt_num</td><td>slot id to delete target from </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback to be fired once target has been successfully deleted. The first parameter of callback function is the vhost SCSI device, the second is user provided argument <em>cb_arg</em>. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>parameter to be passed to <em>cb_fn</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a8b8c054fdc8ed4ad573b2d0bcf2d4797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8c054fdc8ed4ad573b2d0bcf2d4797">&#9670;&nbsp;</a></span>spdk_vhost_set_coalescing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_set_coalescing </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay_base_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iops_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>By default, events are generated when asked, but for high queue depth and high IOPS this prove to be inefficient both for guest kernel that have to handle a lot more IO completions and for SPDK vhost that need to make more syscalls. </p>
<p>If enabled, limit amount of events (IRQs) sent to initiator by SPDK vhost effectively coalescing couple of completions. This of cource introduce IO latency penalty proportional to event delay time.</p>
<p>Actual events delay time when is calculated according to below formula: if (delay_base == 0 || IOPS &lt; iops_threshold) { delay = 0; } else if (IOPS &lt; iops_threshold) { delay = delay_base * (iops - iops_threshold) / iops_threshold; }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device. </td></tr>
    <tr><td class="paramname">delay_base_us</td><td>Base delay time in microseconds. If 0, coalescing is disabled. </td></tr>
    <tr><td class="paramname">iops_threshold</td><td>IOPS threshold when coalescing is activated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15921078a895d090283fbbeaaddee76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15921078a895d090283fbbeaaddee76c">&#9670;&nbsp;</a></span>spdk_vhost_set_socket_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_set_socket_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>basename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the path to the directory where vhost sockets will be created. </p>
<p>This function must be called before <a class="el" href="vhost_8h.html#a38abeca2169a11feec2ecdce057f3263" title="Init vhost environment. ">spdk_vhost_init()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basename</td><td>Path to vhost socket directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="afd7159f8eb1e0d65dad5bedaa6cc5e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7159f8eb1e0d65dad5bedaa6cc5e43">&#9670;&nbsp;</a></span>spdk_vhost_shutdown_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_shutdown_cb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinit vhost application. </p>
<p>This is called once by SPDK app layer. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
