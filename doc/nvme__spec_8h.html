<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.13">
  <title>SPDK: nvme_spec.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-sm-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://ci.spdk.io/status/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://github.com/spdk/spdk/wiki/Roadmap">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://github.com/spdk/spdk/wiki/News">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_67fbcc0b4317645100def1406b508c33.html">spdk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nvme_spec.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>NVMe specification definitions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionspdk__nvme__cap__register.html">spdk_nvme_cap_register</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionspdk__nvme__cc__register.html">spdk_nvme_cc_register</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionspdk__nvme__csts__register.html">spdk_nvme_csts_register</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionspdk__nvme__aqa__register.html">spdk_nvme_aqa_register</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionspdk__nvme__vs__register.html">spdk_nvme_vs_register</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionspdk__nvme__cmbloc__register.html">spdk_nvme_cmbloc_register</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionspdk__nvme__cmbsz__register.html">spdk_nvme_cmbsz_register</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionspdk__nvme__bpinfo__register.html">spdk_nvme_bpinfo_register</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot partition information.  <a href="unionspdk__nvme__bpinfo__register.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionspdk__nvme__bprsel__register.html">spdk_nvme_bprsel_register</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boot partition read select.  <a href="unionspdk__nvme__bprsel__register.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__registers.html">spdk_nvme_registers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__sgl__descriptor.html">spdk_nvme_sgl_descriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__status.html">spdk_nvme_status</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion queue entry.  <a href="structspdk__nvme__cpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__dsm__range.html">spdk_nvme_dsm_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dataset Management range.  <a href="structspdk__nvme__dsm__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__power__state.html">spdk_nvme_power_state</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__ctrlr__data.html">spdk_nvme_ctrlr_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__reservation__acquire__data.html">spdk_nvme_reservation_acquire_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__reservation__status__data.html">spdk_nvme_reservation_status_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__reservation__ctrlr__data.html">spdk_nvme_reservation_ctrlr_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__reservation__register__data.html">spdk_nvme_reservation_register_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__reservation__key__data.html">spdk_nvme_reservation_key_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__error__information__entry.html">spdk_nvme_error_information_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error information log page (<a class="el" href="nvme__spec_8h.html#a3d5e453e4d95b0f5b9bb4de04ace78c4ad05013a36512c9cd6ad0249263a3f583">SPDK_NVME_LOG_ERROR</a>)  <a href="structspdk__nvme__error__information__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionspdk__nvme__critical__warning__state.html">spdk_nvme_critical_warning_state</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__health__information__page.html">spdk_nvme_health_information_page</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SMART / health information page (<a class="el" href="nvme__spec_8h.html#a3d5e453e4d95b0f5b9bb4de04ace78c4a8c4e97d27e08924e29d76ea66780a886">SPDK_NVME_LOG_HEALTH_INFORMATION</a>)  <a href="structspdk__nvme__health__information__page.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__firmware__page.html">spdk_nvme_firmware_page</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Firmware slot information page (<a class="el" href="nvme__spec_8h.html#a3d5e453e4d95b0f5b9bb4de04ace78c4a898706714ccdcd0c5b2fee0170beecbb">SPDK_NVME_LOG_FIRMWARE_SLOT</a>)  <a href="structspdk__nvme__firmware__page.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__ns__list.html">spdk_nvme_ns_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__ns__id__desc.html">spdk_nvme_ns_id_desc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__ctrlr__list.html">spdk_nvme_ctrlr_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__format.html">spdk_nvme_format</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__protection__info.html">spdk_nvme_protection_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__fw__commit.html">spdk_nvme_fw_commit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for SPDK_NVME_OPC_FIRMWARE_COMMIT cdw10.  <a href="structspdk__nvme__fw__commit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a49914175a8977c209595d436f71136bc"><td class="memItemLeft" align="right" valign="top"><a id="a49914175a8977c209595d436f71136bc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a49914175a8977c209595d436f71136bc">SPDK_NVME_GLOBAL_NS_TAG</a>&#160;&#160;&#160;((uint32_t)0xFFFFFFFF)</td></tr>
<tr class="memdesc:a49914175a8977c209595d436f71136bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to mark a command to apply to all namespaces, or to retrieve global log pages. <br /></td></tr>
<tr class="separator:a49914175a8977c209595d436f71136bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16100e7649c94a89146d02fe4556537a"><td class="memItemLeft" align="right" valign="top"><a id="a16100e7649c94a89146d02fe4556537a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_MAX_IO_QUEUES</b>&#160;&#160;&#160;(65535)</td></tr>
<tr class="separator:a16100e7649c94a89146d02fe4556537a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c74c2bd741f5f291f3e4a032d04647"><td class="memItemLeft" align="right" valign="top"><a id="ae4c74c2bd741f5f291f3e4a032d04647"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_ADMIN_QUEUE_MIN_ENTRIES</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ae4c74c2bd741f5f291f3e4a032d04647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc394cf0b37e4ec245a604e0e48b2b82"><td class="memItemLeft" align="right" valign="top"><a id="afc394cf0b37e4ec245a604e0e48b2b82"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_ADMIN_QUEUE_MAX_ENTRIES</b>&#160;&#160;&#160;4096</td></tr>
<tr class="separator:afc394cf0b37e4ec245a604e0e48b2b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596eccf075cc180ef6148458bd953a22"><td class="memItemLeft" align="right" valign="top"><a id="a596eccf075cc180ef6148458bd953a22"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_IO_QUEUE_MIN_ENTRIES</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a596eccf075cc180ef6148458bd953a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a070303721766a8be74aa19fed086c5"><td class="memItemLeft" align="right" valign="top"><a id="a1a070303721766a8be74aa19fed086c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_IO_QUEUE_MAX_ENTRIES</b>&#160;&#160;&#160;65536</td></tr>
<tr class="separator:a1a070303721766a8be74aa19fed086c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2aa28f22c4dc7336caf96815cb70314"><td class="memItemLeft" align="right" valign="top"><a id="ad2aa28f22c4dc7336caf96815cb70314"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#ad2aa28f22c4dc7336caf96815cb70314">SPDK_NVME_DATASET_MANAGEMENT_MAX_RANGES</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:ad2aa28f22c4dc7336caf96815cb70314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the maximum number of range sets that may be specified in the dataset mangement command. <br /></td></tr>
<tr class="separator:ad2aa28f22c4dc7336caf96815cb70314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9760bf73611488342b5903ba702fd7b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a9760bf73611488342b5903ba702fd7b6">SPDK_NVME_VERSION</a>(mjr,  mnr,  ter)</td></tr>
<tr class="memdesc:a9760bf73611488342b5903ba702fd7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate raw version in the same format as <a class="el" href="unionspdk__nvme__vs__register.html">spdk_nvme_vs_register</a> for comparison.  <a href="#a9760bf73611488342b5903ba702fd7b6">More...</a><br /></td></tr>
<tr class="separator:a9760bf73611488342b5903ba702fd7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ef13320c82eaf4abdef6aa56e8b5ba"><td class="memItemLeft" align="right" valign="top"><a id="ad3ef13320c82eaf4abdef6aa56e8b5ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#ad3ef13320c82eaf4abdef6aa56e8b5ba">SPDK_NVME_NSSR_VALUE</a>&#160;&#160;&#160;0x4E564D65</td></tr>
<tr class="memdesc:ad3ef13320c82eaf4abdef6aa56e8b5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value to write to NSSR to indicate a NVM subsystem reset ("NVMe") <br /></td></tr>
<tr class="separator:ad3ef13320c82eaf4abdef6aa56e8b5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f4e2315b815c9a35831c7b6d6e59ec"><td class="memItemLeft" align="right" valign="top"><a id="ab5f4e2315b815c9a35831c7b6d6e59ec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_CTRLR_SN_LEN</b>&#160;&#160;&#160;20</td></tr>
<tr class="separator:ab5f4e2315b815c9a35831c7b6d6e59ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0d9b18cd903c7f3dcea29744494388"><td class="memItemLeft" align="right" valign="top"><a id="a0e0d9b18cd903c7f3dcea29744494388"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_CTRLR_MN_LEN</b>&#160;&#160;&#160;40</td></tr>
<tr class="separator:a0e0d9b18cd903c7f3dcea29744494388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada253b591ac69e8446d4c4461b15b892"><td class="memItemLeft" align="right" valign="top"><a id="ada253b591ac69e8446d4c4461b15b892"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_CTRLR_FR_LEN</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ada253b591ac69e8446d4c4461b15b892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b2e9dfaeda9fac684e7b456971c710"><td class="memItemLeft" align="right" valign="top"><a id="a62b2e9dfaeda9fac684e7b456971c710"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_cpl_is_error</b>(cpl)&#160;&#160;&#160;((cpl)-&gt;status.sc != 0 || (cpl)-&gt;status.sct != 0)</td></tr>
<tr class="separator:a62b2e9dfaeda9fac684e7b456971c710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093f4f54c893a46cc3a776fa667d09a2"><td class="memItemLeft" align="right" valign="top"><a id="a093f4f54c893a46cc3a776fa667d09a2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a093f4f54c893a46cc3a776fa667d09a2">SPDK_NVME_IO_FLAGS_PRCHK_REFTAG</a>&#160;&#160;&#160;(1U &lt;&lt; 26)</td></tr>
<tr class="memdesc:a093f4f54c893a46cc3a776fa667d09a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable protection information checking of the Logical Block Reference Tag field. <br /></td></tr>
<tr class="separator:a093f4f54c893a46cc3a776fa667d09a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c69904e0cbefa87f348e7c076707a7"><td class="memItemLeft" align="right" valign="top"><a id="ae3c69904e0cbefa87f348e7c076707a7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#ae3c69904e0cbefa87f348e7c076707a7">SPDK_NVME_IO_FLAGS_PRCHK_APPTAG</a>&#160;&#160;&#160;(1U &lt;&lt; 27)</td></tr>
<tr class="memdesc:ae3c69904e0cbefa87f348e7c076707a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable protection information checking of the Application Tag field. <br /></td></tr>
<tr class="separator:ae3c69904e0cbefa87f348e7c076707a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b184c96a7354bee528ca16bd5f9e97"><td class="memItemLeft" align="right" valign="top"><a id="aa4b184c96a7354bee528ca16bd5f9e97"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#aa4b184c96a7354bee528ca16bd5f9e97">SPDK_NVME_IO_FLAGS_PRCHK_GUARD</a>&#160;&#160;&#160;(1U &lt;&lt; 28)</td></tr>
<tr class="memdesc:aa4b184c96a7354bee528ca16bd5f9e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable protection information checking of the Guard field. <br /></td></tr>
<tr class="separator:aa4b184c96a7354bee528ca16bd5f9e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927b883cde43d8000b7a32c1b4d6ed53"><td class="memItemLeft" align="right" valign="top"><a id="a927b883cde43d8000b7a32c1b4d6ed53"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a927b883cde43d8000b7a32c1b4d6ed53">SPDK_NVME_IO_FLAGS_PRACT</a>&#160;&#160;&#160;(1U &lt;&lt; 29)</td></tr>
<tr class="memdesc:a927b883cde43d8000b7a32c1b4d6ed53"><td class="mdescLeft">&#160;</td><td class="mdescRight">The protection information is stripped or inserted when set this bit. <br /></td></tr>
<tr class="separator:a927b883cde43d8000b7a32c1b4d6ed53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0db806408dd6b8ed6e032cde431d9d"><td class="memItemLeft" align="right" valign="top"><a id="abd0db806408dd6b8ed6e032cde431d9d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_IO_FLAGS_FORCE_UNIT_ACCESS</b>&#160;&#160;&#160;(1U &lt;&lt; 30)</td></tr>
<tr class="separator:abd0db806408dd6b8ed6e032cde431d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8360ce1240ec2117d8764bcdefb38acb"><td class="memItemLeft" align="right" valign="top"><a id="a8360ce1240ec2117d8764bcdefb38acb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_IO_FLAGS_LIMITED_RETRY</b>&#160;&#160;&#160;(1U &lt;&lt; 31)</td></tr>
<tr class="separator:a8360ce1240ec2117d8764bcdefb38acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a57ea2eb3f8a34ee2657a960a9645432e"><td class="memItemLeft" align="right" valign="top"><a id="a57ea2eb3f8a34ee2657a960a9645432e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_shn_value</b> { <b>SPDK_NVME_SHN_NORMAL</b> = 0x1, 
<b>SPDK_NVME_SHN_ABRUPT</b> = 0x2
 }</td></tr>
<tr class="separator:a57ea2eb3f8a34ee2657a960a9645432e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53188eec68915208fab035bba9d6eba7"><td class="memItemLeft" align="right" valign="top"><a id="a53188eec68915208fab035bba9d6eba7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_shst_value</b> { <b>SPDK_NVME_SHST_NORMAL</b> = 0x0, 
<b>SPDK_NVME_SHST_OCCURRING</b> = 0x1, 
<b>SPDK_NVME_SHST_COMPLETE</b> = 0x2
 }</td></tr>
<tr class="separator:a53188eec68915208fab035bba9d6eba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa934b2f75a2d0fc8a22f14627f5000"><td class="memItemLeft" align="right" valign="top"><a id="a6aa934b2f75a2d0fc8a22f14627f5000"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_sgl_descriptor_type</b> { <br />
&#160;&#160;<b>SPDK_NVME_SGL_TYPE_DATA_BLOCK</b> = 0x0, 
<b>SPDK_NVME_SGL_TYPE_BIT_BUCKET</b> = 0x1, 
<b>SPDK_NVME_SGL_TYPE_SEGMENT</b> = 0x2, 
<b>SPDK_NVME_SGL_TYPE_LAST_SEGMENT</b> = 0x3, 
<br />
&#160;&#160;<b>SPDK_NVME_SGL_TYPE_KEYED_DATA_BLOCK</b> = 0x4, 
<b>SPDK_NVME_SGL_TYPE_VENDOR_SPECIFIC</b> = 0xF
<br />
 }</td></tr>
<tr class="separator:a6aa934b2f75a2d0fc8a22f14627f5000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93615f8760918ef6dcc1af325eac736"><td class="memItemLeft" align="right" valign="top"><a id="ab93615f8760918ef6dcc1af325eac736"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_sgl_descriptor_subtype</b> { <b>SPDK_NVME_SGL_SUBTYPE_ADDRESS</b> = 0x0, 
<b>SPDK_NVME_SGL_SUBTYPE_OFFSET</b> = 0x1
 }</td></tr>
<tr class="separator:ab93615f8760918ef6dcc1af325eac736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7138fa2c5a95d6c8e992b5ff6a92523"><td class="memItemLeft" align="right" valign="top"><a id="ae7138fa2c5a95d6c8e992b5ff6a92523"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_psdt_value</b> { <b>SPDK_NVME_PSDT_PRP</b> = 0x0, 
<b>SPDK_NVME_PSDT_SGL_MPTR_CONTIG</b> = 0x1, 
<b>SPDK_NVME_PSDT_SGL_MPTR_SGL</b> = 0x2, 
<b>SPDK_NVME_PSDT_RESERVED</b> = 0x3
 }</td></tr>
<tr class="separator:ae7138fa2c5a95d6c8e992b5ff6a92523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83a61e254cf9d1fd59376ceedd1b4e6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#ae83a61e254cf9d1fd59376ceedd1b4e6">spdk_nvme_qprio</a> { <b>SPDK_NVME_QPRIO_URGENT</b> = 0x0, 
<b>SPDK_NVME_QPRIO_HIGH</b> = 0x1, 
<b>SPDK_NVME_QPRIO_MEDIUM</b> = 0x2, 
<b>SPDK_NVME_QPRIO_LOW</b> = 0x3
 }<tr class="memdesc:ae83a61e254cf9d1fd59376ceedd1b4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submission queue priority values for Create I/O Submission Queue Command.  <a href="nvme__spec_8h.html#ae83a61e254cf9d1fd59376ceedd1b4e6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae83a61e254cf9d1fd59376ceedd1b4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6ad5ec9f8c1aa4c7efc45ee9d646b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#adf6ad5ec9f8c1aa4c7efc45ee9d646b6">spdk_nvme_cap_ams</a> { <a class="el" href="nvme__spec_8h.html#adf6ad5ec9f8c1aa4c7efc45ee9d646b6ac8b3721eb6c714051f08db20938b31af">SPDK_NVME_CAP_AMS_WRR</a> = 0x1, 
<a class="el" href="nvme__spec_8h.html#adf6ad5ec9f8c1aa4c7efc45ee9d646b6a0bae550fd4027110273cc75986809274">SPDK_NVME_CAP_AMS_VS</a> = 0x2
 }<tr class="memdesc:adf6ad5ec9f8c1aa4c7efc45ee9d646b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional Arbitration Mechanism Supported by the controller.  <a href="nvme__spec_8h.html#adf6ad5ec9f8c1aa4c7efc45ee9d646b6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:adf6ad5ec9f8c1aa4c7efc45ee9d646b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e72566466cae734d999e755524f7b20"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a7e72566466cae734d999e755524f7b20">spdk_nvme_cc_ams</a> { <a class="el" href="nvme__spec_8h.html#a7e72566466cae734d999e755524f7b20a5064340c35b2c9179d85de39edccdf6c">SPDK_NVME_CC_AMS_RR</a> = 0x0, 
<a class="el" href="nvme__spec_8h.html#a7e72566466cae734d999e755524f7b20a5c1162b2ac15358567bc0da6cfd2c62d">SPDK_NVME_CC_AMS_WRR</a> = 0x1, 
<a class="el" href="nvme__spec_8h.html#a7e72566466cae734d999e755524f7b20a5690f8273561b4be28e1f7d5ae5d8167">SPDK_NVME_CC_AMS_VS</a> = 0x7
 }<tr class="memdesc:a7e72566466cae734d999e755524f7b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arbitration Mechanism Selected to the controller.  <a href="nvme__spec_8h.html#a7e72566466cae734d999e755524f7b20">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7e72566466cae734d999e755524f7b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fb26e5d5c31f6d3d61397951e44b52"><td class="memItemLeft" align="right" valign="top"><a id="a99fb26e5d5c31f6d3d61397951e44b52"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a99fb26e5d5c31f6d3d61397951e44b52">spdk_nvme_status_code_type</a> { <b>SPDK_NVME_SCT_GENERIC</b> = 0x0, 
<b>SPDK_NVME_SCT_COMMAND_SPECIFIC</b> = 0x1, 
<b>SPDK_NVME_SCT_MEDIA_ERROR</b> = 0x2, 
<b>SPDK_NVME_SCT_VENDOR_SPECIFIC</b> = 0x7
 }<tr class="memdesc:a99fb26e5d5c31f6d3d61397951e44b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status code types. <br /></td></tr>
</td></tr>
<tr class="separator:a99fb26e5d5c31f6d3d61397951e44b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70e5bbfae3ba9ec66a65c78e1966a1d"><td class="memItemLeft" align="right" valign="top"><a id="aa70e5bbfae3ba9ec66a65c78e1966a1d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#aa70e5bbfae3ba9ec66a65c78e1966a1d">spdk_nvme_generic_command_status_code</a> { <br />
&#160;&#160;<b>SPDK_NVME_SC_SUCCESS</b> = 0x00, 
<b>SPDK_NVME_SC_INVALID_OPCODE</b> = 0x01, 
<b>SPDK_NVME_SC_INVALID_FIELD</b> = 0x02, 
<b>SPDK_NVME_SC_COMMAND_ID_CONFLICT</b> = 0x03, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_DATA_TRANSFER_ERROR</b> = 0x04, 
<b>SPDK_NVME_SC_ABORTED_POWER_LOSS</b> = 0x05, 
<b>SPDK_NVME_SC_INTERNAL_DEVICE_ERROR</b> = 0x06, 
<b>SPDK_NVME_SC_ABORTED_BY_REQUEST</b> = 0x07, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_ABORTED_SQ_DELETION</b> = 0x08, 
<b>SPDK_NVME_SC_ABORTED_FAILED_FUSED</b> = 0x09, 
<b>SPDK_NVME_SC_ABORTED_MISSING_FUSED</b> = 0x0a, 
<b>SPDK_NVME_SC_INVALID_NAMESPACE_OR_FORMAT</b> = 0x0b, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_COMMAND_SEQUENCE_ERROR</b> = 0x0c, 
<b>SPDK_NVME_SC_INVALID_SGL_SEG_DESCRIPTOR</b> = 0x0d, 
<b>SPDK_NVME_SC_INVALID_NUM_SGL_DESCIRPTORS</b> = 0x0e, 
<b>SPDK_NVME_SC_DATA_SGL_LENGTH_INVALID</b> = 0x0f, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_METADATA_SGL_LENGTH_INVALID</b> = 0x10, 
<b>SPDK_NVME_SC_SGL_DESCRIPTOR_TYPE_INVALID</b> = 0x11, 
<b>SPDK_NVME_SC_INVALID_CONTROLLER_MEM_BUF</b> = 0x12, 
<b>SPDK_NVME_SC_INVALID_PRP_OFFSET</b> = 0x13, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_ATOMIC_WRITE_UNIT_EXCEEDED</b> = 0x14, 
<b>SPDK_NVME_SC_OPERATION_DENIED</b> = 0x15, 
<b>SPDK_NVME_SC_INVALID_SGL_OFFSET</b> = 0x16, 
<b>SPDK_NVME_SC_INVALID_SGL_SUBTYPE</b> = 0x17, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_HOSTID_INCONSISTENT_FORMAT</b> = 0x18, 
<b>SPDK_NVME_SC_KEEP_ALIVE_EXPIRED</b> = 0x19, 
<b>SPDK_NVME_SC_KEEP_ALIVE_INVALID</b> = 0x1a, 
<b>SPDK_NVME_SC_ABORTED_PREEMPT</b> = 0x1b, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_SANITIZE_FAILED</b> = 0x1c, 
<b>SPDK_NVME_SC_SANITIZE_IN_PROGRESS</b> = 0x1d, 
<b>SPDK_NVME_SC_SGL_DATA_BLOCK_GRANULARITY_INVALID</b> = 0x1e, 
<b>SPDK_NVME_SC_COMMAND_INVALID_IN_CMB</b> = 0x1f, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_LBA_OUT_OF_RANGE</b> = 0x80, 
<b>SPDK_NVME_SC_CAPACITY_EXCEEDED</b> = 0x81, 
<b>SPDK_NVME_SC_NAMESPACE_NOT_READY</b> = 0x82, 
<b>SPDK_NVME_SC_RESERVATION_CONFLICT</b> = 0x83, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_FORMAT_IN_PROGRESS</b> = 0x84
<br />
 }<tr class="memdesc:aa70e5bbfae3ba9ec66a65c78e1966a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic command status codes. <br /></td></tr>
</td></tr>
<tr class="separator:aa70e5bbfae3ba9ec66a65c78e1966a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8784fad6a53be95d4c718ad3cf852e"><td class="memItemLeft" align="right" valign="top"><a id="acb8784fad6a53be95d4c718ad3cf852e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#acb8784fad6a53be95d4c718ad3cf852e">spdk_nvme_command_specific_status_code</a> { <br />
&#160;&#160;<b>SPDK_NVME_SC_COMPLETION_QUEUE_INVALID</b> = 0x00, 
<b>SPDK_NVME_SC_INVALID_QUEUE_IDENTIFIER</b> = 0x01, 
<b>SPDK_NVME_SC_MAXIMUM_QUEUE_SIZE_EXCEEDED</b> = 0x02, 
<b>SPDK_NVME_SC_ABORT_COMMAND_LIMIT_EXCEEDED</b> = 0x03, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_ASYNC_EVENT_REQUEST_LIMIT_EXCEEDED</b> = 0x05, 
<b>SPDK_NVME_SC_INVALID_FIRMWARE_SLOT</b> = 0x06, 
<b>SPDK_NVME_SC_INVALID_FIRMWARE_IMAGE</b> = 0x07, 
<b>SPDK_NVME_SC_INVALID_INTERRUPT_VECTOR</b> = 0x08, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_INVALID_LOG_PAGE</b> = 0x09, 
<b>SPDK_NVME_SC_INVALID_FORMAT</b> = 0x0a, 
<b>SPDK_NVME_SC_FIRMWARE_REQ_CONVENTIONAL_RESET</b> = 0x0b, 
<b>SPDK_NVME_SC_INVALID_QUEUE_DELETION</b> = 0x0c, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_FEATURE_ID_NOT_SAVEABLE</b> = 0x0d, 
<b>SPDK_NVME_SC_FEATURE_NOT_CHANGEABLE</b> = 0x0e, 
<b>SPDK_NVME_SC_FEATURE_NOT_NAMESPACE_SPECIFIC</b> = 0x0f, 
<b>SPDK_NVME_SC_FIRMWARE_REQ_NVM_RESET</b> = 0x10, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_FIRMWARE_REQ_RESET</b> = 0x11, 
<b>SPDK_NVME_SC_FIRMWARE_REQ_MAX_TIME_VIOLATION</b> = 0x12, 
<b>SPDK_NVME_SC_FIRMWARE_ACTIVATION_PROHIBITED</b> = 0x13, 
<b>SPDK_NVME_SC_OVERLAPPING_RANGE</b> = 0x14, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_NAMESPACE_INSUFFICIENT_CAPACITY</b> = 0x15, 
<b>SPDK_NVME_SC_NAMESPACE_ID_UNAVAILABLE</b> = 0x16, 
<b>SPDK_NVME_SC_NAMESPACE_ALREADY_ATTACHED</b> = 0x18, 
<b>SPDK_NVME_SC_NAMESPACE_IS_PRIVATE</b> = 0x19, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_NAMESPACE_NOT_ATTACHED</b> = 0x1a, 
<b>SPDK_NVME_SC_THINPROVISIONING_NOT_SUPPORTED</b> = 0x1b, 
<b>SPDK_NVME_SC_CONTROLLER_LIST_INVALID</b> = 0x1c, 
<b>SPDK_NVME_SC_DEVICE_SELF_TEST_IN_PROGRESS</b> = 0x1d, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_BOOT_PARTITION_WRITE_PROHIBITED</b> = 0x1e, 
<b>SPDK_NVME_SC_INVALID_CTRLR_ID</b> = 0x1f, 
<b>SPDK_NVME_SC_INVALID_SECONDARY_CTRLR_STATE</b> = 0x20, 
<b>SPDK_NVME_SC_INVALID_NUM_CTRLR_RESOURCES</b> = 0x21, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_INVALID_RESOURCE_ID</b> = 0x22, 
<b>SPDK_NVME_SC_CONFLICTING_ATTRIBUTES</b> = 0x80, 
<b>SPDK_NVME_SC_INVALID_PROTECTION_INFO</b> = 0x81, 
<b>SPDK_NVME_SC_ATTEMPTED_WRITE_TO_RO_PAGE</b> = 0x82
<br />
 }<tr class="memdesc:acb8784fad6a53be95d4c718ad3cf852e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command specific status codes. <br /></td></tr>
</td></tr>
<tr class="separator:acb8784fad6a53be95d4c718ad3cf852e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a432232311e948e133a1a56325418f"><td class="memItemLeft" align="right" valign="top"><a id="ae2a432232311e948e133a1a56325418f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#ae2a432232311e948e133a1a56325418f">spdk_nvme_media_error_status_code</a> { <br />
&#160;&#160;<b>SPDK_NVME_SC_WRITE_FAULTS</b> = 0x80, 
<b>SPDK_NVME_SC_UNRECOVERED_READ_ERROR</b> = 0x81, 
<b>SPDK_NVME_SC_GUARD_CHECK_ERROR</b> = 0x82, 
<b>SPDK_NVME_SC_APPLICATION_TAG_CHECK_ERROR</b> = 0x83, 
<br />
&#160;&#160;<b>SPDK_NVME_SC_REFERENCE_TAG_CHECK_ERROR</b> = 0x84, 
<b>SPDK_NVME_SC_COMPARE_FAILURE</b> = 0x85, 
<b>SPDK_NVME_SC_ACCESS_DENIED</b> = 0x86, 
<b>SPDK_NVME_SC_DEALLOCATED_OR_UNWRITTEN_BLOCK</b> = 0x87
<br />
 }<tr class="memdesc:ae2a432232311e948e133a1a56325418f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media error status codes. <br /></td></tr>
</td></tr>
<tr class="separator:ae2a432232311e948e133a1a56325418f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d96f5eb214b3cb58675276f19855bf5"><td class="memItemLeft" align="right" valign="top"><a id="a3d96f5eb214b3cb58675276f19855bf5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a3d96f5eb214b3cb58675276f19855bf5">spdk_nvme_admin_opcode</a> { <br />
&#160;&#160;<b>SPDK_NVME_OPC_DELETE_IO_SQ</b> = 0x00, 
<b>SPDK_NVME_OPC_CREATE_IO_SQ</b> = 0x01, 
<b>SPDK_NVME_OPC_GET_LOG_PAGE</b> = 0x02, 
<b>SPDK_NVME_OPC_DELETE_IO_CQ</b> = 0x04, 
<br />
&#160;&#160;<b>SPDK_NVME_OPC_CREATE_IO_CQ</b> = 0x05, 
<b>SPDK_NVME_OPC_IDENTIFY</b> = 0x06, 
<b>SPDK_NVME_OPC_ABORT</b> = 0x08, 
<b>SPDK_NVME_OPC_SET_FEATURES</b> = 0x09, 
<br />
&#160;&#160;<b>SPDK_NVME_OPC_GET_FEATURES</b> = 0x0a, 
<b>SPDK_NVME_OPC_ASYNC_EVENT_REQUEST</b> = 0x0c, 
<b>SPDK_NVME_OPC_NS_MANAGEMENT</b> = 0x0d, 
<b>SPDK_NVME_OPC_FIRMWARE_COMMIT</b> = 0x10, 
<br />
&#160;&#160;<b>SPDK_NVME_OPC_FIRMWARE_IMAGE_DOWNLOAD</b> = 0x11, 
<b>SPDK_NVME_OPC_DEVICE_SELF_TEST</b> = 0x14, 
<b>SPDK_NVME_OPC_NS_ATTACHMENT</b> = 0x15, 
<b>SPDK_NVME_OPC_KEEP_ALIVE</b> = 0x18, 
<br />
&#160;&#160;<b>SPDK_NVME_OPC_DIRECTIVE_SEND</b> = 0x19, 
<b>SPDK_NVME_OPC_DIRECTIVE_RECEIVE</b> = 0x1a, 
<b>SPDK_NVME_OPC_VIRTUALIZATION_MANAGEMENT</b> = 0x1c, 
<b>SPDK_NVME_OPC_NVME_MI_SEND</b> = 0x1d, 
<br />
&#160;&#160;<b>SPDK_NVME_OPC_NVME_MI_RECEIVE</b> = 0x1e, 
<b>SPDK_NVME_OPC_DOORBELL_BUFFER_CONFIG</b> = 0x7c, 
<b>SPDK_NVME_OPC_FORMAT_NVM</b> = 0x80, 
<b>SPDK_NVME_OPC_SECURITY_SEND</b> = 0x81, 
<br />
&#160;&#160;<b>SPDK_NVME_OPC_SECURITY_RECEIVE</b> = 0x82, 
<b>SPDK_NVME_OPC_SANITIZE</b> = 0x84
<br />
 }<tr class="memdesc:a3d96f5eb214b3cb58675276f19855bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Admin opcodes. <br /></td></tr>
</td></tr>
<tr class="separator:a3d96f5eb214b3cb58675276f19855bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3953ec001514cffe849d9c1e3a913e3"><td class="memItemLeft" align="right" valign="top"><a id="ac3953ec001514cffe849d9c1e3a913e3"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#ac3953ec001514cffe849d9c1e3a913e3">spdk_nvme_nvm_opcode</a> { <br />
&#160;&#160;<b>SPDK_NVME_OPC_FLUSH</b> = 0x00, 
<b>SPDK_NVME_OPC_WRITE</b> = 0x01, 
<b>SPDK_NVME_OPC_READ</b> = 0x02, 
<b>SPDK_NVME_OPC_WRITE_UNCORRECTABLE</b> = 0x04, 
<br />
&#160;&#160;<b>SPDK_NVME_OPC_COMPARE</b> = 0x05, 
<b>SPDK_NVME_OPC_WRITE_ZEROES</b> = 0x08, 
<b>SPDK_NVME_OPC_DATASET_MANAGEMENT</b> = 0x09, 
<b>SPDK_NVME_OPC_RESERVATION_REGISTER</b> = 0x0d, 
<br />
&#160;&#160;<b>SPDK_NVME_OPC_RESERVATION_REPORT</b> = 0x0e, 
<b>SPDK_NVME_OPC_RESERVATION_ACQUIRE</b> = 0x11, 
<b>SPDK_NVME_OPC_RESERVATION_RELEASE</b> = 0x15
<br />
 }<tr class="memdesc:ac3953ec001514cffe849d9c1e3a913e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVM command set opcodes. <br /></td></tr>
</td></tr>
<tr class="separator:ac3953ec001514cffe849d9c1e3a913e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe38e042bb939183ed8fd5c1685b2fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#adbe38e042bb939183ed8fd5c1685b2fc">spdk_nvme_data_transfer</a> { <a class="el" href="nvme__spec_8h.html#adbe38e042bb939183ed8fd5c1685b2fca4d074786dad4f37c0211563ec0376974">SPDK_NVME_DATA_NONE</a> = 0, 
<a class="el" href="nvme__spec_8h.html#adbe38e042bb939183ed8fd5c1685b2fca7f08188b3c5f57f2f694f6ef13ad0110">SPDK_NVME_DATA_HOST_TO_CONTROLLER</a> = 1, 
<a class="el" href="nvme__spec_8h.html#adbe38e042bb939183ed8fd5c1685b2fca0de3a8ad0600034555094591e706fb50">SPDK_NVME_DATA_CONTROLLER_TO_HOST</a> = 2, 
<a class="el" href="nvme__spec_8h.html#adbe38e042bb939183ed8fd5c1685b2fcaa550f0ebf32623c8161ca7d5d8cbb0c2">SPDK_NVME_DATA_BIDIRECTIONAL</a> = 3
 }<tr class="memdesc:adbe38e042bb939183ed8fd5c1685b2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data transfer (bits 1:0) of an NVMe opcode.  <a href="nvme__spec_8h.html#adbe38e042bb939183ed8fd5c1685b2fc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:adbe38e042bb939183ed8fd5c1685b2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae5c5fb9df2c7a39215c71f9d9b4c25"><td class="memItemLeft" align="right" valign="top"><a id="aeae5c5fb9df2c7a39215c71f9d9b4c25"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_feat</b> { <br />
&#160;&#160;<b>SPDK_NVME_FEAT_ARBITRATION</b> = 0x01, 
<b>SPDK_NVME_FEAT_POWER_MANAGEMENT</b> = 0x02, 
<b>SPDK_NVME_FEAT_LBA_RANGE_TYPE</b> = 0x03, 
<b>SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD</b> = 0x04, 
<br />
&#160;&#160;<b>SPDK_NVME_FEAT_ERROR_RECOVERY</b> = 0x05, 
<b>SPDK_NVME_FEAT_VOLATILE_WRITE_CACHE</b> = 0x06, 
<b>SPDK_NVME_FEAT_NUMBER_OF_QUEUES</b> = 0x07, 
<b>SPDK_NVME_FEAT_INTERRUPT_COALESCING</b> = 0x08, 
<br />
&#160;&#160;<b>SPDK_NVME_FEAT_INTERRUPT_VECTOR_CONFIGURATION</b> = 0x09, 
<b>SPDK_NVME_FEAT_WRITE_ATOMICITY</b> = 0x0A, 
<b>SPDK_NVME_FEAT_ASYNC_EVENT_CONFIGURATION</b> = 0x0B, 
<b>SPDK_NVME_FEAT_AUTONOMOUS_POWER_STATE_TRANSITION</b> = 0x0C, 
<br />
&#160;&#160;<b>SPDK_NVME_FEAT_HOST_MEM_BUFFER</b> = 0x0D, 
<b>SPDK_NVME_FEAT_TIMESTAMP</b> = 0x0E, 
<b>SPDK_NVME_FEAT_KEEP_ALIVE_TIMER</b> = 0x0F, 
<b>SPDK_NVME_FEAT_HOST_CONTROLLED_THERMAL_MANAGEMENT</b> = 0x10, 
<br />
&#160;&#160;<b>SPDK_NVME_FEAT_NON_OPERATIONAL_POWER_STATE_CONFIG</b> = 0x11, 
<b>SPDK_NVME_FEAT_SOFTWARE_PROGRESS_MARKER</b> = 0x80, 
<b>SPDK_NVME_FEAT_HOST_IDENTIFIER</b> = 0x81, 
<b>SPDK_NVME_FEAT_HOST_RESERVE_MASK</b> = 0x82, 
<br />
&#160;&#160;<b>SPDK_NVME_FEAT_HOST_RESERVE_PERSIST</b> = 0x83
<br />
 }</td></tr>
<tr class="separator:aeae5c5fb9df2c7a39215c71f9d9b4c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553aa11d679deea767299b75e8ff5fca"><td class="memItemLeft" align="right" valign="top"><a id="a553aa11d679deea767299b75e8ff5fca"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_dsm_attribute</b> { <b>SPDK_NVME_DSM_ATTR_INTEGRAL_READ</b> = 0x1, 
<b>SPDK_NVME_DSM_ATTR_INTEGRAL_WRITE</b> = 0x2, 
<b>SPDK_NVME_DSM_ATTR_DEALLOCATE</b> = 0x4
 }</td></tr>
<tr class="separator:a553aa11d679deea767299b75e8ff5fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1491a0118eccaa91ff5cb9fb5d02c2c6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a1491a0118eccaa91ff5cb9fb5d02c2c6">spdk_nvme_identify_cns</a> { <br />
&#160;&#160;<a class="el" href="nvme__spec_8h.html#a1491a0118eccaa91ff5cb9fb5d02c2c6a0e3f9941eabe22d5b3c7c86043d0de32">SPDK_NVME_IDENTIFY_NS</a> = 0x00, 
<a class="el" href="nvme__spec_8h.html#a1491a0118eccaa91ff5cb9fb5d02c2c6a4a37f16cc815935d6ca7c5fc72446ba1">SPDK_NVME_IDENTIFY_CTRLR</a> = 0x01, 
<a class="el" href="nvme__spec_8h.html#a1491a0118eccaa91ff5cb9fb5d02c2c6a8cfbe8373c7c619033d60eede0106f9c">SPDK_NVME_IDENTIFY_ACTIVE_NS_LIST</a> = 0x02, 
<a class="el" href="nvme__spec_8h.html#a1491a0118eccaa91ff5cb9fb5d02c2c6ab945a36d2eb0c77e3c7eec85036e57e8">SPDK_NVME_IDENTIFY_NS_ID_DESCRIPTOR_LIST</a> = 0x03, 
<br />
&#160;&#160;<a class="el" href="nvme__spec_8h.html#a1491a0118eccaa91ff5cb9fb5d02c2c6a6d869fc169f9b1a1710ea422c60fe1c1">SPDK_NVME_IDENTIFY_ALLOCATED_NS_LIST</a> = 0x10, 
<a class="el" href="nvme__spec_8h.html#a1491a0118eccaa91ff5cb9fb5d02c2c6a2577422800e8e7b6da496ff0e26d72ad">SPDK_NVME_IDENTIFY_NS_ALLOCATED</a> = 0x11, 
<a class="el" href="nvme__spec_8h.html#a1491a0118eccaa91ff5cb9fb5d02c2c6a406d8a0fd54843bf3a769c709be8c78a">SPDK_NVME_IDENTIFY_NS_ATTACHED_CTRLR_LIST</a> = 0x12, 
<a class="el" href="nvme__spec_8h.html#a1491a0118eccaa91ff5cb9fb5d02c2c6aeb2ab6a252ff942ca407e965a43069d8">SPDK_NVME_IDENTIFY_CTRLR_LIST</a> = 0x13, 
<br />
&#160;&#160;<a class="el" href="nvme__spec_8h.html#a1491a0118eccaa91ff5cb9fb5d02c2c6a529c0f24ec3362cef551610db7d9642a">SPDK_NVME_IDENTIFY_PRIMARY_CTRLR_CAP</a> = 0x14, 
<a class="el" href="nvme__spec_8h.html#a1491a0118eccaa91ff5cb9fb5d02c2c6acf0506a0b05a13ae3cd613dc3caf365b">SPDK_NVME_IDENTIFY_SECONDARY_CTRLR_LIST</a> = 0x15
<br />
 }<tr class="memdesc:a1491a0118eccaa91ff5cb9fb5d02c2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify command CNS value.  <a href="nvme__spec_8h.html#a1491a0118eccaa91ff5cb9fb5d02c2c6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a1491a0118eccaa91ff5cb9fb5d02c2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b71fb615deb505826eaeddd093e06bc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a2b71fb615deb505826eaeddd093e06bc">spdk_nvmf_ctrlr_model</a> { <a class="el" href="nvme__spec_8h.html#a2b71fb615deb505826eaeddd093e06bcaa69bdafb2302e973fb9c83f8bfff29c5">SPDK_NVMF_CTRLR_MODEL_DYNAMIC</a> = 0, 
<a class="el" href="nvme__spec_8h.html#a2b71fb615deb505826eaeddd093e06bca387c04ba873422f553eec7360e4ea599">SPDK_NVMF_CTRLR_MODEL_STATIC</a> = 1
 }<tr class="memdesc:a2b71fb615deb505826eaeddd093e06bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe over Fabrics controller model.  <a href="nvme__spec_8h.html#a2b71fb615deb505826eaeddd093e06bc">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2b71fb615deb505826eaeddd093e06bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e4102cda177c51a05a6bb02fa62b87"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#af3e4102cda177c51a05a6bb02fa62b87">spdk_nvme_sgls_supported</a> { <a class="el" href="nvme__spec_8h.html#af3e4102cda177c51a05a6bb02fa62b87a5978d5c7ce04a60c9d86b157037cb2f0">SPDK_NVME_SGLS_NOT_SUPPORTED</a> = 0, 
<a class="el" href="nvme__spec_8h.html#af3e4102cda177c51a05a6bb02fa62b87ade9828594ce1d9d11427a38182149d9d">SPDK_NVME_SGLS_SUPPORTED</a> = 1, 
<a class="el" href="nvme__spec_8h.html#af3e4102cda177c51a05a6bb02fa62b87a702868f6b85dd329c4baf00642e99fca">SPDK_NVME_SGLS_SUPPORTED_DWORD_ALIGNED</a> = 2
 }<tr class="memdesc:af3e4102cda177c51a05a6bb02fa62b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify Controller data sgls.supported values.  <a href="nvme__spec_8h.html#af3e4102cda177c51a05a6bb02fa62b87">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af3e4102cda177c51a05a6bb02fa62b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c06fbd66f7572c43c51e6f106215b8d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a1c06fbd66f7572c43c51e6f106215b8d">spdk_nvme_dealloc_logical_block_read_value</a> { <a class="el" href="nvme__spec_8h.html#a1c06fbd66f7572c43c51e6f106215b8da84e7d1027736744032bc32b5f104eb2f">SPDK_NVME_DEALLOC_NOT_REPORTED</a> = 0, 
<a class="el" href="nvme__spec_8h.html#a1c06fbd66f7572c43c51e6f106215b8da315a35b15cc20a03255f8e8e4d3396ba">SPDK_NVME_DEALLOC_READ_00</a> = 1, 
<a class="el" href="nvme__spec_8h.html#a1c06fbd66f7572c43c51e6f106215b8dad8840e6a2c0c1c75b04e0c23ca829464">SPDK_NVME_DEALLOC_READ_FF</a> = 2
 }<tr class="memdesc:a1c06fbd66f7572c43c51e6f106215b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocated logical block features - read value.  <a href="nvme__spec_8h.html#a1c06fbd66f7572c43c51e6f106215b8d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a1c06fbd66f7572c43c51e6f106215b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e108757c0eebbac7e13b598a378210"><td class="memItemLeft" align="right" valign="top"><a id="aa7e108757c0eebbac7e13b598a378210"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#aa7e108757c0eebbac7e13b598a378210">spdk_nvme_reservation_type</a> { <br />
&#160;&#160;<b>SPDK_NVME_RESERVE_WRITE_EXCLUSIVE</b> = 0x1, 
<b>SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS</b> = 0x2, 
<b>SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_REG_ONLY</b> = 0x3, 
<b>SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_REG_ONLY</b> = 0x4, 
<br />
&#160;&#160;<b>SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_ALL_REGS</b> = 0x5, 
<b>SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_ALL_REGS</b> = 0x6
<br />
 }<tr class="memdesc:aa7e108757c0eebbac7e13b598a378210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reservation Type Encoding. <br /></td></tr>
</td></tr>
<tr class="separator:aa7e108757c0eebbac7e13b598a378210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b3685443c2716ee0d125c30182aeac"><td class="memItemLeft" align="right" valign="top"><a id="a95b3685443c2716ee0d125c30182aeac"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a95b3685443c2716ee0d125c30182aeac">spdk_nvme_reservation_acquire_action</a> { <b>SPDK_NVME_RESERVE_ACQUIRE</b> = 0x0, 
<b>SPDK_NVME_RESERVE_PREEMPT</b> = 0x1, 
<b>SPDK_NVME_RESERVE_PREEMPT_ABORT</b> = 0x2
 }<tr class="memdesc:a95b3685443c2716ee0d125c30182aeac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reservation Acquire action. <br /></td></tr>
</td></tr>
<tr class="separator:a95b3685443c2716ee0d125c30182aeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b2db4a398c119c029c234a68760c73"><td class="memItemLeft" align="right" valign="top"><a id="a05b2db4a398c119c029c234a68760c73"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a05b2db4a398c119c029c234a68760c73">spdk_nvme_reservation_register_cptpl</a> { <b>SPDK_NVME_RESERVE_PTPL_NO_CHANGES</b> = 0x0, 
<b>SPDK_NVME_RESERVE_PTPL_CLEAR_POWER_ON</b> = 0x2, 
<b>SPDK_NVME_RESERVE_PTPL_PERSIST_POWER_LOSS</b> = 0x3
 }<tr class="memdesc:a05b2db4a398c119c029c234a68760c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change persist through power loss state for Reservation Register command. <br /></td></tr>
</td></tr>
<tr class="separator:a05b2db4a398c119c029c234a68760c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178a7468a0a9c3e814ca2ba80e3406e5"><td class="memItemLeft" align="right" valign="top"><a id="a178a7468a0a9c3e814ca2ba80e3406e5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a178a7468a0a9c3e814ca2ba80e3406e5">spdk_nvme_reservation_register_action</a> { <b>SPDK_NVME_RESERVE_REGISTER_KEY</b> = 0x0, 
<b>SPDK_NVME_RESERVE_UNREGISTER_KEY</b> = 0x1, 
<b>SPDK_NVME_RESERVE_REPLACE_KEY</b> = 0x2
 }<tr class="memdesc:a178a7468a0a9c3e814ca2ba80e3406e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registration action for Reservation Register command. <br /></td></tr>
</td></tr>
<tr class="separator:a178a7468a0a9c3e814ca2ba80e3406e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa8ea66c4927d8bb4d81d76867e851a"><td class="memItemLeft" align="right" valign="top"><a id="a6fa8ea66c4927d8bb4d81d76867e851a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a6fa8ea66c4927d8bb4d81d76867e851a">spdk_nvme_reservation_release_action</a> { <b>SPDK_NVME_RESERVE_RELEASE</b> = 0x0, 
<b>SPDK_NVME_RESERVE_CLEAR</b> = 0x1
 }<tr class="memdesc:a6fa8ea66c4927d8bb4d81d76867e851a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reservation Release action. <br /></td></tr>
</td></tr>
<tr class="separator:a6fa8ea66c4927d8bb4d81d76867e851a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5e453e4d95b0f5b9bb4de04ace78c4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a3d5e453e4d95b0f5b9bb4de04ace78c4">spdk_nvme_log_page</a> { <br />
&#160;&#160;<a class="el" href="nvme__spec_8h.html#a3d5e453e4d95b0f5b9bb4de04ace78c4ad05013a36512c9cd6ad0249263a3f583">SPDK_NVME_LOG_ERROR</a> = 0x01, 
<a class="el" href="nvme__spec_8h.html#a3d5e453e4d95b0f5b9bb4de04ace78c4a8c4e97d27e08924e29d76ea66780a886">SPDK_NVME_LOG_HEALTH_INFORMATION</a> = 0x02, 
<a class="el" href="nvme__spec_8h.html#a3d5e453e4d95b0f5b9bb4de04ace78c4a898706714ccdcd0c5b2fee0170beecbb">SPDK_NVME_LOG_FIRMWARE_SLOT</a> = 0x03, 
<a class="el" href="nvme__spec_8h.html#a3d5e453e4d95b0f5b9bb4de04ace78c4aaa4a483997b6fa41a9e73755441d2186">SPDK_NVME_LOG_CHANGED_NS_LIST</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="nvme__spec_8h.html#a3d5e453e4d95b0f5b9bb4de04ace78c4aab219389150398bc1b23da1df91e634c">SPDK_NVME_LOG_COMMAND_EFFECTS_LOG</a> = 0x05, 
<a class="el" href="nvme__spec_8h.html#a3d5e453e4d95b0f5b9bb4de04ace78c4a373acc5fc6392f4af3cfd5c6123bb600">SPDK_NVME_LOG_DISCOVERY</a> = 0x70, 
<a class="el" href="nvme__spec_8h.html#a3d5e453e4d95b0f5b9bb4de04ace78c4a37f2ea0a63737907265ff3ed35088a09">SPDK_NVME_LOG_RESERVATION_NOTIFICATION</a> = 0x80
<br />
 }<tr class="memdesc:a3d5e453e4d95b0f5b9bb4de04ace78c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log page identifiers for SPDK_NVME_OPC_GET_LOG_PAGE.  <a href="nvme__spec_8h.html#a3d5e453e4d95b0f5b9bb4de04ace78c4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3d5e453e4d95b0f5b9bb4de04ace78c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3828a2c3688ee12cc4c2ffce0d43031f"><td class="memItemLeft" align="right" valign="top"><a id="a3828a2c3688ee12cc4c2ffce0d43031f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a3828a2c3688ee12cc4c2ffce0d43031f">spdk_nvme_ns_attach_type</a> { <b>SPDK_NVME_NS_CTRLR_ATTACH</b> = 0x0, 
<b>SPDK_NVME_NS_CTRLR_DETACH</b> = 0x1
 }<tr class="memdesc:a3828a2c3688ee12cc4c2ffce0d43031f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace attachment Type Encoding. <br /></td></tr>
</td></tr>
<tr class="separator:a3828a2c3688ee12cc4c2ffce0d43031f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e10443176e941bea118b389679c345"><td class="memItemLeft" align="right" valign="top"><a id="ae4e10443176e941bea118b389679c345"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#ae4e10443176e941bea118b389679c345">spdk_nvme_ns_management_type</a> { <b>SPDK_NVME_NS_MANAGEMENT_CREATE</b> = 0x0, 
<b>SPDK_NVME_NS_MANAGEMENT_DELETE</b> = 0x1
 }<tr class="memdesc:ae4e10443176e941bea118b389679c345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace management Type Encoding. <br /></td></tr>
</td></tr>
<tr class="separator:ae4e10443176e941bea118b389679c345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3711b38213aaa9ff7a2aa7d1efe8e2f1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a3711b38213aaa9ff7a2aa7d1efe8e2f1">spdk_nvme_nidt</a> { <a class="el" href="nvme__spec_8h.html#a3711b38213aaa9ff7a2aa7d1efe8e2f1a782356d3092200ea469f992d0677f08c">SPDK_NVME_NIDT_EUI64</a> = 0x01, 
<a class="el" href="nvme__spec_8h.html#a3711b38213aaa9ff7a2aa7d1efe8e2f1aa49a14ce8e55eb9ebefca7e0d6b4df82">SPDK_NVME_NIDT_NGUID</a> = 0x02, 
<a class="el" href="nvme__spec_8h.html#a3711b38213aaa9ff7a2aa7d1efe8e2f1ae4257777f26428ed69c6122ad06a46de">SPDK_NVME_NIDT_UUID</a> = 0x03
 }<tr class="memdesc:a3711b38213aaa9ff7a2aa7d1efe8e2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace identification descriptor type.  <a href="nvme__spec_8h.html#a3711b38213aaa9ff7a2aa7d1efe8e2f1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3711b38213aaa9ff7a2aa7d1efe8e2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e5f56ea65cdec493d43ca67dc69a33"><td class="memItemLeft" align="right" valign="top"><a id="aa0e5f56ea65cdec493d43ca67dc69a33"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_secure_erase_setting</b> { <b>SPDK_NVME_FMT_NVM_SES_NO_SECURE_ERASE</b> = 0x0, 
<b>SPDK_NVME_FMT_NVM_SES_USER_DATA_ERASE</b> = 0x1, 
<b>SPDK_NVME_FMT_NVM_SES_CRYPTO_ERASE</b> = 0x2
 }</td></tr>
<tr class="separator:aa0e5f56ea65cdec493d43ca67dc69a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86964401c50b1fbc0261ae386fb73095"><td class="memItemLeft" align="right" valign="top"><a id="a86964401c50b1fbc0261ae386fb73095"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_pi_location</b> { <b>SPDK_NVME_FMT_NVM_PROTECTION_AT_TAIL</b> = 0x0, 
<b>SPDK_NVME_FMT_NVM_PROTECTION_AT_HEAD</b> = 0x1
 }</td></tr>
<tr class="separator:a86964401c50b1fbc0261ae386fb73095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3d0ee6e884ecbb37548f9fc74f2076"><td class="memItemLeft" align="right" valign="top"><a id="a1f3d0ee6e884ecbb37548f9fc74f2076"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_pi_type</b> { <b>SPDK_NVME_FMT_NVM_PROTECTION_DISABLE</b> = 0x0, 
<b>SPDK_NVME_FMT_NVM_PROTECTION_TYPE1</b> = 0x1, 
<b>SPDK_NVME_FMT_NVM_PROTECTION_TYPE2</b> = 0x2, 
<b>SPDK_NVME_FMT_NVM_PROTECTION_TYPE3</b> = 0x3
 }</td></tr>
<tr class="separator:a1f3d0ee6e884ecbb37548f9fc74f2076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70e1b04584b7555728588ff98e18686"><td class="memItemLeft" align="right" valign="top"><a id="ad70e1b04584b7555728588ff98e18686"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_metadata_setting</b> { <b>SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_BUFFER</b> = 0x0, 
<b>SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_LBA</b> = 0x1
 }</td></tr>
<tr class="separator:ad70e1b04584b7555728588ff98e18686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4da1c1bec22eb22d1af72bbf37af36e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#ae4da1c1bec22eb22d1af72bbf37af36e">spdk_nvme_fw_commit_action</a> { <a class="el" href="nvme__spec_8h.html#ae4da1c1bec22eb22d1af72bbf37af36eaf8349fa33534c363595859493747e93f">SPDK_NVME_FW_COMMIT_REPLACE_IMG</a> = 0x0, 
<a class="el" href="nvme__spec_8h.html#ae4da1c1bec22eb22d1af72bbf37af36ea85655a09e0cae5f157d3b005ba1f4b6f">SPDK_NVME_FW_COMMIT_REPLACE_AND_ENABLE_IMG</a> = 0x1, 
<a class="el" href="nvme__spec_8h.html#ae4da1c1bec22eb22d1af72bbf37af36eab533ab92baec629b3cbeed4b81885c13">SPDK_NVME_FW_COMMIT_ENABLE_IMG</a> = 0x2, 
<a class="el" href="nvme__spec_8h.html#ae4da1c1bec22eb22d1af72bbf37af36eab62fbc9f58fcf496f7207e7fa6233a0d">SPDK_NVME_FW_COMMIT_RUN_IMG</a> = 0x3
 }<tr class="memdesc:ae4da1c1bec22eb22d1af72bbf37af36e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for SPDK_NVME_OPC_FIRMWARE_COMMIT cdw10: commit action.  <a href="nvme__spec_8h.html#ae4da1c1bec22eb22d1af72bbf37af36e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae4da1c1bec22eb22d1af72bbf37af36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae92cd8f6dbac0f9d6d858b6aa9f31f48"><td class="memItemLeft" align="right" valign="top"><a id="ae92cd8f6dbac0f9d6d858b6aa9f31f48"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(union <a class="el" href="unionspdk__nvme__cap__register.html">spdk_nvme_cap_register</a>)==8, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:ae92cd8f6dbac0f9d6d858b6aa9f31f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45f7ec968470b6507b1f44ccc9898af"><td class="memItemLeft" align="right" valign="top"><a id="ae45f7ec968470b6507b1f44ccc9898af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(union <a class="el" href="unionspdk__nvme__cc__register.html">spdk_nvme_cc_register</a>)==4, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:ae45f7ec968470b6507b1f44ccc9898af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab820b218618f32c32f65d6c47684bb75"><td class="memItemLeft" align="right" valign="top"><a id="ab820b218618f32c32f65d6c47684bb75"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(union <a class="el" href="unionspdk__nvme__csts__register.html">spdk_nvme_csts_register</a>)==4, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:ab820b218618f32c32f65d6c47684bb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9a07ed2de4d98869f489f802ed9c57"><td class="memItemLeft" align="right" valign="top"><a id="acc9a07ed2de4d98869f489f802ed9c57"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(union <a class="el" href="unionspdk__nvme__aqa__register.html">spdk_nvme_aqa_register</a>)==4, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:acc9a07ed2de4d98869f489f802ed9c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06236cae2f30325bf638d34428304797"><td class="memItemLeft" align="right" valign="top"><a id="a06236cae2f30325bf638d34428304797"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(union <a class="el" href="unionspdk__nvme__vs__register.html">spdk_nvme_vs_register</a>)==4, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a06236cae2f30325bf638d34428304797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1299fa250c8abf946a4be0163948575e"><td class="memItemLeft" align="right" valign="top"><a id="a1299fa250c8abf946a4be0163948575e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (<a class="el" href="nvme__spec_8h.html#a9760bf73611488342b5903ba702fd7b6">SPDK_NVME_VERSION</a>(1, 0, 0)==0x00010000, &quot;version macro error&quot;)</td></tr>
<tr class="separator:a1299fa250c8abf946a4be0163948575e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860f8562cd45c3c9090e03116f651f23"><td class="memItemLeft" align="right" valign="top"><a id="a860f8562cd45c3c9090e03116f651f23"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (<a class="el" href="nvme__spec_8h.html#a9760bf73611488342b5903ba702fd7b6">SPDK_NVME_VERSION</a>(1, 2, 1)==0x00010201, &quot;version macro error&quot;)</td></tr>
<tr class="separator:a860f8562cd45c3c9090e03116f651f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87d8dc374a1ac31a29bd616e539487f"><td class="memItemLeft" align="right" valign="top"><a id="ad87d8dc374a1ac31a29bd616e539487f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(union <a class="el" href="unionspdk__nvme__cmbloc__register.html">spdk_nvme_cmbloc_register</a>)==4, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:ad87d8dc374a1ac31a29bd616e539487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3d3c5777535c4e41cf6cfbbd965531"><td class="memItemLeft" align="right" valign="top"><a id="a2a3d3c5777535c4e41cf6cfbbd965531"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(union <a class="el" href="unionspdk__nvme__cmbsz__register.html">spdk_nvme_cmbsz_register</a>)==4, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a2a3d3c5777535c4e41cf6cfbbd965531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fddcee6b4cd4df31016b2d81b27e5b"><td class="memItemLeft" align="right" valign="top"><a id="a73fddcee6b4cd4df31016b2d81b27e5b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(union <a class="el" href="unionspdk__nvme__bpinfo__register.html">spdk_nvme_bpinfo_register</a>)==4, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a73fddcee6b4cd4df31016b2d81b27e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1c49a52af17031dc2937e34ba6ac36"><td class="memItemLeft" align="right" valign="top"><a id="a4c1c49a52af17031dc2937e34ba6ac36"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(union <a class="el" href="unionspdk__nvme__bprsel__register.html">spdk_nvme_bprsel_register</a>)==4, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a4c1c49a52af17031dc2937e34ba6ac36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1537ae312c41f15824dcd8454ea6be58"><td class="memItemLeft" align="right" valign="top"><a id="a1537ae312c41f15824dcd8454ea6be58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x00==offsetof(struct spdk_nvme_registers, cap), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:a1537ae312c41f15824dcd8454ea6be58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa87e0a682dd2dc9aee3edca4d6bfc79"><td class="memItemLeft" align="right" valign="top"><a id="afa87e0a682dd2dc9aee3edca4d6bfc79"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x08==offsetof(struct spdk_nvme_registers, vs), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:afa87e0a682dd2dc9aee3edca4d6bfc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50988412b135d2a7f4d9b9adeca19b54"><td class="memItemLeft" align="right" valign="top"><a id="a50988412b135d2a7f4d9b9adeca19b54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x0C==offsetof(struct spdk_nvme_registers, intms), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:a50988412b135d2a7f4d9b9adeca19b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888c2303da97ca32db3a2539d5cfdf1f"><td class="memItemLeft" align="right" valign="top"><a id="a888c2303da97ca32db3a2539d5cfdf1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x10==offsetof(struct spdk_nvme_registers, intmc), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:a888c2303da97ca32db3a2539d5cfdf1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e81724995c2383712afa520af095681"><td class="memItemLeft" align="right" valign="top"><a id="a3e81724995c2383712afa520af095681"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x14==offsetof(struct spdk_nvme_registers, cc), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:a3e81724995c2383712afa520af095681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e354f65b38a7932bbffcc792672fbbb"><td class="memItemLeft" align="right" valign="top"><a id="a0e354f65b38a7932bbffcc792672fbbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x1C==offsetof(struct spdk_nvme_registers, csts), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:a0e354f65b38a7932bbffcc792672fbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aae17bf27c8cdb05c311ebcf8a1bf0"><td class="memItemLeft" align="right" valign="top"><a id="a86aae17bf27c8cdb05c311ebcf8a1bf0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x20==offsetof(struct spdk_nvme_registers, nssr), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:a86aae17bf27c8cdb05c311ebcf8a1bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3da4b804f157f908509a606b8e26195"><td class="memItemLeft" align="right" valign="top"><a id="ac3da4b804f157f908509a606b8e26195"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x24==offsetof(struct spdk_nvme_registers, aqa), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:ac3da4b804f157f908509a606b8e26195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57aad6992894ef613511b4ad8536fd8c"><td class="memItemLeft" align="right" valign="top"><a id="a57aad6992894ef613511b4ad8536fd8c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x28==offsetof(struct spdk_nvme_registers, asq), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:a57aad6992894ef613511b4ad8536fd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85316d3dc0d9fe50742f3850ee0470a"><td class="memItemLeft" align="right" valign="top"><a id="af85316d3dc0d9fe50742f3850ee0470a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x30==offsetof(struct spdk_nvme_registers, acq), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:af85316d3dc0d9fe50742f3850ee0470a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff01c0b834abe2ffbf1d8210ec70a1d2"><td class="memItemLeft" align="right" valign="top"><a id="aff01c0b834abe2ffbf1d8210ec70a1d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x38==offsetof(struct spdk_nvme_registers, cmbloc), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:aff01c0b834abe2ffbf1d8210ec70a1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c46efb8a6ffeb7e995f61b59a0c3e41"><td class="memItemLeft" align="right" valign="top"><a id="a1c46efb8a6ffeb7e995f61b59a0c3e41"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x3C==offsetof(struct spdk_nvme_registers, cmbsz), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:a1c46efb8a6ffeb7e995f61b59a0c3e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a2b9aa67dcc5c17bb98e695b4897af"><td class="memItemLeft" align="right" valign="top"><a id="aa9a2b9aa67dcc5c17bb98e695b4897af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x40==offsetof(struct spdk_nvme_registers, bpinfo), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:aa9a2b9aa67dcc5c17bb98e695b4897af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2912768b8da739dbddd3164641695a03"><td class="memItemLeft" align="right" valign="top"><a id="a2912768b8da739dbddd3164641695a03"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x44==offsetof(struct spdk_nvme_registers, bprsel), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:a2912768b8da739dbddd3164641695a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175b8e573ea13ec1f79e16f4faa785d5"><td class="memItemLeft" align="right" valign="top"><a id="a175b8e573ea13ec1f79e16f4faa785d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (0x48==offsetof(struct spdk_nvme_registers, bpmbl), &quot;Incorrect register offset&quot;)</td></tr>
<tr class="separator:a175b8e573ea13ec1f79e16f4faa785d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29153190d32f8e78a450ee3490a903a1"><td class="memItemLeft" align="right" valign="top"><a id="a29153190d32f8e78a450ee3490a903a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__sgl__descriptor.html">spdk_nvme_sgl_descriptor</a>)==16, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a29153190d32f8e78a450ee3490a903a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6576b2cfd5e67ec9826f4d0ab327b698"><td class="memItemLeft" align="right" valign="top"><a id="a6576b2cfd5e67ec9826f4d0ab327b698"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a>)==64, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a6576b2cfd5e67ec9826f4d0ab327b698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92c30684ac2fd44cd47c71a8d33e3a9"><td class="memItemLeft" align="right" valign="top"><a id="aa92c30684ac2fd44cd47c71a8d33e3a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__status.html">spdk_nvme_status</a>)==2, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:aa92c30684ac2fd44cd47c71a8d33e3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e18dd142b56dce69eb4613b4a94ccf"><td class="memItemLeft" align="right" valign="top"><a id="a40e18dd142b56dce69eb4613b4a94ccf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a>)==16, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a40e18dd142b56dce69eb4613b4a94ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610a35e1a3abfd96ab8785680f73e136"><td class="memItemLeft" align="right" valign="top"><a id="a610a35e1a3abfd96ab8785680f73e136"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__dsm__range.html">spdk_nvme_dsm_range</a>)==16, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a610a35e1a3abfd96ab8785680f73e136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f96e024feb9e0cb23b941b847058102"><td class="memItemLeft" align="right" valign="top">static enum <a class="el" href="nvme__spec_8h.html#adbe38e042bb939183ed8fd5c1685b2fc">spdk_nvme_data_transfer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme__spec_8h.html#a3f96e024feb9e0cb23b941b847058102">spdk_nvme_opc_get_data_transfer</a> (uint8_t opc)</td></tr>
<tr class="memdesc:a3f96e024feb9e0cb23b941b847058102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the Data Transfer bits from an NVMe opcode.  <a href="#a3f96e024feb9e0cb23b941b847058102">More...</a><br /></td></tr>
<tr class="separator:a3f96e024feb9e0cb23b941b847058102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf09d50341e272b0fd0bfff5e48b7302"><td class="memItemLeft" align="right" valign="top"><a id="aaf09d50341e272b0fd0bfff5e48b7302"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__power__state.html">spdk_nvme_power_state</a>)==32, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:aaf09d50341e272b0fd0bfff5e48b7302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6b1881050ce1e19f5e89e72230474f"><td class="memItemLeft" align="right" valign="top"><a id="a7b6b1881050ce1e19f5e89e72230474f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__ctrlr__data.html">spdk_nvme_ctrlr_data</a>)==4096, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a7b6b1881050ce1e19f5e89e72230474f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c4073a8cd606892be4c21da7c2f598"><td class="memItemLeft" align="right" valign="top"><a id="a37c4073a8cd606892be4c21da7c2f598"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a>)==4096, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a37c4073a8cd606892be4c21da7c2f598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37c51f2c7986e10891430b01cec55e5"><td class="memItemLeft" align="right" valign="top"><a id="ae37c51f2c7986e10891430b01cec55e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__reservation__acquire__data.html">spdk_nvme_reservation_acquire_data</a>)==16, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:ae37c51f2c7986e10891430b01cec55e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070304fde1263b382bee9ab2cec0817c"><td class="memItemLeft" align="right" valign="top"><a id="a070304fde1263b382bee9ab2cec0817c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__reservation__status__data.html">spdk_nvme_reservation_status_data</a>)==24, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a070304fde1263b382bee9ab2cec0817c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1730460a8913d771cb15b21802301ab1"><td class="memItemLeft" align="right" valign="top"><a id="a1730460a8913d771cb15b21802301ab1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__reservation__ctrlr__data.html">spdk_nvme_reservation_ctrlr_data</a>)==24, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a1730460a8913d771cb15b21802301ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d66426372b8df1763ae194f7baca68"><td class="memItemLeft" align="right" valign="top"><a id="ab4d66426372b8df1763ae194f7baca68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__reservation__register__data.html">spdk_nvme_reservation_register_data</a>)==16, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:ab4d66426372b8df1763ae194f7baca68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ea2561b7f1b6a9401e2a63df3d8f74"><td class="memItemLeft" align="right" valign="top"><a id="a76ea2561b7f1b6a9401e2a63df3d8f74"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__reservation__key__data.html">spdk_nvme_reservation_key_data</a>)==8, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a76ea2561b7f1b6a9401e2a63df3d8f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30bbb384ce0ef2931484014453368bb"><td class="memItemLeft" align="right" valign="top"><a id="af30bbb384ce0ef2931484014453368bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__error__information__entry.html">spdk_nvme_error_information_entry</a>)==64, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:af30bbb384ce0ef2931484014453368bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19da86ce679590c8d2f74304e10d5ad1"><td class="memItemLeft" align="right" valign="top"><a id="a19da86ce679590c8d2f74304e10d5ad1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(union <a class="el" href="unionspdk__nvme__critical__warning__state.html">spdk_nvme_critical_warning_state</a>)==1, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a19da86ce679590c8d2f74304e10d5ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e242836a69ed1a6159618e2b47a429"><td class="memItemLeft" align="right" valign="top"><a id="af1e242836a69ed1a6159618e2b47a429"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__health__information__page.html">spdk_nvme_health_information_page</a>)==512, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:af1e242836a69ed1a6159618e2b47a429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac8d0ddfee76064163c4fa55aa8341f"><td class="memItemLeft" align="right" valign="top"><a id="a4ac8d0ddfee76064163c4fa55aa8341f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__firmware__page.html">spdk_nvme_firmware_page</a>)==512, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a4ac8d0ddfee76064163c4fa55aa8341f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82d97bff3b43c67eec6fe7844bde01e"><td class="memItemLeft" align="right" valign="top"><a id="ae82d97bff3b43c67eec6fe7844bde01e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__ns__list.html">spdk_nvme_ns_list</a>)==4096, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:ae82d97bff3b43c67eec6fe7844bde01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf146a891b748113049c48d790f5f78c"><td class="memItemLeft" align="right" valign="top"><a id="abf146a891b748113049c48d790f5f78c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__ns__id__desc.html">spdk_nvme_ns_id_desc</a>)==4, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:abf146a891b748113049c48d790f5f78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c648060c02e8f65344f461a3350c7c"><td class="memItemLeft" align="right" valign="top"><a id="ae4c648060c02e8f65344f461a3350c7c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__ctrlr__list.html">spdk_nvme_ctrlr_list</a>)==4096, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:ae4c648060c02e8f65344f461a3350c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be8d53b97a2c3cb3af9b321eb59d7c5"><td class="memItemLeft" align="right" valign="top"><a id="a2be8d53b97a2c3cb3af9b321eb59d7c5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__format.html">spdk_nvme_format</a>)==4, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a2be8d53b97a2c3cb3af9b321eb59d7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c867478eb707af3711596989e487eed"><td class="memItemLeft" align="right" valign="top"><a id="a9c867478eb707af3711596989e487eed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__protection__info.html">spdk_nvme_protection_info</a>)==8, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a9c867478eb707af3711596989e487eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f00caa7dfb77c3060a6759968cb53c"><td class="memItemLeft" align="right" valign="top"><a id="a84f00caa7dfb77c3060a6759968cb53c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__fw__commit.html">spdk_nvme_fw_commit</a>)==4, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a84f00caa7dfb77c3060a6759968cb53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>NVMe specification definitions. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9760bf73611488342b5903ba702fd7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9760bf73611488342b5903ba702fd7b6">&#9670;&nbsp;</a></span>SPDK_NVME_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPDK_NVME_VERSION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mjr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mnr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ter&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((uint32_t)(mjr) &lt;&lt; 16) | \</div><div class="line">        ((uint32_t)(mnr) &lt;&lt; 8) | \</div><div class="line">        (uint32_t)(ter))</div></div><!-- fragment -->
<p>Generate raw version in the same format as <a class="el" href="unionspdk__nvme__vs__register.html">spdk_nvme_vs_register</a> for comparison. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adf6ad5ec9f8c1aa4c7efc45ee9d646b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6ad5ec9f8c1aa4c7efc45ee9d646b6">&#9670;&nbsp;</a></span>spdk_nvme_cap_ams</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme__spec_8h.html#adf6ad5ec9f8c1aa4c7efc45ee9d646b6">spdk_nvme_cap_ams</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional Arbitration Mechanism Supported by the controller. </p>
<p>Two bits for CAP.AMS (18:17) field are set to '1' when the controller supports. There is no bit for AMS_RR where all controllers support and set to 0x0 by default. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adf6ad5ec9f8c1aa4c7efc45ee9d646b6ac8b3721eb6c714051f08db20938b31af"></a>SPDK_NVME_CAP_AMS_WRR&#160;</td><td class="fielddoc"><p>weighted round robin </p>
</td></tr>
<tr><td class="fieldname"><a id="adf6ad5ec9f8c1aa4c7efc45ee9d646b6a0bae550fd4027110273cc75986809274"></a>SPDK_NVME_CAP_AMS_VS&#160;</td><td class="fielddoc"><p>vendor specific </p>
</td></tr>
</table>

</div>
</div>
<a id="a7e72566466cae734d999e755524f7b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e72566466cae734d999e755524f7b20">&#9670;&nbsp;</a></span>spdk_nvme_cc_ams</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme__spec_8h.html#a7e72566466cae734d999e755524f7b20">spdk_nvme_cc_ams</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arbitration Mechanism Selected to the controller. </p>
<p>Value 0x2 to 0x6 is reserved. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7e72566466cae734d999e755524f7b20a5064340c35b2c9179d85de39edccdf6c"></a>SPDK_NVME_CC_AMS_RR&#160;</td><td class="fielddoc"><p>default round robin </p>
</td></tr>
<tr><td class="fieldname"><a id="a7e72566466cae734d999e755524f7b20a5c1162b2ac15358567bc0da6cfd2c62d"></a>SPDK_NVME_CC_AMS_WRR&#160;</td><td class="fielddoc"><p>weighted round robin </p>
</td></tr>
<tr><td class="fieldname"><a id="a7e72566466cae734d999e755524f7b20a5690f8273561b4be28e1f7d5ae5d8167"></a>SPDK_NVME_CC_AMS_VS&#160;</td><td class="fielddoc"><p>vendor specific </p>
</td></tr>
</table>

</div>
</div>
<a id="adbe38e042bb939183ed8fd5c1685b2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe38e042bb939183ed8fd5c1685b2fc">&#9670;&nbsp;</a></span>spdk_nvme_data_transfer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme__spec_8h.html#adbe38e042bb939183ed8fd5c1685b2fc">spdk_nvme_data_transfer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data transfer (bits 1:0) of an NVMe opcode. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme__spec_8h.html#a3f96e024feb9e0cb23b941b847058102" title="Extract the Data Transfer bits from an NVMe opcode. ">spdk_nvme_opc_get_data_transfer</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adbe38e042bb939183ed8fd5c1685b2fca4d074786dad4f37c0211563ec0376974"></a>SPDK_NVME_DATA_NONE&#160;</td><td class="fielddoc"><p>Opcode does not transfer data. </p>
</td></tr>
<tr><td class="fieldname"><a id="adbe38e042bb939183ed8fd5c1685b2fca7f08188b3c5f57f2f694f6ef13ad0110"></a>SPDK_NVME_DATA_HOST_TO_CONTROLLER&#160;</td><td class="fielddoc"><p>Opcode transfers data from host to controller (e.g. </p>
<p>Write) </p>
</td></tr>
<tr><td class="fieldname"><a id="adbe38e042bb939183ed8fd5c1685b2fca0de3a8ad0600034555094591e706fb50"></a>SPDK_NVME_DATA_CONTROLLER_TO_HOST&#160;</td><td class="fielddoc"><p>Opcode transfers data from controller to host (e.g. </p>
<p>Read) </p>
</td></tr>
<tr><td class="fieldname"><a id="adbe38e042bb939183ed8fd5c1685b2fcaa550f0ebf32623c8161ca7d5d8cbb0c2"></a>SPDK_NVME_DATA_BIDIRECTIONAL&#160;</td><td class="fielddoc"><p>Opcode transfers data both directions. </p>
</td></tr>
</table>

</div>
</div>
<a id="a1c06fbd66f7572c43c51e6f106215b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c06fbd66f7572c43c51e6f106215b8d">&#9670;&nbsp;</a></span>spdk_nvme_dealloc_logical_block_read_value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme__spec_8h.html#a1c06fbd66f7572c43c51e6f106215b8d">spdk_nvme_dealloc_logical_block_read_value</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocated logical block features - read value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1c06fbd66f7572c43c51e6f106215b8da84e7d1027736744032bc32b5f104eb2f"></a>SPDK_NVME_DEALLOC_NOT_REPORTED&#160;</td><td class="fielddoc"><p>Not reported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c06fbd66f7572c43c51e6f106215b8da315a35b15cc20a03255f8e8e4d3396ba"></a>SPDK_NVME_DEALLOC_READ_00&#160;</td><td class="fielddoc"><p>Deallocated blocks read 0x00. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1c06fbd66f7572c43c51e6f106215b8dad8840e6a2c0c1c75b04e0c23ca829464"></a>SPDK_NVME_DEALLOC_READ_FF&#160;</td><td class="fielddoc"><p>Deallocated blocks read 0xFF. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae4da1c1bec22eb22d1af72bbf37af36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4da1c1bec22eb22d1af72bbf37af36e">&#9670;&nbsp;</a></span>spdk_nvme_fw_commit_action</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme__spec_8h.html#ae4da1c1bec22eb22d1af72bbf37af36e">spdk_nvme_fw_commit_action</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parameters for SPDK_NVME_OPC_FIRMWARE_COMMIT cdw10: commit action. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae4da1c1bec22eb22d1af72bbf37af36eaf8349fa33534c363595859493747e93f"></a>SPDK_NVME_FW_COMMIT_REPLACE_IMG&#160;</td><td class="fielddoc"><p>Downloaded image replaces the image specified by the Firmware Slot field. </p>
<p>This image is not activated. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae4da1c1bec22eb22d1af72bbf37af36ea85655a09e0cae5f157d3b005ba1f4b6f"></a>SPDK_NVME_FW_COMMIT_REPLACE_AND_ENABLE_IMG&#160;</td><td class="fielddoc"><p>Downloaded image replaces the image specified by the Firmware Slot field. </p>
<p>This image is activated at the next reset. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae4da1c1bec22eb22d1af72bbf37af36eab533ab92baec629b3cbeed4b81885c13"></a>SPDK_NVME_FW_COMMIT_ENABLE_IMG&#160;</td><td class="fielddoc"><p>The image specified by the Firmware Slot field is activated at the next reset. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae4da1c1bec22eb22d1af72bbf37af36eab62fbc9f58fcf496f7207e7fa6233a0d"></a>SPDK_NVME_FW_COMMIT_RUN_IMG&#160;</td><td class="fielddoc"><p>The image specified by the Firmware Slot field is requested to be activated immediately without reset. </p>
</td></tr>
</table>

</div>
</div>
<a id="a1491a0118eccaa91ff5cb9fb5d02c2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1491a0118eccaa91ff5cb9fb5d02c2c6">&#9670;&nbsp;</a></span>spdk_nvme_identify_cns</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme__spec_8h.html#a1491a0118eccaa91ff5cb9fb5d02c2c6">spdk_nvme_identify_cns</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify command CNS value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1491a0118eccaa91ff5cb9fb5d02c2c6a0e3f9941eabe22d5b3c7c86043d0de32"></a>SPDK_NVME_IDENTIFY_NS&#160;</td><td class="fielddoc"><p>Identify namespace indicated in CDW1.NSID. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1491a0118eccaa91ff5cb9fb5d02c2c6a4a37f16cc815935d6ca7c5fc72446ba1"></a>SPDK_NVME_IDENTIFY_CTRLR&#160;</td><td class="fielddoc"><p>Identify controller. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1491a0118eccaa91ff5cb9fb5d02c2c6a8cfbe8373c7c619033d60eede0106f9c"></a>SPDK_NVME_IDENTIFY_ACTIVE_NS_LIST&#160;</td><td class="fielddoc"><p>List active NSIDs greater than CDW1.NSID. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1491a0118eccaa91ff5cb9fb5d02c2c6ab945a36d2eb0c77e3c7eec85036e57e8"></a>SPDK_NVME_IDENTIFY_NS_ID_DESCRIPTOR_LIST&#160;</td><td class="fielddoc"><p>List namespace identification descriptors. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1491a0118eccaa91ff5cb9fb5d02c2c6a6d869fc169f9b1a1710ea422c60fe1c1"></a>SPDK_NVME_IDENTIFY_ALLOCATED_NS_LIST&#160;</td><td class="fielddoc"><p>List allocated NSIDs greater than CDW1.NSID. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1491a0118eccaa91ff5cb9fb5d02c2c6a2577422800e8e7b6da496ff0e26d72ad"></a>SPDK_NVME_IDENTIFY_NS_ALLOCATED&#160;</td><td class="fielddoc"><p>Identify namespace if CDW1.NSID is allocated. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1491a0118eccaa91ff5cb9fb5d02c2c6a406d8a0fd54843bf3a769c709be8c78a"></a>SPDK_NVME_IDENTIFY_NS_ATTACHED_CTRLR_LIST&#160;</td><td class="fielddoc"><p>Get list of controllers starting at CDW10.CNTID that are attached to CDW1.NSID. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1491a0118eccaa91ff5cb9fb5d02c2c6aeb2ab6a252ff942ca407e965a43069d8"></a>SPDK_NVME_IDENTIFY_CTRLR_LIST&#160;</td><td class="fielddoc"><p>Get list of controllers starting at CDW10.CNTID. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1491a0118eccaa91ff5cb9fb5d02c2c6a529c0f24ec3362cef551610db7d9642a"></a>SPDK_NVME_IDENTIFY_PRIMARY_CTRLR_CAP&#160;</td><td class="fielddoc"><p>Get primary controller capabilities structure. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1491a0118eccaa91ff5cb9fb5d02c2c6acf0506a0b05a13ae3cd613dc3caf365b"></a>SPDK_NVME_IDENTIFY_SECONDARY_CTRLR_LIST&#160;</td><td class="fielddoc"><p>Get secondary controller list. </p>
</td></tr>
</table>

</div>
</div>
<a id="a3d5e453e4d95b0f5b9bb4de04ace78c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5e453e4d95b0f5b9bb4de04ace78c4">&#9670;&nbsp;</a></span>spdk_nvme_log_page</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme__spec_8h.html#a3d5e453e4d95b0f5b9bb4de04ace78c4">spdk_nvme_log_page</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log page identifiers for SPDK_NVME_OPC_GET_LOG_PAGE. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3d5e453e4d95b0f5b9bb4de04ace78c4ad05013a36512c9cd6ad0249263a3f583"></a>SPDK_NVME_LOG_ERROR&#160;</td><td class="fielddoc"><p>Error information (mandatory) - <a class="el" href="structspdk__nvme__error__information__entry.html">spdk_nvme_error_information_entry</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5e453e4d95b0f5b9bb4de04ace78c4a8c4e97d27e08924e29d76ea66780a886"></a>SPDK_NVME_LOG_HEALTH_INFORMATION&#160;</td><td class="fielddoc"><p>SMART / health information (mandatory) - <a class="el" href="structspdk__nvme__health__information__page.html">spdk_nvme_health_information_page</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5e453e4d95b0f5b9bb4de04ace78c4a898706714ccdcd0c5b2fee0170beecbb"></a>SPDK_NVME_LOG_FIRMWARE_SLOT&#160;</td><td class="fielddoc"><p>Firmware slot information (mandatory) - <a class="el" href="structspdk__nvme__firmware__page.html">spdk_nvme_firmware_page</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5e453e4d95b0f5b9bb4de04ace78c4aaa4a483997b6fa41a9e73755441d2186"></a>SPDK_NVME_LOG_CHANGED_NS_LIST&#160;</td><td class="fielddoc"><p>Changed namespace list (optional) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5e453e4d95b0f5b9bb4de04ace78c4aab219389150398bc1b23da1df91e634c"></a>SPDK_NVME_LOG_COMMAND_EFFECTS_LOG&#160;</td><td class="fielddoc"><p>Command effects log (optional) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5e453e4d95b0f5b9bb4de04ace78c4a373acc5fc6392f4af3cfd5c6123bb600"></a>SPDK_NVME_LOG_DISCOVERY&#160;</td><td class="fielddoc"><p>Discovery(refer to the NVMe over Fabrics specification) </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d5e453e4d95b0f5b9bb4de04ace78c4a37f2ea0a63737907265ff3ed35088a09"></a>SPDK_NVME_LOG_RESERVATION_NOTIFICATION&#160;</td><td class="fielddoc"><p>Reservation notification (optional) </p>
</td></tr>
</table>

</div>
</div>
<a id="a3711b38213aaa9ff7a2aa7d1efe8e2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3711b38213aaa9ff7a2aa7d1efe8e2f1">&#9670;&nbsp;</a></span>spdk_nvme_nidt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme__spec_8h.html#a3711b38213aaa9ff7a2aa7d1efe8e2f1">spdk_nvme_nidt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Namespace identification descriptor type. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structspdk__nvme__ns__id__desc.html">spdk_nvme_ns_id_desc</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3711b38213aaa9ff7a2aa7d1efe8e2f1a782356d3092200ea469f992d0677f08c"></a>SPDK_NVME_NIDT_EUI64&#160;</td><td class="fielddoc"><p>IEEE Extended Unique Identifier. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3711b38213aaa9ff7a2aa7d1efe8e2f1aa49a14ce8e55eb9ebefca7e0d6b4df82"></a>SPDK_NVME_NIDT_NGUID&#160;</td><td class="fielddoc"><p>Namespace GUID. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3711b38213aaa9ff7a2aa7d1efe8e2f1ae4257777f26428ed69c6122ad06a46de"></a>SPDK_NVME_NIDT_UUID&#160;</td><td class="fielddoc"><p>Namespace UUID. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae83a61e254cf9d1fd59376ceedd1b4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83a61e254cf9d1fd59376ceedd1b4e6">&#9670;&nbsp;</a></span>spdk_nvme_qprio</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme__spec_8h.html#ae83a61e254cf9d1fd59376ceedd1b4e6">spdk_nvme_qprio</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submission queue priority values for Create I/O Submission Queue Command. </p>
<p>Only valid for weighted round robin arbitration method. </p>

</div>
</div>
<a id="af3e4102cda177c51a05a6bb02fa62b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e4102cda177c51a05a6bb02fa62b87">&#9670;&nbsp;</a></span>spdk_nvme_sgls_supported</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme__spec_8h.html#af3e4102cda177c51a05a6bb02fa62b87">spdk_nvme_sgls_supported</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify Controller data sgls.supported values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af3e4102cda177c51a05a6bb02fa62b87a5978d5c7ce04a60c9d86b157037cb2f0"></a>SPDK_NVME_SGLS_NOT_SUPPORTED&#160;</td><td class="fielddoc"><p>SGLs are not supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="af3e4102cda177c51a05a6bb02fa62b87ade9828594ce1d9d11427a38182149d9d"></a>SPDK_NVME_SGLS_SUPPORTED&#160;</td><td class="fielddoc"><p>SGLs are supported with no alignment or granularity requirement. </p>
</td></tr>
<tr><td class="fieldname"><a id="af3e4102cda177c51a05a6bb02fa62b87a702868f6b85dd329c4baf00642e99fca"></a>SPDK_NVME_SGLS_SUPPORTED_DWORD_ALIGNED&#160;</td><td class="fielddoc"><p>SGLs are supported with a DWORD alignment and granularity requirement. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2b71fb615deb505826eaeddd093e06bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b71fb615deb505826eaeddd093e06bc">&#9670;&nbsp;</a></span>spdk_nvmf_ctrlr_model</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme__spec_8h.html#a2b71fb615deb505826eaeddd093e06bc">spdk_nvmf_ctrlr_model</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NVMe over Fabrics controller model. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2b71fb615deb505826eaeddd093e06bcaa69bdafb2302e973fb9c83f8bfff29c5"></a>SPDK_NVMF_CTRLR_MODEL_DYNAMIC&#160;</td><td class="fielddoc"><p>NVM subsystem uses dynamic controller model. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b71fb615deb505826eaeddd093e06bca387c04ba873422f553eec7360e4ea599"></a>SPDK_NVMF_CTRLR_MODEL_STATIC&#160;</td><td class="fielddoc"><p>NVM subsystem uses static controller model. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3f96e024feb9e0cb23b941b847058102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f96e024feb9e0cb23b941b847058102">&#9670;&nbsp;</a></span>spdk_nvme_opc_get_data_transfer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static enum <a class="el" href="nvme__spec_8h.html#adbe38e042bb939183ed8fd5c1685b2fc">spdk_nvme_data_transfer</a> spdk_nvme_opc_get_data_transfer </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>opc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the Data Transfer bits from an NVMe opcode. </p>
<p>This determines whether a command requires a data buffer and which direction (host to controller or controller to host) it is transferred. </p>

</div>
</div>
</div><!-- contents -->
</div>
