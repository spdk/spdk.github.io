<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="generator" content="Doxygen 1.10.0" />
  <title>SPDK: blob.h File Reference</title>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  <script type="text/javascript" src="../js/doxyboot.js"></script>
  <script type="text/javascript" src="./navtree.js"></script>
  <link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
<body>
  <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/" aria-label="SPDK">
      <img src="/img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <div class="navbar-nav me-auto">
        <a class="nav-link header-link active" href="../doc/">Documentation</a>
        <a class="nav-link header-link" href="../development/">Development</a>
        <a class="nav-link header-link" href="../community/">Community</a>
        <a class="nav-link header-link" href="../blog/">Blog</a>
      </div>
      <div class="navbar-nav ms-auto me-3">
        <a class="nav-link header-link" href="https://github.com/spdk/spdk">
          <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
      </div>
    </div>
  </nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('blob_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">blob.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Blob Storage System.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__bs__dev__cb__args.html">spdk_bs_dev_cb_args</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__blob__ext__io__opts.html">spdk_blob_ext_io_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure with optional IO request parameters The content of this structure must be valid until the IO request is completed.  <a href="structspdk__blob__ext__io__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__bs__type.html">spdk_bs_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__blob__xattr__opts.html">spdk_blob_xattr_opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__blob__opts.html">spdk_blob_opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__blob__open__opts.html">spdk_blob_open_opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3caeda168fe1a5b8b809b546d92eede2" id="r_a3caeda168fe1a5b8b809b546d92eede2"><td class="memItemLeft" align="right" valign="top"><a id="a3caeda168fe1a5b8b809b546d92eede2" name="a3caeda168fe1a5b8b809b546d92eede2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_BLOBID_INVALID</b>&#160;&#160;&#160;(uint64_t)-1</td></tr>
<tr class="separator:a3caeda168fe1a5b8b809b546d92eede2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3892d19dd95f38adcc2d2443cf04a31" id="r_ab3892d19dd95f38adcc2d2443cf04a31"><td class="memItemLeft" align="right" valign="top"><a id="ab3892d19dd95f38adcc2d2443cf04a31" name="ab3892d19dd95f38adcc2d2443cf04a31"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_BLOBID_EXTERNAL_SNAPSHOT</b>&#160;&#160;&#160;(uint64_t)-2</td></tr>
<tr class="separator:ab3892d19dd95f38adcc2d2443cf04a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bbf0471f09e63cd362ed279b71deb5" id="r_a18bbf0471f09e63cd362ed279b71deb5"><td class="memItemLeft" align="right" valign="top"><a id="a18bbf0471f09e63cd362ed279b71deb5" name="a18bbf0471f09e63cd362ed279b71deb5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_BLOBSTORE_TYPE_LENGTH</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a18bbf0471f09e63cd362ed279b71deb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a25618c94412200a1a6ef635d13f3b93b" id="r_a25618c94412200a1a6ef635d13f3b93b"><td class="memItemLeft" align="right" valign="top"><a id="a25618c94412200a1a6ef635d13f3b93b" name="a25618c94412200a1a6ef635d13f3b93b"></a>
typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_blob_id</b></td></tr>
<tr class="separator:a25618c94412200a1a6ef635d13f3b93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c265d4eead39c3419cee4b620bf5052" id="r_a9c265d4eead39c3419cee4b620bf5052"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c265d4eead39c3419cee4b620bf5052">spdk_bs_op_complete</a>) (void *cb_arg, int bserrno)</td></tr>
<tr class="memdesc:a9c265d4eead39c3419cee4b620bf5052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blobstore operation completion callback.  <br /></td></tr>
<tr class="separator:a9c265d4eead39c3419cee4b620bf5052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a976910f2112a4164ae6a12b946855" id="r_a40a976910f2112a4164ae6a12b946855"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40a976910f2112a4164ae6a12b946855">spdk_bs_op_with_handle_complete</a>) (void *cb_arg, struct spdk_blob_store *bs, int bserrno)</td></tr>
<tr class="memdesc:a40a976910f2112a4164ae6a12b946855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blobstore operation completion callback with handle.  <br /></td></tr>
<tr class="separator:a40a976910f2112a4164ae6a12b946855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5253109581a768e06dd197429ef9e1" id="r_aca5253109581a768e06dd197429ef9e1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a>) (void *cb_arg, int bserrno)</td></tr>
<tr class="memdesc:aca5253109581a768e06dd197429ef9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blob operation completion callback.  <br /></td></tr>
<tr class="separator:aca5253109581a768e06dd197429ef9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4955592d73cb1a262d699d10c8e2856f" id="r_a4955592d73cb1a262d699d10c8e2856f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4955592d73cb1a262d699d10c8e2856f">spdk_blob_op_with_id_complete</a>) (void *cb_arg, spdk_blob_id blobid, int bserrno)</td></tr>
<tr class="memdesc:a4955592d73cb1a262d699d10c8e2856f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blob operation completion callback with blob ID.  <br /></td></tr>
<tr class="separator:a4955592d73cb1a262d699d10c8e2856f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6d19ccc3c952877c355030e2a286c1" id="r_aab6d19ccc3c952877c355030e2a286c1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab6d19ccc3c952877c355030e2a286c1">spdk_blob_op_with_handle_complete</a>) (void *cb_arg, struct spdk_blob *blb, int bserrno)</td></tr>
<tr class="memdesc:aab6d19ccc3c952877c355030e2a286c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blob operation completion callback with handle.  <br /></td></tr>
<tr class="separator:aab6d19ccc3c952877c355030e2a286c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1f64973b22548813723a645f9b8995" id="r_afb1f64973b22548813723a645f9b8995"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb1f64973b22548813723a645f9b8995">spdk_bs_dev_cpl</a>) (struct spdk_io_channel *channel, void *cb_arg, int bserrno)</td></tr>
<tr class="memdesc:afb1f64973b22548813723a645f9b8995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blobstore device completion callback.  <br /></td></tr>
<tr class="separator:afb1f64973b22548813723a645f9b8995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674db2e2ce68c181b11ffd676b8cc51b" id="r_a674db2e2ce68c181b11ffd676b8cc51b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a674db2e2ce68c181b11ffd676b8cc51b">spdk_blob_op_with_bs_dev</a>) (void *cb_arg, struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *bs_dev, int bserrno)</td></tr>
<tr class="memdesc:a674db2e2ce68c181b11ffd676b8cc51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blob device open completion callback with blobstore device.  <br /></td></tr>
<tr class="separator:a674db2e2ce68c181b11ffd676b8cc51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9de71c711c86a2fb7b9a7d967ebede4" id="r_aa9de71c711c86a2fb7b9a7d967ebede4"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9de71c711c86a2fb7b9a7d967ebede4">spdk_bs_esnap_dev_create</a>) (void *bs_ctx, void *blob_ctx, struct spdk_blob *blob, const void *esnap_id, uint32_t id_size, struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> **bs_dev)</td></tr>
<tr class="memdesc:aa9de71c711c86a2fb7b9a7d967ebede4"><td class="mdescLeft">&#160;</td><td class="mdescRight">External snapshot device open callback.  <br /></td></tr>
<tr class="separator:aa9de71c711c86a2fb7b9a7d967ebede4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668cd9f989594d7f4f417495ffa7517d" id="r_a668cd9f989594d7f4f417495ffa7517d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a668cd9f989594d7f4f417495ffa7517d">spdk_blob_shallow_copy_status</a>) (uint64_t copied_clusters, void *cb_arg)</td></tr>
<tr class="memdesc:a668cd9f989594d7f4f417495ffa7517d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blob shallow copy status callback.  <br /></td></tr>
<tr class="separator:a668cd9f989594d7f4f417495ffa7517d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae099ff1947cd0f1e8422289222bc1666" id="r_ae099ff1947cd0f1e8422289222bc1666"><td class="memItemLeft" align="right" valign="top"><a id="ae099ff1947cd0f1e8422289222bc1666" name="ae099ff1947cd0f1e8422289222bc1666"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bs_dump_print_xattr</b>) (FILE *fp, const char *bstype, const char *name, const void *value, size_t value_length)</td></tr>
<tr class="separator:ae099ff1947cd0f1e8422289222bc1666"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a59a8d82e28e326595d68b63e0412aa5f" id="r_a59a8d82e28e326595d68b63e0412aa5f"><td class="memItemLeft" align="right" valign="top"><a id="a59a8d82e28e326595d68b63e0412aa5f" name="a59a8d82e28e326595d68b63e0412aa5f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>blob_clear_method</b> { <b>BLOB_CLEAR_WITH_DEFAULT</b>
, <b>BLOB_CLEAR_WITH_NONE</b>
, <b>BLOB_CLEAR_WITH_UNMAP</b>
, <b>BLOB_CLEAR_WITH_WRITE_ZEROES</b>
 }</td></tr>
<tr class="separator:a59a8d82e28e326595d68b63e0412aa5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaee083ec43c409cfe9b86309ad751c6" id="r_acaee083ec43c409cfe9b86309ad751c6"><td class="memItemLeft" align="right" valign="top"><a id="acaee083ec43c409cfe9b86309ad751c6" name="acaee083ec43c409cfe9b86309ad751c6"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>bs_clear_method</b> { <b>BS_CLEAR_WITH_UNMAP</b>
, <b>BS_CLEAR_WITH_WRITE_ZEROES</b>
, <b>BS_CLEAR_WITH_NONE</b>
 }</td></tr>
<tr class="separator:acaee083ec43c409cfe9b86309ad751c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9adaf62358930fae9a67fe5523d254a2" id="r_a9adaf62358930fae9a67fe5523d254a2"><td class="memItemLeft" align="right" valign="top"><a id="a9adaf62358930fae9a67fe5523d254a2" name="a9adaf62358930fae9a67fe5523d254a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__blob__ext__io__opts.html">spdk_blob_ext_io_opts</a>)==32, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a9adaf62358930fae9a67fe5523d254a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3db422648ad9a58354d4973a7af60f6" id="r_ac3db422648ad9a58354d4973a7af60f6"><td class="memItemLeft" align="right" valign="top"><a id="ac3db422648ad9a58354d4973a7af60f6" name="ac3db422648ad9a58354d4973a7af60f6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a>)==88, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:ac3db422648ad9a58354d4973a7af60f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d76e2deeb5cc5354d23370914b28e2a" id="r_a2d76e2deeb5cc5354d23370914b28e2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d76e2deeb5cc5354d23370914b28e2a">spdk_bs_opts_init</a> (struct <a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:a2d76e2deeb5cc5354d23370914b28e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a> structure to the default blobstore option values.  <br /></td></tr>
<tr class="separator:a2d76e2deeb5cc5354d23370914b28e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400da20b69e4f914730fbd15d51eb748" id="r_a400da20b69e4f914730fbd15d51eb748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a400da20b69e4f914730fbd15d51eb748">spdk_bs_load</a> (struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *dev, struct <a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a> *opts, <a class="el" href="#a40a976910f2112a4164ae6a12b946855">spdk_bs_op_with_handle_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a400da20b69e4f914730fbd15d51eb748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a blobstore from the given device.  <br /></td></tr>
<tr class="separator:a400da20b69e4f914730fbd15d51eb748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc717fee381a5dd5c6e1e6f979f1202" id="r_a0fc717fee381a5dd5c6e1e6f979f1202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fc717fee381a5dd5c6e1e6f979f1202">spdk_bs_grow</a> (struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *dev, struct <a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a> *opts, <a class="el" href="#a40a976910f2112a4164ae6a12b946855">spdk_bs_op_with_handle_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a0fc717fee381a5dd5c6e1e6f979f1202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grow a blobstore to fill the underlying device Cannot be used on loaded blobstore.  <br /></td></tr>
<tr class="separator:a0fc717fee381a5dd5c6e1e6f979f1202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd61903827b230cf2f6d25fb321e8d0" id="r_a1bd61903827b230cf2f6d25fb321e8d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bd61903827b230cf2f6d25fb321e8d0">spdk_bs_grow_live</a> (struct spdk_blob_store *bs, <a class="el" href="#a9c265d4eead39c3419cee4b620bf5052">spdk_bs_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a1bd61903827b230cf2f6d25fb321e8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grow a blobstore to fill the underlying device.  <br /></td></tr>
<tr class="separator:a1bd61903827b230cf2f6d25fb321e8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59f1d147b612a7d4ce1eb8439a69cee" id="r_ad59f1d147b612a7d4ce1eb8439a69cee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad59f1d147b612a7d4ce1eb8439a69cee">spdk_bs_init</a> (struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *dev, struct <a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a> *opts, <a class="el" href="#a40a976910f2112a4164ae6a12b946855">spdk_bs_op_with_handle_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ad59f1d147b612a7d4ce1eb8439a69cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a blobstore on the given device.  <br /></td></tr>
<tr class="separator:ad59f1d147b612a7d4ce1eb8439a69cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75072ce1a5a9559fe2db0da30363ad4" id="r_aa75072ce1a5a9559fe2db0da30363ad4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa75072ce1a5a9559fe2db0da30363ad4">spdk_bs_dump</a> (struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *dev, FILE *fp, spdk_bs_dump_print_xattr print_xattr_fn, <a class="el" href="#a9c265d4eead39c3419cee4b620bf5052">spdk_bs_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aa75072ce1a5a9559fe2db0da30363ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a blobstore's metadata to a given FILE in human-readable format.  <br /></td></tr>
<tr class="separator:aa75072ce1a5a9559fe2db0da30363ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba54d7b0d88a136bbfc9f93bc10b87d" id="r_a0ba54d7b0d88a136bbfc9f93bc10b87d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ba54d7b0d88a136bbfc9f93bc10b87d">spdk_bs_destroy</a> (struct spdk_blob_store *bs, <a class="el" href="#a9c265d4eead39c3419cee4b620bf5052">spdk_bs_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a0ba54d7b0d88a136bbfc9f93bc10b87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the blobstore.  <br /></td></tr>
<tr class="separator:a0ba54d7b0d88a136bbfc9f93bc10b87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98e6633723afb306a763b9f571f2cc1" id="r_aa98e6633723afb306a763b9f571f2cc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa98e6633723afb306a763b9f571f2cc1">spdk_bs_unload</a> (struct spdk_blob_store *bs, <a class="el" href="#a9c265d4eead39c3419cee4b620bf5052">spdk_bs_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aa98e6633723afb306a763b9f571f2cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload the blobstore.  <br /></td></tr>
<tr class="separator:aa98e6633723afb306a763b9f571f2cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5c40c9c88d85ef5455ab32a1db3aa4" id="r_a0c5c40c9c88d85ef5455ab32a1db3aa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c5c40c9c88d85ef5455ab32a1db3aa4">spdk_bs_set_super</a> (struct spdk_blob_store *bs, spdk_blob_id blobid, <a class="el" href="#a9c265d4eead39c3419cee4b620bf5052">spdk_bs_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a0c5c40c9c88d85ef5455ab32a1db3aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a super blob on the given blobstore.  <br /></td></tr>
<tr class="separator:a0c5c40c9c88d85ef5455ab32a1db3aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb47e7a73e595499ea23b2415a6176f8" id="r_adb47e7a73e595499ea23b2415a6176f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb47e7a73e595499ea23b2415a6176f8">spdk_bs_get_super</a> (struct spdk_blob_store *bs, <a class="el" href="#a4955592d73cb1a262d699d10c8e2856f">spdk_blob_op_with_id_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:adb47e7a73e595499ea23b2415a6176f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the super blob.  <br /></td></tr>
<tr class="separator:adb47e7a73e595499ea23b2415a6176f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00447f1611b9499fc23e8be2d45f501" id="r_ae00447f1611b9499fc23e8be2d45f501"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae00447f1611b9499fc23e8be2d45f501">spdk_bs_get_cluster_size</a> (struct spdk_blob_store *bs)</td></tr>
<tr class="memdesc:ae00447f1611b9499fc23e8be2d45f501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cluster size in bytes.  <br /></td></tr>
<tr class="separator:ae00447f1611b9499fc23e8be2d45f501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cf3bf4280b524e95358fc2d3282b9a" id="r_a06cf3bf4280b524e95358fc2d3282b9a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06cf3bf4280b524e95358fc2d3282b9a">spdk_bs_get_page_size</a> (struct spdk_blob_store *bs)</td></tr>
<tr class="memdesc:a06cf3bf4280b524e95358fc2d3282b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the page size in bytes.  <br /></td></tr>
<tr class="separator:a06cf3bf4280b524e95358fc2d3282b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0800bfbaa7284454f7ba80275868b7ac" id="r_a0800bfbaa7284454f7ba80275868b7ac"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0800bfbaa7284454f7ba80275868b7ac">spdk_bs_get_io_unit_size</a> (struct spdk_blob_store *bs)</td></tr>
<tr class="memdesc:a0800bfbaa7284454f7ba80275868b7ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the io unit size in bytes.  <br /></td></tr>
<tr class="separator:a0800bfbaa7284454f7ba80275868b7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d03f0499e552b6e858b7c52abcc0820" id="r_a8d03f0499e552b6e858b7c52abcc0820"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d03f0499e552b6e858b7c52abcc0820">spdk_bs_free_cluster_count</a> (struct spdk_blob_store *bs)</td></tr>
<tr class="memdesc:a8d03f0499e552b6e858b7c52abcc0820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of free clusters.  <br /></td></tr>
<tr class="separator:a8d03f0499e552b6e858b7c52abcc0820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c090bf1ffd244cd1d2787d906d0d34f" id="r_a3c090bf1ffd244cd1d2787d906d0d34f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c090bf1ffd244cd1d2787d906d0d34f">spdk_bs_total_data_cluster_count</a> (struct spdk_blob_store *bs)</td></tr>
<tr class="memdesc:a3c090bf1ffd244cd1d2787d906d0d34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of clusters accessible by user.  <br /></td></tr>
<tr class="separator:a3c090bf1ffd244cd1d2787d906d0d34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ed8868e620ad0e15e2bc4b923ccff0" id="r_a40ed8868e620ad0e15e2bc4b923ccff0"><td class="memItemLeft" align="right" valign="top">spdk_blob_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40ed8868e620ad0e15e2bc4b923ccff0">spdk_blob_get_id</a> (struct spdk_blob *blob)</td></tr>
<tr class="memdesc:a40ed8868e620ad0e15e2bc4b923ccff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the blob id.  <br /></td></tr>
<tr class="separator:a40ed8868e620ad0e15e2bc4b923ccff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e19ff1852cf29d6992591953e1964f2" id="r_a1e19ff1852cf29d6992591953e1964f2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e19ff1852cf29d6992591953e1964f2">spdk_blob_get_num_pages</a> (struct spdk_blob *blob)</td></tr>
<tr class="memdesc:a1e19ff1852cf29d6992591953e1964f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of pages allocated to the blob.  <br /></td></tr>
<tr class="separator:a1e19ff1852cf29d6992591953e1964f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9787f698d1f47cca21b3543c0892ab3e" id="r_a9787f698d1f47cca21b3543c0892ab3e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9787f698d1f47cca21b3543c0892ab3e">spdk_blob_get_num_io_units</a> (struct spdk_blob *blob)</td></tr>
<tr class="memdesc:a9787f698d1f47cca21b3543c0892ab3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of io_units allocated to the blob.  <br /></td></tr>
<tr class="separator:a9787f698d1f47cca21b3543c0892ab3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2484b76dc748921d2596a4e207b6a5a2" id="r_a2484b76dc748921d2596a4e207b6a5a2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2484b76dc748921d2596a4e207b6a5a2">spdk_blob_get_num_clusters</a> (struct spdk_blob *blob)</td></tr>
<tr class="memdesc:a2484b76dc748921d2596a4e207b6a5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of clusters in the blob.  <br /></td></tr>
<tr class="separator:a2484b76dc748921d2596a4e207b6a5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dc0610a2d68a18d2315959f9c487fb" id="r_a45dc0610a2d68a18d2315959f9c487fb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45dc0610a2d68a18d2315959f9c487fb">spdk_blob_get_num_allocated_clusters</a> (struct spdk_blob *blob)</td></tr>
<tr class="memdesc:a45dc0610a2d68a18d2315959f9c487fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of allocated clusters to the blob.  <br /></td></tr>
<tr class="separator:a45dc0610a2d68a18d2315959f9c487fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1801ea07e30f5a56ecd043a7b4b55f" id="r_a1f1801ea07e30f5a56ecd043a7b4b55f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f1801ea07e30f5a56ecd043a7b4b55f">spdk_blob_get_next_allocated_io_unit</a> (struct spdk_blob *blob, uint64_t offset)</td></tr>
<tr class="memdesc:a1f1801ea07e30f5a56ecd043a7b4b55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next allocated io_unit.  <br /></td></tr>
<tr class="separator:a1f1801ea07e30f5a56ecd043a7b4b55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bd599919d75e0f32bbd79edb2c062c" id="r_a17bd599919d75e0f32bbd79edb2c062c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17bd599919d75e0f32bbd79edb2c062c">spdk_blob_get_next_unallocated_io_unit</a> (struct spdk_blob *blob, uint64_t offset)</td></tr>
<tr class="memdesc:a17bd599919d75e0f32bbd79edb2c062c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next unallocated io_unit.  <br /></td></tr>
<tr class="separator:a17bd599919d75e0f32bbd79edb2c062c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11cb067ebf87f3a2114357d867e1c95" id="r_aa11cb067ebf87f3a2114357d867e1c95"><td class="memItemLeft" align="right" valign="top"><a id="aa11cb067ebf87f3a2114357d867e1c95" name="aa11cb067ebf87f3a2114357d867e1c95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__blob__opts.html">spdk_blob_opts</a>)==80, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:aa11cb067ebf87f3a2114357d867e1c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bda964f26821899cfbc24c6caa3b748" id="r_a8bda964f26821899cfbc24c6caa3b748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bda964f26821899cfbc24c6caa3b748">spdk_blob_opts_init</a> (struct <a class="el" href="structspdk__blob__opts.html">spdk_blob_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:a8bda964f26821899cfbc24c6caa3b748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="structspdk__blob__opts.html">spdk_blob_opts</a> structure to the default blob option values.  <br /></td></tr>
<tr class="separator:a8bda964f26821899cfbc24c6caa3b748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c00efe656ca70fc5e8f2f477b8e48ed" id="r_a3c00efe656ca70fc5e8f2f477b8e48ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c00efe656ca70fc5e8f2f477b8e48ed">spdk_bs_create_blob_ext</a> (struct spdk_blob_store *bs, const struct <a class="el" href="structspdk__blob__opts.html">spdk_blob_opts</a> *opts, <a class="el" href="#a4955592d73cb1a262d699d10c8e2856f">spdk_blob_op_with_id_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a3c00efe656ca70fc5e8f2f477b8e48ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new blob with options on the given blobstore.  <br /></td></tr>
<tr class="separator:a3c00efe656ca70fc5e8f2f477b8e48ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33263462543c5f2b51f4d507ea26a58d" id="r_a33263462543c5f2b51f4d507ea26a58d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33263462543c5f2b51f4d507ea26a58d">spdk_bs_create_blob</a> (struct spdk_blob_store *bs, <a class="el" href="#a4955592d73cb1a262d699d10c8e2856f">spdk_blob_op_with_id_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a33263462543c5f2b51f4d507ea26a58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new blob with default option values on the given blobstore.  <br /></td></tr>
<tr class="separator:a33263462543c5f2b51f4d507ea26a58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb220c9f50228ed07e108ca1df52b65" id="r_a6fb220c9f50228ed07e108ca1df52b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fb220c9f50228ed07e108ca1df52b65">spdk_bs_create_snapshot</a> (struct spdk_blob_store *bs, spdk_blob_id blobid, const struct <a class="el" href="structspdk__blob__xattr__opts.html">spdk_blob_xattr_opts</a> *snapshot_xattrs, <a class="el" href="#a4955592d73cb1a262d699d10c8e2856f">spdk_blob_op_with_id_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a6fb220c9f50228ed07e108ca1df52b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a read-only snapshot of specified blob with provided options.  <br /></td></tr>
<tr class="separator:a6fb220c9f50228ed07e108ca1df52b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e90ac081ca6c0819940cac7ba35b87" id="r_a73e90ac081ca6c0819940cac7ba35b87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73e90ac081ca6c0819940cac7ba35b87">spdk_bs_create_clone</a> (struct spdk_blob_store *bs, spdk_blob_id blobid, const struct <a class="el" href="structspdk__blob__xattr__opts.html">spdk_blob_xattr_opts</a> *clone_xattrs, <a class="el" href="#a4955592d73cb1a262d699d10c8e2856f">spdk_blob_op_with_id_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a73e90ac081ca6c0819940cac7ba35b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a clone of specified read-only blob.  <br /></td></tr>
<tr class="separator:a73e90ac081ca6c0819940cac7ba35b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1482c72fb9cb040999a376096d3e7caf" id="r_a1482c72fb9cb040999a376096d3e7caf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1482c72fb9cb040999a376096d3e7caf">spdk_blob_get_clones</a> (struct spdk_blob_store *bs, spdk_blob_id blobid, spdk_blob_id *ids, size_t *count)</td></tr>
<tr class="memdesc:a1482c72fb9cb040999a376096d3e7caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide table with blob id's of clones are dependent on specified snapshot.  <br /></td></tr>
<tr class="separator:a1482c72fb9cb040999a376096d3e7caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a4adbf4025d355432c11c72498054a" id="r_a13a4adbf4025d355432c11c72498054a"><td class="memItemLeft" align="right" valign="top">spdk_blob_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13a4adbf4025d355432c11c72498054a">spdk_blob_get_parent_snapshot</a> (struct spdk_blob_store *bs, spdk_blob_id blobid)</td></tr>
<tr class="memdesc:a13a4adbf4025d355432c11c72498054a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the blob id for the parent snapshot of this blob.  <br /></td></tr>
<tr class="separator:a13a4adbf4025d355432c11c72498054a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1133bfe5ef2517860e51e1a58220848" id="r_aa1133bfe5ef2517860e51e1a58220848"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1133bfe5ef2517860e51e1a58220848">spdk_blob_get_esnap_id</a> (struct spdk_blob *blob, const void **id, size_t *len)</td></tr>
<tr class="memdesc:aa1133bfe5ef2517860e51e1a58220848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the id used to access the esnap clone's parent.  <br /></td></tr>
<tr class="separator:aa1133bfe5ef2517860e51e1a58220848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee905d8842cf578dabd897ae68acc142" id="r_aee905d8842cf578dabd897ae68acc142"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee905d8842cf578dabd897ae68acc142">spdk_blob_is_read_only</a> (struct spdk_blob *blob)</td></tr>
<tr class="memdesc:aee905d8842cf578dabd897ae68acc142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if blob is read only.  <br /></td></tr>
<tr class="separator:aee905d8842cf578dabd897ae68acc142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0d1f620d9e5d1e740ee4c4e456c34e" id="r_afc0d1f620d9e5d1e740ee4c4e456c34e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc0d1f620d9e5d1e740ee4c4e456c34e">spdk_blob_is_snapshot</a> (struct spdk_blob *blob)</td></tr>
<tr class="memdesc:afc0d1f620d9e5d1e740ee4c4e456c34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if blob is a snapshot.  <br /></td></tr>
<tr class="separator:afc0d1f620d9e5d1e740ee4c4e456c34e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f057419129eae779eca2774f135718e" id="r_a4f057419129eae779eca2774f135718e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f057419129eae779eca2774f135718e">spdk_blob_is_clone</a> (struct spdk_blob *blob)</td></tr>
<tr class="memdesc:a4f057419129eae779eca2774f135718e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if blob is a clone of a blob.  <br /></td></tr>
<tr class="separator:a4f057419129eae779eca2774f135718e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6487dda0466021c6058beae2e855d8e" id="r_ae6487dda0466021c6058beae2e855d8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6487dda0466021c6058beae2e855d8e">spdk_blob_is_thin_provisioned</a> (struct spdk_blob *blob)</td></tr>
<tr class="memdesc:ae6487dda0466021c6058beae2e855d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if blob is thin-provisioned.  <br /></td></tr>
<tr class="separator:ae6487dda0466021c6058beae2e855d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7abdf15a8f538dea1f91a532301081" id="r_a0d7abdf15a8f538dea1f91a532301081"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d7abdf15a8f538dea1f91a532301081">spdk_blob_is_esnap_clone</a> (const struct spdk_blob *blob)</td></tr>
<tr class="memdesc:a0d7abdf15a8f538dea1f91a532301081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if blob is a clone of an external snapshot.  <br /></td></tr>
<tr class="separator:a0d7abdf15a8f538dea1f91a532301081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4fb5871f9ca58ff60c0dd8810eb223" id="r_aed4fb5871f9ca58ff60c0dd8810eb223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed4fb5871f9ca58ff60c0dd8810eb223">spdk_bs_delete_blob</a> (struct spdk_blob_store *bs, spdk_blob_id blobid, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aed4fb5871f9ca58ff60c0dd8810eb223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an existing blob from the given blobstore.  <br /></td></tr>
<tr class="separator:aed4fb5871f9ca58ff60c0dd8810eb223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1f1b56d9782997ef3e338879a2fa28" id="r_a3d1f1b56d9782997ef3e338879a2fa28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d1f1b56d9782997ef3e338879a2fa28">spdk_bs_inflate_blob</a> (struct spdk_blob_store *bs, struct spdk_io_channel *channel, spdk_blob_id blobid, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a3d1f1b56d9782997ef3e338879a2fa28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate all clusters in this blob.  <br /></td></tr>
<tr class="separator:a3d1f1b56d9782997ef3e338879a2fa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dee33b6b9df9b9a3d6b9957c71a779c" id="r_a7dee33b6b9df9b9a3d6b9957c71a779c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dee33b6b9df9b9a3d6b9957c71a779c">spdk_bs_blob_decouple_parent</a> (struct spdk_blob_store *bs, struct spdk_io_channel *channel, spdk_blob_id blobid, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a7dee33b6b9df9b9a3d6b9957c71a779c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove dependency on parent blob.  <br /></td></tr>
<tr class="separator:a7dee33b6b9df9b9a3d6b9957c71a779c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58a01866afc7755397833a26535ad74" id="r_ad58a01866afc7755397833a26535ad74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad58a01866afc7755397833a26535ad74">spdk_bs_blob_shallow_copy</a> (struct spdk_blob_store *bs, struct spdk_io_channel *channel, spdk_blob_id blobid, struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *ext_dev, <a class="el" href="#a668cd9f989594d7f4f417495ffa7517d">spdk_blob_shallow_copy_status</a> status_cb_fn, void *status_cb_arg, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ad58a01866afc7755397833a26535ad74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a shallow copy of a blob to a blobstore device.  <br /></td></tr>
<tr class="separator:ad58a01866afc7755397833a26535ad74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1c118e86bb394aaa31fe230918c354" id="r_a2c1c118e86bb394aaa31fe230918c354"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c1c118e86bb394aaa31fe230918c354">spdk_bs_blob_set_parent</a> (struct spdk_blob_store *bs, spdk_blob_id blob_id, spdk_blob_id snapshot_id, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a2c1c118e86bb394aaa31fe230918c354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a snapshot as the parent of a blob.  <br /></td></tr>
<tr class="separator:a2c1c118e86bb394aaa31fe230918c354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3225050f74e3198444a966ba50599326" id="r_a3225050f74e3198444a966ba50599326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3225050f74e3198444a966ba50599326">spdk_bs_blob_set_external_parent</a> (struct spdk_blob_store *bs, spdk_blob_id blob_id, struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *esnap_bs_dev, const void *esnap_id, uint32_t esnap_id_len, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a3225050f74e3198444a966ba50599326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an external snapshot as the parent of a blob.  <br /></td></tr>
<tr class="separator:a3225050f74e3198444a966ba50599326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a236d14fc5eea7f6f113b8a94b3af0" id="r_a24a236d14fc5eea7f6f113b8a94b3af0"><td class="memItemLeft" align="right" valign="top"><a id="a24a236d14fc5eea7f6f113b8a94b3af0" name="a24a236d14fc5eea7f6f113b8a94b3af0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__blob__open__opts.html">spdk_blob_open_opts</a>)==24, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a24a236d14fc5eea7f6f113b8a94b3af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa002adffb9648ae66b94223de70dc4f" id="r_afa002adffb9648ae66b94223de70dc4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa002adffb9648ae66b94223de70dc4f">spdk_blob_open_opts_init</a> (struct <a class="el" href="structspdk__blob__open__opts.html">spdk_blob_open_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:afa002adffb9648ae66b94223de70dc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="structspdk__blob__open__opts.html">spdk_blob_open_opts</a> structure to the default blob option values.  <br /></td></tr>
<tr class="separator:afa002adffb9648ae66b94223de70dc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c60e6bc3ccd26228dec2c0f3ecfe618" id="r_a2c60e6bc3ccd26228dec2c0f3ecfe618"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c60e6bc3ccd26228dec2c0f3ecfe618">spdk_bs_open_blob</a> (struct spdk_blob_store *bs, spdk_blob_id blobid, <a class="el" href="#aab6d19ccc3c952877c355030e2a286c1">spdk_blob_op_with_handle_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a2c60e6bc3ccd26228dec2c0f3ecfe618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a blob from the given blobstore.  <br /></td></tr>
<tr class="separator:a2c60e6bc3ccd26228dec2c0f3ecfe618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae147507ca08e788a5245c35f10fa1d1c" id="r_ae147507ca08e788a5245c35f10fa1d1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae147507ca08e788a5245c35f10fa1d1c">spdk_bs_open_blob_ext</a> (struct spdk_blob_store *bs, spdk_blob_id blobid, struct <a class="el" href="structspdk__blob__open__opts.html">spdk_blob_open_opts</a> *opts, <a class="el" href="#aab6d19ccc3c952877c355030e2a286c1">spdk_blob_op_with_handle_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ae147507ca08e788a5245c35f10fa1d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a blob from the given blobstore with additional options.  <br /></td></tr>
<tr class="separator:ae147507ca08e788a5245c35f10fa1d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70993dda1206b4c0aaa76deb2b6fd13c" id="r_a70993dda1206b4c0aaa76deb2b6fd13c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70993dda1206b4c0aaa76deb2b6fd13c">spdk_blob_resize</a> (struct spdk_blob *blob, uint64_t sz, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a70993dda1206b4c0aaa76deb2b6fd13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a blob to 'sz' clusters.  <br /></td></tr>
<tr class="separator:a70993dda1206b4c0aaa76deb2b6fd13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea6db893423c045b8a40d1f0d0bd128" id="r_a1ea6db893423c045b8a40d1f0d0bd128"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ea6db893423c045b8a40d1f0d0bd128">spdk_blob_set_read_only</a> (struct spdk_blob *blob)</td></tr>
<tr class="memdesc:a1ea6db893423c045b8a40d1f0d0bd128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set blob as read only.  <br /></td></tr>
<tr class="separator:a1ea6db893423c045b8a40d1f0d0bd128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acc48debefc30773518871e4f84480f" id="r_a5acc48debefc30773518871e4f84480f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5acc48debefc30773518871e4f84480f">spdk_blob_sync_md</a> (struct spdk_blob *blob, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a5acc48debefc30773518871e4f84480f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync a blob.  <br /></td></tr>
<tr class="separator:a5acc48debefc30773518871e4f84480f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ca1e83e9608eb1dea9fca62881d350" id="r_ac6ca1e83e9608eb1dea9fca62881d350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6ca1e83e9608eb1dea9fca62881d350">spdk_blob_close</a> (struct spdk_blob *blob, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ac6ca1e83e9608eb1dea9fca62881d350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a blob.  <br /></td></tr>
<tr class="separator:ac6ca1e83e9608eb1dea9fca62881d350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469897520b49dca3412ad8857543359c" id="r_a469897520b49dca3412ad8857543359c"><td class="memItemLeft" align="right" valign="top">struct spdk_io_channel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a469897520b49dca3412ad8857543359c">spdk_bs_alloc_io_channel</a> (struct spdk_blob_store *bs)</td></tr>
<tr class="memdesc:a469897520b49dca3412ad8857543359c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an I/O channel for the given blobstore.  <br /></td></tr>
<tr class="separator:a469897520b49dca3412ad8857543359c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cc7c570fc82adf69ab87d277e580a3" id="r_a90cc7c570fc82adf69ab87d277e580a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90cc7c570fc82adf69ab87d277e580a3">spdk_bs_free_io_channel</a> (struct spdk_io_channel *channel)</td></tr>
<tr class="memdesc:a90cc7c570fc82adf69ab87d277e580a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the I/O channel.  <br /></td></tr>
<tr class="separator:a90cc7c570fc82adf69ab87d277e580a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2835355d4266676fa6db5c987c506a77" id="r_a2835355d4266676fa6db5c987c506a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2835355d4266676fa6db5c987c506a77">spdk_blob_io_write</a> (struct spdk_blob *blob, struct spdk_io_channel *channel, void *payload, uint64_t offset, uint64_t length, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a2835355d4266676fa6db5c987c506a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a blob.  <br /></td></tr>
<tr class="separator:a2835355d4266676fa6db5c987c506a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8753efc66a7bc29a63ae74730959b9c1" id="r_a8753efc66a7bc29a63ae74730959b9c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8753efc66a7bc29a63ae74730959b9c1">spdk_blob_io_read</a> (struct spdk_blob *blob, struct spdk_io_channel *channel, void *payload, uint64_t offset, uint64_t length, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a8753efc66a7bc29a63ae74730959b9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a blob.  <br /></td></tr>
<tr class="separator:a8753efc66a7bc29a63ae74730959b9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2fed3283426fb3ddf6abc61a44266b" id="r_afa2fed3283426fb3ddf6abc61a44266b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa2fed3283426fb3ddf6abc61a44266b">spdk_blob_io_writev</a> (struct spdk_blob *blob, struct spdk_io_channel *channel, struct iovec *iov, int iovcnt, uint64_t offset, uint64_t length, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:afa2fed3283426fb3ddf6abc61a44266b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data described by 'iov' to 'length' io_units beginning at 'offset' io_units into the blob.  <br /></td></tr>
<tr class="separator:afa2fed3283426fb3ddf6abc61a44266b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade242e483bcb3a50bb987acf2e0dfd4e" id="r_ade242e483bcb3a50bb987acf2e0dfd4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade242e483bcb3a50bb987acf2e0dfd4e">spdk_blob_io_readv</a> (struct spdk_blob *blob, struct spdk_io_channel *channel, struct iovec *iov, int iovcnt, uint64_t offset, uint64_t length, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ade242e483bcb3a50bb987acf2e0dfd4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 'length' io_units starting at 'offset' io_units into the blob into the memory described by 'iov'.  <br /></td></tr>
<tr class="separator:ade242e483bcb3a50bb987acf2e0dfd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6bb00cd582a2178f5f97479e67e9c3" id="r_a6e6bb00cd582a2178f5f97479e67e9c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e6bb00cd582a2178f5f97479e67e9c3">spdk_blob_io_writev_ext</a> (struct spdk_blob *blob, struct spdk_io_channel *channel, struct iovec *iov, int iovcnt, uint64_t offset, uint64_t length, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg, struct <a class="el" href="structspdk__blob__ext__io__opts.html">spdk_blob_ext_io_opts</a> *io_opts)</td></tr>
<tr class="memdesc:a6e6bb00cd582a2178f5f97479e67e9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data described by 'iov' to 'length' io_units beginning at 'offset' io_units into the blob.  <br /></td></tr>
<tr class="separator:a6e6bb00cd582a2178f5f97479e67e9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f13ed71f6a04b33ef902ca0e320015f" id="r_a3f13ed71f6a04b33ef902ca0e320015f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f13ed71f6a04b33ef902ca0e320015f">spdk_blob_io_readv_ext</a> (struct spdk_blob *blob, struct spdk_io_channel *channel, struct iovec *iov, int iovcnt, uint64_t offset, uint64_t length, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg, struct <a class="el" href="structspdk__blob__ext__io__opts.html">spdk_blob_ext_io_opts</a> *io_opts)</td></tr>
<tr class="memdesc:a3f13ed71f6a04b33ef902ca0e320015f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 'length' io_units starting at 'offset' io_units into the blob into the memory described by 'iov'.  <br /></td></tr>
<tr class="separator:a3f13ed71f6a04b33ef902ca0e320015f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dea7bc3f6cc4dcd2b5d039b14b8640a" id="r_a2dea7bc3f6cc4dcd2b5d039b14b8640a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dea7bc3f6cc4dcd2b5d039b14b8640a">spdk_blob_io_unmap</a> (struct spdk_blob *blob, struct spdk_io_channel *channel, uint64_t offset, uint64_t length, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a2dea7bc3f6cc4dcd2b5d039b14b8640a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap 'length' io_units beginning at 'offset' io_units on the blob as unused.  <br /></td></tr>
<tr class="separator:a2dea7bc3f6cc4dcd2b5d039b14b8640a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0291498c4cac92556e0e7e7bf286bda6" id="r_a0291498c4cac92556e0e7e7bf286bda6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0291498c4cac92556e0e7e7bf286bda6">spdk_blob_io_write_zeroes</a> (struct spdk_blob *blob, struct spdk_io_channel *channel, uint64_t offset, uint64_t length, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a0291498c4cac92556e0e7e7bf286bda6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write zeros into area of a blob.  <br /></td></tr>
<tr class="separator:a0291498c4cac92556e0e7e7bf286bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af173fe4e35623b8dc8256e9141700486" id="r_af173fe4e35623b8dc8256e9141700486"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af173fe4e35623b8dc8256e9141700486">spdk_bs_iter_first</a> (struct spdk_blob_store *bs, <a class="el" href="#aab6d19ccc3c952877c355030e2a286c1">spdk_blob_op_with_handle_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:af173fe4e35623b8dc8256e9141700486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first blob of the blobstore.  <br /></td></tr>
<tr class="separator:af173fe4e35623b8dc8256e9141700486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d90e701cf3377115ff0bb67db1342a" id="r_a98d90e701cf3377115ff0bb67db1342a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98d90e701cf3377115ff0bb67db1342a">spdk_bs_iter_next</a> (struct spdk_blob_store *bs, struct spdk_blob *blob, <a class="el" href="#aab6d19ccc3c952877c355030e2a286c1">spdk_blob_op_with_handle_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a98d90e701cf3377115ff0bb67db1342a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next blob by using the current blob.  <br /></td></tr>
<tr class="separator:a98d90e701cf3377115ff0bb67db1342a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74beed7022f23df295149fd68ac8935d" id="r_a74beed7022f23df295149fd68ac8935d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74beed7022f23df295149fd68ac8935d">spdk_blob_set_xattr</a> (struct spdk_blob *blob, const char *name, const void *value, uint16_t value_len)</td></tr>
<tr class="memdesc:a74beed7022f23df295149fd68ac8935d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an extended attribute for the given blob.  <br /></td></tr>
<tr class="separator:a74beed7022f23df295149fd68ac8935d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c836667ea7f3c5fa5b2e3bf486d8428" id="r_a5c836667ea7f3c5fa5b2e3bf486d8428"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c836667ea7f3c5fa5b2e3bf486d8428">spdk_blob_remove_xattr</a> (struct spdk_blob *blob, const char *name)</td></tr>
<tr class="memdesc:a5c836667ea7f3c5fa5b2e3bf486d8428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the extended attribute from the given blob.  <br /></td></tr>
<tr class="separator:a5c836667ea7f3c5fa5b2e3bf486d8428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe49b3a95d13aed755726bed94f79344" id="r_afe49b3a95d13aed755726bed94f79344"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe49b3a95d13aed755726bed94f79344">spdk_blob_get_xattr_value</a> (struct spdk_blob *blob, const char *name, const void **value, size_t *value_len)</td></tr>
<tr class="memdesc:afe49b3a95d13aed755726bed94f79344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the specified extended attribute.  <br /></td></tr>
<tr class="separator:afe49b3a95d13aed755726bed94f79344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b3d20a4be55b2c2ba046a2ccfe7233" id="r_ab9b3d20a4be55b2c2ba046a2ccfe7233"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9b3d20a4be55b2c2ba046a2ccfe7233">spdk_blob_get_xattr_names</a> (struct spdk_blob *blob, struct spdk_xattr_names **names)</td></tr>
<tr class="memdesc:ab9b3d20a4be55b2c2ba046a2ccfe7233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through all extended attributes of the blob.  <br /></td></tr>
<tr class="separator:ab9b3d20a4be55b2c2ba046a2ccfe7233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113d71117843062da8a24906296b37a6" id="r_a113d71117843062da8a24906296b37a6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a113d71117843062da8a24906296b37a6">spdk_xattr_names_get_count</a> (struct spdk_xattr_names *names)</td></tr>
<tr class="memdesc:a113d71117843062da8a24906296b37a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of extended attributes.  <br /></td></tr>
<tr class="separator:a113d71117843062da8a24906296b37a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6eeb557d81469091ba8b606a595a88" id="r_a7a6eeb557d81469091ba8b606a595a88"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a6eeb557d81469091ba8b606a595a88">spdk_xattr_names_get_name</a> (struct spdk_xattr_names *names, uint32_t index)</td></tr>
<tr class="memdesc:a7a6eeb557d81469091ba8b606a595a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the attribute name specified by the index.  <br /></td></tr>
<tr class="separator:a7a6eeb557d81469091ba8b606a595a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17f3a52d52d9c3e9382cbcfae042c0a" id="r_ae17f3a52d52d9c3e9382cbcfae042c0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae17f3a52d52d9c3e9382cbcfae042c0a">spdk_xattr_names_free</a> (struct spdk_xattr_names *names)</td></tr>
<tr class="memdesc:ae17f3a52d52d9c3e9382cbcfae042c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the attribute names.  <br /></td></tr>
<tr class="separator:ae17f3a52d52d9c3e9382cbcfae042c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1407ae1ce3b0fc57a6ee52cf119f9772" id="r_a1407ae1ce3b0fc57a6ee52cf119f9772"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__bs__type.html">spdk_bs_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1407ae1ce3b0fc57a6ee52cf119f9772">spdk_bs_get_bstype</a> (struct spdk_blob_store *bs)</td></tr>
<tr class="memdesc:a1407ae1ce3b0fc57a6ee52cf119f9772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get blobstore type of the given device.  <br /></td></tr>
<tr class="separator:a1407ae1ce3b0fc57a6ee52cf119f9772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b434a45e67bcebb2fcb79965bd56e5" id="r_aa9b434a45e67bcebb2fcb79965bd56e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9b434a45e67bcebb2fcb79965bd56e5">spdk_bs_set_bstype</a> (struct spdk_blob_store *bs, struct <a class="el" href="structspdk__bs__type.html">spdk_bs_type</a> bstype)</td></tr>
<tr class="memdesc:aa9b434a45e67bcebb2fcb79965bd56e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set blobstore type to the given device.  <br /></td></tr>
<tr class="separator:aa9b434a45e67bcebb2fcb79965bd56e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b5b8159c242a0006b858ee8e4ddc69" id="r_a66b5b8159c242a0006b858ee8e4ddc69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66b5b8159c242a0006b858ee8e4ddc69">spdk_blob_set_esnap_bs_dev</a> (struct spdk_blob *blob, struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *back_bs_dev, <a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a66b5b8159c242a0006b858ee8e4ddc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the existing external snapshot device.  <br /></td></tr>
<tr class="separator:a66b5b8159c242a0006b858ee8e4ddc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc63ceaf7aed7096b4811c0d84ea982" id="r_a5dc63ceaf7aed7096b4811c0d84ea982"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dc63ceaf7aed7096b4811c0d84ea982">spdk_blob_get_esnap_bs_dev</a> (const struct spdk_blob *blob)</td></tr>
<tr class="memdesc:a5dc63ceaf7aed7096b4811c0d84ea982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the existing external snapshot device.  <br /></td></tr>
<tr class="separator:a5dc63ceaf7aed7096b4811c0d84ea982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cc668dae1192d41904d79709da0374" id="r_a74cc668dae1192d41904d79709da0374"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74cc668dae1192d41904d79709da0374">spdk_blob_is_degraded</a> (const struct spdk_blob *blob)</td></tr>
<tr class="memdesc:a74cc668dae1192d41904d79709da0374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the blob is degraded.  <br /></td></tr>
<tr class="separator:a74cc668dae1192d41904d79709da0374"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Blob Storage System. </p>
<p>The blob storage system, or the blobstore for short, is a low level library for placing opaque blobs of data onto a storage device such that scattered physical blocks on the storage device appear as a single, contiguous storage region. These blobs are also persistent, which means they are rediscoverable after reboot or power loss.</p>
<p>The blobstore is designed to be very high performance, and thus has a few general rules regarding thread safety to avoid taking locks in the I/O path. This is primarily done by only allowing most functions to be called on the metadata thread. The metadata thread is the thread which called <a class="el" href="#ad59f1d147b612a7d4ce1eb8439a69cee" title="Initialize a blobstore on the given device.">spdk_bs_init()</a> or <a class="el" href="#a400da20b69e4f914730fbd15d51eb748" title="Load a blobstore from the given device.">spdk_bs_load()</a>.</p>
<p>Functions starting with the prefix "spdk_blob_io" are passed a channel as an argument, and channels may only be used from the thread they were created on. See <a class="el" href="#a469897520b49dca3412ad8857543359c">spdk_bs_alloc_io_channel</a>. These are the only functions that may be called from a thread other than the metadata thread.</p>
<p>The blobstore returns errors using negated POSIX errno values, either returned in the callback or as a return value. An errno value of 0 means success. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aca5253109581a768e06dd197429ef9e1" name="aca5253109581a768e06dd197429ef9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5253109581a768e06dd197429ef9e1">&#9670;&#160;</a></span>spdk_blob_op_complete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_blob_op_complete) (void *cb_arg, int bserrno)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blob operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
    <tr><td class="paramname">bserrno</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a674db2e2ce68c181b11ffd676b8cc51b" name="a674db2e2ce68c181b11ffd676b8cc51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674db2e2ce68c181b11ffd676b8cc51b">&#9670;&#160;</a></span>spdk_blob_op_with_bs_dev</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_blob_op_with_bs_dev) (void *cb_arg, struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *bs_dev, int bserrno)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blob device open completion callback with blobstore device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
    <tr><td class="paramname">bs_dev</td><td>Blobstore device. </td></tr>
    <tr><td class="paramname">bserrno</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab6d19ccc3c952877c355030e2a286c1" name="aab6d19ccc3c952877c355030e2a286c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6d19ccc3c952877c355030e2a286c1">&#9670;&#160;</a></span>spdk_blob_op_with_handle_complete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_blob_op_with_handle_complete) (void *cb_arg, struct spdk_blob *blb, int bserrno)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blob operation completion callback with handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
    <tr><td class="paramname">blb</td><td>Handle to a blob. </td></tr>
    <tr><td class="paramname">bserrno</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4955592d73cb1a262d699d10c8e2856f" name="a4955592d73cb1a262d699d10c8e2856f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4955592d73cb1a262d699d10c8e2856f">&#9670;&#160;</a></span>spdk_blob_op_with_id_complete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_blob_op_with_id_complete) (void *cb_arg, spdk_blob_id blobid, int bserrno)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blob operation completion callback with blob ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
    <tr><td class="paramname">blobid</td><td>Blob ID. </td></tr>
    <tr><td class="paramname">bserrno</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a668cd9f989594d7f4f417495ffa7517d" name="a668cd9f989594d7f4f417495ffa7517d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668cd9f989594d7f4f417495ffa7517d">&#9670;&#160;</a></span>spdk_blob_shallow_copy_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_blob_shallow_copy_status) (uint64_t copied_clusters, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blob shallow copy status callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copied_clusters</td><td>Actual number of copied clusters by the shallow copy operation </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb1f64973b22548813723a645f9b8995" name="afb1f64973b22548813723a645f9b8995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1f64973b22548813723a645f9b8995">&#9670;&#160;</a></span>spdk_bs_dev_cpl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bs_dev_cpl) (struct spdk_io_channel *channel, void *cb_arg, int bserrno)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blobstore device completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>I/O channel the operation was initiated on. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
    <tr><td class="paramname">bserrno</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9de71c711c86a2fb7b9a7d967ebede4" name="aa9de71c711c86a2fb7b9a7d967ebede4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9de71c711c86a2fb7b9a7d967ebede4">&#9670;&#160;</a></span>spdk_bs_esnap_dev_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_bs_esnap_dev_create) (void *bs_ctx, void *blob_ctx, struct spdk_blob *blob, const void *esnap_id, uint32_t id_size, struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> **bs_dev)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External snapshot device open callback. </p>
<p>As an esnap clone blob is loading, it uses this callback registered with the blobstore to create the external snapshot device. The blobstore consumer must set this while loading the blobstore if it intends to support external snapshots.</p>
<p>If the blobstore consumer does not wish to load an external snapshot, it should set *bs_dev to NULL and return 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs_ctx</td><td>Context provided by the blobstore consumer via esnap_ctx member of struct <a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a>. </td></tr>
    <tr><td class="paramname">blob_ctx</td><td>Context provided to spdk_bs_open_ext() via esnap_ctx member of struct spdk_bs_open_opts. </td></tr>
    <tr><td class="paramname">blob</td><td>The blob that needs its external snapshot device. </td></tr>
    <tr><td class="paramname">esnap_id</td><td>A copy of the esnap_id passed via blob_opts when creating the esnap clone. </td></tr>
    <tr><td class="paramname">id_size</td><td>The size in bytes of the data referenced by esnap_id. </td></tr>
    <tr><td class="paramname">bs_dev</td><td>When 0 is returned, the newly created blobstore device is returned by reference.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, else a negative errno. </dd></dl>

</div>
</div>
<a id="a9c265d4eead39c3419cee4b620bf5052" name="a9c265d4eead39c3419cee4b620bf5052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c265d4eead39c3419cee4b620bf5052">&#9670;&#160;</a></span>spdk_bs_op_complete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bs_op_complete) (void *cb_arg, int bserrno)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blobstore operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
    <tr><td class="paramname">bserrno</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40a976910f2112a4164ae6a12b946855" name="a40a976910f2112a4164ae6a12b946855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a976910f2112a4164ae6a12b946855">&#9670;&#160;</a></span>spdk_bs_op_with_handle_complete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bs_op_with_handle_complete) (void *cb_arg, struct spdk_blob_store *bs, int bserrno)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blobstore operation completion callback with handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
    <tr><td class="paramname">bs</td><td>Handle to a blobstore. </td></tr>
    <tr><td class="paramname">bserrno</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac6ca1e83e9608eb1dea9fca62881d350" name="ac6ca1e83e9608eb1dea9fca62881d350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ca1e83e9608eb1dea9fca62881d350">&#9670;&#160;</a></span>spdk_blob_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_blob_close </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a blob. </p>
<p>This will automatically sync.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to close. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1482c72fb9cb040999a376096d3e7caf" name="a1482c72fb9cb040999a376096d3e7caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1482c72fb9cb040999a376096d3e7caf">&#9670;&#160;</a></span>spdk_blob_get_clones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_blob_get_clones </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id</td>          <td class="paramname"><span class="paramname"><em>blobid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id *</td>          <td class="paramname"><span class="paramname"><em>ids</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provide table with blob id's of clones are dependent on specified snapshot. </p>
<p>Ids array should be allocated and the count parameter set to the number of id's it can store, before calling this function.</p>
<p>If ids is NULL or count parameter is not sufficient to handle ids of all clones, -ENOMEM error is returned and count parameter is updated to the total number of clones.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">blobid</td><td>Snapshots blob id. </td></tr>
    <tr><td class="paramname">ids</td><td>Array of the clone ids or NULL to get required size in count. </td></tr>
    <tr><td class="paramname">count</td><td>Size of ids. After call it is updated to the number of clones.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-ENOMEM if count is not sufficient to store all clones. </dd></dl>

</div>
</div>
<a id="a5dc63ceaf7aed7096b4811c0d84ea982" name="a5dc63ceaf7aed7096b4811c0d84ea982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc63ceaf7aed7096b4811c0d84ea982">&#9670;&#160;</a></span>spdk_blob_get_esnap_bs_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> * spdk_blob_get_esnap_bs_dev </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the existing external snapshot device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>A blob that is an esnap clone</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the blob is not an esnap clone, else the current external snapshot device. </dd></dl>

</div>
</div>
<a id="aa1133bfe5ef2517860e51e1a58220848" name="aa1133bfe5ef2517860e51e1a58220848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1133bfe5ef2517860e51e1a58220848">&#9670;&#160;</a></span>spdk_blob_get_esnap_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_blob_get_esnap_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **</td>          <td class="paramname"><span class="paramname"><em>id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the id used to access the esnap clone's parent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>The clone's blob. </td></tr>
    <tr><td class="paramname">id</td><td>On successful return, *id will reference memory that has the same life as blob. </td></tr>
    <tr><td class="paramname">len</td><td>On successful return *len will be the size of id in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-EINVAL if blob is not an esnap clone. </dd></dl>

</div>
</div>
<a id="a40ed8868e620ad0e15e2bc4b923ccff0" name="a40ed8868e620ad0e15e2bc4b923ccff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ed8868e620ad0e15e2bc4b923ccff0">&#9670;&#160;</a></span>spdk_blob_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spdk_blob_id spdk_blob_get_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the blob id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob struct to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>blob id. </dd></dl>

</div>
</div>
<a id="a1f1801ea07e30f5a56ecd043a7b4b55f" name="a1f1801ea07e30f5a56ecd043a7b4b55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1801ea07e30f5a56ecd043a7b4b55f">&#9670;&#160;</a></span>spdk_blob_get_next_allocated_io_unit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_blob_get_next_allocated_io_unit </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next allocated io_unit. </p>
<p>Starting at 'offset' io_units into the blob, returns the offset of the first allocated io unit found. If 'offset' points to an allocated io_unit, same offset is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob struct to query. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset is in io units from the beginning of the blob.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>offset in io_units or UINT64_MAX if no allocated io_unit found </dd></dl>

</div>
</div>
<a id="a17bd599919d75e0f32bbd79edb2c062c" name="a17bd599919d75e0f32bbd79edb2c062c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bd599919d75e0f32bbd79edb2c062c">&#9670;&#160;</a></span>spdk_blob_get_next_unallocated_io_unit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_blob_get_next_unallocated_io_unit </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next unallocated io_unit. </p>
<p>Starting at 'offset' io_units into the blob, returns the offset of the first unallocated io unit found. If 'offset' points to an unallocated io_unit, same offset is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob struct to query. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset is in io units from the beginning of the blob.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>offset in io_units or UINT64_MAX if only allocated io_unit found </dd></dl>

</div>
</div>
<a id="a45dc0610a2d68a18d2315959f9c487fb" name="a45dc0610a2d68a18d2315959f9c487fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45dc0610a2d68a18d2315959f9c487fb">&#9670;&#160;</a></span>spdk_blob_get_num_allocated_clusters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_blob_get_num_allocated_clusters </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of allocated clusters to the blob. </p>
<p>In case of a thin-provisioned blob, this value is less than or equal to the number of clusters in the blob, otherwise they are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob struct to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of clusters actually allocated to the blob. </dd></dl>

</div>
</div>
<a id="a2484b76dc748921d2596a4e207b6a5a2" name="a2484b76dc748921d2596a4e207b6a5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2484b76dc748921d2596a4e207b6a5a2">&#9670;&#160;</a></span>spdk_blob_get_num_clusters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_blob_get_num_clusters </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of clusters in the blob. </p>
<p>This value represents the size of the blob in number of clusters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob struct to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of clusters. </dd></dl>

</div>
</div>
<a id="a9787f698d1f47cca21b3543c0892ab3e" name="a9787f698d1f47cca21b3543c0892ab3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9787f698d1f47cca21b3543c0892ab3e">&#9670;&#160;</a></span>spdk_blob_get_num_io_units()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_blob_get_num_io_units </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of io_units allocated to the blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob struct to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of io_units. </dd></dl>

</div>
</div>
<a id="a1e19ff1852cf29d6992591953e1964f2" name="a1e19ff1852cf29d6992591953e1964f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e19ff1852cf29d6992591953e1964f2">&#9670;&#160;</a></span>spdk_blob_get_num_pages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_blob_get_num_pages </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of pages allocated to the blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob struct to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of pages. </dd></dl>

</div>
</div>
<a id="a13a4adbf4025d355432c11c72498054a" name="a13a4adbf4025d355432c11c72498054a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a4adbf4025d355432c11c72498054a">&#9670;&#160;</a></span>spdk_blob_get_parent_snapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spdk_blob_id spdk_blob_get_parent_snapshot </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id</td>          <td class="paramname"><span class="paramname"><em>blobid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the blob id for the parent snapshot of this blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">blobid</td><td>Blob id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>blob id of parent blob or SPDK_BLOBID_INVALID if have no parent </dd></dl>

</div>
</div>
<a id="ab9b3d20a4be55b2c2ba046a2ccfe7233" name="ab9b3d20a4be55b2c2ba046a2ccfe7233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b3d20a4be55b2c2ba046a2ccfe7233">&#9670;&#160;</a></span>spdk_blob_get_xattr_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_blob_get_xattr_names </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_xattr_names **</td>          <td class="paramname"><span class="paramname"><em>names</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate through all extended attributes of the blob. </p>
<p>Get the names of all extended attributes that will be stored in names.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to query. </td></tr>
    <tr><td class="paramname">names</td><td>Parameter as output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="afe49b3a95d13aed755726bed94f79344" name="afe49b3a95d13aed755726bed94f79344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe49b3a95d13aed755726bed94f79344">&#9670;&#160;</a></span>spdk_blob_get_xattr_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_blob_get_xattr_value </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **</td>          <td class="paramname"><span class="paramname"><em>value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>value_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of the specified extended attribute. </p>
<p>The obtained value and its size will be stored in value and value_len.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to query. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the extended attribute. </td></tr>
    <tr><td class="paramname">value</td><td>Parameter as output. </td></tr>
    <tr><td class="paramname">value_len</td><td>Parameter as output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="a8753efc66a7bc29a63ae74730959b9c1" name="a8753efc66a7bc29a63ae74730959b9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8753efc66a7bc29a63ae74730959b9c1">&#9670;&#160;</a></span>spdk_blob_io_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_blob_io_read </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>payload</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from a blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to read. </td></tr>
    <tr><td class="paramname">channel</td><td>The I/O channel used to submit requests. </td></tr>
    <tr><td class="paramname">payload</td><td>The specified buffer which will store the obtained data. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset is in io units from the beginning of the blob. </td></tr>
    <tr><td class="paramname">length</td><td>Size of data in io units. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade242e483bcb3a50bb987acf2e0dfd4e" name="ade242e483bcb3a50bb987acf2e0dfd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade242e483bcb3a50bb987acf2e0dfd4e">&#9670;&#160;</a></span>spdk_blob_io_readv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_blob_io_readv </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 'length' io_units starting at 'offset' io_units into the blob into the memory described by 'iov'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to read. </td></tr>
    <tr><td class="paramname">channel</td><td>I/O channel used to submit requests. </td></tr>
    <tr><td class="paramname">iov</td><td>The pointer points to an array of iovec structures. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of buffers. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset is in io units from the beginning of the blob. </td></tr>
    <tr><td class="paramname">length</td><td>Size of data in io units. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f13ed71f6a04b33ef902ca0e320015f" name="a3f13ed71f6a04b33ef902ca0e320015f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f13ed71f6a04b33ef902ca0e320015f">&#9670;&#160;</a></span>spdk_blob_io_readv_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_blob_io_readv_ext </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__blob__ext__io__opts.html">spdk_blob_ext_io_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>io_opts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 'length' io_units starting at 'offset' io_units into the blob into the memory described by 'iov'. </p>
<p>Accepts extended IO request options</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to read. </td></tr>
    <tr><td class="paramname">channel</td><td>I/O channel used to submit requests. </td></tr>
    <tr><td class="paramname">iov</td><td>The pointer points to an array of iovec structures. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of buffers. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset is in io units from the beginning of the blob. </td></tr>
    <tr><td class="paramname">length</td><td>Size of data in io units. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
    <tr><td class="paramname">io_opts</td><td>Optional extended IO request options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2dea7bc3f6cc4dcd2b5d039b14b8640a" name="a2dea7bc3f6cc4dcd2b5d039b14b8640a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dea7bc3f6cc4dcd2b5d039b14b8640a">&#9670;&#160;</a></span>spdk_blob_io_unmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_blob_io_unmap </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmap 'length' io_units beginning at 'offset' io_units on the blob as unused. </p>
<p>Unmapped io_units may allow the underlying storage media to behave more efficiently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to unmap. </td></tr>
    <tr><td class="paramname">channel</td><td>I/O channel used to submit requests. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset is in io units from the beginning of the blob. </td></tr>
    <tr><td class="paramname">length</td><td>Size of unmap area in io_units. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2835355d4266676fa6db5c987c506a77" name="a2835355d4266676fa6db5c987c506a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2835355d4266676fa6db5c987c506a77">&#9670;&#160;</a></span>spdk_blob_io_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_blob_io_write </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>payload</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to write. </td></tr>
    <tr><td class="paramname">channel</td><td>The I/O channel used to submit requests. </td></tr>
    <tr><td class="paramname">payload</td><td>The specified buffer which should contain the data to be written. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset is in io units from the beginning of the blob. </td></tr>
    <tr><td class="paramname">length</td><td>Size of data in io units. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0291498c4cac92556e0e7e7bf286bda6" name="a0291498c4cac92556e0e7e7bf286bda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0291498c4cac92556e0e7e7bf286bda6">&#9670;&#160;</a></span>spdk_blob_io_write_zeroes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_blob_io_write_zeroes </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write zeros into area of a blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to write. </td></tr>
    <tr><td class="paramname">channel</td><td>I/O channel used to submit requests. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset is in io units from the beginning of the blob. </td></tr>
    <tr><td class="paramname">length</td><td>Size of data in io units. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa2fed3283426fb3ddf6abc61a44266b" name="afa2fed3283426fb3ddf6abc61a44266b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2fed3283426fb3ddf6abc61a44266b">&#9670;&#160;</a></span>spdk_blob_io_writev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_blob_io_writev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the data described by 'iov' to 'length' io_units beginning at 'offset' io_units into the blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to write. </td></tr>
    <tr><td class="paramname">channel</td><td>I/O channel used to submit requests. </td></tr>
    <tr><td class="paramname">iov</td><td>The pointer points to an array of iovec structures. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of buffers. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset is in io units from the beginning of the blob. </td></tr>
    <tr><td class="paramname">length</td><td>Size of data in io units. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e6bb00cd582a2178f5f97479e67e9c3" name="a6e6bb00cd582a2178f5f97479e67e9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6bb00cd582a2178f5f97479e67e9c3">&#9670;&#160;</a></span>spdk_blob_io_writev_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_blob_io_writev_ext </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__blob__ext__io__opts.html">spdk_blob_ext_io_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>io_opts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the data described by 'iov' to 'length' io_units beginning at 'offset' io_units into the blob. </p>
<p>Accepts extended IO request options</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to write. </td></tr>
    <tr><td class="paramname">channel</td><td>I/O channel used to submit requests. </td></tr>
    <tr><td class="paramname">iov</td><td>The pointer points to an array of iovec structures. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of buffers. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset is in io units from the beginning of the blob. </td></tr>
    <tr><td class="paramname">length</td><td>Size of data in io units. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
    <tr><td class="paramname">io_opts</td><td>Optional extended IO request options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f057419129eae779eca2774f135718e" name="a4f057419129eae779eca2774f135718e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f057419129eae779eca2774f135718e">&#9670;&#160;</a></span>spdk_blob_is_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_blob_is_clone </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if blob is a clone of a blob. </p>
<p>Clones of external snapshots will return false. See spdk_blob_is_esnap_clone.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if blob is a clone of a blob. </dd></dl>

</div>
</div>
<a id="a74cc668dae1192d41904d79709da0374" name="a74cc668dae1192d41904d79709da0374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74cc668dae1192d41904d79709da0374">&#9670;&#160;</a></span>spdk_blob_is_degraded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_blob_is_degraded </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the blob is degraded. </p>
<p>A degraded blob cannot perform IO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>A blob</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the blob or any snapshots upon which it depends are degraded, else false. </dd></dl>

</div>
</div>
<a id="a0d7abdf15a8f538dea1f91a532301081" name="a0d7abdf15a8f538dea1f91a532301081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7abdf15a8f538dea1f91a532301081">&#9670;&#160;</a></span>spdk_blob_is_esnap_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_blob_is_esnap_clone </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if blob is a clone of an external snapshot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if blob is a clone of an external bdev. </dd></dl>

</div>
</div>
<a id="aee905d8842cf578dabd897ae68acc142" name="aee905d8842cf578dabd897ae68acc142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee905d8842cf578dabd897ae68acc142">&#9670;&#160;</a></span>spdk_blob_is_read_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_blob_is_read_only </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if blob is read only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if blob is read only. </dd></dl>

</div>
</div>
<a id="afc0d1f620d9e5d1e740ee4c4e456c34e" name="afc0d1f620d9e5d1e740ee4c4e456c34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0d1f620d9e5d1e740ee4c4e456c34e">&#9670;&#160;</a></span>spdk_blob_is_snapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_blob_is_snapshot </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if blob is a snapshot. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if blob is a snapshot. </dd></dl>

</div>
</div>
<a id="ae6487dda0466021c6058beae2e855d8e" name="ae6487dda0466021c6058beae2e855d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6487dda0466021c6058beae2e855d8e">&#9670;&#160;</a></span>spdk_blob_is_thin_provisioned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_blob_is_thin_provisioned </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if blob is thin-provisioned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if blob is thin-provisioned. </dd></dl>

</div>
</div>
<a id="afa002adffb9648ae66b94223de70dc4f" name="afa002adffb9648ae66b94223de70dc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa002adffb9648ae66b94223de70dc4f">&#9670;&#160;</a></span>spdk_blob_open_opts_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_blob_open_opts_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__blob__open__opts.html">spdk_blob_open_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>opts_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="structspdk__blob__open__opts.html">spdk_blob_open_opts</a> structure to the default blob option values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td><a class="el" href="structspdk__blob__open__opts.html">spdk_blob_open_opts</a> structure to initialize. </td></tr>
    <tr><td class="paramname">opts_size</td><td>It mus be the size of struct <a class="el" href="structspdk__blob__open__opts.html">spdk_blob_open_opts</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bda964f26821899cfbc24c6caa3b748" name="a8bda964f26821899cfbc24c6caa3b748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bda964f26821899cfbc24c6caa3b748">&#9670;&#160;</a></span>spdk_blob_opts_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_blob_opts_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__blob__opts.html">spdk_blob_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>opts_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="structspdk__blob__opts.html">spdk_blob_opts</a> structure to the default blob option values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td><a class="el" href="structspdk__blob__opts.html">spdk_blob_opts</a> structure to initialize. </td></tr>
    <tr><td class="paramname">opts_size</td><td>It must be the size of <a class="el" href="structspdk__blob__opts.html">spdk_blob_opts</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c836667ea7f3c5fa5b2e3bf486d8428" name="a5c836667ea7f3c5fa5b2e3bf486d8428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c836667ea7f3c5fa5b2e3bf486d8428">&#9670;&#160;</a></span>spdk_blob_remove_xattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_blob_remove_xattr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the extended attribute from the given blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to remove attribute. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the extended attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="a70993dda1206b4c0aaa76deb2b6fd13c" name="a70993dda1206b4c0aaa76deb2b6fd13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70993dda1206b4c0aaa76deb2b6fd13c">&#9670;&#160;</a></span>spdk_blob_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_blob_resize </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>sz</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a blob to 'sz' clusters. </p>
<p>These changes are not persisted to disk until spdk_bs_md_sync_blob() is called. If called before previous resize finish, it will fail with errno -EBUSY</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to resize. </td></tr>
    <tr><td class="paramname">sz</td><td>The new number of clusters. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66b5b8159c242a0006b858ee8e4ddc69" name="a66b5b8159c242a0006b858ee8e4ddc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b5b8159c242a0006b858ee8e4ddc69">&#9670;&#160;</a></span>spdk_blob_set_esnap_bs_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_blob_set_esnap_bs_dev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *</td>          <td class="paramname"><span class="paramname"><em>back_bs_dev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the existing external snapshot device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>The blob that is getting a new external snapshot device. </td></tr>
    <tr><td class="paramname">back_bs_dev</td><td>The new blobstore device to use as an external snapshot. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback to be called when complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Callback argument used with cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ea6db893423c045b8a40d1f0d0bd128" name="a1ea6db893423c045b8a40d1f0d0bd128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea6db893423c045b8a40d1f0d0bd128">&#9670;&#160;</a></span>spdk_blob_set_read_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_blob_set_read_only </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set blob as read only. </p>
<p>These changes do not take effect until <a class="el" href="#a5acc48debefc30773518871e4f84480f" title="Sync a blob.">spdk_blob_sync_md()</a> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74beed7022f23df295149fd68ac8935d" name="a74beed7022f23df295149fd68ac8935d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74beed7022f23df295149fd68ac8935d">&#9670;&#160;</a></span>spdk_blob_set_xattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_blob_set_xattr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>value_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an extended attribute for the given blob. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to set attribute. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the extended attribute. </td></tr>
    <tr><td class="paramname">value</td><td>Value of the extended attribute. </td></tr>
    <tr><td class="paramname">value_len</td><td>Length of the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a5acc48debefc30773518871e4f84480f" name="a5acc48debefc30773518871e4f84480f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acc48debefc30773518871e4f84480f">&#9670;&#160;</a></span>spdk_blob_sync_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_blob_sync_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sync a blob. </p>
<p>Make a blob persistent. This applies to open, resize, set xattr, and remove xattr. These operations will not be persistent until the blob has been synced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>Blob to sync. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a469897520b49dca3412ad8857543359c" name="a469897520b49dca3412ad8857543359c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469897520b49dca3412ad8857543359c">&#9670;&#160;</a></span>spdk_bs_alloc_io_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_io_channel * spdk_bs_alloc_io_channel </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an I/O channel for the given blobstore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated I/O channel. </dd></dl>

</div>
</div>
<a id="a7dee33b6b9df9b9a3d6b9957c71a779c" name="a7dee33b6b9df9b9a3d6b9957c71a779c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dee33b6b9df9b9a3d6b9957c71a779c">&#9670;&#160;</a></span>spdk_bs_blob_decouple_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_blob_decouple_parent </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id</td>          <td class="paramname"><span class="paramname"><em>blobid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove dependency on parent blob. </p>
<p>This call allocates and copies data for any clusters that are allocated in the parent blob, and decouples parent updating dependencies of blob to its ancestor.</p>
<p>If blob have no parent -EINVAL error is reported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">channel</td><td>IO channel used to inflate blob. </td></tr>
    <tr><td class="paramname">blobid</td><td>The id of the blob. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3225050f74e3198444a966ba50599326" name="a3225050f74e3198444a966ba50599326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3225050f74e3198444a966ba50599326">&#9670;&#160;</a></span>spdk_bs_blob_set_external_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_blob_set_external_parent </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id</td>          <td class="paramname"><span class="paramname"><em>blob_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *</td>          <td class="paramname"><span class="paramname"><em>esnap_bs_dev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>esnap_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>esnap_id_len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an external snapshot as the parent of a blob. </p>
<p>This call set an external snapshot as the parent of a blob, making the blob a clone of this external snapshot. The previous parent of the blob, if any, can be another external snapshot or a snapshot; if the blob is not a clone, it must be thin-provisioned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">blob_id</td><td>The id of the blob. </td></tr>
    <tr><td class="paramname">esnap_bs_dev</td><td>The new blobstore device to use as an external snapshot. </td></tr>
    <tr><td class="paramname">esnap_id</td><td>The identifier of the external snapshot. </td></tr>
    <tr><td class="paramname">esnap_id_len</td><td>The length of esnap_id, in bytes. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c1c118e86bb394aaa31fe230918c354" name="a2c1c118e86bb394aaa31fe230918c354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1c118e86bb394aaa31fe230918c354">&#9670;&#160;</a></span>spdk_bs_blob_set_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_blob_set_parent </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id</td>          <td class="paramname"><span class="paramname"><em>blob_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id</td>          <td class="paramname"><span class="paramname"><em>snapshot_id</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a snapshot as the parent of a blob. </p>
<p>This call set a snapshot as the parent of a blob, making the blob a clone of this snapshot. The previous parent of the blob, if any, can be another snapshot or an external snapshot; if the blob is not a clone, it must be thin-provisioned. Blob and parent snapshot must have the same size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">blob_id</td><td>The id of the blob. </td></tr>
    <tr><td class="paramname">snapshot_id</td><td>The id of the parent snapshot. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad58a01866afc7755397833a26535ad74" name="ad58a01866afc7755397833a26535ad74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58a01866afc7755397833a26535ad74">&#9670;&#160;</a></span>spdk_bs_blob_shallow_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bs_blob_shallow_copy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id</td>          <td class="paramname"><span class="paramname"><em>blobid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *</td>          <td class="paramname"><span class="paramname"><em>ext_dev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a668cd9f989594d7f4f417495ffa7517d">spdk_blob_shallow_copy_status</a></td>          <td class="paramname"><span class="paramname"><em>status_cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>status_cb_arg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a shallow copy of a blob to a blobstore device. </p>
<p>This makes a shallow copy from a blob to a blobstore device. Only clusters allocated to the blob will be written on the device. Blob must be read only and blob size must be less or equal than device size. Blobstore block size must be a multiple of device block size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>Blobstore </td></tr>
    <tr><td class="paramname">channel</td><td>IO channel used to copy the blob. </td></tr>
    <tr><td class="paramname">blobid</td><td>The id of the blob. </td></tr>
    <tr><td class="paramname">ext_dev</td><td>The device to copy on </td></tr>
    <tr><td class="paramname">status_cb_fn</td><td>Called repeatedly during operation with status updates </td></tr>
    <tr><td class="paramname">status_cb_arg</td><td>Argument passed to function status_cb_fn. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if operation starts correctly, negative errno on failure. </dd></dl>

</div>
</div>
<a id="a33263462543c5f2b51f4d507ea26a58d" name="a33263462543c5f2b51f4d507ea26a58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33263462543c5f2b51f4d507ea26a58d">&#9670;&#160;</a></span>spdk_bs_create_blob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_create_blob </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4955592d73cb1a262d699d10c8e2856f">spdk_blob_op_with_id_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new blob with default option values on the given blobstore. </p>
<p>The new blob id will be passed to the callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c00efe656ca70fc5e8f2f477b8e48ed" name="a3c00efe656ca70fc5e8f2f477b8e48ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c00efe656ca70fc5e8f2f477b8e48ed">&#9670;&#160;</a></span>spdk_bs_create_blob_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_create_blob_ext </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__blob__opts.html">spdk_blob_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4955592d73cb1a262d699d10c8e2856f">spdk_blob_op_with_id_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new blob with options on the given blobstore. </p>
<p>The new blob id will be passed to the callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">opts</td><td>The structure which contains the option values for the new blob. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73e90ac081ca6c0819940cac7ba35b87" name="a73e90ac081ca6c0819940cac7ba35b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e90ac081ca6c0819940cac7ba35b87">&#9670;&#160;</a></span>spdk_bs_create_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_create_clone </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id</td>          <td class="paramname"><span class="paramname"><em>blobid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__blob__xattr__opts.html">spdk_blob_xattr_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>clone_xattrs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4955592d73cb1a262d699d10c8e2856f">spdk_blob_op_with_id_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a clone of specified read-only blob. </p>
<p>Structure clone_xattrs as well as anything it references (like e.g. names array) must be valid until the completion is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">blobid</td><td>Id of the read only blob used as a snapshot for new clone. </td></tr>
    <tr><td class="paramname">clone_xattrs</td><td>xattrs specified for clone. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fb220c9f50228ed07e108ca1df52b65" name="a6fb220c9f50228ed07e108ca1df52b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb220c9f50228ed07e108ca1df52b65">&#9670;&#160;</a></span>spdk_bs_create_snapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_create_snapshot </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id</td>          <td class="paramname"><span class="paramname"><em>blobid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__blob__xattr__opts.html">spdk_blob_xattr_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>snapshot_xattrs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4955592d73cb1a262d699d10c8e2856f">spdk_blob_op_with_id_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a read-only snapshot of specified blob with provided options. </p>
<p>This will automatically sync specified blob.</p>
<p>When operation is done, original blob is converted to the thin-provisioned blob with a newly created read-only snapshot set as a backing blob. Structure snapshot_xattrs as well as anything it references (like e.g. names array) must be valid until the completion is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">blobid</td><td>Id of the source blob used to create a snapshot. </td></tr>
    <tr><td class="paramname">snapshot_xattrs</td><td>xattrs specified for snapshot. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed4fb5871f9ca58ff60c0dd8810eb223" name="aed4fb5871f9ca58ff60c0dd8810eb223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4fb5871f9ca58ff60c0dd8810eb223">&#9670;&#160;</a></span>spdk_bs_delete_blob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_delete_blob </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id</td>          <td class="paramname"><span class="paramname"><em>blobid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an existing blob from the given blobstore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">blobid</td><td>The id of the blob to delete. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ba54d7b0d88a136bbfc9f93bc10b87d" name="a0ba54d7b0d88a136bbfc9f93bc10b87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba54d7b0d88a136bbfc9f93bc10b87d">&#9670;&#160;</a></span>spdk_bs_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_destroy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9c265d4eead39c3419cee4b620bf5052">spdk_bs_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the blobstore. </p>
<p>It will destroy the blobstore by zeroing the super block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore to destroy. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the destruction is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa75072ce1a5a9559fe2db0da30363ad4" name="aa75072ce1a5a9559fe2db0da30363ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75072ce1a5a9559fe2db0da30363ad4">&#9670;&#160;</a></span>spdk_bs_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_dump </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *</td>          <td class="paramname"><span class="paramname"><em>dev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_bs_dump_print_xattr</td>          <td class="paramname"><span class="paramname"><em>print_xattr_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9c265d4eead39c3419cee4b620bf5052">spdk_bs_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a blobstore's metadata to a given FILE in human-readable format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Blobstore block device. </td></tr>
    <tr><td class="paramname">fp</td><td>FILE pointer to dump the metadata contents. </td></tr>
    <tr><td class="paramname">print_xattr_fn</td><td>Callback function to interpret external xattrs. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the dump is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d03f0499e552b6e858b7c52abcc0820" name="a8d03f0499e552b6e858b7c52abcc0820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d03f0499e552b6e858b7c52abcc0820">&#9670;&#160;</a></span>spdk_bs_free_cluster_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_bs_free_cluster_count </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of free clusters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of free clusters. </dd></dl>

</div>
</div>
<a id="a90cc7c570fc82adf69ab87d277e580a3" name="a90cc7c570fc82adf69ab87d277e580a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cc7c570fc82adf69ab87d277e580a3">&#9670;&#160;</a></span>spdk_bs_free_io_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_free_io_channel </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>channel</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the I/O channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>I/O channel to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1407ae1ce3b0fc57a6ee52cf119f9772" name="a1407ae1ce3b0fc57a6ee52cf119f9772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1407ae1ce3b0fc57a6ee52cf119f9772">&#9670;&#160;</a></span>spdk_bs_get_bstype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__bs__type.html">spdk_bs_type</a> spdk_bs_get_bstype </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get blobstore type of the given device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>blobstore type. </dd></dl>

</div>
</div>
<a id="ae00447f1611b9499fc23e8be2d45f501" name="ae00447f1611b9499fc23e8be2d45f501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00447f1611b9499fc23e8be2d45f501">&#9670;&#160;</a></span>spdk_bs_get_cluster_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_bs_get_cluster_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cluster size in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cluster size. </dd></dl>

</div>
</div>
<a id="a0800bfbaa7284454f7ba80275868b7ac" name="a0800bfbaa7284454f7ba80275868b7ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0800bfbaa7284454f7ba80275868b7ac">&#9670;&#160;</a></span>spdk_bs_get_io_unit_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_bs_get_io_unit_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the io unit size in bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>io unit size. </dd></dl>

</div>
</div>
<a id="a06cf3bf4280b524e95358fc2d3282b9a" name="a06cf3bf4280b524e95358fc2d3282b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06cf3bf4280b524e95358fc2d3282b9a">&#9670;&#160;</a></span>spdk_bs_get_page_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_bs_get_page_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the page size in bytes. </p>
<p>This is the write and read granularity of blobs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>page size. </dd></dl>

</div>
</div>
<a id="adb47e7a73e595499ea23b2415a6176f8" name="adb47e7a73e595499ea23b2415a6176f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb47e7a73e595499ea23b2415a6176f8">&#9670;&#160;</a></span>spdk_bs_get_super()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_get_super </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4955592d73cb1a262d699d10c8e2856f">spdk_blob_op_with_id_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the super blob. </p>
<p>The obtained blob id will be passed to the callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fc717fee381a5dd5c6e1e6f979f1202" name="a0fc717fee381a5dd5c6e1e6f979f1202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc717fee381a5dd5c6e1e6f979f1202">&#9670;&#160;</a></span>spdk_bs_grow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_grow </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *</td>          <td class="paramname"><span class="paramname"><em>dev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a40a976910f2112a4164ae6a12b946855">spdk_bs_op_with_handle_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Grow a blobstore to fill the underlying device Cannot be used on loaded blobstore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Blobstore block device. </td></tr>
    <tr><td class="paramname">opts</td><td>The structure which contains the option values for the blobstore. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the loading is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bd61903827b230cf2f6d25fb321e8d0" name="a1bd61903827b230cf2f6d25fb321e8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd61903827b230cf2f6d25fb321e8d0">&#9670;&#160;</a></span>spdk_bs_grow_live()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_grow_live </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9c265d4eead39c3419cee4b620bf5052">spdk_bs_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Grow a blobstore to fill the underlying device. </p>
<p>Can be used on loaded blobstore, even with opened blobs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore to grow. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the growing is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d1f1b56d9782997ef3e338879a2fa28" name="a3d1f1b56d9782997ef3e338879a2fa28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1f1b56d9782997ef3e338879a2fa28">&#9670;&#160;</a></span>spdk_bs_inflate_blob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_inflate_blob </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>channel</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id</td>          <td class="paramname"><span class="paramname"><em>blobid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aca5253109581a768e06dd197429ef9e1">spdk_blob_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate all clusters in this blob. </p>
<p>Data for allocated clusters is copied from backing blob(s) if they exist.</p>
<p>This call removes all dependencies on any backing blobs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">channel</td><td>IO channel used to inflate blob. </td></tr>
    <tr><td class="paramname">blobid</td><td>The id of the blob to inflate. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad59f1d147b612a7d4ce1eb8439a69cee" name="ad59f1d147b612a7d4ce1eb8439a69cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59f1d147b612a7d4ce1eb8439a69cee">&#9670;&#160;</a></span>spdk_bs_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *</td>          <td class="paramname"><span class="paramname"><em>dev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a40a976910f2112a4164ae6a12b946855">spdk_bs_op_with_handle_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a blobstore on the given device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Blobstore block device. </td></tr>
    <tr><td class="paramname">opts</td><td>The structure which contains the option values for the blobstore. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the initialization is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af173fe4e35623b8dc8256e9141700486" name="af173fe4e35623b8dc8256e9141700486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af173fe4e35623b8dc8256e9141700486">&#9670;&#160;</a></span>spdk_bs_iter_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_iter_first </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aab6d19ccc3c952877c355030e2a286c1">spdk_blob_op_with_handle_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first blob of the blobstore. </p>
<p>The obtained blob will be passed to the callback function.</p>
<p>The user's cb_fn will be called with rc == -ENOENT when the iteration is complete.</p>
<p>When the user's cb_fn is called with rc == 0, the associated blob is open. This means that the cb_fn may not attempt to unload the blobstore. It must complete the iteration before attempting to unload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore to traverse. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98d90e701cf3377115ff0bb67db1342a" name="a98d90e701cf3377115ff0bb67db1342a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d90e701cf3377115ff0bb67db1342a">&#9670;&#160;</a></span>spdk_bs_iter_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_iter_next </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_blob *</td>          <td class="paramname"><span class="paramname"><em>blob</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aab6d19ccc3c952877c355030e2a286c1">spdk_blob_op_with_handle_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next blob by using the current blob. </p>
<p>The obtained blob will be passed to the callback function.</p>
<p>The user's cb_fn will be called with rc == -ENOENT when the iteration is complete.</p>
<p>When the user's cb_fn is called with rc == 0, the associated blob is open. This means that the cb_fn may not attempt to unload the blobstore. It must complete the iteration before attempting to unload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore to traverse. </td></tr>
    <tr><td class="paramname">blob</td><td>The current blob. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a400da20b69e4f914730fbd15d51eb748" name="a400da20b69e4f914730fbd15d51eb748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400da20b69e4f914730fbd15d51eb748">&#9670;&#160;</a></span>spdk_bs_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_load </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bs__dev.html">spdk_bs_dev</a> *</td>          <td class="paramname"><span class="paramname"><em>dev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a40a976910f2112a4164ae6a12b946855">spdk_bs_op_with_handle_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a blobstore from the given device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Blobstore block device. </td></tr>
    <tr><td class="paramname">opts</td><td>The structure which contains the option values for the blobstore. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the loading is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c60e6bc3ccd26228dec2c0f3ecfe618" name="a2c60e6bc3ccd26228dec2c0f3ecfe618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c60e6bc3ccd26228dec2c0f3ecfe618">&#9670;&#160;</a></span>spdk_bs_open_blob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_open_blob </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id</td>          <td class="paramname"><span class="paramname"><em>blobid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aab6d19ccc3c952877c355030e2a286c1">spdk_blob_op_with_handle_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a blob from the given blobstore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">blobid</td><td>The id of the blob to open. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae147507ca08e788a5245c35f10fa1d1c" name="ae147507ca08e788a5245c35f10fa1d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae147507ca08e788a5245c35f10fa1d1c">&#9670;&#160;</a></span>spdk_bs_open_blob_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_open_blob_ext </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id</td>          <td class="paramname"><span class="paramname"><em>blobid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__blob__open__opts.html">spdk_blob_open_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aab6d19ccc3c952877c355030e2a286c1">spdk_blob_op_with_handle_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a blob from the given blobstore with additional options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">blobid</td><td>The id of the blob to open. </td></tr>
    <tr><td class="paramname">opts</td><td>The structure which contains the option values for the blob. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d76e2deeb5cc5354d23370914b28e2a" name="a2d76e2deeb5cc5354d23370914b28e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d76e2deeb5cc5354d23370914b28e2a">&#9670;&#160;</a></span>spdk_bs_opts_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_opts_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>opts_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a> structure to the default blobstore option values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>The <a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a> structure to be initialized. </td></tr>
    <tr><td class="paramname">opts_size</td><td>The opts_size must be the size of <a class="el" href="structspdk__bs__opts.html">spdk_bs_opts</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9b434a45e67bcebb2fcb79965bd56e5" name="aa9b434a45e67bcebb2fcb79965bd56e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b434a45e67bcebb2fcb79965bd56e5">&#9670;&#160;</a></span>spdk_bs_set_bstype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_set_bstype </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bs__type.html">spdk_bs_type</a></td>          <td class="paramname"><span class="paramname"><em>bstype</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set blobstore type to the given device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore to set to. </td></tr>
    <tr><td class="paramname">bstype</td><td>Type label to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c5c40c9c88d85ef5455ab32a1db3aa4" name="a0c5c40c9c88d85ef5455ab32a1db3aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5c40c9c88d85ef5455ab32a1db3aa4">&#9670;&#160;</a></span>spdk_bs_set_super()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_set_super </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_blob_id</td>          <td class="paramname"><span class="paramname"><em>blobid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9c265d4eead39c3419cee4b620bf5052">spdk_bs_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a super blob on the given blobstore. </p>
<p>This will be retrievable immediately after <a class="el" href="#a400da20b69e4f914730fbd15d51eb748" title="Load a blobstore from the given device.">spdk_bs_load()</a> on the next initialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore. </td></tr>
    <tr><td class="paramname">blobid</td><td>The id of the blob which will be set as the super blob. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the setting is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c090bf1ffd244cd1d2787d906d0d34f" name="a3c090bf1ffd244cd1d2787d906d0d34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c090bf1ffd244cd1d2787d906d0d34f">&#9670;&#160;</a></span>spdk_bs_total_data_cluster_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_bs_total_data_cluster_count </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total number of clusters accessible by user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total number of clusters accessible by user. </dd></dl>

</div>
</div>
<a id="aa98e6633723afb306a763b9f571f2cc1" name="aa98e6633723afb306a763b9f571f2cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98e6633723afb306a763b9f571f2cc1">&#9670;&#160;</a></span>spdk_bs_unload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bs_unload </td>
          <td>(</td>
          <td class="paramtype">struct spdk_blob_store *</td>          <td class="paramname"><span class="paramname"><em>bs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9c265d4eead39c3419cee4b620bf5052">spdk_bs_op_complete</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unload the blobstore. </p>
<p>It will flush all volatile data to disk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>blobstore to unload. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the unloading is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae17f3a52d52d9c3e9382cbcfae042c0a" name="ae17f3a52d52d9c3e9382cbcfae042c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17f3a52d52d9c3e9382cbcfae042c0a">&#9670;&#160;</a></span>spdk_xattr_names_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_xattr_names_free </td>
          <td>(</td>
          <td class="paramtype">struct spdk_xattr_names *</td>          <td class="paramname"><span class="paramname"><em>names</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the attribute names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>Names of total extended attributes of the blob. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a113d71117843062da8a24906296b37a6" name="a113d71117843062da8a24906296b37a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113d71117843062da8a24906296b37a6">&#9670;&#160;</a></span>spdk_xattr_names_get_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_xattr_names_get_count </td>
          <td>(</td>
          <td class="paramtype">struct spdk_xattr_names *</td>          <td class="paramname"><span class="paramname"><em>names</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of extended attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>Names of total extended attributes of the blob.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of extended attributes. </dd></dl>

</div>
</div>
<a id="a7a6eeb557d81469091ba8b606a595a88" name="a7a6eeb557d81469091ba8b606a595a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6eeb557d81469091ba8b606a595a88">&#9670;&#160;</a></span>spdk_xattr_names_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_xattr_names_get_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_xattr_names *</td>          <td class="paramname"><span class="paramname"><em>names</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the attribute name specified by the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">names</td><td>Names of total extended attributes of the blob. </td></tr>
    <tr><td class="paramname">index</td><td>Index position of the specified attribute.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>attribute name. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.10.0 </li>
</ul>
</div>
</div>
</body>
</html>
