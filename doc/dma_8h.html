<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="generator" content="Doxygen 1.9.1" />
  <title>SPDK: dma.h File Reference</title>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  <script type="text/javascript" src="../js/doxyboot.js"></script>
  <script type="text/javascript" src="./navtree.js"></script>
  <link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
<body>
  <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/" aria-label="SPDK">
      <img src="/img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <div class="navbar-nav mr-auto">
        <a class="nav-link header-link active" href="../doc/">Documentation</a>
        <a class="nav-link header-link" href="../development/">Development</a>
        <a class="nav-link header-link" href="../community/">Community</a>
        <a class="nav-link header-link" href="../blog/">Blog</a>
      </div>
      <div class="navbar-nav ml-auto mr-3">
        <a class="nav-link header-link" href="https://github.com/spdk/spdk">
          <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
      </div>
    </div>
  </nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dma_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dma.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>SPDK DMA device framework.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__memory__domain__translation__result.html">spdk_memory_domain_translation_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__memory__domain__translation__ctx.html">spdk_memory_domain_translation_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__memory__domain__rdma__ctx.html">spdk_memory_domain_rdma_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context of memory domain of RDMA type.  <a href="structspdk__memory__domain__rdma__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__memory__domain__ctx.html">spdk_memory_domain_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6d96f9e4e12eef5b83a1e85c0643edef"><td class="memItemLeft" align="right" valign="top"><a id="a6d96f9e4e12eef5b83a1e85c0643edef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#a6d96f9e4e12eef5b83a1e85c0643edef">SPDK_RDMA_DMA_DEVICE</a>&#160;&#160;&#160;&quot;SPDK_RDMA_DMA_DEVICE&quot;</td></tr>
<tr class="memdesc:a6d96f9e4e12eef5b83a1e85c0643edef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier of SPDK internal DMA device of RDMA type. <br /></td></tr>
<tr class="separator:a6d96f9e4e12eef5b83a1e85c0643edef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8d7a0eee8d944cf100d3006b3f3f1774"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a>) (void *ctx, int rc)</td></tr>
<tr class="memdesc:a8d7a0eee8d944cf100d3006b3f3f1774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of completion callback to be called by pull, push or memzero functions.  <a href="dma_8h.html#a8d7a0eee8d944cf100d3006b3f3f1774">More...</a><br /></td></tr>
<tr class="separator:a8d7a0eee8d944cf100d3006b3f3f1774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5cd879a09a8f23a30b45e94574e893"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#abf5cd879a09a8f23a30b45e94574e893">spdk_memory_domain_pull_data_cb</a>) (struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct iovec *src_iov, uint32_t src_iovcnt, struct iovec *dst_iov, uint32_t dst_iovcnt, <a class="el" href="dma_8h.html#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:abf5cd879a09a8f23a30b45e94574e893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of function which asynchronously pulles data from src_domain to local memory domain.  <a href="dma_8h.html#abf5cd879a09a8f23a30b45e94574e893">More...</a><br /></td></tr>
<tr class="separator:abf5cd879a09a8f23a30b45e94574e893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4b39300fc63eb3fe95530ca4c87305"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#a2f4b39300fc63eb3fe95530ca4c87305">spdk_memory_domain_push_data_cb</a>) (struct spdk_memory_domain *dst_domain, void *dst_domain_ctx, struct iovec *dst_iov, uint32_t dst_iovcnt, struct iovec *src_iov, uint32_t src_iovcnt, <a class="el" href="dma_8h.html#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:a2f4b39300fc63eb3fe95530ca4c87305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of function which asynchronously pushes data from local memory to destination memory domain.  <a href="dma_8h.html#a2f4b39300fc63eb3fe95530ca4c87305">More...</a><br /></td></tr>
<tr class="separator:a2f4b39300fc63eb3fe95530ca4c87305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22484d6db47a04c8a41a84e67cdb4613"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#a22484d6db47a04c8a41a84e67cdb4613">spdk_memory_domain_memzero_cb</a>) (struct spdk_memory_domain *domain, void *domain_ctx, struct iovec *iov, uint32_t iovcnt, <a class="el" href="dma_8h.html#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:a22484d6db47a04c8a41a84e67cdb4613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of function which asynchronously fills memory in <b>domain</b> with zeroes.  <a href="dma_8h.html#a22484d6db47a04c8a41a84e67cdb4613">More...</a><br /></td></tr>
<tr class="separator:a22484d6db47a04c8a41a84e67cdb4613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80080465d2736a76d0ddf95d67c701bb"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#a80080465d2736a76d0ddf95d67c701bb">spdk_memory_domain_translate_memory_cb</a>) (struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct spdk_memory_domain *dst_domain, struct <a class="el" href="structspdk__memory__domain__translation__ctx.html">spdk_memory_domain_translation_ctx</a> *dst_domain_ctx, void *addr, size_t len, struct <a class="el" href="structspdk__memory__domain__translation__result.html">spdk_memory_domain_translation_result</a> *result)</td></tr>
<tr class="memdesc:a80080465d2736a76d0ddf95d67c701bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of function which translates data from src_domain to a form accessible by dst_domain.  <a href="dma_8h.html#a80080465d2736a76d0ddf95d67c701bb">More...</a><br /></td></tr>
<tr class="separator:a80080465d2736a76d0ddf95d67c701bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a85588b3a6ec5c188ab2dc318c3903586"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#a85588b3a6ec5c188ab2dc318c3903586">spdk_dma_device_type</a> { <br />
&#160;&#160;<a class="el" href="dma_8h.html#a85588b3a6ec5c188ab2dc318c3903586a00353a6b099210ed1c52cb9582f1ae01">SPDK_DMA_DEVICE_TYPE_RDMA</a>
, <a class="el" href="dma_8h.html#a85588b3a6ec5c188ab2dc318c3903586ae488329b2d5cebe0bc130e0803c4fefc">SPDK_DMA_DEVICE_TYPE_DMA</a>
, <a class="el" href="dma_8h.html#a85588b3a6ec5c188ab2dc318c3903586a065a87ed31fe120b25d6811ce9b37ba8">SPDK_DMA_DEVICE_TYPE_ACCEL</a>
, <a class="el" href="dma_8h.html#a85588b3a6ec5c188ab2dc318c3903586a1201e15e1a81553cb3ac297e7f5648be">SPDK_DMA_DEVICE_VENDOR_SPECIFIC_TYPE_START</a> = 1000
, <br />
&#160;&#160;<a class="el" href="dma_8h.html#a85588b3a6ec5c188ab2dc318c3903586a51d3c59fcd56fc712b1943b5a08dead2">SPDK_DMA_DEVICE_VENDOR_SPECIFIC_TYPE_END</a> = SPDK_DMA_DEVICE_VENDOR_SPECIFIC_TYPE_START + 999
<br />
 }</td></tr>
<tr class="separator:a85588b3a6ec5c188ab2dc318c3903586"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6ddda62cbca17c587a2c6d201b4e6dff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#a6ddda62cbca17c587a2c6d201b4e6dff">spdk_memory_domain_create</a> (struct spdk_memory_domain **domain, enum <a class="el" href="dma_8h.html#a85588b3a6ec5c188ab2dc318c3903586">spdk_dma_device_type</a> type, struct <a class="el" href="structspdk__memory__domain__ctx.html">spdk_memory_domain_ctx</a> *ctx, const char *id)</td></tr>
<tr class="memdesc:a6ddda62cbca17c587a2c6d201b4e6dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new memory domain of the specified type.  <a href="dma_8h.html#a6ddda62cbca17c587a2c6d201b4e6dff">More...</a><br /></td></tr>
<tr class="separator:a6ddda62cbca17c587a2c6d201b4e6dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4777ac664899af134eaa6c93de05d6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#ab4777ac664899af134eaa6c93de05d6d">spdk_memory_domain_set_translation</a> (struct spdk_memory_domain *domain, <a class="el" href="dma_8h.html#a80080465d2736a76d0ddf95d67c701bb">spdk_memory_domain_translate_memory_cb</a> translate_cb)</td></tr>
<tr class="memdesc:ab4777ac664899af134eaa6c93de05d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set translation function for memory domain.  <a href="dma_8h.html#ab4777ac664899af134eaa6c93de05d6d">More...</a><br /></td></tr>
<tr class="separator:ab4777ac664899af134eaa6c93de05d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c443f5b67500578f056e9fe9039bf76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#a6c443f5b67500578f056e9fe9039bf76">spdk_memory_domain_set_pull</a> (struct spdk_memory_domain *domain, <a class="el" href="dma_8h.html#abf5cd879a09a8f23a30b45e94574e893">spdk_memory_domain_pull_data_cb</a> pull_cb)</td></tr>
<tr class="memdesc:a6c443f5b67500578f056e9fe9039bf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pull function for memory domain.  <a href="dma_8h.html#a6c443f5b67500578f056e9fe9039bf76">More...</a><br /></td></tr>
<tr class="separator:a6c443f5b67500578f056e9fe9039bf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87db0ff92404fc6cb110e8fa98cce0dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#a87db0ff92404fc6cb110e8fa98cce0dd">spdk_memory_domain_set_push</a> (struct spdk_memory_domain *domain, <a class="el" href="dma_8h.html#a2f4b39300fc63eb3fe95530ca4c87305">spdk_memory_domain_push_data_cb</a> push_cb)</td></tr>
<tr class="memdesc:a87db0ff92404fc6cb110e8fa98cce0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set push function for memory domain.  <a href="dma_8h.html#a87db0ff92404fc6cb110e8fa98cce0dd">More...</a><br /></td></tr>
<tr class="separator:a87db0ff92404fc6cb110e8fa98cce0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafa95a5bedcc6c320d09a2ccbbeedfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#abafa95a5bedcc6c320d09a2ccbbeedfc">spdk_memory_domain_set_memzero</a> (struct spdk_memory_domain *domain, <a class="el" href="dma_8h.html#a22484d6db47a04c8a41a84e67cdb4613">spdk_memory_domain_memzero_cb</a> memzero_cb)</td></tr>
<tr class="memdesc:abafa95a5bedcc6c320d09a2ccbbeedfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set memzero function for memory domain.  <a href="dma_8h.html#abafa95a5bedcc6c320d09a2ccbbeedfc">More...</a><br /></td></tr>
<tr class="separator:abafa95a5bedcc6c320d09a2ccbbeedfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0277d9f5317fb5ae789c3394ba933b2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__memory__domain__ctx.html">spdk_memory_domain_ctx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#ac0277d9f5317fb5ae789c3394ba933b2">spdk_memory_domain_get_context</a> (struct spdk_memory_domain *domain)</td></tr>
<tr class="memdesc:ac0277d9f5317fb5ae789c3394ba933b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context passed by the user in <a class="el" href="dma_8h.html#a6ddda62cbca17c587a2c6d201b4e6dff">spdk_memory_domain_create</a>.  <a href="dma_8h.html#ac0277d9f5317fb5ae789c3394ba933b2">More...</a><br /></td></tr>
<tr class="separator:ac0277d9f5317fb5ae789c3394ba933b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2dd7b82d1f0afe434c0ca92fce6fc66"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="dma_8h.html#a85588b3a6ec5c188ab2dc318c3903586">spdk_dma_device_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#aa2dd7b82d1f0afe434c0ca92fce6fc66">spdk_memory_domain_get_dma_device_type</a> (struct spdk_memory_domain *domain)</td></tr>
<tr class="memdesc:aa2dd7b82d1f0afe434c0ca92fce6fc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of the DMA device that can access this memory domain.  <a href="dma_8h.html#aa2dd7b82d1f0afe434c0ca92fce6fc66">More...</a><br /></td></tr>
<tr class="separator:aa2dd7b82d1f0afe434c0ca92fce6fc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce978da1ab1cff0e08f5edfd50a4a88"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#a8ce978da1ab1cff0e08f5edfd50a4a88">spdk_memory_domain_get_dma_device_id</a> (struct spdk_memory_domain *domain)</td></tr>
<tr class="memdesc:a8ce978da1ab1cff0e08f5edfd50a4a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an identifier representing the DMA device that can access this memory domain.  <a href="dma_8h.html#a8ce978da1ab1cff0e08f5edfd50a4a88">More...</a><br /></td></tr>
<tr class="separator:a8ce978da1ab1cff0e08f5edfd50a4a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad908aa65943565af3128e340c8c5e285"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#ad908aa65943565af3128e340c8c5e285">spdk_memory_domain_destroy</a> (struct spdk_memory_domain *domain)</td></tr>
<tr class="memdesc:ad908aa65943565af3128e340c8c5e285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy memory domain.  <a href="dma_8h.html#ad908aa65943565af3128e340c8c5e285">More...</a><br /></td></tr>
<tr class="separator:ad908aa65943565af3128e340c8c5e285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab766b91733e0939cdea6d13e77572d40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#ab766b91733e0939cdea6d13e77572d40">spdk_memory_domain_pull_data</a> (struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct iovec *src_iov, uint32_t src_iov_cnt, struct iovec *dst_iov, uint32_t dst_iov_cnt, <a class="el" href="dma_8h.html#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:ab766b91733e0939cdea6d13e77572d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously pull data which is described by <b>src_domain</b> and located in <b>src_iov</b> to a location <b>dst_iov</b> local memory space.  <a href="dma_8h.html#ab766b91733e0939cdea6d13e77572d40">More...</a><br /></td></tr>
<tr class="separator:ab766b91733e0939cdea6d13e77572d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e494849a34eeab88b96f44e79862eb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#a9e494849a34eeab88b96f44e79862eb8">spdk_memory_domain_push_data</a> (struct spdk_memory_domain *dst_domain, void *dst_domain_ctx, struct iovec *dst_iov, uint32_t dst_iovcnt, struct iovec *src_iov, uint32_t src_iovcnt, <a class="el" href="dma_8h.html#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:a9e494849a34eeab88b96f44e79862eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously push data located in local memory to <b>dst_domain</b>.  <a href="dma_8h.html#a9e494849a34eeab88b96f44e79862eb8">More...</a><br /></td></tr>
<tr class="separator:a9e494849a34eeab88b96f44e79862eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ad1c0fc1a4fa74ede9b48181e044b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#a05ad1c0fc1a4fa74ede9b48181e044b1">spdk_memory_domain_translate_data</a> (struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct spdk_memory_domain *dst_domain, struct <a class="el" href="structspdk__memory__domain__translation__ctx.html">spdk_memory_domain_translation_ctx</a> *dst_domain_ctx, void *addr, size_t len, struct <a class="el" href="structspdk__memory__domain__translation__result.html">spdk_memory_domain_translation_result</a> *result)</td></tr>
<tr class="memdesc:a05ad1c0fc1a4fa74ede9b48181e044b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate data located in <b>src_domain</b> space at address <b>addr</b> with size <b>len</b> into an equivalent description of memory in dst_domain.  <a href="dma_8h.html#a05ad1c0fc1a4fa74ede9b48181e044b1">More...</a><br /></td></tr>
<tr class="separator:a05ad1c0fc1a4fa74ede9b48181e044b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e0567f3920f46cb3644ced997573c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#ae4e0567f3920f46cb3644ced997573c7">spdk_memory_domain_memzero</a> (struct spdk_memory_domain *domain, void *domain_ctx, struct iovec *iov, uint32_t iovcnt, <a class="el" href="dma_8h.html#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:ae4e0567f3920f46cb3644ced997573c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills memory in <b>domain</b> with zeroes.  <a href="dma_8h.html#ae4e0567f3920f46cb3644ced997573c7">More...</a><br /></td></tr>
<tr class="separator:ae4e0567f3920f46cb3644ced997573c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bda4c46e09079dd85d3ea2facdb39a"><td class="memItemLeft" align="right" valign="top">struct spdk_memory_domain *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#a76bda4c46e09079dd85d3ea2facdb39a">spdk_memory_domain_get_first</a> (const char *id)</td></tr>
<tr class="memdesc:a76bda4c46e09079dd85d3ea2facdb39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first memory domain.  <a href="dma_8h.html#a76bda4c46e09079dd85d3ea2facdb39a">More...</a><br /></td></tr>
<tr class="separator:a76bda4c46e09079dd85d3ea2facdb39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fd20c6b213156ac21f95bb19bc83d1"><td class="memItemLeft" align="right" valign="top">struct spdk_memory_domain *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dma_8h.html#aa7fd20c6b213156ac21f95bb19bc83d1">spdk_memory_domain_get_next</a> (struct spdk_memory_domain *prev, const char *id)</td></tr>
<tr class="memdesc:aa7fd20c6b213156ac21f95bb19bc83d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next memory domain.  <a href="dma_8h.html#aa7fd20c6b213156ac21f95bb19bc83d1">More...</a><br /></td></tr>
<tr class="separator:aa7fd20c6b213156ac21f95bb19bc83d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SPDK DMA device framework. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a8d7a0eee8d944cf100d3006b3f3f1774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7a0eee8d944cf100d3006b3f3f1774">&#9670;&nbsp;</a></span>spdk_memory_domain_data_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_memory_domain_data_cpl_cb) (void *ctx, int rc)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of completion callback to be called by pull, push or memzero functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>User context passed to pull of push functions </td></tr>
    <tr><td class="paramname">rc</td><td>Result of asynchronous data pull or push function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22484d6db47a04c8a41a84e67cdb4613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22484d6db47a04c8a41a84e67cdb4613">&#9670;&nbsp;</a></span>spdk_memory_domain_memzero_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_memory_domain_memzero_cb) (struct spdk_memory_domain *domain, void *domain_ctx, struct iovec *iov, uint32_t iovcnt, <a class="el" href="dma_8h.html#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of function which asynchronously fills memory in <b>domain</b> with zeroes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain in which address space data buffer is located </td></tr>
    <tr><td class="paramname">domain_ctx</td><td>User defined context </td></tr>
    <tr><td class="paramname">iov</td><td>iov in <b>domain</b> memory space to be filled with zeroes </td></tr>
    <tr><td class="paramname">iovcnt</td><td><b>iov</b> array size </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>Completion callback </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Completion callback argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure </dd></dl>

</div>
</div>
<a id="abf5cd879a09a8f23a30b45e94574e893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5cd879a09a8f23a30b45e94574e893">&#9670;&nbsp;</a></span>spdk_memory_domain_pull_data_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_memory_domain_pull_data_cb) (struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct iovec *src_iov, uint32_t src_iovcnt, struct iovec *dst_iov, uint32_t dst_iovcnt, <a class="el" href="dma_8h.html#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of function which asynchronously pulles data from src_domain to local memory domain. </p>
<p>Implementation of this function must call <b>cpl_cb</b> only when it returns 0. All other return codes mean failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_domain</td><td>Memory domain to which the data buffer belongs </td></tr>
    <tr><td class="paramname">src_domain_ctx</td><td>Optional context passed by upper layer with IO request </td></tr>
    <tr><td class="paramname">src_iov</td><td>Iov vector in <b>src_domain</b> space </td></tr>
    <tr><td class="paramname">src_iovcnt</td><td>src_iov array size </td></tr>
    <tr><td class="paramname">dst_iov</td><td>Iov vector in local memory domain space, data buffers must be allocated by the caller of this function, total size of data buffers must not be less than the size of data in <b>src_iov</b>. </td></tr>
    <tr><td class="paramname">dst_iovcnt</td><td>dst_iov array size </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>A callback to be called when pull operation completes </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Optional argument to be passed to <b>cpl_cb</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure </dd></dl>

</div>
</div>
<a id="a2f4b39300fc63eb3fe95530ca4c87305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4b39300fc63eb3fe95530ca4c87305">&#9670;&nbsp;</a></span>spdk_memory_domain_push_data_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_memory_domain_push_data_cb) (struct spdk_memory_domain *dst_domain, void *dst_domain_ctx, struct iovec *dst_iov, uint32_t dst_iovcnt, struct iovec *src_iov, uint32_t src_iovcnt, <a class="el" href="dma_8h.html#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of function which asynchronously pushes data from local memory to destination memory domain. </p>
<p>Implementation of this function must call <b>cpl_cb</b> only when it returns 0. All other return codes mean failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_domain</td><td>Memory domain to which the data should be pushed </td></tr>
    <tr><td class="paramname">dst_domain_ctx</td><td>Optional context passed by upper layer with IO request </td></tr>
    <tr><td class="paramname">dst_iov</td><td>Iov vector in dst_domain space </td></tr>
    <tr><td class="paramname">dst_iovcnt</td><td>dst_iov array size </td></tr>
    <tr><td class="paramname">src_iov</td><td>Iov vector in local memory </td></tr>
    <tr><td class="paramname">src_iovcnt</td><td>src_iov array size </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>A callback to be called when push operation completes </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Optional argument to be passed to <b>cpl_cb</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure </dd></dl>

</div>
</div>
<a id="a80080465d2736a76d0ddf95d67c701bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80080465d2736a76d0ddf95d67c701bb">&#9670;&nbsp;</a></span>spdk_memory_domain_translate_memory_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_memory_domain_translate_memory_cb) (struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct spdk_memory_domain *dst_domain, struct <a class="el" href="structspdk__memory__domain__translation__ctx.html">spdk_memory_domain_translation_ctx</a> *dst_domain_ctx, void *addr, size_t len, struct <a class="el" href="structspdk__memory__domain__translation__result.html">spdk_memory_domain_translation_result</a> *result)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of function which translates data from src_domain to a form accessible by dst_domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_domain</td><td>Memory domain to which the data buffer belongs </td></tr>
    <tr><td class="paramname">src_domain_ctx</td><td>Optional context passed by upper layer with IO request </td></tr>
    <tr><td class="paramname">dst_domain</td><td>Memory domain which determines type of translation function </td></tr>
    <tr><td class="paramname">dst_domain_ctx</td><td>Ancillary data for dst_domain </td></tr>
    <tr><td class="paramname">addr</td><td>Data buffer address in <b>src_domain</b> memory space which should be translated into <b>dst_domain</b> </td></tr>
    <tr><td class="paramname">len</td><td>Length of data buffer </td></tr>
    <tr><td class="paramname">result</td><td>Result of translation function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a85588b3a6ec5c188ab2dc318c3903586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85588b3a6ec5c188ab2dc318c3903586">&#9670;&nbsp;</a></span>spdk_dma_device_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dma_8h.html#a85588b3a6ec5c188ab2dc318c3903586">spdk_dma_device_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85588b3a6ec5c188ab2dc318c3903586a00353a6b099210ed1c52cb9582f1ae01"></a>SPDK_DMA_DEVICE_TYPE_RDMA&#160;</td><td class="fielddoc"><p>RDMA devices are capable of performing DMA operations on memory domains using the standard RDMA model (protection domain, remote key, address). </p>
</td></tr>
<tr><td class="fieldname"><a id="a85588b3a6ec5c188ab2dc318c3903586ae488329b2d5cebe0bc130e0803c4fefc"></a>SPDK_DMA_DEVICE_TYPE_DMA&#160;</td><td class="fielddoc"><p>DMA devices are capable of performing DMA operations on memory domains using physical or I/O virtual addresses. </p>
</td></tr>
<tr><td class="fieldname"><a id="a85588b3a6ec5c188ab2dc318c3903586a065a87ed31fe120b25d6811ce9b37ba8"></a>SPDK_DMA_DEVICE_TYPE_ACCEL&#160;</td><td class="fielddoc"><p>Virtual memory domain representing memory being transformed by accel framework. </p>
</td></tr>
<tr><td class="fieldname"><a id="a85588b3a6ec5c188ab2dc318c3903586a1201e15e1a81553cb3ac297e7f5648be"></a>SPDK_DMA_DEVICE_VENDOR_SPECIFIC_TYPE_START&#160;</td><td class="fielddoc"><p>Start of the range of vendor-specific DMA device types. </p>
</td></tr>
<tr><td class="fieldname"><a id="a85588b3a6ec5c188ab2dc318c3903586a51d3c59fcd56fc712b1943b5a08dead2"></a>SPDK_DMA_DEVICE_VENDOR_SPECIFIC_TYPE_END&#160;</td><td class="fielddoc"><p>End of the range of vendor-specific DMA device types. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6ddda62cbca17c587a2c6d201b4e6dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddda62cbca17c587a2c6d201b4e6dff">&#9670;&nbsp;</a></span>spdk_memory_domain_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_memory_domain_create </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain **&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="dma_8h.html#a85588b3a6ec5c188ab2dc318c3903586">spdk_dma_device_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__memory__domain__ctx.html">spdk_memory_domain_ctx</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new memory domain of the specified type. </p>
<p>Translation functions can be provided to translate addresses from one memory domain to another. If the two domains both use the same addressing scheme for, then this translation does nothing. However, it is possible that the two memory domains may address the same physical memory differently, so this translation step is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Double pointer to memory domain to be allocated by this function </td></tr>
    <tr><td class="paramname">type</td><td>Type of the DMA device which can access this memory domain </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional memory domain context to be copied by this function. Later <b>ctx</b> can be retrieved using <a class="el" href="dma_8h.html#ac0277d9f5317fb5ae789c3394ba933b2">spdk_memory_domain_get_context</a> function </td></tr>
    <tr><td class="paramname">id</td><td>String identifier representing the DMA device that can access this memory domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure </dd></dl>

</div>
</div>
<a id="ad908aa65943565af3128e340c8c5e285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad908aa65943565af3128e340c8c5e285">&#9670;&nbsp;</a></span>spdk_memory_domain_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memory_domain_destroy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy memory domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0277d9f5317fb5ae789c3394ba933b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0277d9f5317fb5ae789c3394ba933b2">&#9670;&nbsp;</a></span>spdk_memory_domain_get_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__memory__domain__ctx.html">spdk_memory_domain_ctx</a>* spdk_memory_domain_get_context </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the context passed by the user in <a class="el" href="dma_8h.html#a6ddda62cbca17c587a2c6d201b4e6dff">spdk_memory_domain_create</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory domain context </dd></dl>

</div>
</div>
<a id="a8ce978da1ab1cff0e08f5edfd50a4a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce978da1ab1cff0e08f5edfd50a4a88">&#9670;&nbsp;</a></span>spdk_memory_domain_get_dma_device_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_memory_domain_get_dma_device_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an identifier representing the DMA device that can access this memory domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DMA device identifier </dd></dl>

</div>
</div>
<a id="aa2dd7b82d1f0afe434c0ca92fce6fc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2dd7b82d1f0afe434c0ca92fce6fc66">&#9670;&nbsp;</a></span>spdk_memory_domain_get_dma_device_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dma_8h.html#a85588b3a6ec5c188ab2dc318c3903586">spdk_dma_device_type</a> spdk_memory_domain_get_dma_device_type </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *&#160;</td>
          <td class="paramname"><em>domain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get type of the DMA device that can access this memory domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DMA device type </dd></dl>

</div>
</div>
<a id="a76bda4c46e09079dd85d3ea2facdb39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76bda4c46e09079dd85d3ea2facdb39a">&#9670;&nbsp;</a></span>spdk_memory_domain_get_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_memory_domain* spdk_memory_domain_get_first </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first memory domain. </p>
<p>Combined with <a class="el" href="dma_8h.html#aa7fd20c6b213156ac21f95bb19bc83d1">spdk_memory_domain_get_next</a> to iterate over all memory domains</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Optional identifier representing the DMA device that can access a memory domain, if set then this function returns the first memory domain which id matches or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first memory domain or NULL </dd></dl>

</div>
</div>
<a id="aa7fd20c6b213156ac21f95bb19bc83d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fd20c6b213156ac21f95bb19bc83d1">&#9670;&nbsp;</a></span>spdk_memory_domain_get_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_memory_domain* spdk_memory_domain_get_next </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *&#160;</td>
          <td class="paramname"><em>prev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next memory domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>Previous memory domain </td></tr>
    <tr><td class="paramname">id</td><td>Optional identifier representing the DMA device that can access a memory domain, if set then this function returns the next memory domain which id matches or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to next memory domain or NULL; </dd></dl>

</div>
</div>
<a id="ae4e0567f3920f46cb3644ced997573c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e0567f3920f46cb3644ced997573c7">&#9670;&nbsp;</a></span>spdk_memory_domain_memzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_memory_domain_memzero </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>domain_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dma_8h.html#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a>&#160;</td>
          <td class="paramname"><em>cpl_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cpl_cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills memory in <b>domain</b> with zeroes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain in which address space data buffer is located </td></tr>
    <tr><td class="paramname">domain_ctx</td><td>User defined context </td></tr>
    <tr><td class="paramname">iov</td><td>iov in <b>domain</b> memory space to be filled with zeroes </td></tr>
    <tr><td class="paramname">iovcnt</td><td><b>iov</b> array size </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>Completion callback </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Completion callback argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure. memzero implementation must only call the callback when 0 is returned </dd></dl>

</div>
</div>
<a id="ab766b91733e0939cdea6d13e77572d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab766b91733e0939cdea6d13e77572d40">&#9670;&nbsp;</a></span>spdk_memory_domain_pull_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_memory_domain_pull_data </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *&#160;</td>
          <td class="paramname"><em>src_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src_domain_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>src_iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>src_iov_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>dst_iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dst_iov_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dma_8h.html#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a>&#160;</td>
          <td class="paramname"><em>cpl_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cpl_cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously pull data which is described by <b>src_domain</b> and located in <b>src_iov</b> to a location <b>dst_iov</b> local memory space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_domain</td><td>Memory domain in which space data buffer is located </td></tr>
    <tr><td class="paramname">src_domain_ctx</td><td>User defined context </td></tr>
    <tr><td class="paramname">src_iov</td><td>Source data iov </td></tr>
    <tr><td class="paramname">src_iov_cnt</td><td>The number of elements in <b>src_iov</b> </td></tr>
    <tr><td class="paramname">dst_iov</td><td>Destination iov </td></tr>
    <tr><td class="paramname">dst_iov_cnt</td><td>The number of elements in <b>dst_iov</b> </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>Completion callback </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Completion callback argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure. pull_cb implementation must only call the callback when 0 is returned </dd></dl>

</div>
</div>
<a id="a9e494849a34eeab88b96f44e79862eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e494849a34eeab88b96f44e79862eb8">&#9670;&nbsp;</a></span>spdk_memory_domain_push_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_memory_domain_push_data </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *&#160;</td>
          <td class="paramname"><em>dst_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst_domain_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>dst_iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dst_iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>src_iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>src_iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dma_8h.html#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a>&#160;</td>
          <td class="paramname"><em>cpl_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cpl_cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously push data located in local memory to <b>dst_domain</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_domain</td><td>Memory domain to which the data should be pushed </td></tr>
    <tr><td class="paramname">dst_domain_ctx</td><td>Optional context passed by upper layer with IO request </td></tr>
    <tr><td class="paramname">dst_iov</td><td>Iov vector in dst_domain space </td></tr>
    <tr><td class="paramname">dst_iovcnt</td><td>dst_iov array size </td></tr>
    <tr><td class="paramname">src_iov</td><td>Iov vector in local memory </td></tr>
    <tr><td class="paramname">src_iovcnt</td><td>src_iov array size </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>Completion callback </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Completion callback argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure. push_cb implementation must only call the callback when 0 is returned </dd></dl>

</div>
</div>
<a id="abafa95a5bedcc6c320d09a2ccbbeedfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafa95a5bedcc6c320d09a2ccbbeedfc">&#9670;&nbsp;</a></span>spdk_memory_domain_set_memzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memory_domain_set_memzero </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dma_8h.html#a22484d6db47a04c8a41a84e67cdb4613">spdk_memory_domain_memzero_cb</a>&#160;</td>
          <td class="paramname"><em>memzero_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set memzero function for memory domain. </p>
<p>Overwrites existing memzero function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
    <tr><td class="paramname">memzero_cb</td><td>memzero function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c443f5b67500578f056e9fe9039bf76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c443f5b67500578f056e9fe9039bf76">&#9670;&nbsp;</a></span>spdk_memory_domain_set_pull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memory_domain_set_pull </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dma_8h.html#abf5cd879a09a8f23a30b45e94574e893">spdk_memory_domain_pull_data_cb</a>&#160;</td>
          <td class="paramname"><em>pull_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set pull function for memory domain. </p>
<p>Overwrites existing pull function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
    <tr><td class="paramname">pull_cb</td><td>pull function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87db0ff92404fc6cb110e8fa98cce0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87db0ff92404fc6cb110e8fa98cce0dd">&#9670;&nbsp;</a></span>spdk_memory_domain_set_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memory_domain_set_push </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dma_8h.html#a2f4b39300fc63eb3fe95530ca4c87305">spdk_memory_domain_push_data_cb</a>&#160;</td>
          <td class="paramname"><em>push_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set push function for memory domain. </p>
<p>Overwrites existing push function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
    <tr><td class="paramname">push_cb</td><td>push function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4777ac664899af134eaa6c93de05d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4777ac664899af134eaa6c93de05d6d">&#9670;&nbsp;</a></span>spdk_memory_domain_set_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memory_domain_set_translation </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dma_8h.html#a80080465d2736a76d0ddf95d67c701bb">spdk_memory_domain_translate_memory_cb</a>&#160;</td>
          <td class="paramname"><em>translate_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set translation function for memory domain. </p>
<p>Overwrites existing translation function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
    <tr><td class="paramname">translate_cb</td><td>Translation function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05ad1c0fc1a4fa74ede9b48181e044b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ad1c0fc1a4fa74ede9b48181e044b1">&#9670;&nbsp;</a></span>spdk_memory_domain_translate_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_memory_domain_translate_data </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *&#160;</td>
          <td class="paramname"><em>src_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src_domain_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_memory_domain *&#160;</td>
          <td class="paramname"><em>dst_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__memory__domain__translation__ctx.html">spdk_memory_domain_translation_ctx</a> *&#160;</td>
          <td class="paramname"><em>dst_domain_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__memory__domain__translation__result.html">spdk_memory_domain_translation_result</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate data located in <b>src_domain</b> space at address <b>addr</b> with size <b>len</b> into an equivalent description of memory in dst_domain. </p>
<p>This function calls <b>src_domain</b> translation callback, the callback needs to be set using <a class="el" href="dma_8h.html#ab4777ac664899af134eaa6c93de05d6d">spdk_memory_domain_set_translation</a> function. No data is moved during this operation. Both src_domain and dst_domain must describe the same physical memory, just from the point of view of two different memory domain. This is a translation of the description of the memory only. Result of translation is stored in <b>result</b>, its content depends on the type of <b>dst_domain</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_domain</td><td>Memory domain in which address space data buffer is located </td></tr>
    <tr><td class="paramname">src_domain_ctx</td><td>User defined context </td></tr>
    <tr><td class="paramname">dst_domain</td><td>Memory domain in which memory space data buffer should be translated </td></tr>
    <tr><td class="paramname">dst_domain_ctx</td><td>Ancillary data for dst_domain </td></tr>
    <tr><td class="paramname">addr</td><td>Address in <b>src_domain</b> memory space </td></tr>
    <tr><td class="paramname">len</td><td>Length of the data </td></tr>
    <tr><td class="paramname">result</td><td>Translation result. The content of the translation result is only valid if this function returns 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.1 </li>
</ul>
</div>
</div>
</body>
</html>
