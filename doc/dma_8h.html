<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Doxygen 1.10.0" />
	<title>SPDK: dma.h File Reference</title>
	<script src="https://code.jquery.com/jquery-3.7.1.slim.min.js" integrity="sha256-kmHvs0B+OpCW5GVHUNjv9rOmY0IvSIRcf7zGUDTDQM8=" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.11.8/umd/popper.min.js" integrity="sha512-TPh2Oxlg1zp+kz3nFA0C5vVC6leG/6mm1z9+mA81MI5eaUVqasPLO8Cuk4gMF4gUfP5etR73rgU/8PNMsSesoQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js" integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+" crossorigin="anonymous"></script>
	<script type="text/javascript" src="../js/doxyboot.js"></script>
	<script type="text/javascript">
		$( document ).ready(function() {
			$("#cn_lang_btn").remove();
		});
	</script>
	<script type="text/javascript" src="./navtree.js"></script>
	<link rel="stylesheet" href='https://fonts.googleapis.com/css?family=Roboto:400,900' type='text/css'>
	<link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
	<link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
  <body>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <a class="navbar-brand" href="/" aria-label="SPDK">
    <img src="../img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
  </a>
  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <div class="navbar-nav me-auto">
      <a class="nav-link header-link"
      href="../releases/">
        download
      </a>
      <a class="nav-link header-link active text-white"
      href="/doc/">
        documentation
      </a>
      <a class="nav-link header-link"
      href="../development/">
        development
      </a>
      <a class="nav-link header-link"
      href="/ci/">
        CI status
      </a>
      <a class="nav-link header-link"
      href="../community/">
        community
      </a>
      <a class="nav-link header-link"
      href="../blog/">
        Blog
      </a>
      <a class="nav-link header-link"
      href="https://github.com/orgs/spdk/projects/5">
        Roadmap
      </a>
      <a class="nav-link header-link"
      href="../news/">
        News
      </a>
    </div>
    <div class="navbar-nav ms-auto me-3">
      <a class="nav-link header-link" href="https://github.com/spdk/spdk">
        <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
      </a>
      <a id="cn_lang_btn" href="/cn/doc/" class="nav-link header-link">中文</a>
    </div>
  </div>
</nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dma_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">dma.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>SPDK DMA device framework.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__memory__domain__translation__result.html">spdk_memory_domain_translation_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__memory__domain__translation__ctx.html">spdk_memory_domain_translation_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__memory__domain__rdma__ctx.html">spdk_memory_domain_rdma_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context of memory domain of RDMA type.  <a href="structspdk__memory__domain__rdma__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__memory__domain__ctx.html">spdk_memory_domain_ctx</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6d96f9e4e12eef5b83a1e85c0643edef" id="r_a6d96f9e4e12eef5b83a1e85c0643edef"><td class="memItemLeft" align="right" valign="top"><a id="a6d96f9e4e12eef5b83a1e85c0643edef" name="a6d96f9e4e12eef5b83a1e85c0643edef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_RDMA_DMA_DEVICE</b>&#160;&#160;&#160;&quot;SPDK_RDMA_DMA_DEVICE&quot;</td></tr>
<tr class="memdesc:a6d96f9e4e12eef5b83a1e85c0643edef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier of SPDK internal DMA device of RDMA type. <br /></td></tr>
<tr class="separator:a6d96f9e4e12eef5b83a1e85c0643edef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8d7a0eee8d944cf100d3006b3f3f1774" id="r_a8d7a0eee8d944cf100d3006b3f3f1774"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a>) (void *ctx, int rc)</td></tr>
<tr class="memdesc:a8d7a0eee8d944cf100d3006b3f3f1774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of completion callback to be called by pull, push or memzero functions.  <br /></td></tr>
<tr class="separator:a8d7a0eee8d944cf100d3006b3f3f1774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5cd879a09a8f23a30b45e94574e893" id="r_abf5cd879a09a8f23a30b45e94574e893"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf5cd879a09a8f23a30b45e94574e893">spdk_memory_domain_pull_data_cb</a>) (struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct iovec *src_iov, uint32_t src_iovcnt, struct iovec *dst_iov, uint32_t dst_iovcnt, <a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:abf5cd879a09a8f23a30b45e94574e893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of function which asynchronously pulles data from src_domain to local memory domain.  <br /></td></tr>
<tr class="separator:abf5cd879a09a8f23a30b45e94574e893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4b39300fc63eb3fe95530ca4c87305" id="r_a2f4b39300fc63eb3fe95530ca4c87305"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f4b39300fc63eb3fe95530ca4c87305">spdk_memory_domain_push_data_cb</a>) (struct spdk_memory_domain *dst_domain, void *dst_domain_ctx, struct iovec *dst_iov, uint32_t dst_iovcnt, struct iovec *src_iov, uint32_t src_iovcnt, <a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:a2f4b39300fc63eb3fe95530ca4c87305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of function which asynchronously pushes data from local memory to destination memory domain.  <br /></td></tr>
<tr class="separator:a2f4b39300fc63eb3fe95530ca4c87305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22484d6db47a04c8a41a84e67cdb4613" id="r_a22484d6db47a04c8a41a84e67cdb4613"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22484d6db47a04c8a41a84e67cdb4613">spdk_memory_domain_memzero_cb</a>) (struct spdk_memory_domain *domain, void *domain_ctx, struct iovec *iov, uint32_t iovcnt, <a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:a22484d6db47a04c8a41a84e67cdb4613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of function which asynchronously fills memory in <b>domain</b> with zeroes.  <br /></td></tr>
<tr class="separator:a22484d6db47a04c8a41a84e67cdb4613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b08a0983057edbc19cb1dd6bdea2de" id="r_a01b08a0983057edbc19cb1dd6bdea2de"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01b08a0983057edbc19cb1dd6bdea2de">spdk_memory_domain_transfer_data_cb</a>) (struct spdk_memory_domain *dst_domain, void *dst_domain_ctx, struct iovec *dst_iov, uint32_t dst_iovcnt, struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct iovec *src_iov, uint32_t src_iovcnt, struct <a class="el" href="structspdk__memory__domain__translation__result.html">spdk_memory_domain_translation_result</a> *src_translation, <a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:a01b08a0983057edbc19cb1dd6bdea2de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of function which starts asynchronous operation to transfer data from the source to destination memory domains.  <br /></td></tr>
<tr class="separator:a01b08a0983057edbc19cb1dd6bdea2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80080465d2736a76d0ddf95d67c701bb" id="r_a80080465d2736a76d0ddf95d67c701bb"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80080465d2736a76d0ddf95d67c701bb">spdk_memory_domain_translate_memory_cb</a>) (struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct spdk_memory_domain *dst_domain, struct <a class="el" href="structspdk__memory__domain__translation__ctx.html">spdk_memory_domain_translation_ctx</a> *dst_domain_ctx, void *addr, size_t len, struct <a class="el" href="structspdk__memory__domain__translation__result.html">spdk_memory_domain_translation_result</a> *result)</td></tr>
<tr class="memdesc:a80080465d2736a76d0ddf95d67c701bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of function which translates data from src_domain to a form accessible by dst_domain.  <br /></td></tr>
<tr class="separator:a80080465d2736a76d0ddf95d67c701bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9437c10aecf1f03c8137b870a83dac17" id="r_a9437c10aecf1f03c8137b870a83dac17"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9437c10aecf1f03c8137b870a83dac17">spdk_memory_domain_invalidate_data_cb</a>) (struct spdk_memory_domain *domain, void *domain_ctx, struct iovec *iov, uint32_t iovcnt)</td></tr>
<tr class="memdesc:a9437c10aecf1f03c8137b870a83dac17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of function which invalidates the data range in the given domain.  <br /></td></tr>
<tr class="separator:a9437c10aecf1f03c8137b870a83dac17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a85588b3a6ec5c188ab2dc318c3903586" id="r_a85588b3a6ec5c188ab2dc318c3903586"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85588b3a6ec5c188ab2dc318c3903586">spdk_dma_device_type</a> { <br />
&#160;&#160;<a class="el" href="#a85588b3a6ec5c188ab2dc318c3903586a00353a6b099210ed1c52cb9582f1ae01">SPDK_DMA_DEVICE_TYPE_RDMA</a>
, <a class="el" href="#a85588b3a6ec5c188ab2dc318c3903586ae488329b2d5cebe0bc130e0803c4fefc">SPDK_DMA_DEVICE_TYPE_DMA</a>
, <a class="el" href="#a85588b3a6ec5c188ab2dc318c3903586a065a87ed31fe120b25d6811ce9b37ba8">SPDK_DMA_DEVICE_TYPE_ACCEL</a>
, <a class="el" href="#a85588b3a6ec5c188ab2dc318c3903586a1201e15e1a81553cb3ac297e7f5648be">SPDK_DMA_DEVICE_VENDOR_SPECIFIC_TYPE_START</a> = 1000
, <br />
&#160;&#160;<a class="el" href="#a85588b3a6ec5c188ab2dc318c3903586a51d3c59fcd56fc712b1943b5a08dead2">SPDK_DMA_DEVICE_VENDOR_SPECIFIC_TYPE_END</a> = SPDK_DMA_DEVICE_VENDOR_SPECIFIC_TYPE_START + 999
<br />
 }</td></tr>
<tr class="separator:a85588b3a6ec5c188ab2dc318c3903586"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6ddda62cbca17c587a2c6d201b4e6dff" id="r_a6ddda62cbca17c587a2c6d201b4e6dff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ddda62cbca17c587a2c6d201b4e6dff">spdk_memory_domain_create</a> (struct spdk_memory_domain **domain, enum <a class="el" href="#a85588b3a6ec5c188ab2dc318c3903586">spdk_dma_device_type</a> type, struct <a class="el" href="structspdk__memory__domain__ctx.html">spdk_memory_domain_ctx</a> *ctx, const char *id)</td></tr>
<tr class="memdesc:a6ddda62cbca17c587a2c6d201b4e6dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new memory domain of the specified type.  <br /></td></tr>
<tr class="separator:a6ddda62cbca17c587a2c6d201b4e6dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4777ac664899af134eaa6c93de05d6d" id="r_ab4777ac664899af134eaa6c93de05d6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4777ac664899af134eaa6c93de05d6d">spdk_memory_domain_set_translation</a> (struct spdk_memory_domain *domain, <a class="el" href="#a80080465d2736a76d0ddf95d67c701bb">spdk_memory_domain_translate_memory_cb</a> translate_cb)</td></tr>
<tr class="memdesc:ab4777ac664899af134eaa6c93de05d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set translation function for memory domain.  <br /></td></tr>
<tr class="separator:ab4777ac664899af134eaa6c93de05d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a73817c22cc0ffd8000480576795cbf" id="r_a1a73817c22cc0ffd8000480576795cbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a73817c22cc0ffd8000480576795cbf">spdk_memory_domain_set_invalidate</a> (struct spdk_memory_domain *domain, <a class="el" href="#a9437c10aecf1f03c8137b870a83dac17">spdk_memory_domain_invalidate_data_cb</a> invalidate_cb)</td></tr>
<tr class="memdesc:a1a73817c22cc0ffd8000480576795cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set invalidate function for memory domain.  <br /></td></tr>
<tr class="separator:a1a73817c22cc0ffd8000480576795cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c443f5b67500578f056e9fe9039bf76" id="r_a6c443f5b67500578f056e9fe9039bf76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c443f5b67500578f056e9fe9039bf76">spdk_memory_domain_set_pull</a> (struct spdk_memory_domain *domain, <a class="el" href="#abf5cd879a09a8f23a30b45e94574e893">spdk_memory_domain_pull_data_cb</a> pull_cb)</td></tr>
<tr class="memdesc:a6c443f5b67500578f056e9fe9039bf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pull function for memory domain.  <br /></td></tr>
<tr class="separator:a6c443f5b67500578f056e9fe9039bf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87db0ff92404fc6cb110e8fa98cce0dd" id="r_a87db0ff92404fc6cb110e8fa98cce0dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87db0ff92404fc6cb110e8fa98cce0dd">spdk_memory_domain_set_push</a> (struct spdk_memory_domain *domain, <a class="el" href="#a2f4b39300fc63eb3fe95530ca4c87305">spdk_memory_domain_push_data_cb</a> push_cb)</td></tr>
<tr class="memdesc:a87db0ff92404fc6cb110e8fa98cce0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set push function for memory domain.  <br /></td></tr>
<tr class="separator:a87db0ff92404fc6cb110e8fa98cce0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0b55d4e43516904d453242ca04fd24" id="r_a2d0b55d4e43516904d453242ca04fd24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d0b55d4e43516904d453242ca04fd24">spdk_memory_domain_set_data_transfer</a> (struct spdk_memory_domain *domain, <a class="el" href="#a01b08a0983057edbc19cb1dd6bdea2de">spdk_memory_domain_transfer_data_cb</a> transfer_cb)</td></tr>
<tr class="memdesc:a2d0b55d4e43516904d453242ca04fd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data transfer for memory domain.  <br /></td></tr>
<tr class="separator:a2d0b55d4e43516904d453242ca04fd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafa95a5bedcc6c320d09a2ccbbeedfc" id="r_abafa95a5bedcc6c320d09a2ccbbeedfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abafa95a5bedcc6c320d09a2ccbbeedfc">spdk_memory_domain_set_memzero</a> (struct spdk_memory_domain *domain, <a class="el" href="#a22484d6db47a04c8a41a84e67cdb4613">spdk_memory_domain_memzero_cb</a> memzero_cb)</td></tr>
<tr class="memdesc:abafa95a5bedcc6c320d09a2ccbbeedfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set memzero function for memory domain.  <br /></td></tr>
<tr class="separator:abafa95a5bedcc6c320d09a2ccbbeedfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76ad75ffcdb2c3344872367eb113067" id="r_ab76ad75ffcdb2c3344872367eb113067"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__memory__domain__ctx.html">spdk_memory_domain_ctx</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab76ad75ffcdb2c3344872367eb113067">spdk_memory_domain_get_context</a> (struct spdk_memory_domain *domain)</td></tr>
<tr class="memdesc:ab76ad75ffcdb2c3344872367eb113067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context passed by the user in <a class="el" href="#a6ddda62cbca17c587a2c6d201b4e6dff">spdk_memory_domain_create</a>.  <br /></td></tr>
<tr class="separator:ab76ad75ffcdb2c3344872367eb113067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfac8979ac6f0bb0aef7833db95ee29a" id="r_adfac8979ac6f0bb0aef7833db95ee29a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfac8979ac6f0bb0aef7833db95ee29a">spdk_memory_domain_get_user_context</a> (struct spdk_memory_domain *domain, size_t *ctx_size)</td></tr>
<tr class="memdesc:adfac8979ac6f0bb0aef7833db95ee29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an opaque pointer to the user context and its size.  <br /></td></tr>
<tr class="separator:adfac8979ac6f0bb0aef7833db95ee29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2dd7b82d1f0afe434c0ca92fce6fc66" id="r_aa2dd7b82d1f0afe434c0ca92fce6fc66"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="#a85588b3a6ec5c188ab2dc318c3903586">spdk_dma_device_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2dd7b82d1f0afe434c0ca92fce6fc66">spdk_memory_domain_get_dma_device_type</a> (struct spdk_memory_domain *domain)</td></tr>
<tr class="memdesc:aa2dd7b82d1f0afe434c0ca92fce6fc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get type of the DMA device that can access this memory domain.  <br /></td></tr>
<tr class="separator:aa2dd7b82d1f0afe434c0ca92fce6fc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b745bd27f31212b5ffd9027165cb773" id="r_a3b745bd27f31212b5ffd9027165cb773"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b745bd27f31212b5ffd9027165cb773">spdk_memory_domain_get_dma_device_id</a> (struct spdk_memory_domain *domain)</td></tr>
<tr class="memdesc:a3b745bd27f31212b5ffd9027165cb773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an identifier representing the DMA device that can access this memory domain.  <br /></td></tr>
<tr class="separator:a3b745bd27f31212b5ffd9027165cb773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad908aa65943565af3128e340c8c5e285" id="r_ad908aa65943565af3128e340c8c5e285"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad908aa65943565af3128e340c8c5e285">spdk_memory_domain_destroy</a> (struct spdk_memory_domain *domain)</td></tr>
<tr class="memdesc:ad908aa65943565af3128e340c8c5e285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy memory domain.  <br /></td></tr>
<tr class="separator:ad908aa65943565af3128e340c8c5e285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab766b91733e0939cdea6d13e77572d40" id="r_ab766b91733e0939cdea6d13e77572d40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab766b91733e0939cdea6d13e77572d40">spdk_memory_domain_pull_data</a> (struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct iovec *src_iov, uint32_t src_iov_cnt, struct iovec *dst_iov, uint32_t dst_iov_cnt, <a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:ab766b91733e0939cdea6d13e77572d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously pull data which is described by <b>src_domain</b> and located in <b>src_iov</b> to a location <b>dst_iov</b> local memory space.  <br /></td></tr>
<tr class="separator:ab766b91733e0939cdea6d13e77572d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e494849a34eeab88b96f44e79862eb8" id="r_a9e494849a34eeab88b96f44e79862eb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e494849a34eeab88b96f44e79862eb8">spdk_memory_domain_push_data</a> (struct spdk_memory_domain *dst_domain, void *dst_domain_ctx, struct iovec *dst_iov, uint32_t dst_iovcnt, struct iovec *src_iov, uint32_t src_iovcnt, <a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:a9e494849a34eeab88b96f44e79862eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously push data located in local memory to <b>dst_domain</b>.  <br /></td></tr>
<tr class="separator:a9e494849a34eeab88b96f44e79862eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193ea6d6c72cb91f81e66cc5f0f9130e" id="r_a193ea6d6c72cb91f81e66cc5f0f9130e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a193ea6d6c72cb91f81e66cc5f0f9130e">spdk_memory_domain_transfer_data</a> (struct spdk_memory_domain *dst_domain, void *dst_domain_ctx, struct iovec *dst_iov, uint32_t dst_iovcnt, struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct iovec *src_iov, uint32_t src_iovcnt, struct <a class="el" href="structspdk__memory__domain__translation__result.html">spdk_memory_domain_translation_result</a> *src_translation, <a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:a193ea6d6c72cb91f81e66cc5f0f9130e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously transfer data from the source memory domain to the destination memory domain.  <br /></td></tr>
<tr class="separator:a193ea6d6c72cb91f81e66cc5f0f9130e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ad1c0fc1a4fa74ede9b48181e044b1" id="r_a05ad1c0fc1a4fa74ede9b48181e044b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05ad1c0fc1a4fa74ede9b48181e044b1">spdk_memory_domain_translate_data</a> (struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct spdk_memory_domain *dst_domain, struct <a class="el" href="structspdk__memory__domain__translation__ctx.html">spdk_memory_domain_translation_ctx</a> *dst_domain_ctx, void *addr, size_t len, struct <a class="el" href="structspdk__memory__domain__translation__result.html">spdk_memory_domain_translation_result</a> *result)</td></tr>
<tr class="memdesc:a05ad1c0fc1a4fa74ede9b48181e044b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate data located in <b>src_domain</b> space at address <b>addr</b> with size <b>len</b> into an equivalent description of memory in dst_domain.  <br /></td></tr>
<tr class="separator:a05ad1c0fc1a4fa74ede9b48181e044b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d423f61ff7a187effcb7564f8eb18e" id="r_a98d423f61ff7a187effcb7564f8eb18e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98d423f61ff7a187effcb7564f8eb18e">spdk_memory_domain_invalidate_data</a> (struct spdk_memory_domain *domain, void *domain_ctx, struct iovec *iov, uint32_t iovcnt)</td></tr>
<tr class="memdesc:a98d423f61ff7a187effcb7564f8eb18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate memory in the given domain.  <br /></td></tr>
<tr class="separator:a98d423f61ff7a187effcb7564f8eb18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e0567f3920f46cb3644ced997573c7" id="r_ae4e0567f3920f46cb3644ced997573c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4e0567f3920f46cb3644ced997573c7">spdk_memory_domain_memzero</a> (struct spdk_memory_domain *domain, void *domain_ctx, struct iovec *iov, uint32_t iovcnt, <a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:ae4e0567f3920f46cb3644ced997573c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills memory in <b>domain</b> with zeroes.  <br /></td></tr>
<tr class="separator:ae4e0567f3920f46cb3644ced997573c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff9796de86f6c6e7fbd60684b2f525b" id="r_a1ff9796de86f6c6e7fbd60684b2f525b"><td class="memItemLeft" align="right" valign="top">struct spdk_memory_domain *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ff9796de86f6c6e7fbd60684b2f525b">spdk_memory_domain_get_first</a> (const char *id)</td></tr>
<tr class="memdesc:a1ff9796de86f6c6e7fbd60684b2f525b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first memory domain.  <br /></td></tr>
<tr class="separator:a1ff9796de86f6c6e7fbd60684b2f525b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63b08f5e78f0c9c700978a7c005d17e" id="r_ae63b08f5e78f0c9c700978a7c005d17e"><td class="memItemLeft" align="right" valign="top">struct spdk_memory_domain *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae63b08f5e78f0c9c700978a7c005d17e">spdk_memory_domain_get_next</a> (struct spdk_memory_domain *prev, const char *id)</td></tr>
<tr class="memdesc:ae63b08f5e78f0c9c700978a7c005d17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next memory domain.  <br /></td></tr>
<tr class="separator:ae63b08f5e78f0c9c700978a7c005d17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdfcd0ae17fc9e62d759ee03b842df8" id="r_a3bdfcd0ae17fc9e62d759ee03b842df8"><td class="memItemLeft" align="right" valign="top">struct spdk_memory_domain *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bdfcd0ae17fc9e62d759ee03b842df8">spdk_memory_domain_get_system_domain</a> (void)</td></tr>
<tr class="memdesc:a3bdfcd0ae17fc9e62d759ee03b842df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the System memory domain.  <br /></td></tr>
<tr class="separator:a3bdfcd0ae17fc9e62d759ee03b842df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SPDK DMA device framework. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a8d7a0eee8d944cf100d3006b3f3f1774" name="a8d7a0eee8d944cf100d3006b3f3f1774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7a0eee8d944cf100d3006b3f3f1774">&#9670;&#160;</a></span>spdk_memory_domain_data_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_memory_domain_data_cpl_cb) (void *ctx, int rc)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of completion callback to be called by pull, push or memzero functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>User context passed to pull of push functions </td></tr>
    <tr><td class="paramname">rc</td><td>Result of asynchronous data pull or push function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9437c10aecf1f03c8137b870a83dac17" name="a9437c10aecf1f03c8137b870a83dac17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9437c10aecf1f03c8137b870a83dac17">&#9670;&#160;</a></span>spdk_memory_domain_invalidate_data_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_memory_domain_invalidate_data_cb) (struct spdk_memory_domain *domain, void *domain_ctx, struct iovec *iov, uint32_t iovcnt)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of function which invalidates the data range in the given domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain to which the data buffer belongs </td></tr>
    <tr><td class="paramname">domain_ctx</td><td>Optional context passed by upper layer </td></tr>
    <tr><td class="paramname">iov</td><td>Iov array in <b>domain</b> memory space to be invalidated </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Iov array size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22484d6db47a04c8a41a84e67cdb4613" name="a22484d6db47a04c8a41a84e67cdb4613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22484d6db47a04c8a41a84e67cdb4613">&#9670;&#160;</a></span>spdk_memory_domain_memzero_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_memory_domain_memzero_cb) (struct spdk_memory_domain *domain, void *domain_ctx, struct iovec *iov, uint32_t iovcnt, <a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of function which asynchronously fills memory in <b>domain</b> with zeroes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain in which address space data buffer is located </td></tr>
    <tr><td class="paramname">domain_ctx</td><td>User defined context </td></tr>
    <tr><td class="paramname">iov</td><td>iov in <b>domain</b> memory space to be filled with zeroes </td></tr>
    <tr><td class="paramname">iovcnt</td><td><b>iov</b> array size </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>Completion callback </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Completion callback argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure </dd></dl>

</div>
</div>
<a id="abf5cd879a09a8f23a30b45e94574e893" name="abf5cd879a09a8f23a30b45e94574e893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5cd879a09a8f23a30b45e94574e893">&#9670;&#160;</a></span>spdk_memory_domain_pull_data_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_memory_domain_pull_data_cb) (struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct iovec *src_iov, uint32_t src_iovcnt, struct iovec *dst_iov, uint32_t dst_iovcnt, <a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of function which asynchronously pulles data from src_domain to local memory domain. </p>
<p>Implementation of this function must call <b>cpl_cb</b> only when it returns 0. All other return codes mean failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_domain</td><td>Memory domain to which the data buffer belongs </td></tr>
    <tr><td class="paramname">src_domain_ctx</td><td>Optional context passed by upper layer with IO request </td></tr>
    <tr><td class="paramname">src_iov</td><td>Iov vector in <b>src_domain</b> space </td></tr>
    <tr><td class="paramname">src_iovcnt</td><td>src_iov array size </td></tr>
    <tr><td class="paramname">dst_iov</td><td>Iov vector in local memory domain space, data buffers must be allocated by the caller of this function, total size of data buffers must not be less than the size of data in <b>src_iov</b>. </td></tr>
    <tr><td class="paramname">dst_iovcnt</td><td>dst_iov array size </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>A callback to be called when pull operation completes </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Optional argument to be passed to <b>cpl_cb</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure </dd></dl>

</div>
</div>
<a id="a2f4b39300fc63eb3fe95530ca4c87305" name="a2f4b39300fc63eb3fe95530ca4c87305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4b39300fc63eb3fe95530ca4c87305">&#9670;&#160;</a></span>spdk_memory_domain_push_data_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_memory_domain_push_data_cb) (struct spdk_memory_domain *dst_domain, void *dst_domain_ctx, struct iovec *dst_iov, uint32_t dst_iovcnt, struct iovec *src_iov, uint32_t src_iovcnt, <a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of function which asynchronously pushes data from local memory to destination memory domain. </p>
<p>Implementation of this function must call <b>cpl_cb</b> only when it returns 0. All other return codes mean failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_domain</td><td>Memory domain to which the data should be pushed </td></tr>
    <tr><td class="paramname">dst_domain_ctx</td><td>Optional context passed by upper layer with IO request </td></tr>
    <tr><td class="paramname">dst_iov</td><td>Iov vector in dst_domain space </td></tr>
    <tr><td class="paramname">dst_iovcnt</td><td>dst_iov array size </td></tr>
    <tr><td class="paramname">src_iov</td><td>Iov vector in local memory </td></tr>
    <tr><td class="paramname">src_iovcnt</td><td>src_iov array size </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>A callback to be called when push operation completes </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Optional argument to be passed to <b>cpl_cb</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure </dd></dl>

</div>
</div>
<a id="a01b08a0983057edbc19cb1dd6bdea2de" name="a01b08a0983057edbc19cb1dd6bdea2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b08a0983057edbc19cb1dd6bdea2de">&#9670;&#160;</a></span>spdk_memory_domain_transfer_data_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_memory_domain_transfer_data_cb) (struct spdk_memory_domain *dst_domain, void *dst_domain_ctx, struct iovec *dst_iov, uint32_t dst_iovcnt, struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct iovec *src_iov, uint32_t src_iovcnt, struct <a class="el" href="structspdk__memory__domain__translation__result.html">spdk_memory_domain_translation_result</a> *src_translation, <a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a> cpl_cb, void *cpl_cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of function which starts asynchronous operation to transfer data from the source to destination memory domains. </p>
<p>Implementation of this function must call <b>cpl_cb</b> only when it returns 0. All other return codes mean failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_domain</td><td>Memory domain to which the data should be transferred </td></tr>
    <tr><td class="paramname">dst_domain_ctx</td><td>Optional context passed by upper layer with IO request </td></tr>
    <tr><td class="paramname">dst_iov</td><td>Iov vector in dst_domain space </td></tr>
    <tr><td class="paramname">dst_iovcnt</td><td>dst_iov array size </td></tr>
    <tr><td class="paramname">src_domain</td><td>Memory domain from which the data should be transferred </td></tr>
    <tr><td class="paramname">src_domain_ctx</td><td>Optional context passed by the caller </td></tr>
    <tr><td class="paramname">src_iov</td><td>Iov vector in local memory </td></tr>
    <tr><td class="paramname">src_iovcnt</td><td>src_iov array size </td></tr>
    <tr><td class="paramname">src_translation</td><td>Optional memory translation from the source to the destination memory domain </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>A callback to be called when push operation completes </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Optional argument to be passed to <b>cpl_cb</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure </dd></dl>

</div>
</div>
<a id="a80080465d2736a76d0ddf95d67c701bb" name="a80080465d2736a76d0ddf95d67c701bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80080465d2736a76d0ddf95d67c701bb">&#9670;&#160;</a></span>spdk_memory_domain_translate_memory_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_memory_domain_translate_memory_cb) (struct spdk_memory_domain *src_domain, void *src_domain_ctx, struct spdk_memory_domain *dst_domain, struct <a class="el" href="structspdk__memory__domain__translation__ctx.html">spdk_memory_domain_translation_ctx</a> *dst_domain_ctx, void *addr, size_t len, struct <a class="el" href="structspdk__memory__domain__translation__result.html">spdk_memory_domain_translation_result</a> *result)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of function which translates data from src_domain to a form accessible by dst_domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_domain</td><td>Memory domain to which the data buffer belongs </td></tr>
    <tr><td class="paramname">src_domain_ctx</td><td>Optional context passed by upper layer with IO request </td></tr>
    <tr><td class="paramname">dst_domain</td><td>Memory domain which determines type of translation function </td></tr>
    <tr><td class="paramname">dst_domain_ctx</td><td>Ancillary data for dst_domain </td></tr>
    <tr><td class="paramname">addr</td><td>Data buffer address in <b>src_domain</b> memory space which should be translated into <b>dst_domain</b> </td></tr>
    <tr><td class="paramname">len</td><td>Length of data buffer </td></tr>
    <tr><td class="paramname">result</td><td>Result of translation function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a85588b3a6ec5c188ab2dc318c3903586" name="a85588b3a6ec5c188ab2dc318c3903586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85588b3a6ec5c188ab2dc318c3903586">&#9670;&#160;</a></span>spdk_dma_device_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a85588b3a6ec5c188ab2dc318c3903586">spdk_dma_device_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85588b3a6ec5c188ab2dc318c3903586a00353a6b099210ed1c52cb9582f1ae01" name="a85588b3a6ec5c188ab2dc318c3903586a00353a6b099210ed1c52cb9582f1ae01"></a>SPDK_DMA_DEVICE_TYPE_RDMA&#160;</td><td class="fielddoc"><p>RDMA devices are capable of performing DMA operations on memory domains using the standard RDMA model (protection domain, remote key, address). </p>
</td></tr>
<tr><td class="fieldname"><a id="a85588b3a6ec5c188ab2dc318c3903586ae488329b2d5cebe0bc130e0803c4fefc" name="a85588b3a6ec5c188ab2dc318c3903586ae488329b2d5cebe0bc130e0803c4fefc"></a>SPDK_DMA_DEVICE_TYPE_DMA&#160;</td><td class="fielddoc"><p>DMA devices are capable of performing DMA operations on memory domains using physical or I/O virtual addresses. </p>
</td></tr>
<tr><td class="fieldname"><a id="a85588b3a6ec5c188ab2dc318c3903586a065a87ed31fe120b25d6811ce9b37ba8" name="a85588b3a6ec5c188ab2dc318c3903586a065a87ed31fe120b25d6811ce9b37ba8"></a>SPDK_DMA_DEVICE_TYPE_ACCEL&#160;</td><td class="fielddoc"><p>Virtual memory domain representing memory being transformed by accel framework. </p>
</td></tr>
<tr><td class="fieldname"><a id="a85588b3a6ec5c188ab2dc318c3903586a1201e15e1a81553cb3ac297e7f5648be" name="a85588b3a6ec5c188ab2dc318c3903586a1201e15e1a81553cb3ac297e7f5648be"></a>SPDK_DMA_DEVICE_VENDOR_SPECIFIC_TYPE_START&#160;</td><td class="fielddoc"><p>Start of the range of vendor-specific DMA device types. </p>
</td></tr>
<tr><td class="fieldname"><a id="a85588b3a6ec5c188ab2dc318c3903586a51d3c59fcd56fc712b1943b5a08dead2" name="a85588b3a6ec5c188ab2dc318c3903586a51d3c59fcd56fc712b1943b5a08dead2"></a>SPDK_DMA_DEVICE_VENDOR_SPECIFIC_TYPE_END&#160;</td><td class="fielddoc"><p>End of the range of vendor-specific DMA device types. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6ddda62cbca17c587a2c6d201b4e6dff" name="a6ddda62cbca17c587a2c6d201b4e6dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddda62cbca17c587a2c6d201b4e6dff">&#9670;&#160;</a></span>spdk_memory_domain_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_memory_domain_create </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain **</td>          <td class="paramname"><span class="paramname"><em>domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#a85588b3a6ec5c188ab2dc318c3903586">spdk_dma_device_type</a></td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__memory__domain__ctx.html">spdk_memory_domain_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new memory domain of the specified type. </p>
<p>Translation functions can be provided to translate addresses from one memory domain to another. If the two domains both use the same addressing scheme for, then this translation does nothing. However, it is possible that the two memory domains may address the same physical memory differently, so this translation step is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Double pointer to memory domain to be allocated by this function </td></tr>
    <tr><td class="paramname">type</td><td>Type of the DMA device which can access this memory domain </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional memory domain context to be copied by this function. Later <b>ctx</b> can be retrieved using <a class="el" href="#ab76ad75ffcdb2c3344872367eb113067">spdk_memory_domain_get_context</a> function </td></tr>
    <tr><td class="paramname">id</td><td>String identifier representing the DMA device that can access this memory domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure </dd></dl>

</div>
</div>
<a id="ad908aa65943565af3128e340c8c5e285" name="ad908aa65943565af3128e340c8c5e285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad908aa65943565af3128e340c8c5e285">&#9670;&#160;</a></span>spdk_memory_domain_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memory_domain_destroy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>domain</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy memory domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab76ad75ffcdb2c3344872367eb113067" name="ab76ad75ffcdb2c3344872367eb113067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76ad75ffcdb2c3344872367eb113067">&#9670;&#160;</a></span>spdk_memory_domain_get_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__memory__domain__ctx.html">spdk_memory_domain_ctx</a> * spdk_memory_domain_get_context </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>domain</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the context passed by the user in <a class="el" href="#a6ddda62cbca17c587a2c6d201b4e6dff">spdk_memory_domain_create</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory domain context </dd></dl>

</div>
</div>
<a id="a3b745bd27f31212b5ffd9027165cb773" name="a3b745bd27f31212b5ffd9027165cb773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b745bd27f31212b5ffd9027165cb773">&#9670;&#160;</a></span>spdk_memory_domain_get_dma_device_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_memory_domain_get_dma_device_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>domain</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an identifier representing the DMA device that can access this memory domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DMA device identifier </dd></dl>

</div>
</div>
<a id="aa2dd7b82d1f0afe434c0ca92fce6fc66" name="aa2dd7b82d1f0afe434c0ca92fce6fc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2dd7b82d1f0afe434c0ca92fce6fc66">&#9670;&#160;</a></span>spdk_memory_domain_get_dma_device_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a85588b3a6ec5c188ab2dc318c3903586">spdk_dma_device_type</a> spdk_memory_domain_get_dma_device_type </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>domain</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get type of the DMA device that can access this memory domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DMA device type </dd></dl>

</div>
</div>
<a id="a1ff9796de86f6c6e7fbd60684b2f525b" name="a1ff9796de86f6c6e7fbd60684b2f525b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff9796de86f6c6e7fbd60684b2f525b">&#9670;&#160;</a></span>spdk_memory_domain_get_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_memory_domain * spdk_memory_domain_get_first </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first memory domain. </p>
<p>Combined with <a class="el" href="#ae63b08f5e78f0c9c700978a7c005d17e">spdk_memory_domain_get_next</a> to iterate over all memory domains</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Optional identifier representing the DMA device that can access a memory domain, if set then this function returns the first memory domain which id matches or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first memory domain or NULL </dd></dl>

</div>
</div>
<a id="ae63b08f5e78f0c9c700978a7c005d17e" name="ae63b08f5e78f0c9c700978a7c005d17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63b08f5e78f0c9c700978a7c005d17e">&#9670;&#160;</a></span>spdk_memory_domain_get_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_memory_domain * spdk_memory_domain_get_next </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>prev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next memory domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>Previous memory domain </td></tr>
    <tr><td class="paramname">id</td><td>Optional identifier representing the DMA device that can access a memory domain, if set then this function returns the next memory domain which id matches or NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to next memory domain or NULL; </dd></dl>

</div>
</div>
<a id="a3bdfcd0ae17fc9e62d759ee03b842df8" name="a3bdfcd0ae17fc9e62d759ee03b842df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdfcd0ae17fc9e62d759ee03b842df8">&#9670;&#160;</a></span>spdk_memory_domain_get_system_domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_memory_domain * spdk_memory_domain_get_system_domain </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the System memory domain. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the System memory domain. </dd></dl>

</div>
</div>
<a id="adfac8979ac6f0bb0aef7833db95ee29a" name="adfac8979ac6f0bb0aef7833db95ee29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfac8979ac6f0bb0aef7833db95ee29a">&#9670;&#160;</a></span>spdk_memory_domain_get_user_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * spdk_memory_domain_get_user_context </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>ctx_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an opaque pointer to the user context and its size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
    <tr><td class="paramname">ctx_size</td><td>Stores size of the user context. NULL pointer is not allowed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>User context pointer </dd></dl>

</div>
</div>
<a id="a98d423f61ff7a187effcb7564f8eb18e" name="a98d423f61ff7a187effcb7564f8eb18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d423f61ff7a187effcb7564f8eb18e">&#9670;&#160;</a></span>spdk_memory_domain_invalidate_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memory_domain_invalidate_data </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>domain_ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>iovcnt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate memory in the given domain. </p>
<p>This function calls <b>domain</b> invalidate callback, the callback needs to be set using <a class="el" href="#a1a73817c22cc0ffd8000480576795cbf">spdk_memory_domain_set_invalidate</a> function. This operation is optional and is meant to be executed on the translation result <a class="el" href="#a05ad1c0fc1a4fa74ede9b48181e044b1">spdk_memory_domain_translate_data</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain in which address space of the buffer is located </td></tr>
    <tr><td class="paramname">domain_ctx</td><td>User defined context </td></tr>
    <tr><td class="paramname">iov</td><td>Iov vector in <b>domain</b> memory space to be invalidated </td></tr>
    <tr><td class="paramname">iovcnt</td><td>iov array size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4e0567f3920f46cb3644ced997573c7" name="ae4e0567f3920f46cb3644ced997573c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e0567f3920f46cb3644ced997573c7">&#9670;&#160;</a></span>spdk_memory_domain_memzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_memory_domain_memzero </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>domain_ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cpl_cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cpl_cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills memory in <b>domain</b> with zeroes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain in which address space data buffer is located </td></tr>
    <tr><td class="paramname">domain_ctx</td><td>User defined context </td></tr>
    <tr><td class="paramname">iov</td><td>iov in <b>domain</b> memory space to be filled with zeroes </td></tr>
    <tr><td class="paramname">iovcnt</td><td><b>iov</b> array size </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>Completion callback </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Completion callback argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure. memzero implementation must only call the callback when 0 is returned </dd></dl>

</div>
</div>
<a id="ab766b91733e0939cdea6d13e77572d40" name="ab766b91733e0939cdea6d13e77572d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab766b91733e0939cdea6d13e77572d40">&#9670;&#160;</a></span>spdk_memory_domain_pull_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_memory_domain_pull_data </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>src_domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>src_domain_ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>src_iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>src_iov_cnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>dst_iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>dst_iov_cnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cpl_cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cpl_cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously pull data which is described by <b>src_domain</b> and located in <b>src_iov</b> to a location <b>dst_iov</b> local memory space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_domain</td><td>Memory domain in which space data buffer is located </td></tr>
    <tr><td class="paramname">src_domain_ctx</td><td>User defined context </td></tr>
    <tr><td class="paramname">src_iov</td><td>Source data iov </td></tr>
    <tr><td class="paramname">src_iov_cnt</td><td>The number of elements in <b>src_iov</b> </td></tr>
    <tr><td class="paramname">dst_iov</td><td>Destination iov </td></tr>
    <tr><td class="paramname">dst_iov_cnt</td><td>The number of elements in <b>dst_iov</b> </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>Completion callback </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Completion callback argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure. pull_cb implementation must only call the callback when 0 is returned </dd></dl>

</div>
</div>
<a id="a9e494849a34eeab88b96f44e79862eb8" name="a9e494849a34eeab88b96f44e79862eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e494849a34eeab88b96f44e79862eb8">&#9670;&#160;</a></span>spdk_memory_domain_push_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_memory_domain_push_data </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>dst_domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dst_domain_ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>dst_iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>dst_iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>src_iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>src_iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cpl_cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cpl_cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously push data located in local memory to <b>dst_domain</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_domain</td><td>Memory domain to which the data should be pushed </td></tr>
    <tr><td class="paramname">dst_domain_ctx</td><td>Optional context passed by upper layer with IO request </td></tr>
    <tr><td class="paramname">dst_iov</td><td>Iov vector in dst_domain space </td></tr>
    <tr><td class="paramname">dst_iovcnt</td><td>dst_iov array size </td></tr>
    <tr><td class="paramname">src_iov</td><td>Iov vector in local memory </td></tr>
    <tr><td class="paramname">src_iovcnt</td><td>src_iov array size </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>Completion callback </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Completion callback argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure. push_cb implementation must only call the callback when 0 is returned </dd></dl>

</div>
</div>
<a id="a2d0b55d4e43516904d453242ca04fd24" name="a2d0b55d4e43516904d453242ca04fd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0b55d4e43516904d453242ca04fd24">&#9670;&#160;</a></span>spdk_memory_domain_set_data_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memory_domain_set_data_transfer </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a01b08a0983057edbc19cb1dd6bdea2de">spdk_memory_domain_transfer_data_cb</a></td>          <td class="paramname"><span class="paramname"><em>transfer_cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set data transfer for memory domain. </p>
<p>Overwrites existing function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
    <tr><td class="paramname">transfer_cb</td><td>Data transfer function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a73817c22cc0ffd8000480576795cbf" name="a1a73817c22cc0ffd8000480576795cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a73817c22cc0ffd8000480576795cbf">&#9670;&#160;</a></span>spdk_memory_domain_set_invalidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memory_domain_set_invalidate </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9437c10aecf1f03c8137b870a83dac17">spdk_memory_domain_invalidate_data_cb</a></td>          <td class="paramname"><span class="paramname"><em>invalidate_cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set invalidate function for memory domain. </p>
<p>Overwrites existing invalidate function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
    <tr><td class="paramname">invalidate_cb</td><td>Invalidate function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abafa95a5bedcc6c320d09a2ccbbeedfc" name="abafa95a5bedcc6c320d09a2ccbbeedfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafa95a5bedcc6c320d09a2ccbbeedfc">&#9670;&#160;</a></span>spdk_memory_domain_set_memzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memory_domain_set_memzero </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a22484d6db47a04c8a41a84e67cdb4613">spdk_memory_domain_memzero_cb</a></td>          <td class="paramname"><span class="paramname"><em>memzero_cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set memzero function for memory domain. </p>
<p>Overwrites existing memzero function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
    <tr><td class="paramname">memzero_cb</td><td>memzero function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c443f5b67500578f056e9fe9039bf76" name="a6c443f5b67500578f056e9fe9039bf76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c443f5b67500578f056e9fe9039bf76">&#9670;&#160;</a></span>spdk_memory_domain_set_pull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memory_domain_set_pull </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#abf5cd879a09a8f23a30b45e94574e893">spdk_memory_domain_pull_data_cb</a></td>          <td class="paramname"><span class="paramname"><em>pull_cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set pull function for memory domain. </p>
<p>Overwrites existing pull function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
    <tr><td class="paramname">pull_cb</td><td>pull function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87db0ff92404fc6cb110e8fa98cce0dd" name="a87db0ff92404fc6cb110e8fa98cce0dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87db0ff92404fc6cb110e8fa98cce0dd">&#9670;&#160;</a></span>spdk_memory_domain_set_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memory_domain_set_push </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2f4b39300fc63eb3fe95530ca4c87305">spdk_memory_domain_push_data_cb</a></td>          <td class="paramname"><span class="paramname"><em>push_cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set push function for memory domain. </p>
<p>Overwrites existing push function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
    <tr><td class="paramname">push_cb</td><td>push function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4777ac664899af134eaa6c93de05d6d" name="ab4777ac664899af134eaa6c93de05d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4777ac664899af134eaa6c93de05d6d">&#9670;&#160;</a></span>spdk_memory_domain_set_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memory_domain_set_translation </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a80080465d2736a76d0ddf95d67c701bb">spdk_memory_domain_translate_memory_cb</a></td>          <td class="paramname"><span class="paramname"><em>translate_cb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set translation function for memory domain. </p>
<p>Overwrites existing translation function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>Memory domain </td></tr>
    <tr><td class="paramname">translate_cb</td><td>Translation function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a193ea6d6c72cb91f81e66cc5f0f9130e" name="a193ea6d6c72cb91f81e66cc5f0f9130e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193ea6d6c72cb91f81e66cc5f0f9130e">&#9670;&#160;</a></span>spdk_memory_domain_transfer_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_memory_domain_transfer_data </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>dst_domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dst_domain_ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>dst_iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>dst_iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>src_domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>src_domain_ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>src_iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>src_iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__memory__domain__translation__result.html">spdk_memory_domain_translation_result</a> *</td>          <td class="paramname"><span class="paramname"><em>src_translation</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8d7a0eee8d944cf100d3006b3f3f1774">spdk_memory_domain_data_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cpl_cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cpl_cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously transfer data from the source memory domain to the destination memory domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst_domain</td><td>Memory domain to which the data should be transferred </td></tr>
    <tr><td class="paramname">dst_domain_ctx</td><td>Optional context passed by upper layer with IO request </td></tr>
    <tr><td class="paramname">dst_iov</td><td>Iov vector in dst_domain space </td></tr>
    <tr><td class="paramname">dst_iovcnt</td><td>dst_iov array size </td></tr>
    <tr><td class="paramname">src_domain</td><td>Memory domain from which the data should be transferred </td></tr>
    <tr><td class="paramname">src_domain_ctx</td><td>Optional context passed by the caller </td></tr>
    <tr><td class="paramname">src_iov</td><td>Iov vector in local memory </td></tr>
    <tr><td class="paramname">src_iovcnt</td><td>src_iov array size </td></tr>
    <tr><td class="paramname">src_translation</td><td>Optional memory translation from the source to the destination memory domain </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>A callback to be called when push operation completes </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Optional argument to be passed to <b>cpl_cb</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure. push_cb implementation must only call the callback when 0 is returned </dd></dl>

</div>
</div>
<a id="a05ad1c0fc1a4fa74ede9b48181e044b1" name="a05ad1c0fc1a4fa74ede9b48181e044b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ad1c0fc1a4fa74ede9b48181e044b1">&#9670;&#160;</a></span>spdk_memory_domain_translate_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_memory_domain_translate_data </td>
          <td>(</td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>src_domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>src_domain_ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_memory_domain *</td>          <td class="paramname"><span class="paramname"><em>dst_domain</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__memory__domain__translation__ctx.html">spdk_memory_domain_translation_ctx</a> *</td>          <td class="paramname"><span class="paramname"><em>dst_domain_ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>addr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__memory__domain__translation__result.html">spdk_memory_domain_translation_result</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate data located in <b>src_domain</b> space at address <b>addr</b> with size <b>len</b> into an equivalent description of memory in dst_domain. </p>
<p>This function calls <b>src_domain</b> translation callback, the callback needs to be set using <a class="el" href="#ab4777ac664899af134eaa6c93de05d6d">spdk_memory_domain_set_translation</a> function. No data is moved during this operation. Both src_domain and dst_domain must describe the same physical memory, just from the point of view of two different memory domain. This is a translation of the description of the memory only. Result of translation is stored in <b>result</b>, its content depends on the type of <b>dst_domain</b>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_domain</td><td>Memory domain in which address space data buffer is located </td></tr>
    <tr><td class="paramname">src_domain_ctx</td><td>User defined context </td></tr>
    <tr><td class="paramname">dst_domain</td><td>Memory domain in which memory space data buffer should be translated </td></tr>
    <tr><td class="paramname">dst_domain_ctx</td><td>Ancillary data for dst_domain </td></tr>
    <tr><td class="paramname">addr</td><td>Address in <b>src_domain</b> memory space </td></tr>
    <tr><td class="paramname">len</td><td>Length of the data </td></tr>
    <tr><td class="paramname">result</td><td>Translation result. The content of the translation result is only valid if this function returns 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.10.0 </li>
</ul>
</div>
</div>
</body>
</html>
