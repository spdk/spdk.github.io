<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.13">
  <title>SPDK: env.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-sm-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://ci.spdk.io/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/roadmap/">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('env_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">env.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulated third-party dependencies.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__env__opts.html">spdk_env_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Environment initialization options.  <a href="structspdk__env__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__pci__id.html">spdk_pci_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3e5247302342025f028c57bc024291b1"><td class="memItemLeft" align="right" valign="top"><a id="a3e5247302342025f028c57bc024291b1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_ENV_SOCKET_ID_ANY</b>&#160;&#160;&#160;(-1)</td></tr>
<tr class="separator:a3e5247302342025f028c57bc024291b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab337c70c632ec69967444fcdd4ab17c2"><td class="memItemLeft" align="right" valign="top"><a id="ab337c70c632ec69967444fcdd4ab17c2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_ENV_LCORE_ID_ANY</b>&#160;&#160;&#160;(UINT32_MAX)</td></tr>
<tr class="separator:ab337c70c632ec69967444fcdd4ab17c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f065a5e897ff548b2dbf0996608929a"><td class="memItemLeft" align="right" valign="top"><a id="a7f065a5e897ff548b2dbf0996608929a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a7f065a5e897ff548b2dbf0996608929a">SPDK_MALLOC_DMA</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:a7f065a5e897ff548b2dbf0996608929a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory is dma-safe. <br /></td></tr>
<tr class="separator:a7f065a5e897ff548b2dbf0996608929a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1660ffa6731090ef3f480c295a87dba"><td class="memItemLeft" align="right" valign="top"><a id="ad1660ffa6731090ef3f480c295a87dba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ad1660ffa6731090ef3f480c295a87dba">SPDK_MALLOC_SHARE</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:ad1660ffa6731090ef3f480c295a87dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory is sharable across process boundries. <br /></td></tr>
<tr class="separator:ad1660ffa6731090ef3f480c295a87dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1856012938db5f1c0beba921ee5a7c"><td class="memItemLeft" align="right" valign="top"><a id="aba1856012938db5f1c0beba921ee5a7c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_MEMPOOL_DEFAULT_CACHE_SIZE</b>&#160;&#160;&#160;SIZE_MAX</td></tr>
<tr class="separator:aba1856012938db5f1c0beba921ee5a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d08df976f75c1e47ce174ebc446f95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_ENV_FOREACH_CORE</b>(i)</td></tr>
<tr class="separator:a42d08df976f75c1e47ce174ebc446f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eb4a0e044f1a5e9515b8c2f96078a4"><td class="memItemLeft" align="right" valign="top"><a id="a26eb4a0e044f1a5e9515b8c2f96078a4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_VTOPHYS_ERROR</b>&#160;&#160;&#160;(0xFFFFFFFFFFFFFFFFULL)</td></tr>
<tr class="separator:a26eb4a0e044f1a5e9515b8c2f96078a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a039d3ef1514e326b6c2d8a527f6a6aaa"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a039d3ef1514e326b6c2d8a527f6a6aaa">spdk_mempool_obj_cb_t</a>(struct spdk_mempool *mp, void *opaque, void *obj, unsigned obj_idx)</td></tr>
<tr class="memdesc:a039d3ef1514e326b6c2d8a527f6a6aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object callback function for memory pool.  <a href="#a039d3ef1514e326b6c2d8a527f6a6aaa">More...</a><br /></td></tr>
<tr class="separator:a039d3ef1514e326b6c2d8a527f6a6aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0083ace78471c3d3d247e21e4968d526"><td class="memItemLeft" align="right" valign="top"><a id="a0083ace78471c3d3d247e21e4968d526"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>thread_start_fn</b>) (void *)</td></tr>
<tr class="separator:a0083ace78471c3d3d247e21e4968d526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbcd903dfa26b4e625bdbef66b6d6a8"><td class="memItemLeft" align="right" valign="top"><a id="abdbcd903dfa26b4e625bdbef66b6d6a8"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_enum_cb</b>) (void *enum_ctx, struct spdk_pci_device *pci_dev)</td></tr>
<tr class="separator:abdbcd903dfa26b4e625bdbef66b6d6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac018be4449e60d4e5992e1e4be9bbef3"><td class="memItemLeft" align="right" valign="top"><a id="ac018be4449e60d4e5992e1e4be9bbef3"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_mem_map_notify_cb</b>) (void *cb_ctx, struct spdk_mem_map *map, enum spdk_mem_map_notify_action action, void *vaddr, size_t size)</td></tr>
<tr class="separator:ac018be4449e60d4e5992e1e4be9bbef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a88610413d6db3cc0eaafa4bda0f2caa9"><td class="memItemLeft" align="right" valign="top"><a id="a88610413d6db3cc0eaafa4bda0f2caa9"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_ring_type</b> { <b>SPDK_RING_TYPE_SP_SC</b>, 
<b>SPDK_RING_TYPE_MP_SC</b>
 }</td></tr>
<tr class="separator:a88610413d6db3cc0eaafa4bda0f2caa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96af19906abf2a01e9f1f2105f90722c"><td class="memItemLeft" align="right" valign="top"><a id="a96af19906abf2a01e9f1f2105f90722c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_mem_map_notify_action</b> { <b>SPDK_MEM_MAP_NOTIFY_REGISTER</b>, 
<b>SPDK_MEM_MAP_NOTIFY_UNREGISTER</b>
 }</td></tr>
<tr class="separator:a96af19906abf2a01e9f1f2105f90722c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a668370523a786a75a7d08a8e8f4b28b9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a668370523a786a75a7d08a8e8f4b28b9">spdk_malloc</a> (size_t size, size_t align, uint64_t *phys_addr, int socket_id, uint32_t flags)</td></tr>
<tr class="memdesc:a668370523a786a75a7d08a8e8f4b28b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate dma/sharable memory based on a given dma_flg.  <a href="#a668370523a786a75a7d08a8e8f4b28b9">More...</a><br /></td></tr>
<tr class="separator:a668370523a786a75a7d08a8e8f4b28b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ad245dae3554cf96d62e9b2b0b1596"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a49ad245dae3554cf96d62e9b2b0b1596">spdk_zmalloc</a> (size_t size, size_t align, uint64_t *phys_addr, int socket_id, uint32_t flags)</td></tr>
<tr class="memdesc:a49ad245dae3554cf96d62e9b2b0b1596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate dma/sharable memory based on a given dma_flg.  <a href="#a49ad245dae3554cf96d62e9b2b0b1596">More...</a><br /></td></tr>
<tr class="separator:a49ad245dae3554cf96d62e9b2b0b1596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452d670d7188f883224574dfabc39f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a452d670d7188f883224574dfabc39f2c">spdk_free</a> (void *buf)</td></tr>
<tr class="memdesc:a452d670d7188f883224574dfabc39f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free buffer memory that was previously allocated with <a class="el" href="env_8h.html#a668370523a786a75a7d08a8e8f4b28b9" title="Allocate dma/sharable memory based on a given dma_flg. ">spdk_malloc()</a> or <a class="el" href="env_8h.html#a49ad245dae3554cf96d62e9b2b0b1596" title="Allocate dma/sharable memory based on a given dma_flg. ">spdk_zmalloc()</a>.  <a href="#a452d670d7188f883224574dfabc39f2c">More...</a><br /></td></tr>
<tr class="separator:a452d670d7188f883224574dfabc39f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b1a05d3f4dee14ba3f980672c9b3a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#af3b1a05d3f4dee14ba3f980672c9b3a6">spdk_env_opts_init</a> (struct <a class="el" href="structspdk__env__opts.html">spdk_env_opts</a> *opts)</td></tr>
<tr class="memdesc:af3b1a05d3f4dee14ba3f980672c9b3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the default value of opts.  <a href="#af3b1a05d3f4dee14ba3f980672c9b3a6">More...</a><br /></td></tr>
<tr class="separator:af3b1a05d3f4dee14ba3f980672c9b3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402ca8ae67be57c2c258a7a2bf22cfec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a402ca8ae67be57c2c258a7a2bf22cfec">spdk_env_init</a> (const struct <a class="el" href="structspdk__env__opts.html">spdk_env_opts</a> *opts)</td></tr>
<tr class="memdesc:a402ca8ae67be57c2c258a7a2bf22cfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the environment library.  <a href="#a402ca8ae67be57c2c258a7a2bf22cfec">More...</a><br /></td></tr>
<tr class="separator:a402ca8ae67be57c2c258a7a2bf22cfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0874731c44ac31e4b14d91c6844a87d1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a0874731c44ac31e4b14d91c6844a87d1">spdk_dma_malloc</a> (size_t size, size_t align, uint64_t *phys_addr)</td></tr>
<tr class="memdesc:a0874731c44ac31e4b14d91c6844a87d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a pinned, physically contiguous memory buffer with the given size and alignment.  <a href="#a0874731c44ac31e4b14d91c6844a87d1">More...</a><br /></td></tr>
<tr class="separator:a0874731c44ac31e4b14d91c6844a87d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c470325a493f204e1b1535d4b7bb1e9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a4c470325a493f204e1b1535d4b7bb1e9">spdk_dma_malloc_socket</a> (size_t size, size_t align, uint64_t *phys_addr, int socket_id)</td></tr>
<tr class="memdesc:a4c470325a493f204e1b1535d4b7bb1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a pinned, physically contiguous memory buffer with the given size, alignment and socket id.  <a href="#a4c470325a493f204e1b1535d4b7bb1e9">More...</a><br /></td></tr>
<tr class="separator:a4c470325a493f204e1b1535d4b7bb1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b4bd563b918e721fd5006bfe960bc6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab5b4bd563b918e721fd5006bfe960bc6">spdk_dma_zmalloc</a> (size_t size, size_t align, uint64_t *phys_addr)</td></tr>
<tr class="memdesc:ab5b4bd563b918e721fd5006bfe960bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a pinned, physically contiguous memory buffer with the given size and alignment.  <a href="#ab5b4bd563b918e721fd5006bfe960bc6">More...</a><br /></td></tr>
<tr class="separator:ab5b4bd563b918e721fd5006bfe960bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4e9f571d0b77a46ef0192e4cfb13f0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a7f4e9f571d0b77a46ef0192e4cfb13f0">spdk_dma_zmalloc_socket</a> (size_t size, size_t align, uint64_t *phys_addr, int socket_id)</td></tr>
<tr class="memdesc:a7f4e9f571d0b77a46ef0192e4cfb13f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a pinned, physically contiguous memory buffer with the given size, alignment and socket id.  <a href="#a7f4e9f571d0b77a46ef0192e4cfb13f0">More...</a><br /></td></tr>
<tr class="separator:a7f4e9f571d0b77a46ef0192e4cfb13f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205172871786d57fca65f76a96874cdb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a205172871786d57fca65f76a96874cdb">spdk_dma_realloc</a> (void *buf, size_t size, size_t align, uint64_t *phys_addr)</td></tr>
<tr class="memdesc:a205172871786d57fca65f76a96874cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the allocated and pinned memory buffer with the given new size and alignment.  <a href="#a205172871786d57fca65f76a96874cdb">More...</a><br /></td></tr>
<tr class="separator:a205172871786d57fca65f76a96874cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd01324e661a5d6deb59bd2bc6230de3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#acd01324e661a5d6deb59bd2bc6230de3">spdk_dma_free</a> (void *buf)</td></tr>
<tr class="memdesc:acd01324e661a5d6deb59bd2bc6230de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a memory buffer previously allocated, for example from <a class="el" href="env_8h.html#ab5b4bd563b918e721fd5006bfe960bc6" title="Allocate a pinned, physically contiguous memory buffer with the given size and alignment. ">spdk_dma_zmalloc()</a>.  <a href="#acd01324e661a5d6deb59bd2bc6230de3">More...</a><br /></td></tr>
<tr class="separator:acd01324e661a5d6deb59bd2bc6230de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48afc08099440a88e9e8dc3abf540ab9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a48afc08099440a88e9e8dc3abf540ab9">spdk_memzone_reserve</a> (const char *name, size_t len, int socket_id, unsigned flags)</td></tr>
<tr class="memdesc:a48afc08099440a88e9e8dc3abf540ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve a named, process shared memory zone with the given size, socket_id and flags.  <a href="#a48afc08099440a88e9e8dc3abf540ab9">More...</a><br /></td></tr>
<tr class="separator:a48afc08099440a88e9e8dc3abf540ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be5bc3f8fc570f45f2ad087fcb91f9e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a2be5bc3f8fc570f45f2ad087fcb91f9e">spdk_memzone_lookup</a> (const char *name)</td></tr>
<tr class="memdesc:a2be5bc3f8fc570f45f2ad087fcb91f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup the memory zone identified by the given name.  <a href="#a2be5bc3f8fc570f45f2ad087fcb91f9e">More...</a><br /></td></tr>
<tr class="separator:a2be5bc3f8fc570f45f2ad087fcb91f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7f9a6391c0e076abd0160b24f2ad81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a5c7f9a6391c0e076abd0160b24f2ad81">spdk_memzone_free</a> (const char *name)</td></tr>
<tr class="memdesc:a5c7f9a6391c0e076abd0160b24f2ad81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory zone identified by the given name.  <a href="#a5c7f9a6391c0e076abd0160b24f2ad81">More...</a><br /></td></tr>
<tr class="separator:a5c7f9a6391c0e076abd0160b24f2ad81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b47302a948b71f493ae775b53f162e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8b47302a948b71f493ae775b53f162e2">spdk_memzone_dump</a> (FILE *f)</td></tr>
<tr class="memdesc:a8b47302a948b71f493ae775b53f162e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump debug information about all memzones.  <a href="#a8b47302a948b71f493ae775b53f162e2">More...</a><br /></td></tr>
<tr class="separator:a8b47302a948b71f493ae775b53f162e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4f7842191990b49694495bba10fcbd"><td class="memItemLeft" align="right" valign="top">struct spdk_mempool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8d4f7842191990b49694495bba10fcbd">spdk_mempool_create</a> (const char *name, size_t count, size_t ele_size, size_t cache_size, int socket_id)</td></tr>
<tr class="memdesc:a8d4f7842191990b49694495bba10fcbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread-safe memory pool.  <a href="#a8d4f7842191990b49694495bba10fcbd">More...</a><br /></td></tr>
<tr class="separator:a8d4f7842191990b49694495bba10fcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8981c2ba451d7214e157708a718db6c9"><td class="memItemLeft" align="right" valign="top">struct spdk_mempool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8981c2ba451d7214e157708a718db6c9">spdk_mempool_create_ctor</a> (const char *name, size_t count, size_t ele_size, size_t cache_size, int socket_id, <a class="el" href="env_8h.html#a039d3ef1514e326b6c2d8a527f6a6aaa">spdk_mempool_obj_cb_t</a> *obj_init, void *obj_init_arg)</td></tr>
<tr class="memdesc:a8981c2ba451d7214e157708a718db6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread-safe memory pool with user provided initialization function and argument.  <a href="#a8981c2ba451d7214e157708a718db6c9">More...</a><br /></td></tr>
<tr class="separator:a8981c2ba451d7214e157708a718db6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef50d2e8f2d7fccfd5c5edf95e5013d2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aef50d2e8f2d7fccfd5c5edf95e5013d2">spdk_mempool_get_name</a> (struct spdk_mempool *mp)</td></tr>
<tr class="memdesc:aef50d2e8f2d7fccfd5c5edf95e5013d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a memory pool.  <a href="#aef50d2e8f2d7fccfd5c5edf95e5013d2">More...</a><br /></td></tr>
<tr class="separator:aef50d2e8f2d7fccfd5c5edf95e5013d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d2feacf9f6979db875add06ab06494"><td class="memItemLeft" align="right" valign="top"><a id="ab9d2feacf9f6979db875add06ab06494"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab9d2feacf9f6979db875add06ab06494">spdk_mempool_free</a> (struct spdk_mempool *mp)</td></tr>
<tr class="memdesc:ab9d2feacf9f6979db875add06ab06494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a memory pool. <br /></td></tr>
<tr class="separator:ab9d2feacf9f6979db875add06ab06494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5041ebc03066dede6e0972c22dc77f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ada5041ebc03066dede6e0972c22dc77f">spdk_mempool_get</a> (struct spdk_mempool *mp)</td></tr>
<tr class="memdesc:ada5041ebc03066dede6e0972c22dc77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element from a memory pool.  <a href="#ada5041ebc03066dede6e0972c22dc77f">More...</a><br /></td></tr>
<tr class="separator:ada5041ebc03066dede6e0972c22dc77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5695d9dcc6f53a561f41c932a198853b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a5695d9dcc6f53a561f41c932a198853b">spdk_mempool_get_bulk</a> (struct spdk_mempool *mp, void **ele_arr, size_t count)</td></tr>
<tr class="memdesc:a5695d9dcc6f53a561f41c932a198853b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get multiple elements from a memory pool.  <a href="#a5695d9dcc6f53a561f41c932a198853b">More...</a><br /></td></tr>
<tr class="separator:a5695d9dcc6f53a561f41c932a198853b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56233342766c54990e044b8ca2f3d41a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a56233342766c54990e044b8ca2f3d41a">spdk_mempool_put</a> (struct spdk_mempool *mp, void *ele)</td></tr>
<tr class="memdesc:a56233342766c54990e044b8ca2f3d41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an element back into the memory pool.  <a href="#a56233342766c54990e044b8ca2f3d41a">More...</a><br /></td></tr>
<tr class="separator:a56233342766c54990e044b8ca2f3d41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fc57c5f23f34aa1cf56ed355daa3b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ac3fc57c5f23f34aa1cf56ed355daa3b8">spdk_mempool_put_bulk</a> (struct spdk_mempool *mp, void *const *ele_arr, size_t count)</td></tr>
<tr class="memdesc:ac3fc57c5f23f34aa1cf56ed355daa3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put multiple elements back into the memory pool.  <a href="#ac3fc57c5f23f34aa1cf56ed355daa3b8">More...</a><br /></td></tr>
<tr class="separator:ac3fc57c5f23f34aa1cf56ed355daa3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434cdf73691c745e717b8b794b2acb52"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a434cdf73691c745e717b8b794b2acb52">spdk_mempool_count</a> (const struct spdk_mempool *pool)</td></tr>
<tr class="memdesc:a434cdf73691c745e717b8b794b2acb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of entries in the memory pool.  <a href="#a434cdf73691c745e717b8b794b2acb52">More...</a><br /></td></tr>
<tr class="separator:a434cdf73691c745e717b8b794b2acb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4461ccdde430461ad2756b3799099330"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a4461ccdde430461ad2756b3799099330">spdk_env_get_core_count</a> (void)</td></tr>
<tr class="memdesc:a4461ccdde430461ad2756b3799099330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of dedicated CPU cores utilized by this env abstraction.  <a href="#a4461ccdde430461ad2756b3799099330">More...</a><br /></td></tr>
<tr class="separator:a4461ccdde430461ad2756b3799099330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2483610a36d7daa9e6b067d9270d0087"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a2483610a36d7daa9e6b067d9270d0087">spdk_env_get_current_core</a> (void)</td></tr>
<tr class="memdesc:a2483610a36d7daa9e6b067d9270d0087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CPU core index of the current thread.  <a href="#a2483610a36d7daa9e6b067d9270d0087">More...</a><br /></td></tr>
<tr class="separator:a2483610a36d7daa9e6b067d9270d0087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2127ecc88ceb8e4b1242c316634de50e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a2127ecc88ceb8e4b1242c316634de50e">spdk_env_get_first_core</a> (void)</td></tr>
<tr class="memdesc:a2127ecc88ceb8e4b1242c316634de50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the first dedicated CPU core for this application.  <a href="#a2127ecc88ceb8e4b1242c316634de50e">More...</a><br /></td></tr>
<tr class="separator:a2127ecc88ceb8e4b1242c316634de50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66fc19d0c23cb21ff456581f0385a2b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ad66fc19d0c23cb21ff456581f0385a2b">spdk_env_get_last_core</a> (void)</td></tr>
<tr class="memdesc:ad66fc19d0c23cb21ff456581f0385a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the last dedicated CPU core for this application.  <a href="#ad66fc19d0c23cb21ff456581f0385a2b">More...</a><br /></td></tr>
<tr class="separator:ad66fc19d0c23cb21ff456581f0385a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab480f817ecdd801a0e53a4d8494ffc67"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab480f817ecdd801a0e53a4d8494ffc67">spdk_env_get_next_core</a> (uint32_t prev_core)</td></tr>
<tr class="memdesc:ab480f817ecdd801a0e53a4d8494ffc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the next dedicated CPU core for this application.  <a href="#ab480f817ecdd801a0e53a4d8494ffc67">More...</a><br /></td></tr>
<tr class="separator:ab480f817ecdd801a0e53a4d8494ffc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18052aa1bc0ff634ffc0ce11c577d65"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab18052aa1bc0ff634ffc0ce11c577d65">spdk_env_get_socket_id</a> (uint32_t core)</td></tr>
<tr class="memdesc:ab18052aa1bc0ff634ffc0ce11c577d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the socket ID for the given core.  <a href="#ab18052aa1bc0ff634ffc0ce11c577d65">More...</a><br /></td></tr>
<tr class="separator:ab18052aa1bc0ff634ffc0ce11c577d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4282feec502eca721136e88c824d59cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a4282feec502eca721136e88c824d59cf">spdk_env_thread_launch_pinned</a> (uint32_t core, thread_start_fn fn, void *arg)</td></tr>
<tr class="memdesc:a4282feec502eca721136e88c824d59cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch a thread pinned to the given core.  <a href="#a4282feec502eca721136e88c824d59cf">More...</a><br /></td></tr>
<tr class="separator:a4282feec502eca721136e88c824d59cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7e5ab204489da6d344999e4a0c8a73"><td class="memItemLeft" align="right" valign="top"><a id="aec7e5ab204489da6d344999e4a0c8a73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aec7e5ab204489da6d344999e4a0c8a73">spdk_env_thread_wait_all</a> (void)</td></tr>
<tr class="memdesc:aec7e5ab204489da6d344999e4a0c8a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all threads to exit before returning. <br /></td></tr>
<tr class="separator:aec7e5ab204489da6d344999e4a0c8a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798ae910c8563b33eea17af50cabb1ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a798ae910c8563b33eea17af50cabb1ab">spdk_process_is_primary</a> (void)</td></tr>
<tr class="memdesc:a798ae910c8563b33eea17af50cabb1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the calling process is primary process.  <a href="#a798ae910c8563b33eea17af50cabb1ab">More...</a><br /></td></tr>
<tr class="separator:a798ae910c8563b33eea17af50cabb1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d868d272aa0c000f6135966dfadc596"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596">spdk_get_ticks</a> (void)</td></tr>
<tr class="memdesc:a7d868d272aa0c000f6135966dfadc596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a monotonic timestamp counter.  <a href="#a7d868d272aa0c000f6135966dfadc596">More...</a><br /></td></tr>
<tr class="separator:a7d868d272aa0c000f6135966dfadc596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7d0eb3000d71b588486cf9903cd434"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a0e7d0eb3000d71b588486cf9903cd434">spdk_get_ticks_hz</a> (void)</td></tr>
<tr class="memdesc:a0e7d0eb3000d71b588486cf9903cd434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tick rate of <a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596" title="Get a monotonic timestamp counter. ">spdk_get_ticks()</a> per second.  <a href="#a0e7d0eb3000d71b588486cf9903cd434">More...</a><br /></td></tr>
<tr class="separator:a0e7d0eb3000d71b588486cf9903cd434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e338ce2d6510489ae83bfff226b8b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab2e338ce2d6510489ae83bfff226b8b1">spdk_delay_us</a> (unsigned int us)</td></tr>
<tr class="memdesc:ab2e338ce2d6510489ae83bfff226b8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay the given number of microseconds.  <a href="#ab2e338ce2d6510489ae83bfff226b8b1">More...</a><br /></td></tr>
<tr class="separator:ab2e338ce2d6510489ae83bfff226b8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9038d37e14d07c89b399ee92bcbb87"><td class="memItemLeft" align="right" valign="top">struct spdk_ring *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a9f9038d37e14d07c89b399ee92bcbb87">spdk_ring_create</a> (enum spdk_ring_type type, size_t count, int socket_id)</td></tr>
<tr class="memdesc:a9f9038d37e14d07c89b399ee92bcbb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a ring.  <a href="#a9f9038d37e14d07c89b399ee92bcbb87">More...</a><br /></td></tr>
<tr class="separator:a9f9038d37e14d07c89b399ee92bcbb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1ec5c3714962d4b01ceb5a50571dca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a3f1ec5c3714962d4b01ceb5a50571dca">spdk_ring_free</a> (struct spdk_ring *ring)</td></tr>
<tr class="memdesc:a3f1ec5c3714962d4b01ceb5a50571dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the ring.  <a href="#a3f1ec5c3714962d4b01ceb5a50571dca">More...</a><br /></td></tr>
<tr class="separator:a3f1ec5c3714962d4b01ceb5a50571dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6320a791a777b2d518def6413e543ac8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a6320a791a777b2d518def6413e543ac8">spdk_ring_count</a> (struct spdk_ring *ring)</td></tr>
<tr class="memdesc:a6320a791a777b2d518def6413e543ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of objects in the ring.  <a href="#a6320a791a777b2d518def6413e543ac8">More...</a><br /></td></tr>
<tr class="separator:a6320a791a777b2d518def6413e543ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a5c5e5f14c336e7d64db996c0ed2dc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a94a5c5e5f14c336e7d64db996c0ed2dc">spdk_ring_enqueue</a> (struct spdk_ring *ring, void **objs, size_t count)</td></tr>
<tr class="memdesc:a94a5c5e5f14c336e7d64db996c0ed2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue the array of objects (with length count) on the ring.  <a href="#a94a5c5e5f14c336e7d64db996c0ed2dc">More...</a><br /></td></tr>
<tr class="separator:a94a5c5e5f14c336e7d64db996c0ed2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982e1b212d497dbb209902f56b192afb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a982e1b212d497dbb209902f56b192afb">spdk_ring_dequeue</a> (struct spdk_ring *ring, void **objs, size_t count)</td></tr>
<tr class="memdesc:a982e1b212d497dbb209902f56b192afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue count objects from the ring into the array objs.  <a href="#a982e1b212d497dbb209902f56b192afb">More...</a><br /></td></tr>
<tr class="separator:a982e1b212d497dbb209902f56b192afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96a59dc23cf16ed24029ea50598be5b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ae96a59dc23cf16ed24029ea50598be5b">spdk_vtophys</a> (void *buf)</td></tr>
<tr class="memdesc:ae96a59dc23cf16ed24029ea50598be5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the physical address of a buffer.  <a href="#ae96a59dc23cf16ed24029ea50598be5b">More...</a><br /></td></tr>
<tr class="separator:ae96a59dc23cf16ed24029ea50598be5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdff13ebe1c7830bee0788d6740d186"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a4fdff13ebe1c7830bee0788d6740d186">spdk_pci_nvme_enumerate</a> (spdk_pci_enum_cb enum_cb, void *enum_ctx)</td></tr>
<tr class="memdesc:a4fdff13ebe1c7830bee0788d6740d186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate NVMe devices.  <a href="#a4fdff13ebe1c7830bee0788d6740d186">More...</a><br /></td></tr>
<tr class="separator:a4fdff13ebe1c7830bee0788d6740d186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb419df0c4f549fc77b8d81aa0d689d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#afb419df0c4f549fc77b8d81aa0d689d4">spdk_pci_ioat_enumerate</a> (spdk_pci_enum_cb enum_cb, void *enum_ctx)</td></tr>
<tr class="memdesc:afb419df0c4f549fc77b8d81aa0d689d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate I/OAT device.  <a href="#afb419df0c4f549fc77b8d81aa0d689d4">More...</a><br /></td></tr>
<tr class="separator:afb419df0c4f549fc77b8d81aa0d689d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d0242f6123177ac5ac842732683ae2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a90d0242f6123177ac5ac842732683ae2">spdk_pci_virtio_enumerate</a> (spdk_pci_enum_cb enum_cb, void *enum_ctx)</td></tr>
<tr class="memdesc:a90d0242f6123177ac5ac842732683ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate virtio device.  <a href="#a90d0242f6123177ac5ac842732683ae2">More...</a><br /></td></tr>
<tr class="separator:a90d0242f6123177ac5ac842732683ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3779ef938c1a803ca521af9b5c61033"><td class="memItemLeft" align="right" valign="top">struct spdk_pci_device *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ae3779ef938c1a803ca521af9b5c61033">spdk_pci_get_device</a> (struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *pci_addr)</td></tr>
<tr class="memdesc:ae3779ef938c1a803ca521af9b5c61033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get PCI device from the given address.  <a href="#ae3779ef938c1a803ca521af9b5c61033">More...</a><br /></td></tr>
<tr class="separator:ae3779ef938c1a803ca521af9b5c61033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1964fc8e4bdbe6c8fc3002f063a6747"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab1964fc8e4bdbe6c8fc3002f063a6747">spdk_pci_device_map_bar</a> (struct spdk_pci_device *dev, uint32_t bar, void **mapped_addr, uint64_t *phys_addr, uint64_t *size)</td></tr>
<tr class="memdesc:ab1964fc8e4bdbe6c8fc3002f063a6747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mapping of the virtual address to the BAR of the PCI device.  <a href="#ab1964fc8e4bdbe6c8fc3002f063a6747">More...</a><br /></td></tr>
<tr class="separator:ab1964fc8e4bdbe6c8fc3002f063a6747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfc985bf61ba230bea950e02391448c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aabfc985bf61ba230bea950e02391448c">spdk_pci_device_unmap_bar</a> (struct spdk_pci_device *dev, uint32_t bar, void *addr)</td></tr>
<tr class="memdesc:aabfc985bf61ba230bea950e02391448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the mapping of the virtual address to the BAR of the PCI device.  <a href="#aabfc985bf61ba230bea950e02391448c">More...</a><br /></td></tr>
<tr class="separator:aabfc985bf61ba230bea950e02391448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b6650e48ccffaea6ca59fe0b875da5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a10b6650e48ccffaea6ca59fe0b875da5">spdk_pci_device_get_domain</a> (struct spdk_pci_device *dev)</td></tr>
<tr class="memdesc:a10b6650e48ccffaea6ca59fe0b875da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the domain address of a PCI device.  <a href="#a10b6650e48ccffaea6ca59fe0b875da5">More...</a><br /></td></tr>
<tr class="separator:a10b6650e48ccffaea6ca59fe0b875da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae16576e55bc5015818abc07c370244"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a1ae16576e55bc5015818abc07c370244">spdk_pci_device_get_bus</a> (struct spdk_pci_device *dev)</td></tr>
<tr class="memdesc:a1ae16576e55bc5015818abc07c370244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bus address of a PCI device.  <a href="#a1ae16576e55bc5015818abc07c370244">More...</a><br /></td></tr>
<tr class="separator:a1ae16576e55bc5015818abc07c370244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5027b309c5a3210250d896ed5c9b0f8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ae5027b309c5a3210250d896ed5c9b0f8">spdk_pci_device_get_dev</a> (struct spdk_pci_device *dev)</td></tr>
<tr class="memdesc:ae5027b309c5a3210250d896ed5c9b0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device address of a PCI device.  <a href="#ae5027b309c5a3210250d896ed5c9b0f8">More...</a><br /></td></tr>
<tr class="separator:ae5027b309c5a3210250d896ed5c9b0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4342c5bc69edb7b42a3873e54bd2d7"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a6c4342c5bc69edb7b42a3873e54bd2d7">spdk_pci_device_get_func</a> (struct spdk_pci_device *dev)</td></tr>
<tr class="memdesc:a6c4342c5bc69edb7b42a3873e54bd2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the function address of a PCI device.  <a href="#a6c4342c5bc69edb7b42a3873e54bd2d7">More...</a><br /></td></tr>
<tr class="separator:a6c4342c5bc69edb7b42a3873e54bd2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71622d665e7b50f34d2279e7e86b557e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a71622d665e7b50f34d2279e7e86b557e">spdk_pci_device_get_addr</a> (struct spdk_pci_device *dev)</td></tr>
<tr class="memdesc:a71622d665e7b50f34d2279e7e86b557e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the PCI address of a PCI device.  <a href="#a71622d665e7b50f34d2279e7e86b557e">More...</a><br /></td></tr>
<tr class="separator:a71622d665e7b50f34d2279e7e86b557e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6b50f74ddb53ff6ee4552c20a053bc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#abe6b50f74ddb53ff6ee4552c20a053bc">spdk_pci_device_get_vendor_id</a> (struct spdk_pci_device *dev)</td></tr>
<tr class="memdesc:abe6b50f74ddb53ff6ee4552c20a053bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vendor ID of a PCI device.  <a href="#abe6b50f74ddb53ff6ee4552c20a053bc">More...</a><br /></td></tr>
<tr class="separator:abe6b50f74ddb53ff6ee4552c20a053bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2553026e46a40c274980b5b201b0cb"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8b2553026e46a40c274980b5b201b0cb">spdk_pci_device_get_device_id</a> (struct spdk_pci_device *dev)</td></tr>
<tr class="memdesc:a8b2553026e46a40c274980b5b201b0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device ID of a PCI device.  <a href="#a8b2553026e46a40c274980b5b201b0cb">More...</a><br /></td></tr>
<tr class="separator:a8b2553026e46a40c274980b5b201b0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae488ab8a8a1b56ae22ca26b00185f7f8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ae488ab8a8a1b56ae22ca26b00185f7f8">spdk_pci_device_get_subvendor_id</a> (struct spdk_pci_device *dev)</td></tr>
<tr class="memdesc:ae488ab8a8a1b56ae22ca26b00185f7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the subvendor ID of a PCI device.  <a href="#ae488ab8a8a1b56ae22ca26b00185f7f8">More...</a><br /></td></tr>
<tr class="separator:ae488ab8a8a1b56ae22ca26b00185f7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6368feb8685db7cc745f14e184a5e3e0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a6368feb8685db7cc745f14e184a5e3e0">spdk_pci_device_get_subdevice_id</a> (struct spdk_pci_device *dev)</td></tr>
<tr class="memdesc:a6368feb8685db7cc745f14e184a5e3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the subdevice ID of a PCI device.  <a href="#a6368feb8685db7cc745f14e184a5e3e0">More...</a><br /></td></tr>
<tr class="separator:a6368feb8685db7cc745f14e184a5e3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5c2f463bddbce4cc846e04246f6414"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__pci__id.html">spdk_pci_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a5c5c2f463bddbce4cc846e04246f6414">spdk_pci_device_get_id</a> (struct spdk_pci_device *dev)</td></tr>
<tr class="memdesc:a5c5c2f463bddbce4cc846e04246f6414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a PCI ID struct for the PCI device.  <a href="#a5c5c2f463bddbce4cc846e04246f6414">More...</a><br /></td></tr>
<tr class="separator:a5c5c2f463bddbce4cc846e04246f6414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235f1c632be6dc00aad1cf8fd0314609"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a235f1c632be6dc00aad1cf8fd0314609">spdk_pci_device_get_socket_id</a> (struct spdk_pci_device *dev)</td></tr>
<tr class="memdesc:a235f1c632be6dc00aad1cf8fd0314609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NUMA socket ID of a PCI device.  <a href="#a235f1c632be6dc00aad1cf8fd0314609">More...</a><br /></td></tr>
<tr class="separator:a235f1c632be6dc00aad1cf8fd0314609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b979316610b357a35d03500c3059af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a69b979316610b357a35d03500c3059af">spdk_pci_device_get_serial_number</a> (struct spdk_pci_device *dev, char *sn, size_t len)</td></tr>
<tr class="memdesc:a69b979316610b357a35d03500c3059af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the serial number of a PCI device.  <a href="#a69b979316610b357a35d03500c3059af">More...</a><br /></td></tr>
<tr class="separator:a69b979316610b357a35d03500c3059af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1866b3d6e63d1b7be5db38b2094d89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#afa1866b3d6e63d1b7be5db38b2094d89">spdk_pci_device_claim</a> (const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *pci_addr)</td></tr>
<tr class="memdesc:afa1866b3d6e63d1b7be5db38b2094d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claim a PCI device for exclusive SPDK userspace access.  <a href="#afa1866b3d6e63d1b7be5db38b2094d89">More...</a><br /></td></tr>
<tr class="separator:afa1866b3d6e63d1b7be5db38b2094d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98502fc8d794fadaae348496d421082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aa98502fc8d794fadaae348496d421082">spdk_pci_device_detach</a> (struct spdk_pci_device *device)</td></tr>
<tr class="memdesc:aa98502fc8d794fadaae348496d421082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach a PCI device.  <a href="#aa98502fc8d794fadaae348496d421082">More...</a><br /></td></tr>
<tr class="separator:aa98502fc8d794fadaae348496d421082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0392d613054a008f9fbc22ef627e8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8d0392d613054a008f9fbc22ef627e8d">spdk_pci_nvme_device_attach</a> (spdk_pci_enum_cb enum_cb, void *enum_ctx, struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *pci_address)</td></tr>
<tr class="memdesc:a8d0392d613054a008f9fbc22ef627e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a NVMe device.  <a href="#a8d0392d613054a008f9fbc22ef627e8d">More...</a><br /></td></tr>
<tr class="separator:a8d0392d613054a008f9fbc22ef627e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c48afea3729723d2a9b98342df42cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ae7c48afea3729723d2a9b98342df42cc">spdk_pci_ioat_device_attach</a> (spdk_pci_enum_cb enum_cb, void *enum_ctx, struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *pci_address)</td></tr>
<tr class="memdesc:ae7c48afea3729723d2a9b98342df42cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a I/OAT device.  <a href="#ae7c48afea3729723d2a9b98342df42cc">More...</a><br /></td></tr>
<tr class="separator:ae7c48afea3729723d2a9b98342df42cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf5d89c817d3630b76925969fe0e490"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aabf5d89c817d3630b76925969fe0e490">spdk_pci_virtio_device_attach</a> (spdk_pci_enum_cb enum_cb, void *enum_ctx, struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *pci_address)</td></tr>
<tr class="memdesc:aabf5d89c817d3630b76925969fe0e490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a virtio device.  <a href="#aabf5d89c817d3630b76925969fe0e490">More...</a><br /></td></tr>
<tr class="separator:aabf5d89c817d3630b76925969fe0e490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8678c0214fa5f08c3d63784eddbe6221"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8678c0214fa5f08c3d63784eddbe6221">spdk_pci_device_cfg_read</a> (struct spdk_pci_device *dev, void *value, uint32_t len, uint32_t offset)</td></tr>
<tr class="memdesc:a8678c0214fa5f08c3d63784eddbe6221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read PCI configuration space in any specified size.  <a href="#a8678c0214fa5f08c3d63784eddbe6221">More...</a><br /></td></tr>
<tr class="separator:a8678c0214fa5f08c3d63784eddbe6221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b07f91a80793a6b97634d38734f5457"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a0b07f91a80793a6b97634d38734f5457">spdk_pci_device_cfg_write</a> (struct spdk_pci_device *dev, void *value, uint32_t len, uint32_t offset)</td></tr>
<tr class="memdesc:a0b07f91a80793a6b97634d38734f5457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write PCI configuration space in any specified size.  <a href="#a0b07f91a80793a6b97634d38734f5457">More...</a><br /></td></tr>
<tr class="separator:a0b07f91a80793a6b97634d38734f5457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8e0b6936b5844b354b92278f66fa2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a1f8e0b6936b5844b354b92278f66fa2d">spdk_pci_device_cfg_read8</a> (struct spdk_pci_device *dev, uint8_t *value, uint32_t offset)</td></tr>
<tr class="memdesc:a1f8e0b6936b5844b354b92278f66fa2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 1 byte from PCI configuration space.  <a href="#a1f8e0b6936b5844b354b92278f66fa2d">More...</a><br /></td></tr>
<tr class="separator:a1f8e0b6936b5844b354b92278f66fa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff1870d9b97e71f90d63825f0cb32b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a9ff1870d9b97e71f90d63825f0cb32b4">spdk_pci_device_cfg_write8</a> (struct spdk_pci_device *dev, uint8_t value, uint32_t offset)</td></tr>
<tr class="memdesc:a9ff1870d9b97e71f90d63825f0cb32b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 1 byte to PCI configuration space.  <a href="#a9ff1870d9b97e71f90d63825f0cb32b4">More...</a><br /></td></tr>
<tr class="separator:a9ff1870d9b97e71f90d63825f0cb32b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e23e878bfc1748fce850d4d7f5b952c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a4e23e878bfc1748fce850d4d7f5b952c">spdk_pci_device_cfg_read16</a> (struct spdk_pci_device *dev, uint16_t *value, uint32_t offset)</td></tr>
<tr class="memdesc:a4e23e878bfc1748fce850d4d7f5b952c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 2 bytes from PCI configuration space.  <a href="#a4e23e878bfc1748fce850d4d7f5b952c">More...</a><br /></td></tr>
<tr class="separator:a4e23e878bfc1748fce850d4d7f5b952c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b1abf6aacaba2d08bfa9b008c510c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a20b1abf6aacaba2d08bfa9b008c510c4">spdk_pci_device_cfg_write16</a> (struct spdk_pci_device *dev, uint16_t value, uint32_t offset)</td></tr>
<tr class="memdesc:a20b1abf6aacaba2d08bfa9b008c510c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 2 bytes to PCI configuration space.  <a href="#a20b1abf6aacaba2d08bfa9b008c510c4">More...</a><br /></td></tr>
<tr class="separator:a20b1abf6aacaba2d08bfa9b008c510c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc70272071da54727134f9f13ed9771"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a5dc70272071da54727134f9f13ed9771">spdk_pci_device_cfg_read32</a> (struct spdk_pci_device *dev, uint32_t *value, uint32_t offset)</td></tr>
<tr class="memdesc:a5dc70272071da54727134f9f13ed9771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 4 bytes from PCI configuration space.  <a href="#a5dc70272071da54727134f9f13ed9771">More...</a><br /></td></tr>
<tr class="separator:a5dc70272071da54727134f9f13ed9771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488cf86d1c41376aaf526251fc7e3f07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a488cf86d1c41376aaf526251fc7e3f07">spdk_pci_device_cfg_write32</a> (struct spdk_pci_device *dev, uint32_t value, uint32_t offset)</td></tr>
<tr class="memdesc:a488cf86d1c41376aaf526251fc7e3f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 4 bytes to PCI configuration space.  <a href="#a488cf86d1c41376aaf526251fc7e3f07">More...</a><br /></td></tr>
<tr class="separator:a488cf86d1c41376aaf526251fc7e3f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3decf485d6b797775bc4dd2215eb52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a7f3decf485d6b797775bc4dd2215eb52">spdk_pci_addr_compare</a> (const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *a1, const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *a2)</td></tr>
<tr class="memdesc:a7f3decf485d6b797775bc4dd2215eb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two PCI addresses.  <a href="#a7f3decf485d6b797775bc4dd2215eb52">More...</a><br /></td></tr>
<tr class="separator:a7f3decf485d6b797775bc4dd2215eb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96187c4c0c5a302669f684e487ebaa0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a96187c4c0c5a302669f684e487ebaa0d">spdk_pci_addr_parse</a> (struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *addr, const char *bdf)</td></tr>
<tr class="memdesc:a96187c4c0c5a302669f684e487ebaa0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string representation of a PCI address into a struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a>.  <a href="#a96187c4c0c5a302669f684e487ebaa0d">More...</a><br /></td></tr>
<tr class="separator:a96187c4c0c5a302669f684e487ebaa0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492c0520e80d8be841891e4d1bd7a446"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a492c0520e80d8be841891e4d1bd7a446">spdk_pci_addr_fmt</a> (char *bdf, size_t sz, const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *addr)</td></tr>
<tr class="memdesc:a492c0520e80d8be841891e4d1bd7a446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> to a string.  <a href="#a492c0520e80d8be841891e4d1bd7a446">More...</a><br /></td></tr>
<tr class="separator:a492c0520e80d8be841891e4d1bd7a446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925f8e1d1ed12fc1b7eb057a5c5b7bfd"><td class="memItemLeft" align="right" valign="top"><a id="a925f8e1d1ed12fc1b7eb057a5c5b7bfd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a925f8e1d1ed12fc1b7eb057a5c5b7bfd">spdk_unaffinitize_thread</a> (void)</td></tr>
<tr class="memdesc:a925f8e1d1ed12fc1b7eb057a5c5b7bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any CPU affinity from the current thread. <br /></td></tr>
<tr class="separator:a925f8e1d1ed12fc1b7eb057a5c5b7bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafaea6fc34059237e54e0ab254d0f28"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#abafaea6fc34059237e54e0ab254d0f28">spdk_call_unaffinitized</a> (void *cb(void *arg), void *arg)</td></tr>
<tr class="memdesc:abafaea6fc34059237e54e0ab254d0f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function with CPU affinity unset.  <a href="#abafaea6fc34059237e54e0ab254d0f28">More...</a><br /></td></tr>
<tr class="separator:abafaea6fc34059237e54e0ab254d0f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512b5ef37a363a4c8e234c060b734605"><td class="memItemLeft" align="right" valign="top">struct spdk_mem_map *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a512b5ef37a363a4c8e234c060b734605">spdk_mem_map_alloc</a> (uint64_t default_translation, spdk_mem_map_notify_cb notify_cb, void *cb_ctx)</td></tr>
<tr class="memdesc:a512b5ef37a363a4c8e234c060b734605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a virtual memory address translation map.  <a href="#a512b5ef37a363a4c8e234c060b734605">More...</a><br /></td></tr>
<tr class="separator:a512b5ef37a363a4c8e234c060b734605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88ed69bd8b9a057f672a1170f7a5b6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#af88ed69bd8b9a057f672a1170f7a5b6c">spdk_mem_map_free</a> (struct spdk_mem_map **pmap)</td></tr>
<tr class="memdesc:af88ed69bd8b9a057f672a1170f7a5b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a memory map previously allocated by <a class="el" href="env_8h.html#a512b5ef37a363a4c8e234c060b734605" title="Allocate a virtual memory address translation map. ">spdk_mem_map_alloc()</a>.  <a href="#af88ed69bd8b9a057f672a1170f7a5b6c">More...</a><br /></td></tr>
<tr class="separator:af88ed69bd8b9a057f672a1170f7a5b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3314f2917141bf11f5b125c306d4397d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a3314f2917141bf11f5b125c306d4397d">spdk_mem_map_set_translation</a> (struct spdk_mem_map *map, uint64_t vaddr, uint64_t size, uint64_t translation)</td></tr>
<tr class="memdesc:a3314f2917141bf11f5b125c306d4397d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an address translation for a range of virtual memory.  <a href="#a3314f2917141bf11f5b125c306d4397d">More...</a><br /></td></tr>
<tr class="separator:a3314f2917141bf11f5b125c306d4397d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb4967ae71277512334ad27ef481326"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a2fb4967ae71277512334ad27ef481326">spdk_mem_map_clear_translation</a> (struct spdk_mem_map *map, uint64_t vaddr, uint64_t size)</td></tr>
<tr class="memdesc:a2fb4967ae71277512334ad27ef481326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister an address translation.  <a href="#a2fb4967ae71277512334ad27ef481326">More...</a><br /></td></tr>
<tr class="separator:a2fb4967ae71277512334ad27ef481326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93008c5c5f0c79c286b7edd70343ee1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aa93008c5c5f0c79c286b7edd70343ee1">spdk_mem_map_translate</a> (const struct spdk_mem_map *map, uint64_t vaddr)</td></tr>
<tr class="memdesc:aa93008c5c5f0c79c286b7edd70343ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the translation of a virtual address in a memory map.  <a href="#aa93008c5c5f0c79c286b7edd70343ee1">More...</a><br /></td></tr>
<tr class="separator:aa93008c5c5f0c79c286b7edd70343ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae046c45de2849d15f29dedc52e915ad7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ae046c45de2849d15f29dedc52e915ad7">spdk_mem_register</a> (void *vaddr, size_t len)</td></tr>
<tr class="memdesc:ae046c45de2849d15f29dedc52e915ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the specified memory region for address translation.  <a href="#ae046c45de2849d15f29dedc52e915ad7">More...</a><br /></td></tr>
<tr class="separator:ae046c45de2849d15f29dedc52e915ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffa0c74e2d73703266cad2d5d103f09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a3ffa0c74e2d73703266cad2d5d103f09">spdk_mem_unregister</a> (void *vaddr, size_t len)</td></tr>
<tr class="memdesc:a3ffa0c74e2d73703266cad2d5d103f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister the specified memory region from vtophys address translation.  <a href="#a3ffa0c74e2d73703266cad2d5d103f09">More...</a><br /></td></tr>
<tr class="separator:a3ffa0c74e2d73703266cad2d5d103f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulated third-party dependencies. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a42d08df976f75c1e47ce174ebc446f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d08df976f75c1e47ce174ebc446f95">&#9670;&nbsp;</a></span>SPDK_ENV_FOREACH_CORE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPDK_ENV_FOREACH_CORE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = <a class="code" href="env_8h.html#a2127ecc88ceb8e4b1242c316634de50e">spdk_env_get_first_core</a>();     \</div><div class="line">             i &lt; UINT32_MAX;                    \</div><div class="line">             i = <a class="code" href="env_8h.html#ab480f817ecdd801a0e53a4d8494ffc67">spdk_env_get_next_core</a>(i))</div><div class="ttc" id="env_8h_html_ab480f817ecdd801a0e53a4d8494ffc67"><div class="ttname"><a href="env_8h.html#ab480f817ecdd801a0e53a4d8494ffc67">spdk_env_get_next_core</a></div><div class="ttdeci">uint32_t spdk_env_get_next_core(uint32_t prev_core)</div><div class="ttdoc">Get the index of the next dedicated CPU core for this application. </div></div>
<div class="ttc" id="env_8h_html_a2127ecc88ceb8e4b1242c316634de50e"><div class="ttname"><a href="env_8h.html#a2127ecc88ceb8e4b1242c316634de50e">spdk_env_get_first_core</a></div><div class="ttdeci">uint32_t spdk_env_get_first_core(void)</div><div class="ttdoc">Get the index of the first dedicated CPU core for this application. </div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a039d3ef1514e326b6c2d8a527f6a6aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039d3ef1514e326b6c2d8a527f6a6aaa">&#9670;&nbsp;</a></span>spdk_mempool_obj_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() spdk_mempool_obj_cb_t(struct spdk_mempool *mp, void *opaque, void *obj, unsigned obj_idx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An object callback function for memory pool. </p>
<p>Used by <a class="el" href="env_8h.html#a8981c2ba451d7214e157708a718db6c9" title="Create a thread-safe memory pool with user provided initialization function and argument. ">spdk_mempool_create_ctor()</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abafaea6fc34059237e54e0ab254d0f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafaea6fc34059237e54e0ab254d0f28">&#9670;&nbsp;</a></span>spdk_call_unaffinitized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_call_unaffinitized </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb</em>void *arg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function with CPU affinity unset. </p>
<p>This can be used to run a function that creates other threads without inheriting the calling thread's CPU affinity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Function to call </td></tr>
    <tr><td class="paramname">arg</td><td>Parameter to the function cb().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value of cb(). </dd></dl>

</div>
</div>
<a id="ab2e338ce2d6510489ae83bfff226b8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e338ce2d6510489ae83bfff226b8b1">&#9670;&nbsp;</a></span>spdk_delay_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_delay_us </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay the given number of microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">us</td><td>Number of microseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd01324e661a5d6deb59bd2bc6230de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd01324e661a5d6deb59bd2bc6230de3">&#9670;&nbsp;</a></span>spdk_dma_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_dma_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a memory buffer previously allocated, for example from <a class="el" href="env_8h.html#ab5b4bd563b918e721fd5006bfe960bc6" title="Allocate a pinned, physically contiguous memory buffer with the given size and alignment. ">spdk_dma_zmalloc()</a>. </p>
<p>This call is never made from the performance path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0874731c44ac31e4b14d91c6844a87d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0874731c44ac31e4b14d91c6844a87d1">&#9670;&nbsp;</a></span>spdk_dma_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_dma_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>phys_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a pinned, physically contiguous memory buffer with the given size and alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>Alignment value for the allocated memory. If '0', the allocated buffer is suitably aligned (in the same manner as malloc()). Otherwise, the allocated buffer is aligned to the multiple of align. In this case, it must be a power of two. </td></tr>
    <tr><td class="paramname">phys_addr</td><td>A pointer to the variable to hold the physical address of the allocated buffer is passed. If NULL, the physical address is not returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory buffer. </dd></dl>

</div>
</div>
<a id="a4c470325a493f204e1b1535d4b7bb1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c470325a493f204e1b1535d4b7bb1e9">&#9670;&nbsp;</a></span>spdk_dma_malloc_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_dma_malloc_socket </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>phys_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a pinned, physically contiguous memory buffer with the given size, alignment and socket id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>Alignment value for the allocated memory. If '0', the allocated buffer is suitably aligned (in the same manner as malloc()). Otherwise, the allocated buffer is aligned to the multiple of align. In this case, it must be a power of two. </td></tr>
    <tr><td class="paramname">phys_addr</td><td>A pointer to the variable to hold the physical address of the allocated buffer is passed. If NULL, the physical address is not returned. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory buffer. </dd></dl>

</div>
</div>
<a id="a205172871786d57fca65f76a96874cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205172871786d57fca65f76a96874cdb">&#9670;&nbsp;</a></span>spdk_dma_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_dma_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>phys_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the allocated and pinned memory buffer with the given new size and alignment. </p>
<p>Existing contents are preserved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to resize. </td></tr>
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>Alignment value for the allocated memory. If '0', the allocated buffer is suitably aligned (in the same manner as malloc()). Otherwise, the allocated buffer is aligned to the multiple of align. In this case, it must be a power of two. </td></tr>
    <tr><td class="paramname">phys_addr</td><td>A pointer to the variable to hold the physical address of the allocated buffer is passed. If NULL, the physical address is not returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resized memory buffer. </dd></dl>

</div>
</div>
<a id="ab5b4bd563b918e721fd5006bfe960bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b4bd563b918e721fd5006bfe960bc6">&#9670;&nbsp;</a></span>spdk_dma_zmalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_dma_zmalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>phys_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a pinned, physically contiguous memory buffer with the given size and alignment. </p>
<p>The buffer will be zeroed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>Alignment value for the allocated memory. If '0', the allocated buffer is suitably aligned (in the same manner as malloc()). Otherwise, the allocated buffer is aligned to the multiple of align. In this case, it must be a power of two. </td></tr>
    <tr><td class="paramname">phys_addr</td><td>A pointer to the variable to hold the physical address of the allocated buffer is passed. If NULL, the physical address is not returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory buffer. </dd></dl>

</div>
</div>
<a id="a7f4e9f571d0b77a46ef0192e4cfb13f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4e9f571d0b77a46ef0192e4cfb13f0">&#9670;&nbsp;</a></span>spdk_dma_zmalloc_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_dma_zmalloc_socket </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>phys_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a pinned, physically contiguous memory buffer with the given size, alignment and socket id. </p>
<p>The buffer will be zeroed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>Alignment value for the allocated memory. If '0', the allocated buffer is suitably aligned (in the same manner as malloc()). Otherwise, the allocated buffer is aligned to the multiple of align. In this case, it must be a power of two. </td></tr>
    <tr><td class="paramname">phys_addr</td><td>A pointer to the variable to hold the physical address of the allocated buffer is passed. If NULL, the physical address is not returned. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory buffer. </dd></dl>

</div>
</div>
<a id="a4461ccdde430461ad2756b3799099330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4461ccdde430461ad2756b3799099330">&#9670;&nbsp;</a></span>spdk_env_get_core_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_core_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of dedicated CPU cores utilized by this env abstraction. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of dedicated CPU cores. </dd></dl>

</div>
</div>
<a id="a2483610a36d7daa9e6b067d9270d0087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2483610a36d7daa9e6b067d9270d0087">&#9670;&nbsp;</a></span>spdk_env_get_current_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_current_core </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CPU core index of the current thread. </p>
<p>This will only function when called from threads set up by this environment abstraction. For any other threads <code>SPDK_ENV_LCORE_ID_ANY</code> will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the CPU core index of the current thread. </dd></dl>

</div>
</div>
<a id="a2127ecc88ceb8e4b1242c316634de50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2127ecc88ceb8e4b1242c316634de50e">&#9670;&nbsp;</a></span>spdk_env_get_first_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_first_core </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the first dedicated CPU core for this application. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the first dedicated CPU core. </dd></dl>

</div>
</div>
<a id="ad66fc19d0c23cb21ff456581f0385a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66fc19d0c23cb21ff456581f0385a2b">&#9670;&nbsp;</a></span>spdk_env_get_last_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_last_core </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the last dedicated CPU core for this application. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the last dedicated CPU core. </dd></dl>

</div>
</div>
<a id="ab480f817ecdd801a0e53a4d8494ffc67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab480f817ecdd801a0e53a4d8494ffc67">&#9670;&nbsp;</a></span>spdk_env_get_next_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_next_core </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>prev_core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the next dedicated CPU core for this application. </p>
<p>If there is no next core, return UINT32_MAX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev_core</td><td>Index of previous core.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the next dedicated CPU core. </dd></dl>

</div>
</div>
<a id="ab18052aa1bc0ff634ffc0ce11c577d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18052aa1bc0ff634ffc0ce11c577d65">&#9670;&nbsp;</a></span>spdk_env_get_socket_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_socket_id </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the socket ID for the given core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core</td><td>CPU core to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the socket ID for the given core. </dd></dl>

</div>
</div>
<a id="a402ca8ae67be57c2c258a7a2bf22cfec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402ca8ae67be57c2c258a7a2bf22cfec">&#9670;&nbsp;</a></span>spdk_env_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_env_init </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__env__opts.html">spdk_env_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the environment library. </p>
<p>This must be called prior to using any other functions in this library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Environment initialization options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negative errno on failure. </dd></dl>

</div>
</div>
<a id="af3b1a05d3f4dee14ba3f980672c9b3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b1a05d3f4dee14ba3f980672c9b3a6">&#9670;&nbsp;</a></span>spdk_env_opts_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_env_opts_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__env__opts.html">spdk_env_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the default value of opts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Data structure where SPDK will initialize the default options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4282feec502eca721136e88c824d59cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4282feec502eca721136e88c824d59cf">&#9670;&nbsp;</a></span>spdk_env_thread_launch_pinned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_env_thread_launch_pinned </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_start_fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launch a thread pinned to the given core. </p>
<p>Only a single pinned thread may be launched per core. Subsequent attempts to launch pinned threads on that core will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core</td><td>The core to pin the thread to. </td></tr>
    <tr><td class="paramname">fn</td><td>Entry point on the new thread. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument apssed to thread_start_fn</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="a452d670d7188f883224574dfabc39f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452d670d7188f883224574dfabc39f2c">&#9670;&nbsp;</a></span>spdk_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free buffer memory that was previously allocated with <a class="el" href="env_8h.html#a668370523a786a75a7d08a8e8f4b28b9" title="Allocate dma/sharable memory based on a given dma_flg. ">spdk_malloc()</a> or <a class="el" href="env_8h.html#a49ad245dae3554cf96d62e9b2b0b1596" title="Allocate dma/sharable memory based on a given dma_flg. ">spdk_zmalloc()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d868d272aa0c000f6135966dfadc596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d868d272aa0c000f6135966dfadc596">&#9670;&nbsp;</a></span>spdk_get_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_get_ticks </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a monotonic timestamp counter. </p>
<dl class="section return"><dt>Returns</dt><dd>the monotonic timestamp counter. </dd></dl>

</div>
</div>
<a id="a0e7d0eb3000d71b588486cf9903cd434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7d0eb3000d71b588486cf9903cd434">&#9670;&nbsp;</a></span>spdk_get_ticks_hz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_get_ticks_hz </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tick rate of <a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596" title="Get a monotonic timestamp counter. ">spdk_get_ticks()</a> per second. </p>
<dl class="section return"><dt>Returns</dt><dd>the tick rate of <a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596" title="Get a monotonic timestamp counter. ">spdk_get_ticks()</a> per second. </dd></dl>

</div>
</div>
<a id="a668370523a786a75a7d08a8e8f4b28b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668370523a786a75a7d08a8e8f4b28b9">&#9670;&nbsp;</a></span>spdk_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>phys_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate dma/sharable memory based on a given dma_flg. </p>
<p>It is a physically contiguous memory buffer with the given size, alignment and socket id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>Alignment value for the allocated memory. If '0', the allocated buffer is suitably aligned (in the same manner as malloc()). Otherwise, the allocated buffer is aligned to the multiple of align. In this case, it must be a power of two. </td></tr>
    <tr><td class="paramname">phys_addr</td><td>A pointer to the variable to hold the physical address of the allocated buffer is passed. If NULL, the physical address is not returned. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket. </td></tr>
    <tr><td class="paramname">flags</td><td>Combination of SPDK_MALLOC flags (<a class="el" href="env_8h.html#a7f065a5e897ff548b2dbf0996608929a">SPDK_MALLOC_DMA</a>, <a class="el" href="env_8h.html#ad1660ffa6731090ef3f480c295a87dba">SPDK_MALLOC_SHARE</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory buffer. </dd></dl>

</div>
</div>
<a id="a512b5ef37a363a4c8e234c060b734605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512b5ef37a363a4c8e234c060b734605">&#9670;&nbsp;</a></span>spdk_mem_map_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_mem_map* spdk_mem_map_alloc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>default_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_mem_map_notify_cb&#160;</td>
          <td class="paramname"><em>notify_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a virtual memory address translation map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_translation</td><td>Default translation for the map. </td></tr>
    <tr><td class="paramname">notify_cb</td><td>Callback function to notify the mapping. </td></tr>
    <tr><td class="paramname">cb_ctx</td><td>Argument passed to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated virtual memory address translation map. </dd></dl>

</div>
</div>
<a id="a2fb4967ae71277512334ad27ef481326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb4967ae71277512334ad27ef481326">&#9670;&nbsp;</a></span>spdk_mem_map_clear_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mem_map_clear_translation </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mem_map *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister an address translation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Memory map. </td></tr>
    <tr><td class="paramname">vaddr</td><td>Virtual address of the region to unregister - must be 2 MB aligned. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the region in bytes - must be multiple of 2 MB in the current implementation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="env_8h.html#a3314f2917141bf11f5b125c306d4397d" title="Register an address translation for a range of virtual memory. ">spdk_mem_map_set_translation()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="af88ed69bd8b9a057f672a1170f7a5b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88ed69bd8b9a057f672a1170f7a5b6c">&#9670;&nbsp;</a></span>spdk_mem_map_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_mem_map_free </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mem_map **&#160;</td>
          <td class="paramname"><em>pmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a memory map previously allocated by <a class="el" href="env_8h.html#a512b5ef37a363a4c8e234c060b734605" title="Allocate a virtual memory address translation map. ">spdk_mem_map_alloc()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmap</td><td>Memory map to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3314f2917141bf11f5b125c306d4397d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3314f2917141bf11f5b125c306d4397d">&#9670;&nbsp;</a></span>spdk_mem_map_set_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mem_map_set_translation </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mem_map *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an address translation for a range of virtual memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Memory map. </td></tr>
    <tr><td class="paramname">vaddr</td><td>Virtual address of the region to register - must be 2 MB aligned. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the region in bytes - must be multiple of 2 MB in the current implementation. </td></tr>
    <tr><td class="paramname">translation</td><td>Translation to store in the map for this address range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="env_8h.html#a2fb4967ae71277512334ad27ef481326" title="Unregister an address translation. ">spdk_mem_map_clear_translation()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="aa93008c5c5f0c79c286b7edd70343ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93008c5c5f0c79c286b7edd70343ee1">&#9670;&nbsp;</a></span>spdk_mem_map_translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_mem_map_translate </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_mem_map *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>vaddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the translation of a virtual address in a memory map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Memory map. </td></tr>
    <tr><td class="paramname">vaddr</td><td>Virtual address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the translation of 2MB hugepage mapping. </dd></dl>

</div>
</div>
<a id="ae046c45de2849d15f29dedc52e915ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae046c45de2849d15f29dedc52e915ad7">&#9670;&nbsp;</a></span>spdk_mem_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mem_register </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the specified memory region for address translation. </p>
<p>The memory region must map to pinned huge pages (2MB or greater).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vaddr</td><td>Virtual address to register. </td></tr>
    <tr><td class="paramname">len</td><td>Length in bytes of the vaddr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="a3ffa0c74e2d73703266cad2d5d103f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffa0c74e2d73703266cad2d5d103f09">&#9670;&nbsp;</a></span>spdk_mem_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mem_unregister </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister the specified memory region from vtophys address translation. </p>
<p>The caller must ensure all in-flight DMA operations to this memory region are completed or cancelled before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vaddr</td><td>Virtual address to unregister. </td></tr>
    <tr><td class="paramname">leng</td><td>Length in bytes of the vaddr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="a434cdf73691c745e717b8b794b2acb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434cdf73691c745e717b8b794b2acb52">&#9670;&nbsp;</a></span>spdk_mempool_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_mempool_count </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of entries in the memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Memory pool to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of entries in the memory pool. </dd></dl>

</div>
</div>
<a id="a8d4f7842191990b49694495bba10fcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4f7842191990b49694495bba10fcbd">&#9670;&nbsp;</a></span>spdk_mempool_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_mempool* spdk_mempool_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ele_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread-safe memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name for the memory pool. </td></tr>
    <tr><td class="paramname">count</td><td>Count of elements. </td></tr>
    <tr><td class="paramname">ele_size</td><td>Element size in bytes. </td></tr>
    <tr><td class="paramname">cache_size</td><td>How many elements may be cached in per-core caches. Use SPDK_MEMPOOL_DEFAULT_CACHE_SIZE for a reasonable default, or 0 for no per-core cache. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the created memory pool. </dd></dl>

</div>
</div>
<a id="a8981c2ba451d7214e157708a718db6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8981c2ba451d7214e157708a718db6c9">&#9670;&nbsp;</a></span>spdk_mempool_create_ctor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_mempool* spdk_mempool_create_ctor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ele_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="env_8h.html#a039d3ef1514e326b6c2d8a527f6a6aaa">spdk_mempool_obj_cb_t</a> *&#160;</td>
          <td class="paramname"><em>obj_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj_init_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread-safe memory pool with user provided initialization function and argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name for the memory pool. </td></tr>
    <tr><td class="paramname">count</td><td>Count of elements. </td></tr>
    <tr><td class="paramname">ele_size</td><td>Element size in bytes. </td></tr>
    <tr><td class="paramname">cache_size</td><td>How many elements may be cached in per-core caches. Use SPDK_MEMPOOL_DEFAULT_CACHE_SIZE for a reasonable default, or 0 for no per-core cache. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket. </td></tr>
    <tr><td class="paramname">obj_init</td><td>User provided object calllback initialization function. </td></tr>
    <tr><td class="paramname">obj_init_arg</td><td>User provided callback initialization function argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the created memory pool. </dd></dl>

</div>
</div>
<a id="ada5041ebc03066dede6e0972c22dc77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5041ebc03066dede6e0972c22dc77f">&#9670;&nbsp;</a></span>spdk_mempool_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_mempool_get </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an element from a memory pool. </p>
<p>If no elements remain, return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Memory pool to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element. </dd></dl>

</div>
</div>
<a id="a5695d9dcc6f53a561f41c932a198853b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5695d9dcc6f53a561f41c932a198853b">&#9670;&nbsp;</a></span>spdk_mempool_get_bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mempool_get_bulk </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ele_arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get multiple elements from a memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Memory pool to get multiple elements from. </td></tr>
    <tr><td class="paramname">ele_arr</td><td>Array of the elements to fill. </td></tr>
    <tr><td class="paramname">count</td><td>Count of elements to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="aef50d2e8f2d7fccfd5c5edf95e5013d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef50d2e8f2d7fccfd5c5edf95e5013d2">&#9670;&nbsp;</a></span>spdk_mempool_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* spdk_mempool_get_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of a memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Memory pool to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the memory pool. </dd></dl>

</div>
</div>
<a id="a56233342766c54990e044b8ca2f3d41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56233342766c54990e044b8ca2f3d41a">&#9670;&nbsp;</a></span>spdk_mempool_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_mempool_put </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ele</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put an element back into the memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Memory pool to put element back into. </td></tr>
    <tr><td class="paramname">ele</td><td>Element to put. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3fc57c5f23f34aa1cf56ed355daa3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fc57c5f23f34aa1cf56ed355daa3b8">&#9670;&nbsp;</a></span>spdk_mempool_put_bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_mempool_put_bulk </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>ele_arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put multiple elements back into the memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Memory pool to put multiple elements back into. </td></tr>
    <tr><td class="paramname">ele_arr</td><td>Array of the elements to put. </td></tr>
    <tr><td class="paramname">count</td><td>Count of elements to put. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b47302a948b71f493ae775b53f162e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b47302a948b71f493ae775b53f162e2">&#9670;&nbsp;</a></span>spdk_memzone_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memzone_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump debug information about all memzones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>File to write debug information to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c7f9a6391c0e076abd0160b24f2ad81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7f9a6391c0e076abd0160b24f2ad81">&#9670;&nbsp;</a></span>spdk_memzone_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_memzone_free </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory zone identified by the given name. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a2be5bc3f8fc570f45f2ad087fcb91f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be5bc3f8fc570f45f2ad087fcb91f9e">&#9670;&nbsp;</a></span>spdk_memzone_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_memzone_lookup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup the memory zone identified by the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the memory zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the reserved memory address on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a48afc08099440a88e9e8dc3abf540ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48afc08099440a88e9e8dc3abf540ab9">&#9670;&nbsp;</a></span>spdk_memzone_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_memzone_reserve </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve a named, process shared memory zone with the given size, socket_id and flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name to set for this memory zone. </td></tr>
    <tr><td class="paramname">len</td><td>Length in bytes. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to set for this memory zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory address on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a7f3decf485d6b797775bc4dd2215eb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3decf485d6b797775bc4dd2215eb52">&#9670;&nbsp;</a></span>spdk_pci_addr_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_addr_compare </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two PCI addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a1</td><td>PCI address 1. </td></tr>
    <tr><td class="paramname">a2</td><td>PCI address 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if a1 == a2, less than 0 if a1 &lt; a2, greater than 0 if a1 &gt; a2 </dd></dl>

</div>
</div>
<a id="a492c0520e80d8be841891e4d1bd7a446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492c0520e80d8be841891e4d1bd7a446">&#9670;&nbsp;</a></span>spdk_pci_addr_fmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_addr_fmt </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdf</td><td>String into which a string will be output in the format domain:bus:device.function. The string must be at least 14 characters in size. </td></tr>
    <tr><td class="paramname">sz</td><td>Size of bdf in bytes. Must be at least 14. </td></tr>
    <tr><td class="paramname">addr</td><td>PCI address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negated errno on failure. </dd></dl>

</div>
</div>
<a id="a96187c4c0c5a302669f684e487ebaa0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96187c4c0c5a302669f684e487ebaa0d">&#9670;&nbsp;</a></span>spdk_pci_addr_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_addr_parse </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bdf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string representation of a PCI address into a struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>PCI adddress output on success. </td></tr>
    <tr><td class="paramname">bdf</td><td>PCI address in domain:bus:device.function format or domain.bus.device.function format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="a8678c0214fa5f08c3d63784eddbe6221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8678c0214fa5f08c3d63784eddbe6221">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_read </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read PCI configuration space in any specified size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the buffer to hold the value. </td></tr>
    <tr><td class="paramname">len</td><td>Length in bytes to read. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a4e23e878bfc1748fce850d4d7f5b952c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e23e878bfc1748fce850d4d7f5b952c">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_read16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_read16 </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 2 bytes from PCI configuration space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the buffer to hold the value. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a5dc70272071da54727134f9f13ed9771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc70272071da54727134f9f13ed9771">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_read32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_read32 </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 4 bytes from PCI configuration space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the buffer to hold the value. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a1f8e0b6936b5844b354b92278f66fa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8e0b6936b5844b354b92278f66fa2d">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_read8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_read8 </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 1 byte from PCI configuration space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the buffer to hold the value. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a0b07f91a80793a6b97634d38734f5457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b07f91a80793a6b97634d38734f5457">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_write </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write PCI configuration space in any specified size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the value to write. </td></tr>
    <tr><td class="paramname">len</td><td>Length in bytes to write. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a20b1abf6aacaba2d08bfa9b008c510c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b1abf6aacaba2d08bfa9b008c510c4">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_write16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_write16 </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 2 bytes to PCI configuration space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">value</td><td>A value to write. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a488cf86d1c41376aaf526251fc7e3f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488cf86d1c41376aaf526251fc7e3f07">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_write32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_write32 </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 4 bytes to PCI configuration space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">value</td><td>A value to write. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a9ff1870d9b97e71f90d63825f0cb32b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff1870d9b97e71f90d63825f0cb32b4">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_write8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_write8 </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 1 byte to PCI configuration space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">value</td><td>A value to write. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="afa1866b3d6e63d1b7be5db38b2094d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1866b3d6e63d1b7be5db38b2094d89">&#9670;&nbsp;</a></span>spdk_pci_device_claim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_claim </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>pci_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Claim a PCI device for exclusive SPDK userspace access. </p>
<p>Uses F_SETLK on a shared memory file with the PCI address embedded in its name. As long as this file remains open with the lock acquired, other processes will not be able to successfully call this function on the same PCI device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pci_addr</td><td>PCI address of the device to claim</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the device has already been claimed, an fd otherwise. This fd should be closed when the application no longer needs access to the PCI device (including when it is hot removed). </dd></dl>

</div>
</div>
<a id="aa98502fc8d794fadaae348496d421082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98502fc8d794fadaae348496d421082">&#9670;&nbsp;</a></span>spdk_pci_device_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_pci_device_detach </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>PCI device to detach. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71622d665e7b50f34d2279e7e86b557e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71622d665e7b50f34d2279e7e86b557e">&#9670;&nbsp;</a></span>spdk_pci_device_get_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> spdk_pci_device_get_addr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the PCI address of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A pointer to the PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the PCI address structure. </dd></dl>

</div>
</div>
<a id="a1ae16576e55bc5015818abc07c370244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae16576e55bc5015818abc07c370244">&#9670;&nbsp;</a></span>spdk_pci_device_get_bus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t spdk_pci_device_get_bus </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bus address of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A pointer to the PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bus address of PCI device. </dd></dl>

</div>
</div>
<a id="ae5027b309c5a3210250d896ed5c9b0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5027b309c5a3210250d896ed5c9b0f8">&#9670;&nbsp;</a></span>spdk_pci_device_get_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t spdk_pci_device_get_dev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device address of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A pointer to the PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the device address of PCI device. </dd></dl>

</div>
</div>
<a id="a8b2553026e46a40c274980b5b201b0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2553026e46a40c274980b5b201b0cb">&#9670;&nbsp;</a></span>spdk_pci_device_get_device_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t spdk_pci_device_get_device_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device ID of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A pointer to the PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the device ID of PCI device. </dd></dl>

</div>
</div>
<a id="a10b6650e48ccffaea6ca59fe0b875da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b6650e48ccffaea6ca59fe0b875da5">&#9670;&nbsp;</a></span>spdk_pci_device_get_domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_pci_device_get_domain </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the domain address of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A pointer to the PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the domain address of PCI device. </dd></dl>

</div>
</div>
<a id="a6c4342c5bc69edb7b42a3873e54bd2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4342c5bc69edb7b42a3873e54bd2d7">&#9670;&nbsp;</a></span>spdk_pci_device_get_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t spdk_pci_device_get_func </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the function address of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A pointer to the PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the function address of PCI device. </dd></dl>

</div>
</div>
<a id="a5c5c2f463bddbce4cc846e04246f6414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5c2f463bddbce4cc846e04246f6414">&#9670;&nbsp;</a></span>spdk_pci_device_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__pci__id.html">spdk_pci_id</a> spdk_pci_device_get_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a PCI ID struct for the PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A pointer to the PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a PCI ID struct. </dd></dl>

</div>
</div>
<a id="a69b979316610b357a35d03500c3059af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b979316610b357a35d03500c3059af">&#9670;&nbsp;</a></span>spdk_pci_device_get_serial_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_get_serial_number </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the serial number of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A pointer to the PCI device. </td></tr>
    <tr><td class="paramname">sn</td><td>String to store the serial number. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the 'sn'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a235f1c632be6dc00aad1cf8fd0314609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235f1c632be6dc00aad1cf8fd0314609">&#9670;&nbsp;</a></span>spdk_pci_device_get_socket_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_get_socket_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NUMA socket ID of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device to get the socket ID of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the socket ID (&gt;= 0) of PCI device. </dd></dl>

</div>
</div>
<a id="a6368feb8685db7cc745f14e184a5e3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6368feb8685db7cc745f14e184a5e3e0">&#9670;&nbsp;</a></span>spdk_pci_device_get_subdevice_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t spdk_pci_device_get_subdevice_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the subdevice ID of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A pointer to the PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the subdevice ID of PCI device. </dd></dl>

</div>
</div>
<a id="ae488ab8a8a1b56ae22ca26b00185f7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae488ab8a8a1b56ae22ca26b00185f7f8">&#9670;&nbsp;</a></span>spdk_pci_device_get_subvendor_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t spdk_pci_device_get_subvendor_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the subvendor ID of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A pointer to the PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the subvendor ID of PCI device. </dd></dl>

</div>
</div>
<a id="abe6b50f74ddb53ff6ee4552c20a053bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6b50f74ddb53ff6ee4552c20a053bc">&#9670;&nbsp;</a></span>spdk_pci_device_get_vendor_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t spdk_pci_device_get_vendor_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the vendor ID of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>A pointer to the PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vendor ID of PCI device. </dd></dl>

</div>
</div>
<a id="ab1964fc8e4bdbe6c8fc3002f063a6747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1964fc8e4bdbe6c8fc3002f063a6747">&#9670;&nbsp;</a></span>spdk_pci_device_map_bar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_map_bar </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>mapped_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>phys_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a mapping of the virtual address to the BAR of the PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">bar</td><td>Index to the BAR. </td></tr>
    <tr><td class="paramname">mapped_addr</td><td>A pointer to the pointer to hold the virtual address of the mapping. </td></tr>
    <tr><td class="paramname">phys_addr</td><td>A pointer to the variable to hold the physical address of the mapping. </td></tr>
    <tr><td class="paramname">size</td><td>A pointer to the variable to hold the mapped size in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a id="aabfc985bf61ba230bea950e02391448c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabfc985bf61ba230bea950e02391448c">&#9670;&nbsp;</a></span>spdk_pci_device_unmap_bar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_unmap_bar </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the mapping of the virtual address to the BAR of the PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">bar</td><td>Index to the BAR. </td></tr>
    <tr><td class="paramname">addr</td><td>Virtual address to remove that must be the mapped_addr returned by a previous call to <a class="el" href="env_8h.html#ab1964fc8e4bdbe6c8fc3002f063a6747" title="Get a mapping of the virtual address to the BAR of the PCI device. ">spdk_pci_device_map_bar()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a id="ae3779ef938c1a803ca521af9b5c61033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3779ef938c1a803ca521af9b5c61033">&#9670;&nbsp;</a></span>spdk_pci_get_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_pci_device* spdk_pci_get_device </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>pci_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get PCI device from the given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pci_addr</td><td>A pointer to the PCI address struct.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the PCI device or NULL if no devide is found at the given address. </dd></dl>

</div>
</div>
<a id="ae7c48afea3729723d2a9b98342df42cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c48afea3729723d2a9b98342df42cc">&#9670;&nbsp;</a></span>spdk_pci_ioat_device_attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_ioat_device_attach </td>
          <td>(</td>
          <td class="paramtype">spdk_pci_enum_cb&#160;</td>
          <td class="paramname"><em>enum_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>enum_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>pci_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a I/OAT device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enum_cb</td><td>Called when the attach operation completes. </td></tr>
    <tr><td class="paramname">enum_ctx</td><td>Argument passed to the callback function. </td></tr>
    <tr><td class="paramname">pci_address</td><td>PCI address of the I/OAT device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="afb419df0c4f549fc77b8d81aa0d689d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb419df0c4f549fc77b8d81aa0d689d4">&#9670;&nbsp;</a></span>spdk_pci_ioat_enumerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_ioat_enumerate </td>
          <td>(</td>
          <td class="paramtype">spdk_pci_enum_cb&#160;</td>
          <td class="paramname"><em>enum_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>enum_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate I/OAT device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enum_cb</td><td>Called when the enumerate operation completes. </td></tr>
    <tr><td class="paramname">enum_ctx</td><td>Argument passed to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a8d0392d613054a008f9fbc22ef627e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0392d613054a008f9fbc22ef627e8d">&#9670;&nbsp;</a></span>spdk_pci_nvme_device_attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_nvme_device_attach </td>
          <td>(</td>
          <td class="paramtype">spdk_pci_enum_cb&#160;</td>
          <td class="paramname"><em>enum_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>enum_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>pci_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a NVMe device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enum_cb</td><td>Called when the attach operation completes. </td></tr>
    <tr><td class="paramname">enum_ctx</td><td>Argument passed to the callback function. </td></tr>
    <tr><td class="paramname">pci_address</td><td>PCI address of the NVMe device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a4fdff13ebe1c7830bee0788d6740d186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdff13ebe1c7830bee0788d6740d186">&#9670;&nbsp;</a></span>spdk_pci_nvme_enumerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_nvme_enumerate </td>
          <td>(</td>
          <td class="paramtype">spdk_pci_enum_cb&#160;</td>
          <td class="paramname"><em>enum_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>enum_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate NVMe devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enum_cb</td><td>Called when the enumerate operation completes. </td></tr>
    <tr><td class="paramname">enum_ctx</td><td>Argument passed to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="aabf5d89c817d3630b76925969fe0e490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf5d89c817d3630b76925969fe0e490">&#9670;&nbsp;</a></span>spdk_pci_virtio_device_attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_virtio_device_attach </td>
          <td>(</td>
          <td class="paramtype">spdk_pci_enum_cb&#160;</td>
          <td class="paramname"><em>enum_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>enum_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>pci_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a virtio device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enum_cb</td><td>Called when the attach operation completes. </td></tr>
    <tr><td class="paramname">enum_ctx</td><td>Argument passed to the callback function. </td></tr>
    <tr><td class="paramname">pci_address</td><td>PCI address of the virtio device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a90d0242f6123177ac5ac842732683ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d0242f6123177ac5ac842732683ae2">&#9670;&nbsp;</a></span>spdk_pci_virtio_enumerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_virtio_enumerate </td>
          <td>(</td>
          <td class="paramtype">spdk_pci_enum_cb&#160;</td>
          <td class="paramname"><em>enum_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>enum_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate virtio device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enum_cb</td><td>Called when the enumerate operation completes. </td></tr>
    <tr><td class="paramname">enum_ctx</td><td>Argument passed to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a798ae910c8563b33eea17af50cabb1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798ae910c8563b33eea17af50cabb1ab">&#9670;&nbsp;</a></span>spdk_process_is_primary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_process_is_primary </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the calling process is primary process. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the calling process is primary process, or false otherwise. </dd></dl>

</div>
</div>
<a id="a6320a791a777b2d518def6413e543ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6320a791a777b2d518def6413e543ac8">&#9670;&nbsp;</a></span>spdk_ring_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_ring_count </td>
          <td>(</td>
          <td class="paramtype">struct spdk_ring *&#160;</td>
          <td class="paramname"><em>ring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of objects in the ring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>the ring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of objects in the ring. </dd></dl>

</div>
</div>
<a id="a9f9038d37e14d07c89b399ee92bcbb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9038d37e14d07c89b399ee92bcbb87">&#9670;&nbsp;</a></span>spdk_ring_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_ring* spdk_ring_create </td>
          <td>(</td>
          <td class="paramtype">enum spdk_ring_type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a ring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Type for the ring. (SPDK_RING_TYPE_SP_SC or SPDK_RING_TYPE_MP_SC). </td></tr>
    <tr><td class="paramname">count</td><td>Size of the ring in elements. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the created ring. </dd></dl>

</div>
</div>
<a id="a982e1b212d497dbb209902f56b192afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982e1b212d497dbb209902f56b192afb">&#9670;&nbsp;</a></span>spdk_ring_dequeue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_ring_dequeue </td>
          <td>(</td>
          <td class="paramtype">struct spdk_ring *&#160;</td>
          <td class="paramname"><em>ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>objs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dequeue count objects from the ring into the array objs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>A pointer to the ring. </td></tr>
    <tr><td class="paramname">objs</td><td>A pointer to the array to be dequeued. </td></tr>
    <tr><td class="paramname">count</td><td>Maximum number of elements to be dequeued.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of objects dequeued which is less than 'count'. </dd></dl>

</div>
</div>
<a id="a94a5c5e5f14c336e7d64db996c0ed2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a5c5e5f14c336e7d64db996c0ed2dc">&#9670;&nbsp;</a></span>spdk_ring_enqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_ring_enqueue </td>
          <td>(</td>
          <td class="paramtype">struct spdk_ring *&#160;</td>
          <td class="paramname"><em>ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>objs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue the array of objects (with length count) on the ring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>A pointer to the ring. </td></tr>
    <tr><td class="paramname">objs</td><td>A pointer to the array to be queued. </td></tr>
    <tr><td class="paramname">count</td><td>Length count of the array of objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of objects enqueued. </dd></dl>

</div>
</div>
<a id="a3f1ec5c3714962d4b01ceb5a50571dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1ec5c3714962d4b01ceb5a50571dca">&#9670;&nbsp;</a></span>spdk_ring_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_ring_free </td>
          <td>(</td>
          <td class="paramtype">struct spdk_ring *&#160;</td>
          <td class="paramname"><em>ring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the ring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>Ring to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae96a59dc23cf16ed24029ea50598be5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96a59dc23cf16ed24029ea50598be5b">&#9670;&nbsp;</a></span>spdk_vtophys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_vtophys </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the physical address of a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A pointer to a buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the physical address of this buffer on success, or SPDK_VTOPHYS_ERROR on failure. </dd></dl>

</div>
</div>
<a id="a49ad245dae3554cf96d62e9b2b0b1596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ad245dae3554cf96d62e9b2b0b1596">&#9670;&nbsp;</a></span>spdk_zmalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_zmalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>phys_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate dma/sharable memory based on a given dma_flg. </p>
<p>It is a physically contiguous memory buffer with the given size, alignment and socket id. Also, the buffer will be zeroed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>Alignment value for the allocated memory. If '0', the allocated buffer is suitably aligned (in the same manner as malloc()). Otherwise, the allocated buffer is aligned to the multiple of align. In this case, it must be a power of two. </td></tr>
    <tr><td class="paramname">phys_addr</td><td>A pointer to the variable to hold the physical address of the allocated buffer is passed. If NULL, the physical address is not returned. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket. </td></tr>
    <tr><td class="paramname">flags</td><td>Combination of SPDK_MALLOC flags (<a class="el" href="env_8h.html#a7f065a5e897ff548b2dbf0996608929a">SPDK_MALLOC_DMA</a>, <a class="el" href="env_8h.html#ad1660ffa6731090ef3f480c295a87dba">SPDK_MALLOC_SHARE</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory buffer. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
