<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.11">
  <title>SPDK: env.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-sm-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://ci.spdk.io/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/roadmap/">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('env_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">env.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulated third-party dependencies.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__env__opts.html">spdk_env_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Environment initialization options.  <a href="structspdk__env__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__pci__id.html">spdk_pci_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3e5247302342025f028c57bc024291b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e5247302342025f028c57bc024291b1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_ENV_SOCKET_ID_ANY</b>&#160;&#160;&#160;(-1)</td></tr>
<tr class="separator:a3e5247302342025f028c57bc024291b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab337c70c632ec69967444fcdd4ab17c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab337c70c632ec69967444fcdd4ab17c2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_ENV_LCORE_ID_ANY</b>&#160;&#160;&#160;(UINT32_MAX)</td></tr>
<tr class="separator:ab337c70c632ec69967444fcdd4ab17c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1856012938db5f1c0beba921ee5a7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba1856012938db5f1c0beba921ee5a7c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_MEMPOOL_DEFAULT_CACHE_SIZE</b>&#160;&#160;&#160;SIZE_MAX</td></tr>
<tr class="separator:aba1856012938db5f1c0beba921ee5a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d08df976f75c1e47ce174ebc446f95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_ENV_FOREACH_CORE</b>(i)</td></tr>
<tr class="separator:a42d08df976f75c1e47ce174ebc446f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eb4a0e044f1a5e9515b8c2f96078a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26eb4a0e044f1a5e9515b8c2f96078a4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_VTOPHYS_ERROR</b>&#160;&#160;&#160;(0xFFFFFFFFFFFFFFFFULL)</td></tr>
<tr class="separator:a26eb4a0e044f1a5e9515b8c2f96078a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0083ace78471c3d3d247e21e4968d526"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0083ace78471c3d3d247e21e4968d526"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>thread_start_fn</b>) (void *)</td></tr>
<tr class="separator:a0083ace78471c3d3d247e21e4968d526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbcd903dfa26b4e625bdbef66b6d6a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdbcd903dfa26b4e625bdbef66b6d6a8"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_enum_cb</b>) (void *enum_ctx, struct spdk_pci_device *pci_dev)</td></tr>
<tr class="separator:abdbcd903dfa26b4e625bdbef66b6d6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac018be4449e60d4e5992e1e4be9bbef3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac018be4449e60d4e5992e1e4be9bbef3"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_mem_map_notify_cb</b>) (void *cb_ctx, struct spdk_mem_map *map, enum spdk_mem_map_notify_action action, void *vaddr, size_t size)</td></tr>
<tr class="separator:ac018be4449e60d4e5992e1e4be9bbef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a88610413d6db3cc0eaafa4bda0f2caa9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88610413d6db3cc0eaafa4bda0f2caa9"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_ring_type</b> { <b>SPDK_RING_TYPE_SP_SC</b>, 
<b>SPDK_RING_TYPE_MP_SC</b>
 }</td></tr>
<tr class="separator:a88610413d6db3cc0eaafa4bda0f2caa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96af19906abf2a01e9f1f2105f90722c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96af19906abf2a01e9f1f2105f90722c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_mem_map_notify_action</b> { <b>SPDK_MEM_MAP_NOTIFY_REGISTER</b>, 
<b>SPDK_MEM_MAP_NOTIFY_UNREGISTER</b>
 }</td></tr>
<tr class="separator:a96af19906abf2a01e9f1f2105f90722c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af3b1a05d3f4dee14ba3f980672c9b3a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3b1a05d3f4dee14ba3f980672c9b3a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#af3b1a05d3f4dee14ba3f980672c9b3a6">spdk_env_opts_init</a> (struct <a class="el" href="structspdk__env__opts.html">spdk_env_opts</a> *opts)</td></tr>
<tr class="memdesc:af3b1a05d3f4dee14ba3f980672c9b3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the default value of opts. <br /></td></tr>
<tr class="separator:af3b1a05d3f4dee14ba3f980672c9b3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64eecb39affafd001dfddcdf60114906"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a64eecb39affafd001dfddcdf60114906">spdk_env_init</a> (const struct <a class="el" href="structspdk__env__opts.html">spdk_env_opts</a> *opts)</td></tr>
<tr class="memdesc:a64eecb39affafd001dfddcdf60114906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the environment library.  <a href="#a64eecb39affafd001dfddcdf60114906">More...</a><br /></td></tr>
<tr class="separator:a64eecb39affafd001dfddcdf60114906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0874731c44ac31e4b14d91c6844a87d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0874731c44ac31e4b14d91c6844a87d1"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a0874731c44ac31e4b14d91c6844a87d1">spdk_dma_malloc</a> (size_t size, size_t align, uint64_t *phys_addr)</td></tr>
<tr class="memdesc:a0874731c44ac31e4b14d91c6844a87d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a pinned, physically contiguous memory buffer with the given size and alignment. <br /></td></tr>
<tr class="separator:a0874731c44ac31e4b14d91c6844a87d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c470325a493f204e1b1535d4b7bb1e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c470325a493f204e1b1535d4b7bb1e9"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a4c470325a493f204e1b1535d4b7bb1e9">spdk_dma_malloc_socket</a> (size_t size, size_t align, uint64_t *phys_addr, int socket_id)</td></tr>
<tr class="memdesc:a4c470325a493f204e1b1535d4b7bb1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a pinned, physically contiguous memory buffer with the given size, alignment and socket id. <br /></td></tr>
<tr class="separator:a4c470325a493f204e1b1535d4b7bb1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b4bd563b918e721fd5006bfe960bc6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab5b4bd563b918e721fd5006bfe960bc6">spdk_dma_zmalloc</a> (size_t size, size_t align, uint64_t *phys_addr)</td></tr>
<tr class="memdesc:ab5b4bd563b918e721fd5006bfe960bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a pinned, physically contiguous memory buffer with the given size and alignment.  <a href="#ab5b4bd563b918e721fd5006bfe960bc6">More...</a><br /></td></tr>
<tr class="separator:ab5b4bd563b918e721fd5006bfe960bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4e9f571d0b77a46ef0192e4cfb13f0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a7f4e9f571d0b77a46ef0192e4cfb13f0">spdk_dma_zmalloc_socket</a> (size_t size, size_t align, uint64_t *phys_addr, int socket_id)</td></tr>
<tr class="memdesc:a7f4e9f571d0b77a46ef0192e4cfb13f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a pinned, physically contiguous memory buffer with the given size, alignment and socket id.  <a href="#a7f4e9f571d0b77a46ef0192e4cfb13f0">More...</a><br /></td></tr>
<tr class="separator:a7f4e9f571d0b77a46ef0192e4cfb13f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205172871786d57fca65f76a96874cdb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a205172871786d57fca65f76a96874cdb">spdk_dma_realloc</a> (void *buf, size_t size, size_t align, uint64_t *phys_addr)</td></tr>
<tr class="memdesc:a205172871786d57fca65f76a96874cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the allocated and pinned memory buffer with the given new size and alignment.  <a href="#a205172871786d57fca65f76a96874cdb">More...</a><br /></td></tr>
<tr class="separator:a205172871786d57fca65f76a96874cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd01324e661a5d6deb59bd2bc6230de3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#acd01324e661a5d6deb59bd2bc6230de3">spdk_dma_free</a> (void *buf)</td></tr>
<tr class="memdesc:acd01324e661a5d6deb59bd2bc6230de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a memory buffer previously allocated with spdk_dma_zmalloc.  <a href="#acd01324e661a5d6deb59bd2bc6230de3">More...</a><br /></td></tr>
<tr class="separator:acd01324e661a5d6deb59bd2bc6230de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48afc08099440a88e9e8dc3abf540ab9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a48afc08099440a88e9e8dc3abf540ab9">spdk_memzone_reserve</a> (const char *name, size_t len, int socket_id, unsigned flags)</td></tr>
<tr class="memdesc:a48afc08099440a88e9e8dc3abf540ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve a named, process shared memory zone with the given size, socket_id and flags.  <a href="#a48afc08099440a88e9e8dc3abf540ab9">More...</a><br /></td></tr>
<tr class="separator:a48afc08099440a88e9e8dc3abf540ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be5bc3f8fc570f45f2ad087fcb91f9e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a2be5bc3f8fc570f45f2ad087fcb91f9e">spdk_memzone_lookup</a> (const char *name)</td></tr>
<tr class="memdesc:a2be5bc3f8fc570f45f2ad087fcb91f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup the memory zone identified by the given name.  <a href="#a2be5bc3f8fc570f45f2ad087fcb91f9e">More...</a><br /></td></tr>
<tr class="separator:a2be5bc3f8fc570f45f2ad087fcb91f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7f9a6391c0e076abd0160b24f2ad81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c7f9a6391c0e076abd0160b24f2ad81"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a5c7f9a6391c0e076abd0160b24f2ad81">spdk_memzone_free</a> (const char *name)</td></tr>
<tr class="memdesc:a5c7f9a6391c0e076abd0160b24f2ad81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory zone identified by the given name. <br /></td></tr>
<tr class="separator:a5c7f9a6391c0e076abd0160b24f2ad81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b47302a948b71f493ae775b53f162e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b47302a948b71f493ae775b53f162e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8b47302a948b71f493ae775b53f162e2">spdk_memzone_dump</a> (FILE *f)</td></tr>
<tr class="memdesc:a8b47302a948b71f493ae775b53f162e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump debug information about all memzones. <br /></td></tr>
<tr class="separator:a8b47302a948b71f493ae775b53f162e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4f7842191990b49694495bba10fcbd"><td class="memItemLeft" align="right" valign="top">struct spdk_mempool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8d4f7842191990b49694495bba10fcbd">spdk_mempool_create</a> (const char *name, size_t count, size_t ele_size, size_t cache_size, int socket_id)</td></tr>
<tr class="memdesc:a8d4f7842191990b49694495bba10fcbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread-safe memory pool.  <a href="#a8d4f7842191990b49694495bba10fcbd">More...</a><br /></td></tr>
<tr class="separator:a8d4f7842191990b49694495bba10fcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d2feacf9f6979db875add06ab06494"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9d2feacf9f6979db875add06ab06494"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab9d2feacf9f6979db875add06ab06494">spdk_mempool_free</a> (struct spdk_mempool *mp)</td></tr>
<tr class="memdesc:ab9d2feacf9f6979db875add06ab06494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a memory pool. <br /></td></tr>
<tr class="separator:ab9d2feacf9f6979db875add06ab06494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5041ebc03066dede6e0972c22dc77f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ada5041ebc03066dede6e0972c22dc77f">spdk_mempool_get</a> (struct spdk_mempool *mp)</td></tr>
<tr class="memdesc:ada5041ebc03066dede6e0972c22dc77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element from a memory pool.  <a href="#ada5041ebc03066dede6e0972c22dc77f">More...</a><br /></td></tr>
<tr class="separator:ada5041ebc03066dede6e0972c22dc77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56233342766c54990e044b8ca2f3d41a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56233342766c54990e044b8ca2f3d41a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a56233342766c54990e044b8ca2f3d41a">spdk_mempool_put</a> (struct spdk_mempool *mp, void *ele)</td></tr>
<tr class="memdesc:a56233342766c54990e044b8ca2f3d41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an element back into the memory pool. <br /></td></tr>
<tr class="separator:a56233342766c54990e044b8ca2f3d41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fc57c5f23f34aa1cf56ed355daa3b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3fc57c5f23f34aa1cf56ed355daa3b8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ac3fc57c5f23f34aa1cf56ed355daa3b8">spdk_mempool_put_bulk</a> (struct spdk_mempool *mp, void *const *ele_arr, size_t count)</td></tr>
<tr class="memdesc:ac3fc57c5f23f34aa1cf56ed355daa3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put multiple elements back into the memory pool. <br /></td></tr>
<tr class="separator:ac3fc57c5f23f34aa1cf56ed355daa3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434cdf73691c745e717b8b794b2acb52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a434cdf73691c745e717b8b794b2acb52"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a434cdf73691c745e717b8b794b2acb52">spdk_mempool_count</a> (const struct spdk_mempool *pool)</td></tr>
<tr class="memdesc:a434cdf73691c745e717b8b794b2acb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of entries in the mempool. <br /></td></tr>
<tr class="separator:a434cdf73691c745e717b8b794b2acb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4461ccdde430461ad2756b3799099330"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4461ccdde430461ad2756b3799099330"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a4461ccdde430461ad2756b3799099330">spdk_env_get_core_count</a> (void)</td></tr>
<tr class="memdesc:a4461ccdde430461ad2756b3799099330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of dedicated CPU cores utilized by this env abstraction. <br /></td></tr>
<tr class="separator:a4461ccdde430461ad2756b3799099330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2483610a36d7daa9e6b067d9270d0087"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a2483610a36d7daa9e6b067d9270d0087">spdk_env_get_current_core</a> (void)</td></tr>
<tr class="memdesc:a2483610a36d7daa9e6b067d9270d0087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the CPU core index of the current thread.  <a href="#a2483610a36d7daa9e6b067d9270d0087">More...</a><br /></td></tr>
<tr class="separator:a2483610a36d7daa9e6b067d9270d0087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2127ecc88ceb8e4b1242c316634de50e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2127ecc88ceb8e4b1242c316634de50e"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a2127ecc88ceb8e4b1242c316634de50e">spdk_env_get_first_core</a> (void)</td></tr>
<tr class="memdesc:a2127ecc88ceb8e4b1242c316634de50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the first dedicated CPU core for this application. <br /></td></tr>
<tr class="separator:a2127ecc88ceb8e4b1242c316634de50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab480f817ecdd801a0e53a4d8494ffc67"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab480f817ecdd801a0e53a4d8494ffc67">spdk_env_get_next_core</a> (uint32_t prev_core)</td></tr>
<tr class="memdesc:ab480f817ecdd801a0e53a4d8494ffc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the next dedicated CPU core for this application.  <a href="#ab480f817ecdd801a0e53a4d8494ffc67">More...</a><br /></td></tr>
<tr class="separator:ab480f817ecdd801a0e53a4d8494ffc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18052aa1bc0ff634ffc0ce11c577d65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab18052aa1bc0ff634ffc0ce11c577d65"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab18052aa1bc0ff634ffc0ce11c577d65">spdk_env_get_socket_id</a> (uint32_t core)</td></tr>
<tr class="memdesc:ab18052aa1bc0ff634ffc0ce11c577d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the socket ID for the given core. <br /></td></tr>
<tr class="separator:ab18052aa1bc0ff634ffc0ce11c577d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4282feec502eca721136e88c824d59cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a4282feec502eca721136e88c824d59cf">spdk_env_thread_launch_pinned</a> (uint32_t core, thread_start_fn fn, void *arg)</td></tr>
<tr class="memdesc:a4282feec502eca721136e88c824d59cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch a thread pinned to the given core.  <a href="#a4282feec502eca721136e88c824d59cf">More...</a><br /></td></tr>
<tr class="separator:a4282feec502eca721136e88c824d59cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7e5ab204489da6d344999e4a0c8a73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec7e5ab204489da6d344999e4a0c8a73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aec7e5ab204489da6d344999e4a0c8a73">spdk_env_thread_wait_all</a> (void)</td></tr>
<tr class="memdesc:aec7e5ab204489da6d344999e4a0c8a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all threads to exit before returning. <br /></td></tr>
<tr class="separator:aec7e5ab204489da6d344999e4a0c8a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798ae910c8563b33eea17af50cabb1ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a798ae910c8563b33eea17af50cabb1ab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a798ae910c8563b33eea17af50cabb1ab">spdk_process_is_primary</a> (void)</td></tr>
<tr class="memdesc:a798ae910c8563b33eea17af50cabb1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the calling process is primary process. <br /></td></tr>
<tr class="separator:a798ae910c8563b33eea17af50cabb1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d868d272aa0c000f6135966dfadc596"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d868d272aa0c000f6135966dfadc596"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596">spdk_get_ticks</a> (void)</td></tr>
<tr class="memdesc:a7d868d272aa0c000f6135966dfadc596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a monotonic timestamp counter. <br /></td></tr>
<tr class="separator:a7d868d272aa0c000f6135966dfadc596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7d0eb3000d71b588486cf9903cd434"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e7d0eb3000d71b588486cf9903cd434"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a0e7d0eb3000d71b588486cf9903cd434">spdk_get_ticks_hz</a> (void)</td></tr>
<tr class="memdesc:a0e7d0eb3000d71b588486cf9903cd434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tick rate of <a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596" title="Get a monotonic timestamp counter. ">spdk_get_ticks()</a> per second. <br /></td></tr>
<tr class="separator:a0e7d0eb3000d71b588486cf9903cd434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e338ce2d6510489ae83bfff226b8b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2e338ce2d6510489ae83bfff226b8b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab2e338ce2d6510489ae83bfff226b8b1">spdk_delay_us</a> (unsigned int us)</td></tr>
<tr class="memdesc:ab2e338ce2d6510489ae83bfff226b8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay the given number of microseconds. <br /></td></tr>
<tr class="separator:ab2e338ce2d6510489ae83bfff226b8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9038d37e14d07c89b399ee92bcbb87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f9038d37e14d07c89b399ee92bcbb87"></a>
struct spdk_ring *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a9f9038d37e14d07c89b399ee92bcbb87">spdk_ring_create</a> (enum spdk_ring_type type, size_t count, int socket_id)</td></tr>
<tr class="memdesc:a9f9038d37e14d07c89b399ee92bcbb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a ring. <br /></td></tr>
<tr class="separator:a9f9038d37e14d07c89b399ee92bcbb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1ec5c3714962d4b01ceb5a50571dca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f1ec5c3714962d4b01ceb5a50571dca"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a3f1ec5c3714962d4b01ceb5a50571dca">spdk_ring_free</a> (struct spdk_ring *ring)</td></tr>
<tr class="memdesc:a3f1ec5c3714962d4b01ceb5a50571dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the ring. <br /></td></tr>
<tr class="separator:a3f1ec5c3714962d4b01ceb5a50571dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6320a791a777b2d518def6413e543ac8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a6320a791a777b2d518def6413e543ac8">spdk_ring_count</a> (struct spdk_ring *ring)</td></tr>
<tr class="memdesc:a6320a791a777b2d518def6413e543ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of objects in the ring.  <a href="#a6320a791a777b2d518def6413e543ac8">More...</a><br /></td></tr>
<tr class="separator:a6320a791a777b2d518def6413e543ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a5c5e5f14c336e7d64db996c0ed2dc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a94a5c5e5f14c336e7d64db996c0ed2dc">spdk_ring_enqueue</a> (struct spdk_ring *ring, void **objs, size_t count)</td></tr>
<tr class="memdesc:a94a5c5e5f14c336e7d64db996c0ed2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue the array of objects (with length count) on the ring.  <a href="#a94a5c5e5f14c336e7d64db996c0ed2dc">More...</a><br /></td></tr>
<tr class="separator:a94a5c5e5f14c336e7d64db996c0ed2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982e1b212d497dbb209902f56b192afb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a982e1b212d497dbb209902f56b192afb">spdk_ring_dequeue</a> (struct spdk_ring *ring, void **objs, size_t count)</td></tr>
<tr class="memdesc:a982e1b212d497dbb209902f56b192afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue count objects from the ring into the array objs.  <a href="#a982e1b212d497dbb209902f56b192afb">More...</a><br /></td></tr>
<tr class="separator:a982e1b212d497dbb209902f56b192afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96a59dc23cf16ed24029ea50598be5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae96a59dc23cf16ed24029ea50598be5b"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_vtophys</b> (void *buf)</td></tr>
<tr class="separator:ae96a59dc23cf16ed24029ea50598be5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdff13ebe1c7830bee0788d6740d186"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fdff13ebe1c7830bee0788d6740d186"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_nvme_enumerate</b> (spdk_pci_enum_cb enum_cb, void *enum_ctx)</td></tr>
<tr class="separator:a4fdff13ebe1c7830bee0788d6740d186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb419df0c4f549fc77b8d81aa0d689d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb419df0c4f549fc77b8d81aa0d689d4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_ioat_enumerate</b> (spdk_pci_enum_cb enum_cb, void *enum_ctx)</td></tr>
<tr class="separator:afb419df0c4f549fc77b8d81aa0d689d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d0242f6123177ac5ac842732683ae2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90d0242f6123177ac5ac842732683ae2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_virtio_enumerate</b> (spdk_pci_enum_cb enum_cb, void *enum_ctx)</td></tr>
<tr class="separator:a90d0242f6123177ac5ac842732683ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3779ef938c1a803ca521af9b5c61033"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3779ef938c1a803ca521af9b5c61033"></a>
struct spdk_pci_device *&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_get_device</b> (struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *pci_addr)</td></tr>
<tr class="separator:ae3779ef938c1a803ca521af9b5c61033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1964fc8e4bdbe6c8fc3002f063a6747"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1964fc8e4bdbe6c8fc3002f063a6747"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_map_bar</b> (struct spdk_pci_device *dev, uint32_t bar, void **mapped_addr, uint64_t *phys_addr, uint64_t *size)</td></tr>
<tr class="separator:ab1964fc8e4bdbe6c8fc3002f063a6747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabfc985bf61ba230bea950e02391448c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabfc985bf61ba230bea950e02391448c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_unmap_bar</b> (struct spdk_pci_device *dev, uint32_t bar, void *addr)</td></tr>
<tr class="separator:aabfc985bf61ba230bea950e02391448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b6650e48ccffaea6ca59fe0b875da5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10b6650e48ccffaea6ca59fe0b875da5"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_get_domain</b> (struct spdk_pci_device *dev)</td></tr>
<tr class="separator:a10b6650e48ccffaea6ca59fe0b875da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae16576e55bc5015818abc07c370244"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ae16576e55bc5015818abc07c370244"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_get_bus</b> (struct spdk_pci_device *dev)</td></tr>
<tr class="separator:a1ae16576e55bc5015818abc07c370244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5027b309c5a3210250d896ed5c9b0f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5027b309c5a3210250d896ed5c9b0f8"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_get_dev</b> (struct spdk_pci_device *dev)</td></tr>
<tr class="separator:ae5027b309c5a3210250d896ed5c9b0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4342c5bc69edb7b42a3873e54bd2d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c4342c5bc69edb7b42a3873e54bd2d7"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_get_func</b> (struct spdk_pci_device *dev)</td></tr>
<tr class="separator:a6c4342c5bc69edb7b42a3873e54bd2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71622d665e7b50f34d2279e7e86b557e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71622d665e7b50f34d2279e7e86b557e"></a>
struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_get_addr</b> (struct spdk_pci_device *dev)</td></tr>
<tr class="separator:a71622d665e7b50f34d2279e7e86b557e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6b50f74ddb53ff6ee4552c20a053bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe6b50f74ddb53ff6ee4552c20a053bc"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_get_vendor_id</b> (struct spdk_pci_device *dev)</td></tr>
<tr class="separator:abe6b50f74ddb53ff6ee4552c20a053bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2553026e46a40c274980b5b201b0cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b2553026e46a40c274980b5b201b0cb"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_get_device_id</b> (struct spdk_pci_device *dev)</td></tr>
<tr class="separator:a8b2553026e46a40c274980b5b201b0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae488ab8a8a1b56ae22ca26b00185f7f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae488ab8a8a1b56ae22ca26b00185f7f8"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_get_subvendor_id</b> (struct spdk_pci_device *dev)</td></tr>
<tr class="separator:ae488ab8a8a1b56ae22ca26b00185f7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6368feb8685db7cc745f14e184a5e3e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6368feb8685db7cc745f14e184a5e3e0"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_get_subdevice_id</b> (struct spdk_pci_device *dev)</td></tr>
<tr class="separator:a6368feb8685db7cc745f14e184a5e3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5c2f463bddbce4cc846e04246f6414"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c5c2f463bddbce4cc846e04246f6414"></a>
struct <a class="el" href="structspdk__pci__id.html">spdk_pci_id</a>&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_get_id</b> (struct spdk_pci_device *dev)</td></tr>
<tr class="separator:a5c5c2f463bddbce4cc846e04246f6414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235f1c632be6dc00aad1cf8fd0314609"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a235f1c632be6dc00aad1cf8fd0314609">spdk_pci_device_get_socket_id</a> (struct spdk_pci_device *dev)</td></tr>
<tr class="memdesc:a235f1c632be6dc00aad1cf8fd0314609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NUMA socket ID of a PCI device.  <a href="#a235f1c632be6dc00aad1cf8fd0314609">More...</a><br /></td></tr>
<tr class="separator:a235f1c632be6dc00aad1cf8fd0314609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b979316610b357a35d03500c3059af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69b979316610b357a35d03500c3059af"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_get_serial_number</b> (struct spdk_pci_device *dev, char *sn, size_t len)</td></tr>
<tr class="separator:a69b979316610b357a35d03500c3059af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1866b3d6e63d1b7be5db38b2094d89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#afa1866b3d6e63d1b7be5db38b2094d89">spdk_pci_device_claim</a> (const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *pci_addr)</td></tr>
<tr class="memdesc:afa1866b3d6e63d1b7be5db38b2094d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claim a PCI device for exclusive SPDK userspace access.  <a href="#afa1866b3d6e63d1b7be5db38b2094d89">More...</a><br /></td></tr>
<tr class="separator:afa1866b3d6e63d1b7be5db38b2094d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98502fc8d794fadaae348496d421082"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa98502fc8d794fadaae348496d421082"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_detach</b> (struct spdk_pci_device *device)</td></tr>
<tr class="separator:aa98502fc8d794fadaae348496d421082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0392d613054a008f9fbc22ef627e8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d0392d613054a008f9fbc22ef627e8d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_nvme_device_attach</b> (spdk_pci_enum_cb enum_cb, void *enum_ctx, struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *pci_address)</td></tr>
<tr class="separator:a8d0392d613054a008f9fbc22ef627e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c48afea3729723d2a9b98342df42cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7c48afea3729723d2a9b98342df42cc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_ioat_device_attach</b> (spdk_pci_enum_cb enum_cb, void *enum_ctx, struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *pci_address)</td></tr>
<tr class="separator:ae7c48afea3729723d2a9b98342df42cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf5d89c817d3630b76925969fe0e490"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabf5d89c817d3630b76925969fe0e490"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_virtio_device_attach</b> (spdk_pci_enum_cb enum_cb, void *enum_ctx, struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *pci_address)</td></tr>
<tr class="separator:aabf5d89c817d3630b76925969fe0e490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8678c0214fa5f08c3d63784eddbe6221"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8678c0214fa5f08c3d63784eddbe6221"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_cfg_read</b> (struct spdk_pci_device *dev, void *value, uint32_t len, uint32_t offset)</td></tr>
<tr class="separator:a8678c0214fa5f08c3d63784eddbe6221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b07f91a80793a6b97634d38734f5457"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b07f91a80793a6b97634d38734f5457"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_cfg_write</b> (struct spdk_pci_device *dev, void *value, uint32_t len, uint32_t offset)</td></tr>
<tr class="separator:a0b07f91a80793a6b97634d38734f5457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8e0b6936b5844b354b92278f66fa2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f8e0b6936b5844b354b92278f66fa2d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_cfg_read8</b> (struct spdk_pci_device *dev, uint8_t *value, uint32_t offset)</td></tr>
<tr class="separator:a1f8e0b6936b5844b354b92278f66fa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff1870d9b97e71f90d63825f0cb32b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ff1870d9b97e71f90d63825f0cb32b4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_cfg_write8</b> (struct spdk_pci_device *dev, uint8_t value, uint32_t offset)</td></tr>
<tr class="separator:a9ff1870d9b97e71f90d63825f0cb32b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e23e878bfc1748fce850d4d7f5b952c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e23e878bfc1748fce850d4d7f5b952c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_cfg_read16</b> (struct spdk_pci_device *dev, uint16_t *value, uint32_t offset)</td></tr>
<tr class="separator:a4e23e878bfc1748fce850d4d7f5b952c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b1abf6aacaba2d08bfa9b008c510c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20b1abf6aacaba2d08bfa9b008c510c4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_cfg_write16</b> (struct spdk_pci_device *dev, uint16_t value, uint32_t offset)</td></tr>
<tr class="separator:a20b1abf6aacaba2d08bfa9b008c510c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc70272071da54727134f9f13ed9771"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dc70272071da54727134f9f13ed9771"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_cfg_read32</b> (struct spdk_pci_device *dev, uint32_t *value, uint32_t offset)</td></tr>
<tr class="separator:a5dc70272071da54727134f9f13ed9771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488cf86d1c41376aaf526251fc7e3f07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a488cf86d1c41376aaf526251fc7e3f07"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_device_cfg_write32</b> (struct spdk_pci_device *dev, uint32_t value, uint32_t offset)</td></tr>
<tr class="separator:a488cf86d1c41376aaf526251fc7e3f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3decf485d6b797775bc4dd2215eb52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a7f3decf485d6b797775bc4dd2215eb52">spdk_pci_addr_compare</a> (const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *a1, const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *a2)</td></tr>
<tr class="memdesc:a7f3decf485d6b797775bc4dd2215eb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two PCI addresses.  <a href="#a7f3decf485d6b797775bc4dd2215eb52">More...</a><br /></td></tr>
<tr class="separator:a7f3decf485d6b797775bc4dd2215eb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96187c4c0c5a302669f684e487ebaa0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a96187c4c0c5a302669f684e487ebaa0d">spdk_pci_addr_parse</a> (struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *addr, const char *bdf)</td></tr>
<tr class="memdesc:a96187c4c0c5a302669f684e487ebaa0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string representation of a PCI address into a struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a>.  <a href="#a96187c4c0c5a302669f684e487ebaa0d">More...</a><br /></td></tr>
<tr class="separator:a96187c4c0c5a302669f684e487ebaa0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492c0520e80d8be841891e4d1bd7a446"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a492c0520e80d8be841891e4d1bd7a446">spdk_pci_addr_fmt</a> (char *bdf, size_t sz, const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *addr)</td></tr>
<tr class="memdesc:a492c0520e80d8be841891e4d1bd7a446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> to a string.  <a href="#a492c0520e80d8be841891e4d1bd7a446">More...</a><br /></td></tr>
<tr class="separator:a492c0520e80d8be841891e4d1bd7a446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925f8e1d1ed12fc1b7eb057a5c5b7bfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a925f8e1d1ed12fc1b7eb057a5c5b7bfd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a925f8e1d1ed12fc1b7eb057a5c5b7bfd">spdk_unaffinitize_thread</a> (void)</td></tr>
<tr class="memdesc:a925f8e1d1ed12fc1b7eb057a5c5b7bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any CPU affinitization from the current thread. <br /></td></tr>
<tr class="separator:a925f8e1d1ed12fc1b7eb057a5c5b7bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafaea6fc34059237e54e0ab254d0f28"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#abafaea6fc34059237e54e0ab254d0f28">spdk_call_unaffinitized</a> (void *cb(void *arg), void *arg)</td></tr>
<tr class="memdesc:abafaea6fc34059237e54e0ab254d0f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function with CPU affinity unset.  <a href="#abafaea6fc34059237e54e0ab254d0f28">More...</a><br /></td></tr>
<tr class="separator:abafaea6fc34059237e54e0ab254d0f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512b5ef37a363a4c8e234c060b734605"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a512b5ef37a363a4c8e234c060b734605"></a>
struct spdk_mem_map *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a512b5ef37a363a4c8e234c060b734605">spdk_mem_map_alloc</a> (uint64_t default_translation, spdk_mem_map_notify_cb notify_cb, void *cb_ctx)</td></tr>
<tr class="memdesc:a512b5ef37a363a4c8e234c060b734605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a virtual memory address translation map. <br /></td></tr>
<tr class="separator:a512b5ef37a363a4c8e234c060b734605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88ed69bd8b9a057f672a1170f7a5b6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af88ed69bd8b9a057f672a1170f7a5b6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#af88ed69bd8b9a057f672a1170f7a5b6c">spdk_mem_map_free</a> (struct spdk_mem_map **pmap)</td></tr>
<tr class="memdesc:af88ed69bd8b9a057f672a1170f7a5b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a memory map previously allocated by <a class="el" href="env_8h.html#a512b5ef37a363a4c8e234c060b734605" title="Allocate a virtual memory address translation map. ">spdk_mem_map_alloc()</a> <br /></td></tr>
<tr class="separator:af88ed69bd8b9a057f672a1170f7a5b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3314f2917141bf11f5b125c306d4397d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a3314f2917141bf11f5b125c306d4397d">spdk_mem_map_set_translation</a> (struct spdk_mem_map *map, uint64_t vaddr, uint64_t size, uint64_t translation)</td></tr>
<tr class="memdesc:a3314f2917141bf11f5b125c306d4397d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an address translation for a range of virtual memory.  <a href="#a3314f2917141bf11f5b125c306d4397d">More...</a><br /></td></tr>
<tr class="separator:a3314f2917141bf11f5b125c306d4397d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb4967ae71277512334ad27ef481326"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a2fb4967ae71277512334ad27ef481326">spdk_mem_map_clear_translation</a> (struct spdk_mem_map *map, uint64_t vaddr, uint64_t size)</td></tr>
<tr class="memdesc:a2fb4967ae71277512334ad27ef481326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister an address translation.  <a href="#a2fb4967ae71277512334ad27ef481326">More...</a><br /></td></tr>
<tr class="separator:a2fb4967ae71277512334ad27ef481326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93008c5c5f0c79c286b7edd70343ee1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa93008c5c5f0c79c286b7edd70343ee1"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aa93008c5c5f0c79c286b7edd70343ee1">spdk_mem_map_translate</a> (const struct spdk_mem_map *map, uint64_t vaddr)</td></tr>
<tr class="memdesc:aa93008c5c5f0c79c286b7edd70343ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the translation of a virtual address in a memory map. <br /></td></tr>
<tr class="separator:aa93008c5c5f0c79c286b7edd70343ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae046c45de2849d15f29dedc52e915ad7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ae046c45de2849d15f29dedc52e915ad7">spdk_mem_register</a> (void *vaddr, size_t len)</td></tr>
<tr class="memdesc:ae046c45de2849d15f29dedc52e915ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the specified memory region for address translation.  <a href="#ae046c45de2849d15f29dedc52e915ad7">More...</a><br /></td></tr>
<tr class="separator:ae046c45de2849d15f29dedc52e915ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffa0c74e2d73703266cad2d5d103f09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a3ffa0c74e2d73703266cad2d5d103f09">spdk_mem_unregister</a> (void *vaddr, size_t len)</td></tr>
<tr class="memdesc:a3ffa0c74e2d73703266cad2d5d103f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister the specified memory region from vtophys address translation.  <a href="#a3ffa0c74e2d73703266cad2d5d103f09">More...</a><br /></td></tr>
<tr class="separator:a3ffa0c74e2d73703266cad2d5d103f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulated third-party dependencies. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a42d08df976f75c1e47ce174ebc446f95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPDK_ENV_FOREACH_CORE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span> (i = <a class="code" href="env_8h.html#a2127ecc88ceb8e4b1242c316634de50e">spdk_env_get_first_core</a>();     \</div><div class="line">             i &lt; UINT32_MAX;                    \</div><div class="line">             i = <a class="code" href="env_8h.html#ab480f817ecdd801a0e53a4d8494ffc67">spdk_env_get_next_core</a>(i))</div><div class="ttc" id="env_8h_html_ab480f817ecdd801a0e53a4d8494ffc67"><div class="ttname"><a href="env_8h.html#ab480f817ecdd801a0e53a4d8494ffc67">spdk_env_get_next_core</a></div><div class="ttdeci">uint32_t spdk_env_get_next_core(uint32_t prev_core)</div><div class="ttdoc">Return the index of the next dedicated CPU core for this application. </div></div>
<div class="ttc" id="env_8h_html_a2127ecc88ceb8e4b1242c316634de50e"><div class="ttname"><a href="env_8h.html#a2127ecc88ceb8e4b1242c316634de50e">spdk_env_get_first_core</a></div><div class="ttdeci">uint32_t spdk_env_get_first_core(void)</div><div class="ttdoc">Return the index of the first dedicated CPU core for this application. </div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="abafaea6fc34059237e54e0ab254d0f28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_call_unaffinitized </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb</em>void *arg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function with CPU affinity unset. </p>
<p>This can be used to run a function that creates other threads without inheriting the calling thread's CPU affinity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>function to call </td></tr>
    <tr><td class="paramname">arg</td><td>parameter to cb function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value of cb() </dd></dl>

</div>
</div>
<a class="anchor" id="acd01324e661a5d6deb59bd2bc6230de3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_dma_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a memory buffer previously allocated with spdk_dma_zmalloc. </p>
<p>This call is never made from the performance path. </p>

</div>
</div>
<a class="anchor" id="a205172871786d57fca65f76a96874cdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_dma_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>phys_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the allocated and pinned memory buffer with the given new size and alignment. </p>
<p>Existing contents are preserved. </p>

</div>
</div>
<a class="anchor" id="ab5b4bd563b918e721fd5006bfe960bc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_dma_zmalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>phys_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a pinned, physically contiguous memory buffer with the given size and alignment. </p>
<p>The buffer will be zeroed. </p>

</div>
</div>
<a class="anchor" id="a7f4e9f571d0b77a46ef0192e4cfb13f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_dma_zmalloc_socket </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>phys_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a pinned, physically contiguous memory buffer with the given size, alignment and socket id. </p>
<p>The buffer will be zeroed. </p>

</div>
</div>
<a class="anchor" id="a2483610a36d7daa9e6b067d9270d0087"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_current_core </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the CPU core index of the current thread. </p>
<p>This will only function when called from threads set up by this environment abstraction. For any other threads <code>SPDK_ENV_LCORE_ID_ANY</code> will be returned. </p>

</div>
</div>
<a class="anchor" id="ab480f817ecdd801a0e53a4d8494ffc67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_next_core </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>prev_core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the next dedicated CPU core for this application. </p>
<p>If there is no next core, return UINT32_MAX. </p>

</div>
</div>
<a class="anchor" id="a64eecb39affafd001dfddcdf60114906"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_env_init </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__env__opts.html">spdk_env_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the environment library. </p>
<p>This must be called prior to using any other functions in this library. </p>

</div>
</div>
<a class="anchor" id="a4282feec502eca721136e88c824d59cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_env_thread_launch_pinned </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_start_fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launch a thread pinned to the given core. </p>
<p>Only a single pinned thread may be launched per core. Subsequent attempts to launch pinned threads on that core will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core</td><td>The core to pin the thread to. </td></tr>
    <tr><td class="paramname">fn</td><td>Entry point on the new thread. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument apssed to thread_start_fn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fb4967ae71277512334ad27ef481326"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mem_map_clear_translation </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mem_map *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister an address translation. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="env_8h.html#a3314f2917141bf11f5b125c306d4397d" title="Register an address translation for a range of virtual memory. ">spdk_mem_map_set_translation()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3314f2917141bf11f5b125c306d4397d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mem_map_set_translation </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mem_map *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an address translation for a range of virtual memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Memory map </td></tr>
    <tr><td class="paramname">vaddr</td><td>Virtual address of the region to register - must be 2 MB aligned. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the region - must be 2 MB in the current implementation. </td></tr>
    <tr><td class="paramname">translation</td><td>Translation to store in the map for this address range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="env_8h.html#a2fb4967ae71277512334ad27ef481326" title="Unregister an address translation. ">spdk_mem_map_clear_translation()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae046c45de2849d15f29dedc52e915ad7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mem_register </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the specified memory region for address translation. </p>
<p>The memory region must map to pinned huge pages (2MB or greater). </p>

</div>
</div>
<a class="anchor" id="a3ffa0c74e2d73703266cad2d5d103f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mem_unregister </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister the specified memory region from vtophys address translation. </p>
<p>The caller must ensure all in-flight DMA operations to this memory region are completed or cancelled before calling this function. </p>

</div>
</div>
<a class="anchor" id="a8d4f7842191990b49694495bba10fcbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_mempool* spdk_mempool_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ele_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread-safe memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cache_size</td><td>How many elements may be cached in per-core caches. Use SPDK_MEMPOOL_DEFAULT_CACHE_SIZE for a reasonable default, or 0 for no per-core cache. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada5041ebc03066dede6e0972c22dc77f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_mempool_get </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an element from a memory pool. </p>
<p>If no elements remain, return NULL. </p>

</div>
</div>
<a class="anchor" id="a2be5bc3f8fc570f45f2ad087fcb91f9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_memzone_lookup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup the memory zone identified by the given name. </p>
<p>Return a pointer to the reserved memory address. If the reservation cannot be found, return NULL. </p>

</div>
</div>
<a class="anchor" id="a48afc08099440a88e9e8dc3abf540ab9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_memzone_reserve </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve a named, process shared memory zone with the given size, socket_id and flags. </p>
<p>Return a pointer to the allocated memory address. If the allocation cannot be done, return NULL. Note: to pick any socket id, just set socket_id to SPDK_ENV_SOCKET_ID_ANY. </p>

</div>
</div>
<a class="anchor" id="a7f3decf485d6b797775bc4dd2215eb52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_addr_compare </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two PCI addresses. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if a1 == a2, less than 0 if a1 &lt; a2, greater than 0 if a1 &gt; a2 </dd></dl>

</div>
</div>
<a class="anchor" id="a492c0520e80d8be841891e4d1bd7a446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_addr_fmt </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdf</td><td>String into which a string will be output in the format domain:bus:device.function. The string must be at least 14 characters in size. </td></tr>
    <tr><td class="paramname">sz</td><td>Size of bdf. Must be at least 14. </td></tr>
    <tr><td class="paramname">addr</td><td>PCI address input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negated errno value on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a96187c4c0c5a302669f684e487ebaa0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_addr_parse </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bdf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string representation of a PCI address into a struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>PCI adddress output on success </td></tr>
    <tr><td class="paramname">bdf</td><td>PCI address in domain:bus:device.function format or domain.bus.device.function format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negated errno value on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="afa1866b3d6e63d1b7be5db38b2094d89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_claim </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>pci_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Claim a PCI device for exclusive SPDK userspace access. </p>
<p>Uses F_SETLK on a shared memory file with the PCI address embedded in its name. As long as this file remains open with the lock acquired, other processes will not be able to successfully call this function on the same PCI device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pci_addr</td><td>PCI address of the device to claim</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the device has already been claimed, an fd otherwise. This fd should be closed when the application no longer needs access to the PCI device (including when it is hot removed). </dd></dl>

</div>
</div>
<a class="anchor" id="a235f1c632be6dc00aad1cf8fd0314609"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_get_socket_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NUMA socket ID of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device to get the socket ID of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Socket ID (&gt;= 0), or negative if unknown. </dd></dl>

</div>
</div>
<a class="anchor" id="a6320a791a777b2d518def6413e543ac8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_ring_count </td>
          <td>(</td>
          <td class="paramtype">struct spdk_ring *&#160;</td>
          <td class="paramname"><em>ring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of objects in the ring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>the ring </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of objects in the ring </dd></dl>

</div>
</div>
<a class="anchor" id="a982e1b212d497dbb209902f56b192afb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_ring_dequeue </td>
          <td>(</td>
          <td class="paramtype">struct spdk_ring *&#160;</td>
          <td class="paramname"><em>ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>objs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dequeue count objects from the ring into the array objs. </p>
<p>Return the number of objects dequeued. </p>

</div>
</div>
<a class="anchor" id="a94a5c5e5f14c336e7d64db996c0ed2dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_ring_enqueue </td>
          <td>(</td>
          <td class="paramtype">struct spdk_ring *&#160;</td>
          <td class="paramname"><em>ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>objs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue the array of objects (with length count) on the ring. </p>
<p>Return the number of objects enqueued. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
