<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="generator" content="Doxygen 1.9.1" />
  <title>SPDK: env.h File Reference</title>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  <script type="text/javascript" src="../js/doxyboot.js"></script>
  <script type="text/javascript" src="./navtree.js"></script>
  <link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
<body>
  <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/" aria-label="SPDK">
      <img src="/img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <div class="navbar-nav me-auto">
        <a class="nav-link header-link active" href="../doc/">Documentation</a>
        <a class="nav-link header-link" href="../development/">Development</a>
        <a class="nav-link header-link" href="../community/">Community</a>
        <a class="nav-link header-link" href="../blog/">Blog</a>
      </div>
      <div class="navbar-nav ms-auto me-3">
        <a class="nav-link header-link" href="https://github.com/spdk/spdk">
          <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
      </div>
    </div>
  </nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('env_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">env.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulated third-party dependencies.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__env__opts.html">spdk_env_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Environment initialization options.  <a href="structspdk__env__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__pci__id.html">spdk_pci_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__pci__device.html">spdk_pci_device</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__pci__device_1_1__spdk__pci__device__internal.html">spdk_pci_device::_spdk_pci_device_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__pci__device__provider.html">spdk_pci_device_provider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__mem__map__ops.html">spdk_mem_map_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function table to be implemented by each memory map.  <a href="structspdk__mem__map__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__pci__event.html">spdk_pci_event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3e5247302342025f028c57bc024291b1"><td class="memItemLeft" align="right" valign="top"><a id="a3e5247302342025f028c57bc024291b1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_ENV_SOCKET_ID_ANY</b>&#160;&#160;&#160;(-1)</td></tr>
<tr class="separator:a3e5247302342025f028c57bc024291b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab337c70c632ec69967444fcdd4ab17c2"><td class="memItemLeft" align="right" valign="top"><a id="ab337c70c632ec69967444fcdd4ab17c2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_ENV_LCORE_ID_ANY</b>&#160;&#160;&#160;(UINT32_MAX)</td></tr>
<tr class="separator:ab337c70c632ec69967444fcdd4ab17c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f065a5e897ff548b2dbf0996608929a"><td class="memItemLeft" align="right" valign="top"><a id="a7f065a5e897ff548b2dbf0996608929a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a7f065a5e897ff548b2dbf0996608929a">SPDK_MALLOC_DMA</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:a7f065a5e897ff548b2dbf0996608929a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory is dma-safe. <br /></td></tr>
<tr class="separator:a7f065a5e897ff548b2dbf0996608929a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1660ffa6731090ef3f480c295a87dba"><td class="memItemLeft" align="right" valign="top"><a id="ad1660ffa6731090ef3f480c295a87dba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ad1660ffa6731090ef3f480c295a87dba">SPDK_MALLOC_SHARE</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:ad1660ffa6731090ef3f480c295a87dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory is sharable across process boundaries. <br /></td></tr>
<tr class="separator:ad1660ffa6731090ef3f480c295a87dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411823d4d31753e42df192aa75f74928"><td class="memItemLeft" align="right" valign="top"><a id="a411823d4d31753e42df192aa75f74928"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_MAX_MEMZONE_NAME_LEN</b>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a411823d4d31753e42df192aa75f74928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58022b1b197127cd278aebff2a5a6888"><td class="memItemLeft" align="right" valign="top"><a id="a58022b1b197127cd278aebff2a5a6888"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_MAX_MEMPOOL_NAME_LEN</b>&#160;&#160;&#160;29</td></tr>
<tr class="separator:a58022b1b197127cd278aebff2a5a6888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723c2f644ec11282b96e1568f3124d07"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a723c2f644ec11282b96e1568f3124d07">SPDK_MEMZONE_NO_IOVA_CONTIG</a>&#160;&#160;&#160;0x00100000</td></tr>
<tr class="memdesc:a723c2f644ec11282b96e1568f3124d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memzone flags.  <a href="env_8h.html#a723c2f644ec11282b96e1568f3124d07">More...</a><br /></td></tr>
<tr class="separator:a723c2f644ec11282b96e1568f3124d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1856012938db5f1c0beba921ee5a7c"><td class="memItemLeft" align="right" valign="top"><a id="aba1856012938db5f1c0beba921ee5a7c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_MEMPOOL_DEFAULT_CACHE_SIZE</b>&#160;&#160;&#160;SIZE_MAX</td></tr>
<tr class="separator:aba1856012938db5f1c0beba921ee5a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d08df976f75c1e47ce174ebc446f95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_ENV_FOREACH_CORE</b>(i)</td></tr>
<tr class="separator:a42d08df976f75c1e47ce174ebc446f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eb4a0e044f1a5e9515b8c2f96078a4"><td class="memItemLeft" align="right" valign="top"><a id="a26eb4a0e044f1a5e9515b8c2f96078a4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_VTOPHYS_ERROR</b>&#160;&#160;&#160;(0xFFFFFFFFFFFFFFFFULL)</td></tr>
<tr class="separator:a26eb4a0e044f1a5e9515b8c2f96078a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af804d200bbd6b9aa3ddf5d37f602b5e5"><td class="memItemLeft" align="right" valign="top"><a id="af804d200bbd6b9aa3ddf5d37f602b5e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#af804d200bbd6b9aa3ddf5d37f602b5e5">SPDK_PCI_DRIVER_NEED_MAPPING</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:af804d200bbd6b9aa3ddf5d37f602b5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device needs PCI BAR mapping (done with either IGB_UIO or VFIO) <br /></td></tr>
<tr class="separator:af804d200bbd6b9aa3ddf5d37f602b5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8b7b86b3bec06b90bd2f1677f97735"><td class="memItemLeft" align="right" valign="top"><a id="a8a8b7b86b3bec06b90bd2f1677f97735"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8a8b7b86b3bec06b90bd2f1677f97735">SPDK_PCI_DRIVER_WC_ACTIVATE</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:a8a8b7b86b3bec06b90bd2f1677f97735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device needs PCI BAR mapping with enabled write combining (wc) <br /></td></tr>
<tr class="separator:a8a8b7b86b3bec06b90bd2f1677f97735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2a2a0f55f73b122740643e55d82d31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_PCI_DEVICE</b>(vend,  dev)</td></tr>
<tr class="separator:a6e2a2a0f55f73b122740643e55d82d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a1b0ba34d824e4bd0a63af0a331916"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_PCI_DRIVER_REGISTER</b>(name,  id_table,  flags)</td></tr>
<tr class="separator:a35a1b0ba34d824e4bd0a63af0a331916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3845f913b94ec2c05711450fecc468"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_PCI_REGISTER_DEVICE_PROVIDER</b>(name,  provider)</td></tr>
<tr class="separator:a5d3845f913b94ec2c05711450fecc468"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a039d3ef1514e326b6c2d8a527f6a6aaa"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a039d3ef1514e326b6c2d8a527f6a6aaa">spdk_mempool_obj_cb_t</a>(struct spdk_mempool *mp, void *opaque, void *obj, unsigned obj_idx)</td></tr>
<tr class="memdesc:a039d3ef1514e326b6c2d8a527f6a6aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object callback function for memory pool.  <a href="env_8h.html#a039d3ef1514e326b6c2d8a527f6a6aaa">More...</a><br /></td></tr>
<tr class="separator:a039d3ef1514e326b6c2d8a527f6a6aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae529cf9f5041c8014839d9ecfe5750a4"><td class="memItemLeft" align="right" valign="top">typedef void()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ae529cf9f5041c8014839d9ecfe5750a4">spdk_mempool_mem_cb_t</a>(struct spdk_mempool *mp, void *opaque, void *addr, uint64_t iova, size_t len, unsigned mem_idx)</td></tr>
<tr class="memdesc:ae529cf9f5041c8014839d9ecfe5750a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A memory chunk callback function for memory pool.  <a href="env_8h.html#ae529cf9f5041c8014839d9ecfe5750a4">More...</a><br /></td></tr>
<tr class="separator:ae529cf9f5041c8014839d9ecfe5750a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0083ace78471c3d3d247e21e4968d526"><td class="memItemLeft" align="right" valign="top"><a id="a0083ace78471c3d3d247e21e4968d526"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>thread_start_fn</b>) (void *)</td></tr>
<tr class="separator:a0083ace78471c3d3d247e21e4968d526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0083aec1c2ac9ae023b744a80160af79"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a0083aec1c2ac9ae023b744a80160af79">spdk_pci_enum_cb</a>) (void *enum_ctx, struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:a0083aec1c2ac9ae023b744a80160af79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for device attach handling.  <a href="env_8h.html#a0083aec1c2ac9ae023b744a80160af79">More...</a><br /></td></tr>
<tr class="separator:a0083aec1c2ac9ae023b744a80160af79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac018be4449e60d4e5992e1e4be9bbef3"><td class="memItemLeft" align="right" valign="top"><a id="ac018be4449e60d4e5992e1e4be9bbef3"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_mem_map_notify_cb</b>) (void *cb_ctx, struct spdk_mem_map *map, enum spdk_mem_map_notify_action action, void *vaddr, size_t size)</td></tr>
<tr class="separator:ac018be4449e60d4e5992e1e4be9bbef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d177f59e4dab8f7806c6fded1559da"><td class="memItemLeft" align="right" valign="top"><a id="a97d177f59e4dab8f7806c6fded1559da"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_mem_map_contiguous_translations</b>) (uint64_t addr_1, uint64_t addr_2)</td></tr>
<tr class="separator:a97d177f59e4dab8f7806c6fded1559da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0403fee5f2698d952790cd76a58dc794"><td class="memItemLeft" align="right" valign="top"><a id="a0403fee5f2698d952790cd76a58dc794"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_error_handler</b>) (const void *failure_addr, void *ctx)</td></tr>
<tr class="separator:a0403fee5f2698d952790cd76a58dc794"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a88610413d6db3cc0eaafa4bda0f2caa9"><td class="memItemLeft" align="right" valign="top"><a id="a88610413d6db3cc0eaafa4bda0f2caa9"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_ring_type</b> { <b>SPDK_RING_TYPE_SP_SC</b>
, <b>SPDK_RING_TYPE_MP_SC</b>
, <b>SPDK_RING_TYPE_MP_MC</b>
 }</td></tr>
<tr class="separator:a88610413d6db3cc0eaafa4bda0f2caa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96af19906abf2a01e9f1f2105f90722c"><td class="memItemLeft" align="right" valign="top"><a id="a96af19906abf2a01e9f1f2105f90722c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_mem_map_notify_action</b> { <b>SPDK_MEM_MAP_NOTIFY_REGISTER</b>
, <b>SPDK_MEM_MAP_NOTIFY_UNREGISTER</b>
 }</td></tr>
<tr class="separator:a96af19906abf2a01e9f1f2105f90722c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5665e04f8196d456eafccbdb1302c9"><td class="memItemLeft" align="right" valign="top"><a id="a0a5665e04f8196d456eafccbdb1302c9"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_event_type</b> { <b>SPDK_UEVENT_ADD</b> = 0
, <b>SPDK_UEVENT_REMOVE</b> = 1
 }</td></tr>
<tr class="separator:a0a5665e04f8196d456eafccbdb1302c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a54dee7b759c26ff2a7e1789ddb59f214"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a54dee7b759c26ff2a7e1789ddb59f214">spdk_malloc</a> (size_t size, size_t align, uint64_t *unused, int socket_id, uint32_t flags)</td></tr>
<tr class="memdesc:a54dee7b759c26ff2a7e1789ddb59f214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate dma/sharable memory based on a given dma_flg.  <a href="env_8h.html#a54dee7b759c26ff2a7e1789ddb59f214">More...</a><br /></td></tr>
<tr class="separator:a54dee7b759c26ff2a7e1789ddb59f214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccd5c242af65c41dbe49ae2d903b5e4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a3ccd5c242af65c41dbe49ae2d903b5e4">spdk_zmalloc</a> (size_t size, size_t align, uint64_t *unused, int socket_id, uint32_t flags)</td></tr>
<tr class="memdesc:a3ccd5c242af65c41dbe49ae2d903b5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate dma/sharable memory based on a given dma_flg.  <a href="env_8h.html#a3ccd5c242af65c41dbe49ae2d903b5e4">More...</a><br /></td></tr>
<tr class="separator:a3ccd5c242af65c41dbe49ae2d903b5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf96e1e440b86ba23728e226b0745c6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#acbf96e1e440b86ba23728e226b0745c6">spdk_realloc</a> (void *buf, size_t size, size_t align)</td></tr>
<tr class="memdesc:acbf96e1e440b86ba23728e226b0745c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a dma/sharable memory buffer with the given new size and alignment.  <a href="env_8h.html#acbf96e1e440b86ba23728e226b0745c6">More...</a><br /></td></tr>
<tr class="separator:acbf96e1e440b86ba23728e226b0745c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452d670d7188f883224574dfabc39f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a452d670d7188f883224574dfabc39f2c">spdk_free</a> (void *buf)</td></tr>
<tr class="memdesc:a452d670d7188f883224574dfabc39f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free buffer memory that was previously allocated with <a class="el" href="env_8h.html#a54dee7b759c26ff2a7e1789ddb59f214" title="Allocate dma/sharable memory based on a given dma_flg.">spdk_malloc()</a> or <a class="el" href="env_8h.html#a3ccd5c242af65c41dbe49ae2d903b5e4" title="Allocate dma/sharable memory based on a given dma_flg.">spdk_zmalloc()</a>.  <a href="env_8h.html#a452d670d7188f883224574dfabc39f2c">More...</a><br /></td></tr>
<tr class="separator:a452d670d7188f883224574dfabc39f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b1a05d3f4dee14ba3f980672c9b3a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#af3b1a05d3f4dee14ba3f980672c9b3a6">spdk_env_opts_init</a> (struct <a class="el" href="structspdk__env__opts.html">spdk_env_opts</a> *opts)</td></tr>
<tr class="memdesc:af3b1a05d3f4dee14ba3f980672c9b3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the default value of opts.  <a href="env_8h.html#af3b1a05d3f4dee14ba3f980672c9b3a6">More...</a><br /></td></tr>
<tr class="separator:af3b1a05d3f4dee14ba3f980672c9b3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402ca8ae67be57c2c258a7a2bf22cfec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a402ca8ae67be57c2c258a7a2bf22cfec">spdk_env_init</a> (const struct <a class="el" href="structspdk__env__opts.html">spdk_env_opts</a> *opts)</td></tr>
<tr class="memdesc:a402ca8ae67be57c2c258a7a2bf22cfec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize the environment library.  <a href="env_8h.html#a402ca8ae67be57c2c258a7a2bf22cfec">More...</a><br /></td></tr>
<tr class="separator:a402ca8ae67be57c2c258a7a2bf22cfec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719b5099cc3aa62190a1f44642ba6f91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a719b5099cc3aa62190a1f44642ba6f91">spdk_env_fini</a> (void)</td></tr>
<tr class="memdesc:a719b5099cc3aa62190a1f44642ba6f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release any resources of the environment library that were allocated with <a class="el" href="env_8h.html#a402ca8ae67be57c2c258a7a2bf22cfec" title="Initialize or reinitialize the environment library.">spdk_env_init()</a>.  <a href="env_8h.html#a719b5099cc3aa62190a1f44642ba6f91">More...</a><br /></td></tr>
<tr class="separator:a719b5099cc3aa62190a1f44642ba6f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b56bdbcfeeebe6ad61eb574c823268"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ac9b56bdbcfeeebe6ad61eb574c823268">spdk_dma_malloc</a> (size_t size, size_t align, uint64_t *unused)</td></tr>
<tr class="memdesc:ac9b56bdbcfeeebe6ad61eb574c823268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a pinned memory buffer with the given size and alignment.  <a href="env_8h.html#ac9b56bdbcfeeebe6ad61eb574c823268">More...</a><br /></td></tr>
<tr class="separator:ac9b56bdbcfeeebe6ad61eb574c823268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1051e8f2c56403c55435c079b4f77b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#adc1051e8f2c56403c55435c079b4f77b">spdk_dma_malloc_socket</a> (size_t size, size_t align, uint64_t *unused, int socket_id)</td></tr>
<tr class="memdesc:adc1051e8f2c56403c55435c079b4f77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a pinned, memory buffer with the given size, alignment and socket id.  <a href="env_8h.html#adc1051e8f2c56403c55435c079b4f77b">More...</a><br /></td></tr>
<tr class="separator:adc1051e8f2c56403c55435c079b4f77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33af43d2e6f8037a58149c1defeb16c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ae33af43d2e6f8037a58149c1defeb16c">spdk_dma_zmalloc</a> (size_t size, size_t align, uint64_t *unused)</td></tr>
<tr class="memdesc:ae33af43d2e6f8037a58149c1defeb16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a pinned memory buffer with the given size and alignment.  <a href="env_8h.html#ae33af43d2e6f8037a58149c1defeb16c">More...</a><br /></td></tr>
<tr class="separator:ae33af43d2e6f8037a58149c1defeb16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6c3cc4df9f71125dec5c4c703ee1b0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8a6c3cc4df9f71125dec5c4c703ee1b0">spdk_dma_zmalloc_socket</a> (size_t size, size_t align, uint64_t *unused, int socket_id)</td></tr>
<tr class="memdesc:a8a6c3cc4df9f71125dec5c4c703ee1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a pinned memory buffer with the given size, alignment and socket id.  <a href="env_8h.html#a8a6c3cc4df9f71125dec5c4c703ee1b0">More...</a><br /></td></tr>
<tr class="separator:a8a6c3cc4df9f71125dec5c4c703ee1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7327bf788d5f76dc793ed2d9ee1b14e3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a7327bf788d5f76dc793ed2d9ee1b14e3">spdk_dma_realloc</a> (void *buf, size_t size, size_t align, uint64_t *unused)</td></tr>
<tr class="memdesc:a7327bf788d5f76dc793ed2d9ee1b14e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the allocated and pinned memory buffer with the given new size and alignment.  <a href="env_8h.html#a7327bf788d5f76dc793ed2d9ee1b14e3">More...</a><br /></td></tr>
<tr class="separator:a7327bf788d5f76dc793ed2d9ee1b14e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd01324e661a5d6deb59bd2bc6230de3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#acd01324e661a5d6deb59bd2bc6230de3">spdk_dma_free</a> (void *buf)</td></tr>
<tr class="memdesc:acd01324e661a5d6deb59bd2bc6230de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a memory buffer previously allocated, for example from <a class="el" href="env_8h.html#ae33af43d2e6f8037a58149c1defeb16c" title="Allocate a pinned memory buffer with the given size and alignment.">spdk_dma_zmalloc()</a>.  <a href="env_8h.html#acd01324e661a5d6deb59bd2bc6230de3">More...</a><br /></td></tr>
<tr class="separator:acd01324e661a5d6deb59bd2bc6230de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48afc08099440a88e9e8dc3abf540ab9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a48afc08099440a88e9e8dc3abf540ab9">spdk_memzone_reserve</a> (const char *name, size_t len, int socket_id, unsigned flags)</td></tr>
<tr class="memdesc:a48afc08099440a88e9e8dc3abf540ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve a named, process shared memory zone with the given size, socket_id and flags.  <a href="env_8h.html#a48afc08099440a88e9e8dc3abf540ab9">More...</a><br /></td></tr>
<tr class="separator:a48afc08099440a88e9e8dc3abf540ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa179a05a509878b70a9e4dfe8079841a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aa179a05a509878b70a9e4dfe8079841a">spdk_memzone_reserve_aligned</a> (const char *name, size_t len, int socket_id, unsigned flags, unsigned align)</td></tr>
<tr class="memdesc:aa179a05a509878b70a9e4dfe8079841a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve a named, process shared memory zone with the given size, socket_id, flags and alignment.  <a href="env_8h.html#aa179a05a509878b70a9e4dfe8079841a">More...</a><br /></td></tr>
<tr class="separator:aa179a05a509878b70a9e4dfe8079841a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be5bc3f8fc570f45f2ad087fcb91f9e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a2be5bc3f8fc570f45f2ad087fcb91f9e">spdk_memzone_lookup</a> (const char *name)</td></tr>
<tr class="memdesc:a2be5bc3f8fc570f45f2ad087fcb91f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup the memory zone identified by the given name.  <a href="env_8h.html#a2be5bc3f8fc570f45f2ad087fcb91f9e">More...</a><br /></td></tr>
<tr class="separator:a2be5bc3f8fc570f45f2ad087fcb91f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7f9a6391c0e076abd0160b24f2ad81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a5c7f9a6391c0e076abd0160b24f2ad81">spdk_memzone_free</a> (const char *name)</td></tr>
<tr class="memdesc:a5c7f9a6391c0e076abd0160b24f2ad81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory zone identified by the given name.  <a href="env_8h.html#a5c7f9a6391c0e076abd0160b24f2ad81">More...</a><br /></td></tr>
<tr class="separator:a5c7f9a6391c0e076abd0160b24f2ad81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b47302a948b71f493ae775b53f162e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8b47302a948b71f493ae775b53f162e2">spdk_memzone_dump</a> (FILE *f)</td></tr>
<tr class="memdesc:a8b47302a948b71f493ae775b53f162e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump debug information about all memzones.  <a href="env_8h.html#a8b47302a948b71f493ae775b53f162e2">More...</a><br /></td></tr>
<tr class="separator:a8b47302a948b71f493ae775b53f162e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4f7842191990b49694495bba10fcbd"><td class="memItemLeft" align="right" valign="top">struct spdk_mempool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8d4f7842191990b49694495bba10fcbd">spdk_mempool_create</a> (const char *name, size_t count, size_t ele_size, size_t cache_size, int socket_id)</td></tr>
<tr class="memdesc:a8d4f7842191990b49694495bba10fcbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread-safe memory pool.  <a href="env_8h.html#a8d4f7842191990b49694495bba10fcbd">More...</a><br /></td></tr>
<tr class="separator:a8d4f7842191990b49694495bba10fcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8981c2ba451d7214e157708a718db6c9"><td class="memItemLeft" align="right" valign="top">struct spdk_mempool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8981c2ba451d7214e157708a718db6c9">spdk_mempool_create_ctor</a> (const char *name, size_t count, size_t ele_size, size_t cache_size, int socket_id, <a class="el" href="env_8h.html#a039d3ef1514e326b6c2d8a527f6a6aaa">spdk_mempool_obj_cb_t</a> *obj_init, void *obj_init_arg)</td></tr>
<tr class="memdesc:a8981c2ba451d7214e157708a718db6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a thread-safe memory pool with user provided initialization function and argument.  <a href="env_8h.html#a8981c2ba451d7214e157708a718db6c9">More...</a><br /></td></tr>
<tr class="separator:a8981c2ba451d7214e157708a718db6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef50d2e8f2d7fccfd5c5edf95e5013d2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aef50d2e8f2d7fccfd5c5edf95e5013d2">spdk_mempool_get_name</a> (struct spdk_mempool *mp)</td></tr>
<tr class="memdesc:aef50d2e8f2d7fccfd5c5edf95e5013d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a memory pool.  <a href="env_8h.html#aef50d2e8f2d7fccfd5c5edf95e5013d2">More...</a><br /></td></tr>
<tr class="separator:aef50d2e8f2d7fccfd5c5edf95e5013d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d2feacf9f6979db875add06ab06494"><td class="memItemLeft" align="right" valign="top"><a id="ab9d2feacf9f6979db875add06ab06494"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab9d2feacf9f6979db875add06ab06494">spdk_mempool_free</a> (struct spdk_mempool *mp)</td></tr>
<tr class="memdesc:ab9d2feacf9f6979db875add06ab06494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a memory pool. <br /></td></tr>
<tr class="separator:ab9d2feacf9f6979db875add06ab06494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5041ebc03066dede6e0972c22dc77f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ada5041ebc03066dede6e0972c22dc77f">spdk_mempool_get</a> (struct spdk_mempool *mp)</td></tr>
<tr class="memdesc:ada5041ebc03066dede6e0972c22dc77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element from a memory pool.  <a href="env_8h.html#ada5041ebc03066dede6e0972c22dc77f">More...</a><br /></td></tr>
<tr class="separator:ada5041ebc03066dede6e0972c22dc77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5695d9dcc6f53a561f41c932a198853b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a5695d9dcc6f53a561f41c932a198853b">spdk_mempool_get_bulk</a> (struct spdk_mempool *mp, void **ele_arr, size_t count)</td></tr>
<tr class="memdesc:a5695d9dcc6f53a561f41c932a198853b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get multiple elements from a memory pool.  <a href="env_8h.html#a5695d9dcc6f53a561f41c932a198853b">More...</a><br /></td></tr>
<tr class="separator:a5695d9dcc6f53a561f41c932a198853b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56233342766c54990e044b8ca2f3d41a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a56233342766c54990e044b8ca2f3d41a">spdk_mempool_put</a> (struct spdk_mempool *mp, void *ele)</td></tr>
<tr class="memdesc:a56233342766c54990e044b8ca2f3d41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put an element back into the memory pool.  <a href="env_8h.html#a56233342766c54990e044b8ca2f3d41a">More...</a><br /></td></tr>
<tr class="separator:a56233342766c54990e044b8ca2f3d41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f2b221ab82ba09c51013291313fe2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a02f2b221ab82ba09c51013291313fe2e">spdk_mempool_put_bulk</a> (struct spdk_mempool *mp, void **ele_arr, size_t count)</td></tr>
<tr class="memdesc:a02f2b221ab82ba09c51013291313fe2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put multiple elements back into the memory pool.  <a href="env_8h.html#a02f2b221ab82ba09c51013291313fe2e">More...</a><br /></td></tr>
<tr class="separator:a02f2b221ab82ba09c51013291313fe2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434cdf73691c745e717b8b794b2acb52"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a434cdf73691c745e717b8b794b2acb52">spdk_mempool_count</a> (const struct spdk_mempool *pool)</td></tr>
<tr class="memdesc:a434cdf73691c745e717b8b794b2acb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of entries in the memory pool.  <a href="env_8h.html#a434cdf73691c745e717b8b794b2acb52">More...</a><br /></td></tr>
<tr class="separator:a434cdf73691c745e717b8b794b2acb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b9b2980b2bf4be6e1b75024d676cd1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ad3b9b2980b2bf4be6e1b75024d676cd1">spdk_mempool_obj_iter</a> (struct spdk_mempool *mp, <a class="el" href="env_8h.html#a039d3ef1514e326b6c2d8a527f6a6aaa">spdk_mempool_obj_cb_t</a> obj_cb, void *obj_cb_arg)</td></tr>
<tr class="memdesc:ad3b9b2980b2bf4be6e1b75024d676cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through all elements of the pool and call a function on each one.  <a href="env_8h.html#ad3b9b2980b2bf4be6e1b75024d676cd1">More...</a><br /></td></tr>
<tr class="separator:ad3b9b2980b2bf4be6e1b75024d676cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63d48e98e2dc3b0fdc9ad75905fc379"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aa63d48e98e2dc3b0fdc9ad75905fc379">spdk_mempool_mem_iter</a> (struct spdk_mempool *mp, <a class="el" href="env_8h.html#ae529cf9f5041c8014839d9ecfe5750a4">spdk_mempool_mem_cb_t</a> mem_cb, void *mem_cb_arg)</td></tr>
<tr class="memdesc:aa63d48e98e2dc3b0fdc9ad75905fc379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate through all memory chunks of the pool and call a function on each one.  <a href="env_8h.html#aa63d48e98e2dc3b0fdc9ad75905fc379">More...</a><br /></td></tr>
<tr class="separator:aa63d48e98e2dc3b0fdc9ad75905fc379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397f334df8126cae08a8499688e1601f"><td class="memItemLeft" align="right" valign="top">struct spdk_mempool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a397f334df8126cae08a8499688e1601f">spdk_mempool_lookup</a> (const char *name)</td></tr>
<tr class="memdesc:a397f334df8126cae08a8499688e1601f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup the memory pool identified by the given name.  <a href="env_8h.html#a397f334df8126cae08a8499688e1601f">More...</a><br /></td></tr>
<tr class="separator:a397f334df8126cae08a8499688e1601f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4461ccdde430461ad2756b3799099330"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a4461ccdde430461ad2756b3799099330">spdk_env_get_core_count</a> (void)</td></tr>
<tr class="memdesc:a4461ccdde430461ad2756b3799099330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of dedicated CPU cores utilized by this env abstraction.  <a href="env_8h.html#a4461ccdde430461ad2756b3799099330">More...</a><br /></td></tr>
<tr class="separator:a4461ccdde430461ad2756b3799099330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2483610a36d7daa9e6b067d9270d0087"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a2483610a36d7daa9e6b067d9270d0087">spdk_env_get_current_core</a> (void)</td></tr>
<tr class="memdesc:a2483610a36d7daa9e6b067d9270d0087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CPU core index of the current thread.  <a href="env_8h.html#a2483610a36d7daa9e6b067d9270d0087">More...</a><br /></td></tr>
<tr class="separator:a2483610a36d7daa9e6b067d9270d0087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8cb2ee2493457ecf9d5e4d1cded32f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aec8cb2ee2493457ecf9d5e4d1cded32f">spdk_env_get_main_core</a> (void)</td></tr>
<tr class="memdesc:aec8cb2ee2493457ecf9d5e4d1cded32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the main dedicated CPU core for this application.  <a href="env_8h.html#aec8cb2ee2493457ecf9d5e4d1cded32f">More...</a><br /></td></tr>
<tr class="separator:aec8cb2ee2493457ecf9d5e4d1cded32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2127ecc88ceb8e4b1242c316634de50e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a2127ecc88ceb8e4b1242c316634de50e">spdk_env_get_first_core</a> (void)</td></tr>
<tr class="memdesc:a2127ecc88ceb8e4b1242c316634de50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the first dedicated CPU core for this application.  <a href="env_8h.html#a2127ecc88ceb8e4b1242c316634de50e">More...</a><br /></td></tr>
<tr class="separator:a2127ecc88ceb8e4b1242c316634de50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad66fc19d0c23cb21ff456581f0385a2b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ad66fc19d0c23cb21ff456581f0385a2b">spdk_env_get_last_core</a> (void)</td></tr>
<tr class="memdesc:ad66fc19d0c23cb21ff456581f0385a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the last dedicated CPU core for this application.  <a href="env_8h.html#ad66fc19d0c23cb21ff456581f0385a2b">More...</a><br /></td></tr>
<tr class="separator:ad66fc19d0c23cb21ff456581f0385a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab480f817ecdd801a0e53a4d8494ffc67"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab480f817ecdd801a0e53a4d8494ffc67">spdk_env_get_next_core</a> (uint32_t prev_core)</td></tr>
<tr class="memdesc:ab480f817ecdd801a0e53a4d8494ffc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the next dedicated CPU core for this application.  <a href="env_8h.html#ab480f817ecdd801a0e53a4d8494ffc67">More...</a><br /></td></tr>
<tr class="separator:ab480f817ecdd801a0e53a4d8494ffc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18052aa1bc0ff634ffc0ce11c577d65"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab18052aa1bc0ff634ffc0ce11c577d65">spdk_env_get_socket_id</a> (uint32_t core)</td></tr>
<tr class="memdesc:ab18052aa1bc0ff634ffc0ce11c577d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the socket ID for the given core.  <a href="env_8h.html#ab18052aa1bc0ff634ffc0ce11c577d65">More...</a><br /></td></tr>
<tr class="separator:ab18052aa1bc0ff634ffc0ce11c577d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a54ecf72f47decc6e8abc0bafcb578f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8a54ecf72f47decc6e8abc0bafcb578f">spdk_env_get_cpuset</a> (struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *cpuset)</td></tr>
<tr class="memdesc:a8a54ecf72f47decc6e8abc0bafcb578f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cpuset with each dedicated core's bit set to true.  <a href="env_8h.html#a8a54ecf72f47decc6e8abc0bafcb578f">More...</a><br /></td></tr>
<tr class="separator:a8a54ecf72f47decc6e8abc0bafcb578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4282feec502eca721136e88c824d59cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a4282feec502eca721136e88c824d59cf">spdk_env_thread_launch_pinned</a> (uint32_t core, thread_start_fn fn, void *arg)</td></tr>
<tr class="memdesc:a4282feec502eca721136e88c824d59cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch a thread pinned to the given core.  <a href="env_8h.html#a4282feec502eca721136e88c824d59cf">More...</a><br /></td></tr>
<tr class="separator:a4282feec502eca721136e88c824d59cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7e5ab204489da6d344999e4a0c8a73"><td class="memItemLeft" align="right" valign="top"><a id="aec7e5ab204489da6d344999e4a0c8a73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aec7e5ab204489da6d344999e4a0c8a73">spdk_env_thread_wait_all</a> (void)</td></tr>
<tr class="memdesc:aec7e5ab204489da6d344999e4a0c8a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all threads to exit before returning. <br /></td></tr>
<tr class="separator:aec7e5ab204489da6d344999e4a0c8a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798ae910c8563b33eea17af50cabb1ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a798ae910c8563b33eea17af50cabb1ab">spdk_process_is_primary</a> (void)</td></tr>
<tr class="memdesc:a798ae910c8563b33eea17af50cabb1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the calling process is primary process.  <a href="env_8h.html#a798ae910c8563b33eea17af50cabb1ab">More...</a><br /></td></tr>
<tr class="separator:a798ae910c8563b33eea17af50cabb1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d868d272aa0c000f6135966dfadc596"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596">spdk_get_ticks</a> (void)</td></tr>
<tr class="memdesc:a7d868d272aa0c000f6135966dfadc596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a monotonic timestamp counter.  <a href="env_8h.html#a7d868d272aa0c000f6135966dfadc596">More...</a><br /></td></tr>
<tr class="separator:a7d868d272aa0c000f6135966dfadc596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7d0eb3000d71b588486cf9903cd434"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a0e7d0eb3000d71b588486cf9903cd434">spdk_get_ticks_hz</a> (void)</td></tr>
<tr class="memdesc:a0e7d0eb3000d71b588486cf9903cd434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tick rate of <a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596" title="Get a monotonic timestamp counter.">spdk_get_ticks()</a> per second.  <a href="env_8h.html#a0e7d0eb3000d71b588486cf9903cd434">More...</a><br /></td></tr>
<tr class="separator:a0e7d0eb3000d71b588486cf9903cd434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e338ce2d6510489ae83bfff226b8b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab2e338ce2d6510489ae83bfff226b8b1">spdk_delay_us</a> (unsigned int us)</td></tr>
<tr class="memdesc:ab2e338ce2d6510489ae83bfff226b8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay the given number of microseconds.  <a href="env_8h.html#ab2e338ce2d6510489ae83bfff226b8b1">More...</a><br /></td></tr>
<tr class="separator:ab2e338ce2d6510489ae83bfff226b8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b4804441c4333e414ebd3d508d91fa"><td class="memItemLeft" align="right" valign="top"><a id="a83b4804441c4333e414ebd3d508d91fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a83b4804441c4333e414ebd3d508d91fa">spdk_pause</a> (void)</td></tr>
<tr class="memdesc:a83b4804441c4333e414ebd3d508d91fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause CPU execution for a short while. <br /></td></tr>
<tr class="separator:a83b4804441c4333e414ebd3d508d91fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9038d37e14d07c89b399ee92bcbb87"><td class="memItemLeft" align="right" valign="top">struct spdk_ring *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a9f9038d37e14d07c89b399ee92bcbb87">spdk_ring_create</a> (enum spdk_ring_type type, size_t count, int socket_id)</td></tr>
<tr class="memdesc:a9f9038d37e14d07c89b399ee92bcbb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a ring.  <a href="env_8h.html#a9f9038d37e14d07c89b399ee92bcbb87">More...</a><br /></td></tr>
<tr class="separator:a9f9038d37e14d07c89b399ee92bcbb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1ec5c3714962d4b01ceb5a50571dca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a3f1ec5c3714962d4b01ceb5a50571dca">spdk_ring_free</a> (struct spdk_ring *ring)</td></tr>
<tr class="memdesc:a3f1ec5c3714962d4b01ceb5a50571dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the ring.  <a href="env_8h.html#a3f1ec5c3714962d4b01ceb5a50571dca">More...</a><br /></td></tr>
<tr class="separator:a3f1ec5c3714962d4b01ceb5a50571dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6320a791a777b2d518def6413e543ac8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a6320a791a777b2d518def6413e543ac8">spdk_ring_count</a> (struct spdk_ring *ring)</td></tr>
<tr class="memdesc:a6320a791a777b2d518def6413e543ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of objects in the ring.  <a href="env_8h.html#a6320a791a777b2d518def6413e543ac8">More...</a><br /></td></tr>
<tr class="separator:a6320a791a777b2d518def6413e543ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a046de83d31127e79a7b16760b4776"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a96a046de83d31127e79a7b16760b4776">spdk_ring_enqueue</a> (struct spdk_ring *ring, void **objs, size_t count, size_t *free_space)</td></tr>
<tr class="memdesc:a96a046de83d31127e79a7b16760b4776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue the array of objects (with length count) on the ring.  <a href="env_8h.html#a96a046de83d31127e79a7b16760b4776">More...</a><br /></td></tr>
<tr class="separator:a96a046de83d31127e79a7b16760b4776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982e1b212d497dbb209902f56b192afb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a982e1b212d497dbb209902f56b192afb">spdk_ring_dequeue</a> (struct spdk_ring *ring, void **objs, size_t count)</td></tr>
<tr class="memdesc:a982e1b212d497dbb209902f56b192afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue count objects from the ring into the array objs.  <a href="env_8h.html#a982e1b212d497dbb209902f56b192afb">More...</a><br /></td></tr>
<tr class="separator:a982e1b212d497dbb209902f56b192afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e36d9cc7a1aa8ae701bec368502273"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab7e36d9cc7a1aa8ae701bec368502273">spdk_iommu_is_enabled</a> (void)</td></tr>
<tr class="memdesc:ab7e36d9cc7a1aa8ae701bec368502273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether the SPDK application is using the IOMMU for DMA.  <a href="env_8h.html#ab7e36d9cc7a1aa8ae701bec368502273">More...</a><br /></td></tr>
<tr class="separator:ab7e36d9cc7a1aa8ae701bec368502273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73d54bd295c1d46aa9a45df17e6aa40"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ae73d54bd295c1d46aa9a45df17e6aa40">spdk_vtophys</a> (const void *buf, uint64_t *size)</td></tr>
<tr class="memdesc:ae73d54bd295c1d46aa9a45df17e6aa40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the physical address of a buffer.  <a href="env_8h.html#ae73d54bd295c1d46aa9a45df17e6aa40">More...</a><br /></td></tr>
<tr class="separator:ae73d54bd295c1d46aa9a45df17e6aa40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a124d809ac4df6773ec12fdacc0bc1"><td class="memItemLeft" align="right" valign="top"><a id="a85a124d809ac4df6773ec12fdacc0bc1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_pci_driver_register</b> (const char *name, struct <a class="el" href="structspdk__pci__id.html">spdk_pci_id</a> *id_table, uint32_t flags)</td></tr>
<tr class="separator:a85a124d809ac4df6773ec12fdacc0bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c62369cc020953b05f3bdac9ae67bed"><td class="memItemLeft" align="right" valign="top">struct spdk_pci_driver *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a9c62369cc020953b05f3bdac9ae67bed">spdk_pci_vmd_get_driver</a> (void)</td></tr>
<tr class="memdesc:a9c62369cc020953b05f3bdac9ae67bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the VMD PCI driver object.  <a href="env_8h.html#a9c62369cc020953b05f3bdac9ae67bed">More...</a><br /></td></tr>
<tr class="separator:a9c62369cc020953b05f3bdac9ae67bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d208ba1e19b37b76bb993c358b5760"><td class="memItemLeft" align="right" valign="top">struct spdk_pci_driver *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ad9d208ba1e19b37b76bb993c358b5760">spdk_pci_ioat_get_driver</a> (void)</td></tr>
<tr class="memdesc:ad9d208ba1e19b37b76bb993c358b5760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the I/OAT PCI driver object.  <a href="env_8h.html#ad9d208ba1e19b37b76bb993c358b5760">More...</a><br /></td></tr>
<tr class="separator:ad9d208ba1e19b37b76bb993c358b5760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba107481f435164bef55ae65652775a8"><td class="memItemLeft" align="right" valign="top">struct spdk_pci_driver *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aba107481f435164bef55ae65652775a8">spdk_pci_idxd_get_driver</a> (void)</td></tr>
<tr class="memdesc:aba107481f435164bef55ae65652775a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IDXD PCI driver object.  <a href="env_8h.html#aba107481f435164bef55ae65652775a8">More...</a><br /></td></tr>
<tr class="separator:aba107481f435164bef55ae65652775a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fabe1b4dba0227ab07e5bd91fe8816"><td class="memItemLeft" align="right" valign="top">struct spdk_pci_driver *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ac7fabe1b4dba0227ab07e5bd91fe8816">spdk_pci_virtio_get_driver</a> (void)</td></tr>
<tr class="memdesc:ac7fabe1b4dba0227ab07e5bd91fe8816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Virtio PCI driver object.  <a href="env_8h.html#ac7fabe1b4dba0227ab07e5bd91fe8816">More...</a><br /></td></tr>
<tr class="separator:ac7fabe1b4dba0227ab07e5bd91fe8816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cedd84c4dbf700c387d8fb6ebc42578"><td class="memItemLeft" align="right" valign="top">struct spdk_pci_driver *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a0cedd84c4dbf700c387d8fb6ebc42578">spdk_pci_get_driver</a> (const char *name)</td></tr>
<tr class="memdesc:a0cedd84c4dbf700c387d8fb6ebc42578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get PCI driver by name (e.g.  <a href="env_8h.html#a0cedd84c4dbf700c387d8fb6ebc42578">More...</a><br /></td></tr>
<tr class="separator:a0cedd84c4dbf700c387d8fb6ebc42578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a5c3c4f51c1eaac132f6093fe219f4"><td class="memItemLeft" align="right" valign="top">struct spdk_pci_driver *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aa4a5c3c4f51c1eaac132f6093fe219f4">spdk_pci_nvme_get_driver</a> (void)</td></tr>
<tr class="memdesc:aa4a5c3c4f51c1eaac132f6093fe219f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe PCI driver object.  <a href="env_8h.html#aa4a5c3c4f51c1eaac132f6093fe219f4">More...</a><br /></td></tr>
<tr class="separator:aa4a5c3c4f51c1eaac132f6093fe219f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2430eaebf3d756c8608aea6957b614"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8e2430eaebf3d756c8608aea6957b614">spdk_pci_enumerate</a> (struct spdk_pci_driver *driver, <a class="el" href="env_8h.html#a0083aec1c2ac9ae023b744a80160af79">spdk_pci_enum_cb</a> enum_cb, void *enum_ctx)</td></tr>
<tr class="memdesc:a8e2430eaebf3d756c8608aea6957b614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate all PCI devices supported by the provided driver and try to attach those that weren't attached yet.  <a href="env_8h.html#a8e2430eaebf3d756c8608aea6957b614">More...</a><br /></td></tr>
<tr class="separator:a8e2430eaebf3d756c8608aea6957b614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4705df2fb00412d72deda48ab9bf088a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a4705df2fb00412d72deda48ab9bf088a">spdk_pci_for_each_device</a> (void *ctx, void(*fn)(void *ctx, struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev))</td></tr>
<tr class="memdesc:a4705df2fb00412d72deda48ab9bf088a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the provided function pointer for every enumerated PCI device.  <a href="env_8h.html#a4705df2fb00412d72deda48ab9bf088a">More...</a><br /></td></tr>
<tr class="separator:a4705df2fb00412d72deda48ab9bf088a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1964fc8e4bdbe6c8fc3002f063a6747"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab1964fc8e4bdbe6c8fc3002f063a6747">spdk_pci_device_map_bar</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev, uint32_t bar, void **mapped_addr, uint64_t *phys_addr, uint64_t *size)</td></tr>
<tr class="memdesc:ab1964fc8e4bdbe6c8fc3002f063a6747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a PCI BAR in the current process.  <a href="env_8h.html#ab1964fc8e4bdbe6c8fc3002f063a6747">More...</a><br /></td></tr>
<tr class="separator:ab1964fc8e4bdbe6c8fc3002f063a6747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b33324546e79d1478f25c185076336"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a80b33324546e79d1478f25c185076336">spdk_pci_device_unmap_bar</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev, uint32_t bar, void *mapped_addr)</td></tr>
<tr class="memdesc:a80b33324546e79d1478f25c185076336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap a PCI BAR from the current process.  <a href="env_8h.html#a80b33324546e79d1478f25c185076336">More...</a><br /></td></tr>
<tr class="separator:a80b33324546e79d1478f25c185076336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca80b3a77dfc8b35e65dc281737019d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a3ca80b3a77dfc8b35e65dc281737019d">spdk_pci_device_enable_interrupt</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:a3ca80b3a77dfc8b35e65dc281737019d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable PCI device interrupts.  <a href="env_8h.html#a3ca80b3a77dfc8b35e65dc281737019d">More...</a><br /></td></tr>
<tr class="separator:a3ca80b3a77dfc8b35e65dc281737019d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab796808f5105da215e5da178ad39e3ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab796808f5105da215e5da178ad39e3ac">spdk_pci_device_disable_interrupt</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:ab796808f5105da215e5da178ad39e3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable PCI device interrupts.  <a href="env_8h.html#ab796808f5105da215e5da178ad39e3ac">More...</a><br /></td></tr>
<tr class="separator:ab796808f5105da215e5da178ad39e3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b50d57653132fb21a10a4ff120125c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a6b50d57653132fb21a10a4ff120125c7">spdk_pci_device_get_interrupt_efd</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:a6b50d57653132fb21a10a4ff120125c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an event file descriptor assosiated with a PCI device interrupt.  <a href="env_8h.html#a6b50d57653132fb21a10a4ff120125c7">More...</a><br /></td></tr>
<tr class="separator:a6b50d57653132fb21a10a4ff120125c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b6650e48ccffaea6ca59fe0b875da5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a10b6650e48ccffaea6ca59fe0b875da5">spdk_pci_device_get_domain</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:a10b6650e48ccffaea6ca59fe0b875da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the domain of a PCI device.  <a href="env_8h.html#a10b6650e48ccffaea6ca59fe0b875da5">More...</a><br /></td></tr>
<tr class="separator:a10b6650e48ccffaea6ca59fe0b875da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae16576e55bc5015818abc07c370244"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a1ae16576e55bc5015818abc07c370244">spdk_pci_device_get_bus</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:a1ae16576e55bc5015818abc07c370244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bus number of a PCI device.  <a href="env_8h.html#a1ae16576e55bc5015818abc07c370244">More...</a><br /></td></tr>
<tr class="separator:a1ae16576e55bc5015818abc07c370244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5027b309c5a3210250d896ed5c9b0f8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ae5027b309c5a3210250d896ed5c9b0f8">spdk_pci_device_get_dev</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:ae5027b309c5a3210250d896ed5c9b0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device number within the PCI bus the device is on.  <a href="env_8h.html#ae5027b309c5a3210250d896ed5c9b0f8">More...</a><br /></td></tr>
<tr class="separator:ae5027b309c5a3210250d896ed5c9b0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4342c5bc69edb7b42a3873e54bd2d7"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a6c4342c5bc69edb7b42a3873e54bd2d7">spdk_pci_device_get_func</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:a6c4342c5bc69edb7b42a3873e54bd2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the particular function number represented by struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a>.  <a href="env_8h.html#a6c4342c5bc69edb7b42a3873e54bd2d7">More...</a><br /></td></tr>
<tr class="separator:a6c4342c5bc69edb7b42a3873e54bd2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71622d665e7b50f34d2279e7e86b557e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a71622d665e7b50f34d2279e7e86b557e">spdk_pci_device_get_addr</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:a71622d665e7b50f34d2279e7e86b557e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the full DomainBDF address of a PCI device.  <a href="env_8h.html#a71622d665e7b50f34d2279e7e86b557e">More...</a><br /></td></tr>
<tr class="separator:a71622d665e7b50f34d2279e7e86b557e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6b50f74ddb53ff6ee4552c20a053bc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#abe6b50f74ddb53ff6ee4552c20a053bc">spdk_pci_device_get_vendor_id</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:abe6b50f74ddb53ff6ee4552c20a053bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the vendor ID of a PCI device.  <a href="env_8h.html#abe6b50f74ddb53ff6ee4552c20a053bc">More...</a><br /></td></tr>
<tr class="separator:abe6b50f74ddb53ff6ee4552c20a053bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2553026e46a40c274980b5b201b0cb"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8b2553026e46a40c274980b5b201b0cb">spdk_pci_device_get_device_id</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:a8b2553026e46a40c274980b5b201b0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device ID of a PCI device.  <a href="env_8h.html#a8b2553026e46a40c274980b5b201b0cb">More...</a><br /></td></tr>
<tr class="separator:a8b2553026e46a40c274980b5b201b0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae488ab8a8a1b56ae22ca26b00185f7f8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ae488ab8a8a1b56ae22ca26b00185f7f8">spdk_pci_device_get_subvendor_id</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:ae488ab8a8a1b56ae22ca26b00185f7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the subvendor ID of a PCI device.  <a href="env_8h.html#ae488ab8a8a1b56ae22ca26b00185f7f8">More...</a><br /></td></tr>
<tr class="separator:ae488ab8a8a1b56ae22ca26b00185f7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6368feb8685db7cc745f14e184a5e3e0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a6368feb8685db7cc745f14e184a5e3e0">spdk_pci_device_get_subdevice_id</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:a6368feb8685db7cc745f14e184a5e3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the subdevice ID of a PCI device.  <a href="env_8h.html#a6368feb8685db7cc745f14e184a5e3e0">More...</a><br /></td></tr>
<tr class="separator:a6368feb8685db7cc745f14e184a5e3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5c2f463bddbce4cc846e04246f6414"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__pci__id.html">spdk_pci_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a5c5c2f463bddbce4cc846e04246f6414">spdk_pci_device_get_id</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:a5c5c2f463bddbce4cc846e04246f6414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the PCI ID of a PCI device.  <a href="env_8h.html#a5c5c2f463bddbce4cc846e04246f6414">More...</a><br /></td></tr>
<tr class="separator:a5c5c2f463bddbce4cc846e04246f6414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235f1c632be6dc00aad1cf8fd0314609"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a235f1c632be6dc00aad1cf8fd0314609">spdk_pci_device_get_socket_id</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:a235f1c632be6dc00aad1cf8fd0314609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NUMA node the PCI device is on.  <a href="env_8h.html#a235f1c632be6dc00aad1cf8fd0314609">More...</a><br /></td></tr>
<tr class="separator:a235f1c632be6dc00aad1cf8fd0314609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b979316610b357a35d03500c3059af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a69b979316610b357a35d03500c3059af">spdk_pci_device_get_serial_number</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev, char *sn, size_t len)</td></tr>
<tr class="memdesc:a69b979316610b357a35d03500c3059af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the PCIe Device Serial Number into the provided buffer.  <a href="env_8h.html#a69b979316610b357a35d03500c3059af">More...</a><br /></td></tr>
<tr class="separator:a69b979316610b357a35d03500c3059af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab641446baa33ce26187f3baba9e0f914"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab641446baa33ce26187f3baba9e0f914">spdk_pci_device_claim</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:ab641446baa33ce26187f3baba9e0f914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Claim a PCI device for exclusive SPDK userspace access.  <a href="env_8h.html#ab641446baa33ce26187f3baba9e0f914">More...</a><br /></td></tr>
<tr class="separator:ab641446baa33ce26187f3baba9e0f914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e5710a5ece84d2d821b91351892da4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a53e5710a5ece84d2d821b91351892da4">spdk_pci_device_unclaim</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:a53e5710a5ece84d2d821b91351892da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo <a class="el" href="env_8h.html#ab641446baa33ce26187f3baba9e0f914" title="Claim a PCI device for exclusive SPDK userspace access.">spdk_pci_device_claim()</a>.  <a href="env_8h.html#a53e5710a5ece84d2d821b91351892da4">More...</a><br /></td></tr>
<tr class="separator:a53e5710a5ece84d2d821b91351892da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98502fc8d794fadaae348496d421082"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aa98502fc8d794fadaae348496d421082">spdk_pci_device_detach</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *device)</td></tr>
<tr class="memdesc:aa98502fc8d794fadaae348496d421082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all resources associated with the given device and detach it.  <a href="env_8h.html#aa98502fc8d794fadaae348496d421082">More...</a><br /></td></tr>
<tr class="separator:aa98502fc8d794fadaae348496d421082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6aa2606617cc3913fd5d6b7d218eba4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ac6aa2606617cc3913fd5d6b7d218eba4">spdk_pci_device_attach</a> (struct spdk_pci_driver *driver, <a class="el" href="env_8h.html#a0083aec1c2ac9ae023b744a80160af79">spdk_pci_enum_cb</a> enum_cb, void *enum_ctx, struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *pci_address)</td></tr>
<tr class="memdesc:ac6aa2606617cc3913fd5d6b7d218eba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a PCI device.  <a href="env_8h.html#ac6aa2606617cc3913fd5d6b7d218eba4">More...</a><br /></td></tr>
<tr class="separator:ac6aa2606617cc3913fd5d6b7d218eba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa85cff9c8d5bed6ba0eac58631e871"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a8fa85cff9c8d5bed6ba0eac58631e871">spdk_pci_device_allow</a> (struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *pci_addr)</td></tr>
<tr class="memdesc:a8fa85cff9c8d5bed6ba0eac58631e871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow the specified PCI device to be probed by the calling process.  <a href="env_8h.html#a8fa85cff9c8d5bed6ba0eac58631e871">More...</a><br /></td></tr>
<tr class="separator:a8fa85cff9c8d5bed6ba0eac58631e871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1767ff2d8e3bc7788de264d3077905b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a1767ff2d8e3bc7788de264d3077905b7">spdk_pci_device_cfg_read</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev, void *buf, uint32_t len, uint32_t offset)</td></tr>
<tr class="memdesc:a1767ff2d8e3bc7788de264d3077905b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read <code>len</code> bytes from the PCI configuration space.  <a href="env_8h.html#a1767ff2d8e3bc7788de264d3077905b7">More...</a><br /></td></tr>
<tr class="separator:a1767ff2d8e3bc7788de264d3077905b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ebacebce44ce5389fa3227580f6f13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#af0ebacebce44ce5389fa3227580f6f13">spdk_pci_device_cfg_write</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev, void *buf, uint32_t len, uint32_t offset)</td></tr>
<tr class="memdesc:af0ebacebce44ce5389fa3227580f6f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write <code>len</code> bytes into the PCI configuration space.  <a href="env_8h.html#af0ebacebce44ce5389fa3227580f6f13">More...</a><br /></td></tr>
<tr class="separator:af0ebacebce44ce5389fa3227580f6f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8e0b6936b5844b354b92278f66fa2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a1f8e0b6936b5844b354b92278f66fa2d">spdk_pci_device_cfg_read8</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev, uint8_t *value, uint32_t offset)</td></tr>
<tr class="memdesc:a1f8e0b6936b5844b354b92278f66fa2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 1 byte from the PCI configuration space.  <a href="env_8h.html#a1f8e0b6936b5844b354b92278f66fa2d">More...</a><br /></td></tr>
<tr class="separator:a1f8e0b6936b5844b354b92278f66fa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff1870d9b97e71f90d63825f0cb32b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a9ff1870d9b97e71f90d63825f0cb32b4">spdk_pci_device_cfg_write8</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev, uint8_t value, uint32_t offset)</td></tr>
<tr class="memdesc:a9ff1870d9b97e71f90d63825f0cb32b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 1 byte into the PCI configuration space.  <a href="env_8h.html#a9ff1870d9b97e71f90d63825f0cb32b4">More...</a><br /></td></tr>
<tr class="separator:a9ff1870d9b97e71f90d63825f0cb32b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e23e878bfc1748fce850d4d7f5b952c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a4e23e878bfc1748fce850d4d7f5b952c">spdk_pci_device_cfg_read16</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev, uint16_t *value, uint32_t offset)</td></tr>
<tr class="memdesc:a4e23e878bfc1748fce850d4d7f5b952c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 2 bytes from the PCI configuration space.  <a href="env_8h.html#a4e23e878bfc1748fce850d4d7f5b952c">More...</a><br /></td></tr>
<tr class="separator:a4e23e878bfc1748fce850d4d7f5b952c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b1abf6aacaba2d08bfa9b008c510c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a20b1abf6aacaba2d08bfa9b008c510c4">spdk_pci_device_cfg_write16</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev, uint16_t value, uint32_t offset)</td></tr>
<tr class="memdesc:a20b1abf6aacaba2d08bfa9b008c510c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 2 bytes into the PCI configuration space.  <a href="env_8h.html#a20b1abf6aacaba2d08bfa9b008c510c4">More...</a><br /></td></tr>
<tr class="separator:a20b1abf6aacaba2d08bfa9b008c510c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc70272071da54727134f9f13ed9771"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a5dc70272071da54727134f9f13ed9771">spdk_pci_device_cfg_read32</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev, uint32_t *value, uint32_t offset)</td></tr>
<tr class="memdesc:a5dc70272071da54727134f9f13ed9771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read 4 bytes from the PCI configuration space.  <a href="env_8h.html#a5dc70272071da54727134f9f13ed9771">More...</a><br /></td></tr>
<tr class="separator:a5dc70272071da54727134f9f13ed9771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488cf86d1c41376aaf526251fc7e3f07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a488cf86d1c41376aaf526251fc7e3f07">spdk_pci_device_cfg_write32</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev, uint32_t value, uint32_t offset)</td></tr>
<tr class="memdesc:a488cf86d1c41376aaf526251fc7e3f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 4 bytes into the PCI configuration space.  <a href="env_8h.html#a488cf86d1c41376aaf526251fc7e3f07">More...</a><br /></td></tr>
<tr class="separator:a488cf86d1c41376aaf526251fc7e3f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81297d98a464efeea8b33cee11f35dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aa81297d98a464efeea8b33cee11f35dc">spdk_pci_device_is_removed</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:aa81297d98a464efeea8b33cee11f35dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if device was requested to be removed from the process.  <a href="env_8h.html#aa81297d98a464efeea8b33cee11f35dc">More...</a><br /></td></tr>
<tr class="separator:aa81297d98a464efeea8b33cee11f35dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3decf485d6b797775bc4dd2215eb52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a7f3decf485d6b797775bc4dd2215eb52">spdk_pci_addr_compare</a> (const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *a1, const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *a2)</td></tr>
<tr class="memdesc:a7f3decf485d6b797775bc4dd2215eb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two PCI addresses.  <a href="env_8h.html#a7f3decf485d6b797775bc4dd2215eb52">More...</a><br /></td></tr>
<tr class="separator:a7f3decf485d6b797775bc4dd2215eb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96187c4c0c5a302669f684e487ebaa0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a96187c4c0c5a302669f684e487ebaa0d">spdk_pci_addr_parse</a> (struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *addr, const char *bdf)</td></tr>
<tr class="memdesc:a96187c4c0c5a302669f684e487ebaa0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a string representation of a PCI address into a struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a>.  <a href="env_8h.html#a96187c4c0c5a302669f684e487ebaa0d">More...</a><br /></td></tr>
<tr class="separator:a96187c4c0c5a302669f684e487ebaa0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492c0520e80d8be841891e4d1bd7a446"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a492c0520e80d8be841891e4d1bd7a446">spdk_pci_addr_fmt</a> (char *bdf, size_t sz, const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *addr)</td></tr>
<tr class="memdesc:a492c0520e80d8be841891e4d1bd7a446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> to a string.  <a href="env_8h.html#a492c0520e80d8be841891e4d1bd7a446">More...</a><br /></td></tr>
<tr class="separator:a492c0520e80d8be841891e4d1bd7a446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed436524e4df7525045e488206aa648"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a4ed436524e4df7525045e488206aa648">spdk_pci_hook_device</a> (struct spdk_pci_driver *drv, struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:a4ed436524e4df7525045e488206aa648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook a custom PCI device into the PCI layer.  <a href="env_8h.html#a4ed436524e4df7525045e488206aa648">More...</a><br /></td></tr>
<tr class="separator:a4ed436524e4df7525045e488206aa648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cda84fe7f3ca98ee13683207ffeca5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ac6cda84fe7f3ca98ee13683207ffeca5">spdk_pci_unhook_device</a> (struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:ac6cda84fe7f3ca98ee13683207ffeca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Un-hook a custom PCI device from the PCI layer.  <a href="env_8h.html#ac6cda84fe7f3ca98ee13683207ffeca5">More...</a><br /></td></tr>
<tr class="separator:ac6cda84fe7f3ca98ee13683207ffeca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692040f0dc2155a370c4496a1f863c90"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a692040f0dc2155a370c4496a1f863c90">spdk_pci_device_get_type</a> (const struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td></tr>
<tr class="memdesc:a692040f0dc2155a370c4496a1f863c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of the PCI device.  <a href="env_8h.html#a692040f0dc2155a370c4496a1f863c90">More...</a><br /></td></tr>
<tr class="separator:a692040f0dc2155a370c4496a1f863c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30e499f580512a07adde59837ea6b5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#af30e499f580512a07adde59837ea6b5e">spdk_pci_register_device_provider</a> (struct <a class="el" href="structspdk__pci__device__provider.html">spdk_pci_device_provider</a> *provider)</td></tr>
<tr class="memdesc:af30e499f580512a07adde59837ea6b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a PCI device provdier.  <a href="env_8h.html#af30e499f580512a07adde59837ea6b5e">More...</a><br /></td></tr>
<tr class="separator:af30e499f580512a07adde59837ea6b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925f8e1d1ed12fc1b7eb057a5c5b7bfd"><td class="memItemLeft" align="right" valign="top"><a id="a925f8e1d1ed12fc1b7eb057a5c5b7bfd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a925f8e1d1ed12fc1b7eb057a5c5b7bfd">spdk_unaffinitize_thread</a> (void)</td></tr>
<tr class="memdesc:a925f8e1d1ed12fc1b7eb057a5c5b7bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any CPU affinity from the current thread. <br /></td></tr>
<tr class="separator:a925f8e1d1ed12fc1b7eb057a5c5b7bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafaea6fc34059237e54e0ab254d0f28"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#abafaea6fc34059237e54e0ab254d0f28">spdk_call_unaffinitized</a> (void *cb(void *arg), void *arg)</td></tr>
<tr class="memdesc:abafaea6fc34059237e54e0ab254d0f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a function with CPU affinity unset.  <a href="env_8h.html#abafaea6fc34059237e54e0ab254d0f28">More...</a><br /></td></tr>
<tr class="separator:abafaea6fc34059237e54e0ab254d0f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1baea2604a87f2544317cf0c7309a44"><td class="memItemLeft" align="right" valign="top">struct spdk_mem_map *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aa1baea2604a87f2544317cf0c7309a44">spdk_mem_map_alloc</a> (uint64_t default_translation, const struct <a class="el" href="structspdk__mem__map__ops.html">spdk_mem_map_ops</a> *ops, void *cb_ctx)</td></tr>
<tr class="memdesc:aa1baea2604a87f2544317cf0c7309a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a virtual memory address translation map.  <a href="env_8h.html#aa1baea2604a87f2544317cf0c7309a44">More...</a><br /></td></tr>
<tr class="separator:aa1baea2604a87f2544317cf0c7309a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88ed69bd8b9a057f672a1170f7a5b6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#af88ed69bd8b9a057f672a1170f7a5b6c">spdk_mem_map_free</a> (struct spdk_mem_map **pmap)</td></tr>
<tr class="memdesc:af88ed69bd8b9a057f672a1170f7a5b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a memory map previously allocated by <a class="el" href="env_8h.html#aa1baea2604a87f2544317cf0c7309a44" title="Allocate a virtual memory address translation map.">spdk_mem_map_alloc()</a>.  <a href="env_8h.html#af88ed69bd8b9a057f672a1170f7a5b6c">More...</a><br /></td></tr>
<tr class="separator:af88ed69bd8b9a057f672a1170f7a5b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3314f2917141bf11f5b125c306d4397d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a3314f2917141bf11f5b125c306d4397d">spdk_mem_map_set_translation</a> (struct spdk_mem_map *map, uint64_t vaddr, uint64_t size, uint64_t translation)</td></tr>
<tr class="memdesc:a3314f2917141bf11f5b125c306d4397d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an address translation for a range of virtual memory.  <a href="env_8h.html#a3314f2917141bf11f5b125c306d4397d">More...</a><br /></td></tr>
<tr class="separator:a3314f2917141bf11f5b125c306d4397d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb4967ae71277512334ad27ef481326"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a2fb4967ae71277512334ad27ef481326">spdk_mem_map_clear_translation</a> (struct spdk_mem_map *map, uint64_t vaddr, uint64_t size)</td></tr>
<tr class="memdesc:a2fb4967ae71277512334ad27ef481326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister an address translation.  <a href="env_8h.html#a2fb4967ae71277512334ad27ef481326">More...</a><br /></td></tr>
<tr class="separator:a2fb4967ae71277512334ad27ef481326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99549dc9905683f1dea50ff79d0c5651"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a99549dc9905683f1dea50ff79d0c5651">spdk_mem_map_translate</a> (const struct spdk_mem_map *map, uint64_t vaddr, uint64_t *size)</td></tr>
<tr class="memdesc:a99549dc9905683f1dea50ff79d0c5651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the translation of a virtual address in a memory map.  <a href="env_8h.html#a99549dc9905683f1dea50ff79d0c5651">More...</a><br /></td></tr>
<tr class="separator:a99549dc9905683f1dea50ff79d0c5651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae046c45de2849d15f29dedc52e915ad7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ae046c45de2849d15f29dedc52e915ad7">spdk_mem_register</a> (void *vaddr, size_t len)</td></tr>
<tr class="memdesc:ae046c45de2849d15f29dedc52e915ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the specified memory region for address translation.  <a href="env_8h.html#ae046c45de2849d15f29dedc52e915ad7">More...</a><br /></td></tr>
<tr class="separator:ae046c45de2849d15f29dedc52e915ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffa0c74e2d73703266cad2d5d103f09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a3ffa0c74e2d73703266cad2d5d103f09">spdk_mem_unregister</a> (void *vaddr, size_t len)</td></tr>
<tr class="memdesc:a3ffa0c74e2d73703266cad2d5d103f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister the specified memory region from vtophys address translation.  <a href="env_8h.html#a3ffa0c74e2d73703266cad2d5d103f09">More...</a><br /></td></tr>
<tr class="separator:a3ffa0c74e2d73703266cad2d5d103f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981ce6d12bb1d9eeb828c6c7bd2ab585"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a981ce6d12bb1d9eeb828c6c7bd2ab585">spdk_mem_reserve</a> (void *vaddr, size_t len)</td></tr>
<tr class="memdesc:a981ce6d12bb1d9eeb828c6c7bd2ab585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve the address space specified in all memory maps.  <a href="env_8h.html#a981ce6d12bb1d9eeb828c6c7bd2ab585">More...</a><br /></td></tr>
<tr class="separator:a981ce6d12bb1d9eeb828c6c7bd2ab585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44e2bc97e1b87f737d664c047f6c3f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ab44e2bc97e1b87f737d664c047f6c3f2">spdk_mem_get_fd_and_offset</a> (void *vaddr, uint64_t *offset)</td></tr>
<tr class="memdesc:ab44e2bc97e1b87f737d664c047f6c3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address's file descriptor and offset, it works with spdk memory allocation APIs.  <a href="env_8h.html#ab44e2bc97e1b87f737d664c047f6c3f2">More...</a><br /></td></tr>
<tr class="separator:ab44e2bc97e1b87f737d664c047f6c3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a1b068221b7d1f1a1e2981ec3ba4d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ac0a1b068221b7d1f1a1e2981ec3ba4d4">spdk_pci_event_listen</a> (void)</td></tr>
<tr class="memdesc:ac0a1b068221b7d1f1a1e2981ec3ba4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin listening for PCI bus events.  <a href="env_8h.html#ac0a1b068221b7d1f1a1e2981ec3ba4d4">More...</a><br /></td></tr>
<tr class="separator:ac0a1b068221b7d1f1a1e2981ec3ba4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35497ea1837fa72486971df83005c0a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#a35497ea1837fa72486971df83005c0a4">spdk_pci_get_event</a> (int fd, struct <a class="el" href="structspdk__pci__event.html">spdk_pci_event</a> *event)</td></tr>
<tr class="memdesc:a35497ea1837fa72486971df83005c0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next PCI bus event.  <a href="env_8h.html#a35497ea1837fa72486971df83005c0a4">More...</a><br /></td></tr>
<tr class="separator:a35497ea1837fa72486971df83005c0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca05711bef2f8f8fa648e5715667f623"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#aca05711bef2f8f8fa648e5715667f623">spdk_pci_register_error_handler</a> (spdk_pci_error_handler sighandler, void *ctx)</td></tr>
<tr class="memdesc:aca05711bef2f8f8fa648e5715667f623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a signal handler to handle bus errors on the PCI bus.  <a href="env_8h.html#aca05711bef2f8f8fa648e5715667f623">More...</a><br /></td></tr>
<tr class="separator:aca05711bef2f8f8fa648e5715667f623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72f63b1d6c62bfa7cc9fc2683af65d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="env_8h.html#ad72f63b1d6c62bfa7cc9fc2683af65d8">spdk_pci_unregister_error_handler</a> (spdk_pci_error_handler sighandler)</td></tr>
<tr class="memdesc:ad72f63b1d6c62bfa7cc9fc2683af65d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a signal handler to handle bus errors on the PCI bus.  <a href="env_8h.html#ad72f63b1d6c62bfa7cc9fc2683af65d8">More...</a><br /></td></tr>
<tr class="separator:ad72f63b1d6c62bfa7cc9fc2683af65d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulated third-party dependencies. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a42d08df976f75c1e47ce174ebc446f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d08df976f75c1e47ce174ebc446f95">&#9670;&nbsp;</a></span>SPDK_ENV_FOREACH_CORE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPDK_ENV_FOREACH_CORE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        <span class="keywordflow">for</span> (i = <a class="code" href="env_8h.html#a2127ecc88ceb8e4b1242c316634de50e">spdk_env_get_first_core</a>();     \</div>
<div class="line">             i &lt; UINT32_MAX;                    \</div>
<div class="line">             i = <a class="code" href="env_8h.html#ab480f817ecdd801a0e53a4d8494ffc67">spdk_env_get_next_core</a>(i))</div>
<div class="ttc" id="aenv_8h_html_a2127ecc88ceb8e4b1242c316634de50e"><div class="ttname"><a href="env_8h.html#a2127ecc88ceb8e4b1242c316634de50e">spdk_env_get_first_core</a></div><div class="ttdeci">uint32_t spdk_env_get_first_core(void)</div><div class="ttdoc">Get the index of the first dedicated CPU core for this application.</div></div>
<div class="ttc" id="aenv_8h_html_ab480f817ecdd801a0e53a4d8494ffc67"><div class="ttname"><a href="env_8h.html#ab480f817ecdd801a0e53a4d8494ffc67">spdk_env_get_next_core</a></div><div class="ttdeci">uint32_t spdk_env_get_next_core(uint32_t prev_core)</div><div class="ttdoc">Get the index of the next dedicated CPU core for this application.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a723c2f644ec11282b96e1568f3124d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723c2f644ec11282b96e1568f3124d07">&#9670;&nbsp;</a></span>SPDK_MEMZONE_NO_IOVA_CONTIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPDK_MEMZONE_NO_IOVA_CONTIG&#160;&#160;&#160;0x00100000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memzone flags. </p>
<p>no iova contiguity </p>

</div>
</div>
<a id="a6e2a2a0f55f73b122740643e55d82d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2a2a0f55f73b122740643e55d82d31">&#9670;&nbsp;</a></span>SPDK_PCI_DEVICE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPDK_PCI_DEVICE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">vend, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dev&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        .class_id = SPDK_PCI_CLASS_ANY_ID,      \</div>
<div class="line">        .vendor_id = (vend),                    \</div>
<div class="line">        .device_id = (dev),                     \</div>
<div class="line">        .subvendor_id = SPDK_PCI_ANY_ID,        \</div>
<div class="line">        .subdevice_id = SPDK_PCI_ANY_ID</div>
</div><!-- fragment -->
</div>
</div>
<a id="a35a1b0ba34d824e4bd0a63af0a331916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a1b0ba34d824e4bd0a63af0a331916">&#9670;&nbsp;</a></span>SPDK_PCI_DRIVER_REGISTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPDK_PCI_DRIVER_REGISTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id_table, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flags&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">__attribute__((constructor)) <span class="keyword">static</span> <span class="keywordtype">void</span> _spdk_pci_driver_register_##name(<span class="keywordtype">void</span>) \</div>
<div class="line">{ \</div>
<div class="line">        spdk_pci_driver_register(#name, id_table, flags); \</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d3845f913b94ec2c05711450fecc468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3845f913b94ec2c05711450fecc468">&#9670;&nbsp;</a></span>SPDK_PCI_REGISTER_DEVICE_PROVIDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPDK_PCI_REGISTER_DEVICE_PROVIDER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">provider&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">        <span class="keyword">static</span> <span class="keywordtype">void</span> __attribute__((constructor)) _spdk_pci_register_device_provider_##name(<span class="keywordtype">void</span>) \</div>
<div class="line">        { \</div>
<div class="line">                spdk_pci_register_device_provider(provider); \</div>
<div class="line">        }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ae529cf9f5041c8014839d9ecfe5750a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae529cf9f5041c8014839d9ecfe5750a4">&#9670;&nbsp;</a></span>spdk_mempool_mem_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() spdk_mempool_mem_cb_t(struct spdk_mempool *mp, void *opaque, void *addr, uint64_t iova, size_t len, unsigned mem_idx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A memory chunk callback function for memory pool. </p>
<p>Used by <a class="el" href="env_8h.html#aa63d48e98e2dc3b0fdc9ad75905fc379" title="Iterate through all memory chunks of the pool and call a function on each one.">spdk_mempool_mem_iter()</a>. </p>

</div>
</div>
<a id="a039d3ef1514e326b6c2d8a527f6a6aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039d3ef1514e326b6c2d8a527f6a6aaa">&#9670;&nbsp;</a></span>spdk_mempool_obj_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void() spdk_mempool_obj_cb_t(struct spdk_mempool *mp, void *opaque, void *obj, unsigned obj_idx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An object callback function for memory pool. </p>
<p>Used by <a class="el" href="env_8h.html#a8981c2ba451d7214e157708a718db6c9" title="Create a thread-safe memory pool with user provided initialization function and argument.">spdk_mempool_create_ctor()</a>. </p>

</div>
</div>
<a id="a0083aec1c2ac9ae023b744a80160af79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0083aec1c2ac9ae023b744a80160af79">&#9670;&nbsp;</a></span>spdk_pci_enum_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_pci_enum_cb) (void *enum_ctx, struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for device attach handling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enum_ctx</td><td>Opaque value. </td></tr>
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if an error occurred, 0 if device attached successfully, 1 if device not attached. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abafaea6fc34059237e54e0ab254d0f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafaea6fc34059237e54e0ab254d0f28">&#9670;&nbsp;</a></span>spdk_call_unaffinitized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_call_unaffinitized </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb</em>void *arg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a function with CPU affinity unset. </p>
<p>This can be used to run a function that creates other threads without inheriting the calling thread's CPU affinity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Function to call </td></tr>
    <tr><td class="paramname">arg</td><td>Parameter to the function cb().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value of cb(). </dd></dl>

</div>
</div>
<a id="ab2e338ce2d6510489ae83bfff226b8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e338ce2d6510489ae83bfff226b8b1">&#9670;&nbsp;</a></span>spdk_delay_us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_delay_us </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay the given number of microseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">us</td><td>Number of microseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd01324e661a5d6deb59bd2bc6230de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd01324e661a5d6deb59bd2bc6230de3">&#9670;&nbsp;</a></span>spdk_dma_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_dma_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a memory buffer previously allocated, for example from <a class="el" href="env_8h.html#ae33af43d2e6f8037a58149c1defeb16c" title="Allocate a pinned memory buffer with the given size and alignment.">spdk_dma_zmalloc()</a>. </p>
<p>This call is never made from the performance path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9b56bdbcfeeebe6ad61eb574c823268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b56bdbcfeeebe6ad61eb574c823268">&#9670;&nbsp;</a></span>spdk_dma_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_dma_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a pinned memory buffer with the given size and alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>If non-zero, the allocated buffer is aligned to a multiple of align. In this case, it must be a power of two. The returned buffer is always aligned to at least cache line size. </td></tr>
    <tr><td class="paramname">unused</td><td><b>Invalid</b>. If not a NULL, the function will fail and return NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory buffer. </dd></dl>

</div>
</div>
<a id="adc1051e8f2c56403c55435c079b4f77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1051e8f2c56403c55435c079b4f77b">&#9670;&nbsp;</a></span>spdk_dma_malloc_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_dma_malloc_socket </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>unused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a pinned, memory buffer with the given size, alignment and socket id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>If non-zero, the allocated buffer is aligned to a multiple of align. In this case, it must be a power of two. The returned buffer is always aligned to at least cache line size. </td></tr>
    <tr><td class="paramname">unused</td><td><b>Invalid</b>. If not a NULL, the function will fail and return NULL. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory buffer. </dd></dl>

</div>
</div>
<a id="a7327bf788d5f76dc793ed2d9ee1b14e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7327bf788d5f76dc793ed2d9ee1b14e3">&#9670;&nbsp;</a></span>spdk_dma_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_dma_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the allocated and pinned memory buffer with the given new size and alignment. </p>
<p>Existing contents are preserved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to resize. </td></tr>
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>If non-zero, the allocated buffer is aligned to a multiple of align. In this case, it must be a power of two. The returned buffer is always aligned to at least cache line size. </td></tr>
    <tr><td class="paramname">unused</td><td><b>Invalid</b>. If not a NULL, the function will fail and return NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resized memory buffer. </dd></dl>

</div>
</div>
<a id="ae33af43d2e6f8037a58149c1defeb16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33af43d2e6f8037a58149c1defeb16c">&#9670;&nbsp;</a></span>spdk_dma_zmalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_dma_zmalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a pinned memory buffer with the given size and alignment. </p>
<p>The buffer will be zeroed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>If non-zero, the allocated buffer is aligned to a multiple of align. In this case, it must be a power of two. The returned buffer is always aligned to at least cache line size. </td></tr>
    <tr><td class="paramname">unused</td><td><b>Invalid</b>. If not a NULL, the function will fail and return NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory buffer. </dd></dl>

</div>
</div>
<a id="a8a6c3cc4df9f71125dec5c4c703ee1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6c3cc4df9f71125dec5c4c703ee1b0">&#9670;&nbsp;</a></span>spdk_dma_zmalloc_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_dma_zmalloc_socket </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>unused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a pinned memory buffer with the given size, alignment and socket id. </p>
<p>The buffer will be zeroed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>If non-zero, the allocated buffer is aligned to a multiple of align. In this case, it must be a power of two. The returned buffer is always aligned to at least cache line size. </td></tr>
    <tr><td class="paramname">unused</td><td><b>Invalid</b>. If not a NULL, the function will fail and return NULL. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory buffer. </dd></dl>

</div>
</div>
<a id="a719b5099cc3aa62190a1f44642ba6f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719b5099cc3aa62190a1f44642ba6f91">&#9670;&nbsp;</a></span>spdk_env_fini()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_env_fini </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release any resources of the environment library that were allocated with <a class="el" href="env_8h.html#a402ca8ae67be57c2c258a7a2bf22cfec" title="Initialize or reinitialize the environment library.">spdk_env_init()</a>. </p>
<p>After this call, no SPDK env function calls may be made. It is expected that common usage of this function is to call it just before terminating the process or before reinitializing the environment library within the same process. </p>

</div>
</div>
<a id="a4461ccdde430461ad2756b3799099330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4461ccdde430461ad2756b3799099330">&#9670;&nbsp;</a></span>spdk_env_get_core_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_core_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of dedicated CPU cores utilized by this env abstraction. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of dedicated CPU cores. </dd></dl>

</div>
</div>
<a id="a8a54ecf72f47decc6e8abc0bafcb578f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a54ecf72f47decc6e8abc0bafcb578f">&#9670;&nbsp;</a></span>spdk_env_get_cpuset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_env_get_cpuset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *&#160;</td>
          <td class="paramname"><em>cpuset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a cpuset with each dedicated core's bit set to true. </p>
<p>This function will first zero the cpuset and then set the bit for each core dedicated to this application to true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpuset</td><td><a class="el" href="structspdk__cpuset.html" title="List of CPUs.">spdk_cpuset</a> to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2483610a36d7daa9e6b067d9270d0087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2483610a36d7daa9e6b067d9270d0087">&#9670;&nbsp;</a></span>spdk_env_get_current_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_current_core </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CPU core index of the current thread. </p>
<p>This will only function when called from threads set up by this environment abstraction. For any other threads <code>SPDK_ENV_LCORE_ID_ANY</code> will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the CPU core index of the current thread. </dd></dl>

</div>
</div>
<a id="a2127ecc88ceb8e4b1242c316634de50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2127ecc88ceb8e4b1242c316634de50e">&#9670;&nbsp;</a></span>spdk_env_get_first_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_first_core </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the first dedicated CPU core for this application. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the first dedicated CPU core. </dd></dl>

</div>
</div>
<a id="ad66fc19d0c23cb21ff456581f0385a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66fc19d0c23cb21ff456581f0385a2b">&#9670;&nbsp;</a></span>spdk_env_get_last_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_last_core </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the last dedicated CPU core for this application. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the last dedicated CPU core. </dd></dl>

</div>
</div>
<a id="aec8cb2ee2493457ecf9d5e4d1cded32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8cb2ee2493457ecf9d5e4d1cded32f">&#9670;&nbsp;</a></span>spdk_env_get_main_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_main_core </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the main dedicated CPU core for this application. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the main dedicated CPU core. </dd></dl>

</div>
</div>
<a id="ab480f817ecdd801a0e53a4d8494ffc67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab480f817ecdd801a0e53a4d8494ffc67">&#9670;&nbsp;</a></span>spdk_env_get_next_core()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_next_core </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>prev_core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the next dedicated CPU core for this application. </p>
<p>If there is no next core, return UINT32_MAX.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev_core</td><td>Index of previous core.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the next dedicated CPU core. </dd></dl>

</div>
</div>
<a id="ab18052aa1bc0ff634ffc0ce11c577d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18052aa1bc0ff634ffc0ce11c577d65">&#9670;&nbsp;</a></span>spdk_env_get_socket_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_env_get_socket_id </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>core</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the socket ID for the given core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core</td><td>CPU core to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the socket ID for the given core. </dd></dl>

</div>
</div>
<a id="a402ca8ae67be57c2c258a7a2bf22cfec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402ca8ae67be57c2c258a7a2bf22cfec">&#9670;&nbsp;</a></span>spdk_env_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_env_init </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__env__opts.html">spdk_env_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize or reinitialize the environment library. </p>
<p>For initialization, this must be called prior to using any other functions in this library. For reinitialization, the parameter <code>opts</code> must be set to NULL and this must be called after the environment library was finished by <a class="el" href="env_8h.html#a719b5099cc3aa62190a1f44642ba6f91" title="Release any resources of the environment library that were allocated with spdk_env_init().">spdk_env_fini()</a> within the same process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Environment initialization options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negative errno on failure. </dd></dl>

</div>
</div>
<a id="af3b1a05d3f4dee14ba3f980672c9b3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b1a05d3f4dee14ba3f980672c9b3a6">&#9670;&nbsp;</a></span>spdk_env_opts_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_env_opts_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__env__opts.html">spdk_env_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the default value of opts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Data structure where SPDK will initialize the default options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4282feec502eca721136e88c824d59cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4282feec502eca721136e88c824d59cf">&#9670;&nbsp;</a></span>spdk_env_thread_launch_pinned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_env_thread_launch_pinned </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>core</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_start_fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Launch a thread pinned to the given core. </p>
<p>Only a single pinned thread may be launched per core. Subsequent attempts to launch pinned threads on that core will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">core</td><td>The core to pin the thread to. </td></tr>
    <tr><td class="paramname">fn</td><td>Entry point on the new thread. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to thread_start_fn</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="a452d670d7188f883224574dfabc39f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452d670d7188f883224574dfabc39f2c">&#9670;&nbsp;</a></span>spdk_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free buffer memory that was previously allocated with <a class="el" href="env_8h.html#a54dee7b759c26ff2a7e1789ddb59f214" title="Allocate dma/sharable memory based on a given dma_flg.">spdk_malloc()</a> or <a class="el" href="env_8h.html#a3ccd5c242af65c41dbe49ae2d903b5e4" title="Allocate dma/sharable memory based on a given dma_flg.">spdk_zmalloc()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d868d272aa0c000f6135966dfadc596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d868d272aa0c000f6135966dfadc596">&#9670;&nbsp;</a></span>spdk_get_ticks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_get_ticks </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a monotonic timestamp counter. </p>
<dl class="section return"><dt>Returns</dt><dd>the monotonic timestamp counter. </dd></dl>

</div>
</div>
<a id="a0e7d0eb3000d71b588486cf9903cd434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7d0eb3000d71b588486cf9903cd434">&#9670;&nbsp;</a></span>spdk_get_ticks_hz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_get_ticks_hz </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tick rate of <a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596" title="Get a monotonic timestamp counter.">spdk_get_ticks()</a> per second. </p>
<dl class="section return"><dt>Returns</dt><dd>the tick rate of <a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596" title="Get a monotonic timestamp counter.">spdk_get_ticks()</a> per second. </dd></dl>

</div>
</div>
<a id="ab7e36d9cc7a1aa8ae701bec368502273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e36d9cc7a1aa8ae701bec368502273">&#9670;&nbsp;</a></span>spdk_iommu_is_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_iommu_is_enabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether the SPDK application is using the IOMMU for DMA. </p>
<dl class="section return"><dt>Returns</dt><dd>True if we are using the IOMMU, false otherwise. </dd></dl>

</div>
</div>
<a id="a54dee7b759c26ff2a7e1789ddb59f214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54dee7b759c26ff2a7e1789ddb59f214">&#9670;&nbsp;</a></span>spdk_malloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>unused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate dma/sharable memory based on a given dma_flg. </p>
<p>It is a memory buffer with the given size, alignment and socket id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>If non-zero, the allocated buffer is aligned to a multiple of align. In this case, it must be a power of two. The returned buffer is always aligned to at least cache line size. </td></tr>
    <tr><td class="paramname">unused</td><td><b>Invalid</b>. If not a NULL, the function will fail and return NULL. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket. </td></tr>
    <tr><td class="paramname">flags</td><td>Combination of SPDK_MALLOC flags (<a class="el" href="env_8h.html#a7f065a5e897ff548b2dbf0996608929a">SPDK_MALLOC_DMA</a>, <a class="el" href="env_8h.html#ad1660ffa6731090ef3f480c295a87dba">SPDK_MALLOC_SHARE</a>). At least one flag must be specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory buffer. </dd></dl>

</div>
</div>
<a id="ab44e2bc97e1b87f737d664c047f6c3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44e2bc97e1b87f737d664c047f6c3f2">&#9670;&nbsp;</a></span>spdk_mem_get_fd_and_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mem_get_fd_and_offset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the address's file descriptor and offset, it works with spdk memory allocation APIs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vaddr</td><td>Virtual address to get </td></tr>
    <tr><td class="paramname">offset</td><td>Virtual address's map offset to the file descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative errno on failure, otherwise return the file descriptor </dd></dl>

</div>
</div>
<a id="aa1baea2604a87f2544317cf0c7309a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1baea2604a87f2544317cf0c7309a44">&#9670;&nbsp;</a></span>spdk_mem_map_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_mem_map* spdk_mem_map_alloc </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>default_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__mem__map__ops.html">spdk_mem_map_ops</a> *&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a virtual memory address translation map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_translation</td><td>Default translation for the map. </td></tr>
    <tr><td class="paramname">ops</td><td>Table of callback functions for map operations. </td></tr>
    <tr><td class="paramname">cb_ctx</td><td>Argument passed to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated virtual memory address translation map. </dd></dl>

</div>
</div>
<a id="a2fb4967ae71277512334ad27ef481326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb4967ae71277512334ad27ef481326">&#9670;&nbsp;</a></span>spdk_mem_map_clear_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mem_map_clear_translation </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mem_map *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister an address translation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Memory map. </td></tr>
    <tr><td class="paramname">vaddr</td><td>Virtual address of the region to unregister - must be 2 MB aligned. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the region in bytes - must be multiple of 2 MB in the current implementation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="env_8h.html#a3314f2917141bf11f5b125c306d4397d" title="Register an address translation for a range of virtual memory.">spdk_mem_map_set_translation()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="af88ed69bd8b9a057f672a1170f7a5b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88ed69bd8b9a057f672a1170f7a5b6c">&#9670;&nbsp;</a></span>spdk_mem_map_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_mem_map_free </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mem_map **&#160;</td>
          <td class="paramname"><em>pmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a memory map previously allocated by <a class="el" href="env_8h.html#aa1baea2604a87f2544317cf0c7309a44" title="Allocate a virtual memory address translation map.">spdk_mem_map_alloc()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmap</td><td>Memory map to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3314f2917141bf11f5b125c306d4397d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3314f2917141bf11f5b125c306d4397d">&#9670;&nbsp;</a></span>spdk_mem_map_set_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mem_map_set_translation </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mem_map *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an address translation for a range of virtual memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Memory map. </td></tr>
    <tr><td class="paramname">vaddr</td><td>Virtual address of the region to register - must be 2 MB aligned. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the region in bytes - must be multiple of 2 MB in the current implementation. </td></tr>
    <tr><td class="paramname">translation</td><td>Translation to store in the map for this address range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="env_8h.html#a2fb4967ae71277512334ad27ef481326" title="Unregister an address translation.">spdk_mem_map_clear_translation()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="a99549dc9905683f1dea50ff79d0c5651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99549dc9905683f1dea50ff79d0c5651">&#9670;&nbsp;</a></span>spdk_mem_map_translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_mem_map_translate </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_mem_map *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the translation of a virtual address in a memory map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>Memory map. </td></tr>
    <tr><td class="paramname">vaddr</td><td>Virtual address. </td></tr>
    <tr><td class="paramname">size</td><td>Contains the size of the memory region pointed to by vaddr. If vaddr is successfully translated, then this is updated with the size of the memory region for which the translation is valid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the translation of vaddr stored in the map, or default_translation as specified in <a class="el" href="env_8h.html#aa1baea2604a87f2544317cf0c7309a44" title="Allocate a virtual memory address translation map.">spdk_mem_map_alloc()</a> if vaddr is not present in the map. </dd></dl>

</div>
</div>
<a id="ae046c45de2849d15f29dedc52e915ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae046c45de2849d15f29dedc52e915ad7">&#9670;&nbsp;</a></span>spdk_mem_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mem_register </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the specified memory region for address translation. </p>
<p>The memory region must map to pinned huge pages (2MB or greater).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vaddr</td><td>Virtual address to register. </td></tr>
    <tr><td class="paramname">len</td><td>Length in bytes of the vaddr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="a981ce6d12bb1d9eeb828c6c7bd2ab585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981ce6d12bb1d9eeb828c6c7bd2ab585">&#9670;&nbsp;</a></span>spdk_mem_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mem_reserve </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve the address space specified in all memory maps. </p>
<p>This pre-allocates the necessary space in the memory maps such that future calls to <a class="el" href="env_8h.html#ae046c45de2849d15f29dedc52e915ad7" title="Register the specified memory region for address translation.">spdk_mem_register()</a> on that region require no internal memory allocations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vaddr</td><td>Virtual address to reserve </td></tr>
    <tr><td class="paramname">len</td><td>Length in bytes of vaddr</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure. </dd></dl>

</div>
</div>
<a id="a3ffa0c74e2d73703266cad2d5d103f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffa0c74e2d73703266cad2d5d103f09">&#9670;&nbsp;</a></span>spdk_mem_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mem_unregister </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister the specified memory region from vtophys address translation. </p>
<p>The caller must ensure all in-flight DMA operations to this memory region are completed or cancelled before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vaddr</td><td>Virtual address to unregister. </td></tr>
    <tr><td class="paramname">len</td><td>Length in bytes of the vaddr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="a434cdf73691c745e717b8b794b2acb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434cdf73691c745e717b8b794b2acb52">&#9670;&nbsp;</a></span>spdk_mempool_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_mempool_count </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of entries in the memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>Memory pool to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of entries in the memory pool. </dd></dl>

</div>
</div>
<a id="a8d4f7842191990b49694495bba10fcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4f7842191990b49694495bba10fcbd">&#9670;&nbsp;</a></span>spdk_mempool_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_mempool* spdk_mempool_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ele_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread-safe memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name for the memory pool. </td></tr>
    <tr><td class="paramname">count</td><td>Count of elements. </td></tr>
    <tr><td class="paramname">ele_size</td><td>Element size in bytes. </td></tr>
    <tr><td class="paramname">cache_size</td><td>How many elements may be cached in per-core caches. Use SPDK_MEMPOOL_DEFAULT_CACHE_SIZE for a reasonable default, or 0 for no per-core cache. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the created memory pool. </dd></dl>

</div>
</div>
<a id="a8981c2ba451d7214e157708a718db6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8981c2ba451d7214e157708a718db6c9">&#9670;&nbsp;</a></span>spdk_mempool_create_ctor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_mempool* spdk_mempool_create_ctor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ele_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="env_8h.html#a039d3ef1514e326b6c2d8a527f6a6aaa">spdk_mempool_obj_cb_t</a> *&#160;</td>
          <td class="paramname"><em>obj_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj_init_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a thread-safe memory pool with user provided initialization function and argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name for the memory pool. </td></tr>
    <tr><td class="paramname">count</td><td>Count of elements. </td></tr>
    <tr><td class="paramname">ele_size</td><td>Element size in bytes. </td></tr>
    <tr><td class="paramname">cache_size</td><td>How many elements may be cached in per-core caches. Use SPDK_MEMPOOL_DEFAULT_CACHE_SIZE for a reasonable default, or 0 for no per-core cache. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket. </td></tr>
    <tr><td class="paramname">obj_init</td><td>User provided object callback initialization function. </td></tr>
    <tr><td class="paramname">obj_init_arg</td><td>User provided callback initialization function argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the created memory pool. </dd></dl>

</div>
</div>
<a id="ada5041ebc03066dede6e0972c22dc77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5041ebc03066dede6e0972c22dc77f">&#9670;&nbsp;</a></span>spdk_mempool_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_mempool_get </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an element from a memory pool. </p>
<p>If no elements remain, return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Memory pool to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the element. </dd></dl>

</div>
</div>
<a id="a5695d9dcc6f53a561f41c932a198853b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5695d9dcc6f53a561f41c932a198853b">&#9670;&nbsp;</a></span>spdk_mempool_get_bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_mempool_get_bulk </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ele_arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get multiple elements from a memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Memory pool to get multiple elements from. </td></tr>
    <tr><td class="paramname">ele_arr</td><td>Array of the elements to fill. </td></tr>
    <tr><td class="paramname">count</td><td>Count of elements to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="aef50d2e8f2d7fccfd5c5edf95e5013d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef50d2e8f2d7fccfd5c5edf95e5013d2">&#9670;&nbsp;</a></span>spdk_mempool_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* spdk_mempool_get_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of a memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Memory pool to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the memory pool. </dd></dl>

</div>
</div>
<a id="a397f334df8126cae08a8499688e1601f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397f334df8126cae08a8499688e1601f">&#9670;&nbsp;</a></span>spdk_mempool_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_mempool* spdk_mempool_lookup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup the memory pool identified by the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the memory pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the memory pool on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="aa63d48e98e2dc3b0fdc9ad75905fc379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63d48e98e2dc3b0fdc9ad75905fc379">&#9670;&nbsp;</a></span>spdk_mempool_mem_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_mempool_mem_iter </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="env_8h.html#ae529cf9f5041c8014839d9ecfe5750a4">spdk_mempool_mem_cb_t</a>&#160;</td>
          <td class="paramname"><em>mem_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate through all memory chunks of the pool and call a function on each one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Memory pool to iterate on. </td></tr>
    <tr><td class="paramname">mem_cb</td><td>Function to call on each memory chunk. </td></tr>
    <tr><td class="paramname">mem_cb_arg</td><td>Opaque pointer passed to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of memory chunks iterated. </dd></dl>

</div>
</div>
<a id="ad3b9b2980b2bf4be6e1b75024d676cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b9b2980b2bf4be6e1b75024d676cd1">&#9670;&nbsp;</a></span>spdk_mempool_obj_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_mempool_obj_iter </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="env_8h.html#a039d3ef1514e326b6c2d8a527f6a6aaa">spdk_mempool_obj_cb_t</a>&#160;</td>
          <td class="paramname"><em>obj_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj_cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate through all elements of the pool and call a function on each one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Memory pool to iterate on. </td></tr>
    <tr><td class="paramname">obj_cb</td><td>Function to call on each element. </td></tr>
    <tr><td class="paramname">obj_cb_arg</td><td>Opaque pointer passed to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements iterated. </dd></dl>

</div>
</div>
<a id="a56233342766c54990e044b8ca2f3d41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56233342766c54990e044b8ca2f3d41a">&#9670;&nbsp;</a></span>spdk_mempool_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_mempool_put </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ele</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put an element back into the memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Memory pool to put element back into. </td></tr>
    <tr><td class="paramname">ele</td><td>Element to put. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02f2b221ab82ba09c51013291313fe2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f2b221ab82ba09c51013291313fe2e">&#9670;&nbsp;</a></span>spdk_mempool_put_bulk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_mempool_put_bulk </td>
          <td>(</td>
          <td class="paramtype">struct spdk_mempool *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ele_arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put multiple elements back into the memory pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Memory pool to put multiple elements back into. </td></tr>
    <tr><td class="paramname">ele_arr</td><td>Array of the elements to put. </td></tr>
    <tr><td class="paramname">count</td><td>Count of elements to put. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b47302a948b71f493ae775b53f162e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b47302a948b71f493ae775b53f162e2">&#9670;&nbsp;</a></span>spdk_memzone_dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_memzone_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump debug information about all memzones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>File to write debug information to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c7f9a6391c0e076abd0160b24f2ad81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7f9a6391c0e076abd0160b24f2ad81">&#9670;&nbsp;</a></span>spdk_memzone_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_memzone_free </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the memory zone identified by the given name. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a2be5bc3f8fc570f45f2ad087fcb91f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be5bc3f8fc570f45f2ad087fcb91f9e">&#9670;&nbsp;</a></span>spdk_memzone_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_memzone_lookup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup the memory zone identified by the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the memory zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the reserved memory address on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a48afc08099440a88e9e8dc3abf540ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48afc08099440a88e9e8dc3abf540ab9">&#9670;&nbsp;</a></span>spdk_memzone_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_memzone_reserve </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve a named, process shared memory zone with the given size, socket_id and flags. </p>
<p>Unless <code>SPDK_MEMZONE_NO_IOVA_CONTIG</code> flag is provided, the returned memory will be IOVA contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name to set for this memory zone. </td></tr>
    <tr><td class="paramname">len</td><td>Length in bytes. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to set for this memory zone.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory address on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="aa179a05a509878b70a9e4dfe8079841a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa179a05a509878b70a9e4dfe8079841a">&#9670;&nbsp;</a></span>spdk_memzone_reserve_aligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_memzone_reserve_aligned </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve a named, process shared memory zone with the given size, socket_id, flags and alignment. </p>
<p>Unless <code>SPDK_MEMZONE_NO_IOVA_CONTIG</code> flag is provided, the returned memory will be IOVA contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name to set for this memory zone. </td></tr>
    <tr><td class="paramname">len</td><td>Length in bytes. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to set for this memory zone. </td></tr>
    <tr><td class="paramname">align</td><td>Alignment for resulting memzone. Must be a power of 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory address on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a7f3decf485d6b797775bc4dd2215eb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3decf485d6b797775bc4dd2215eb52">&#9670;&nbsp;</a></span>spdk_pci_addr_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_addr_compare </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two PCI addresses. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a1</td><td>PCI address 1. </td></tr>
    <tr><td class="paramname">a2</td><td>PCI address 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if a1 == a2, less than 0 if a1 &lt; a2, greater than 0 if a1 &gt; a2 </dd></dl>

</div>
</div>
<a id="a492c0520e80d8be841891e4d1bd7a446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492c0520e80d8be841891e4d1bd7a446">&#9670;&nbsp;</a></span>spdk_pci_addr_fmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_addr_fmt </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bdf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> to a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdf</td><td>String into which a string will be output in the format domain:bus:device.function. The string must be at least 14 characters in size. </td></tr>
    <tr><td class="paramname">sz</td><td>Size of bdf in bytes. Must be at least 14. </td></tr>
    <tr><td class="paramname">addr</td><td>PCI address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or a negated errno on failure. </dd></dl>

</div>
</div>
<a id="a96187c4c0c5a302669f684e487ebaa0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96187c4c0c5a302669f684e487ebaa0d">&#9670;&nbsp;</a></span>spdk_pci_addr_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_addr_parse </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bdf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a string representation of a PCI address into a struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>PCI address output on success. </td></tr>
    <tr><td class="paramname">bdf</td><td>PCI address in domain:bus:device.function format or domain.bus.device.function format.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. </dd></dl>

</div>
</div>
<a id="a8fa85cff9c8d5bed6ba0eac58631e871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa85cff9c8d5bed6ba0eac58631e871">&#9670;&nbsp;</a></span>spdk_pci_device_allow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_allow </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>pci_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow the specified PCI device to be probed by the calling process. </p>
<p>When using <a class="el" href="env_8h.html#a8e2430eaebf3d756c8608aea6957b614" title="Enumerate all PCI devices supported by the provided driver and try to attach those that weren&#39;t attac...">spdk_pci_enumerate()</a>, only devices with allowed PCI addresses will be probed. By default, this is all PCI addresses, but the pci_allowed and pci_blocked environment options can override this behavior. This API enables the caller to allow a new PCI address that may have previously been blocked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pci_addr</td><td>PCI address to allow </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful </dd>
<dd>
-ENOMEM if environment-specific data structures cannot be allocated </dd>
<dd>
-EINVAL if specified PCI address is not valid </dd></dl>

</div>
</div>
<a id="ac6aa2606617cc3913fd5d6b7d218eba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6aa2606617cc3913fd5d6b7d218eba4">&#9670;&nbsp;</a></span>spdk_pci_device_attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_attach </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_driver *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="env_8h.html#a0083aec1c2ac9ae023b744a80160af79">spdk_pci_enum_cb</a>&#160;</td>
          <td class="paramname"><em>enum_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>enum_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *&#160;</td>
          <td class="paramname"><em>pci_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a PCI device. </p>
<p>This will bypass all blocked list rules and explicitly attach a device at the provided address. The return code of the provided callback will decide whether that device is attached or not. Attached devices have to be manually detached with <a class="el" href="env_8h.html#aa98502fc8d794fadaae348496d421082" title="Release all resources associated with the given device and detach it.">spdk_pci_device_detach()</a> to be attach-able again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver</td><td>Driver for a specific device type. The device will only be attached if it's supported by this driver. </td></tr>
    <tr><td class="paramname">enum_cb</td><td>Callback to be called for the PCI device once it's found. </td></tr>
    <tr><td class="paramname">enum_ctx</td><td>Additional context passed to the callback function. </td></tr>
    <tr><td class="paramname">pci_address</td><td>Address of the device to attach.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if a device at the provided PCI address couldn't be found, -1 if an internal error happened or the provided callback returned non-zero, 0 otherwise </dd></dl>

</div>
</div>
<a id="a1767ff2d8e3bc7788de264d3077905b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1767ff2d8e3bc7788de264d3077905b7">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read <code>len</code> bytes from the PCI configuration space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">buf</td><td>A buffer to copy the data into. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to read. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) in the PCI config space to start reading from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a4e23e878bfc1748fce850d4d7f5b952c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e23e878bfc1748fce850d4d7f5b952c">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_read16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_read16 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 2 bytes from the PCI configuration space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">value</td><td>A buffer to copy the data into. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) in the PCI config space to start reading from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a5dc70272071da54727134f9f13ed9771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc70272071da54727134f9f13ed9771">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_read32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_read32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 4 bytes from the PCI configuration space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">value</td><td>A buffer to copy the data into. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) in the PCI config space to start reading from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a1f8e0b6936b5844b354b92278f66fa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8e0b6936b5844b354b92278f66fa2d">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_read8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_read8 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read 1 byte from the PCI configuration space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">value</td><td>A buffer to copy the data into. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) in the PCI config space to start reading from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="af0ebacebce44ce5389fa3227580f6f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ebacebce44ce5389fa3227580f6f13">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write <code>len</code> bytes into the PCI configuration space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">buf</td><td>A buffer to copy the data from. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to write. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) in the PCI config space to start writing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a20b1abf6aacaba2d08bfa9b008c510c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b1abf6aacaba2d08bfa9b008c510c4">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_write16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_write16 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 2 bytes into the PCI configuration space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">value</td><td>A value to write. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) in the PCI config space to start writing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a488cf86d1c41376aaf526251fc7e3f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488cf86d1c41376aaf526251fc7e3f07">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_write32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_write32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 4 bytes into the PCI configuration space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">value</td><td>A value to write. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) in the PCI config space to start writing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a9ff1870d9b97e71f90d63825f0cb32b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff1870d9b97e71f90d63825f0cb32b4">&#9670;&nbsp;</a></span>spdk_pci_device_cfg_write8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_cfg_write8 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 1 byte into the PCI configuration space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">value</td><td>A value to write. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset (in bytes) in the PCI config space to start writing to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ab641446baa33ce26187f3baba9e0f914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab641446baa33ce26187f3baba9e0f914">&#9670;&nbsp;</a></span>spdk_pci_device_claim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_claim </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Claim a PCI device for exclusive SPDK userspace access. </p>
<p>Uses F_SETLK on a shared memory file with the PCI address embedded in its name. As long as this file remains open with the lock acquired, other processes will not be able to successfully call this function on the same PCI device.</p>
<p>The device can be un-claimed by the owning process with <a class="el" href="env_8h.html#a53e5710a5ece84d2d821b91351892da4" title="Undo spdk_pci_device_claim().">spdk_pci_device_unclaim()</a>. It will be also unclaimed automatically when detached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device to claim.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EACCES if the device has already been claimed, negative errno on unexpected errors, 0 on success. </dd></dl>

</div>
</div>
<a id="aa98502fc8d794fadaae348496d421082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa98502fc8d794fadaae348496d421082">&#9670;&nbsp;</a></span>spdk_pci_device_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_pci_device_detach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release all resources associated with the given device and detach it. </p>
<p>As long as the PCI device is physically available, it will attachable again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>PCI device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab796808f5105da215e5da178ad39e3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab796808f5105da215e5da178ad39e3ac">&#9670;&nbsp;</a></span>spdk_pci_device_disable_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_disable_interrupt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable PCI device interrupts. </p>
<p>(Experimental)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative value on error. </dd></dl>

</div>
</div>
<a id="a3ca80b3a77dfc8b35e65dc281737019d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca80b3a77dfc8b35e65dc281737019d">&#9670;&nbsp;</a></span>spdk_pci_device_enable_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_enable_interrupt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable PCI device interrupts. </p>
<p>(Experimental)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative value on error. </dd></dl>

</div>
</div>
<a id="a71622d665e7b50f34d2279e7e86b557e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71622d665e7b50f34d2279e7e86b557e">&#9670;&nbsp;</a></span>spdk_pci_device_get_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> spdk_pci_device_get_addr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the full DomainBDF address of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PCI address. </dd></dl>

</div>
</div>
<a id="a1ae16576e55bc5015818abc07c370244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae16576e55bc5015818abc07c370244">&#9670;&nbsp;</a></span>spdk_pci_device_get_bus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t spdk_pci_device_get_bus </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bus number of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PCI bus number. </dd></dl>

</div>
</div>
<a id="ae5027b309c5a3210250d896ed5c9b0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5027b309c5a3210250d896ed5c9b0f8">&#9670;&nbsp;</a></span>spdk_pci_device_get_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t spdk_pci_device_get_dev </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device number within the PCI bus the device is on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PCI device number. </dd></dl>

</div>
</div>
<a id="a8b2553026e46a40c274980b5b201b0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2553026e46a40c274980b5b201b0cb">&#9670;&nbsp;</a></span>spdk_pci_device_get_device_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t spdk_pci_device_get_device_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device ID of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>device ID. </dd></dl>

</div>
</div>
<a id="a10b6650e48ccffaea6ca59fe0b875da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b6650e48ccffaea6ca59fe0b875da5">&#9670;&nbsp;</a></span>spdk_pci_device_get_domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_pci_device_get_domain </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the domain of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PCI device domain. </dd></dl>

</div>
</div>
<a id="a6c4342c5bc69edb7b42a3873e54bd2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4342c5bc69edb7b42a3873e54bd2d7">&#9670;&nbsp;</a></span>spdk_pci_device_get_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t spdk_pci_device_get_func </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the particular function number represented by struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PCI function number. </dd></dl>

</div>
</div>
<a id="a5c5c2f463bddbce4cc846e04246f6414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5c2f463bddbce4cc846e04246f6414">&#9670;&nbsp;</a></span>spdk_pci_device_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__pci__id.html">spdk_pci_id</a> spdk_pci_device_get_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the PCI ID of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PCI ID. </dd></dl>

</div>
</div>
<a id="a6b50d57653132fb21a10a4ff120125c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b50d57653132fb21a10a4ff120125c7">&#9670;&nbsp;</a></span>spdk_pci_device_get_interrupt_efd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_get_interrupt_efd </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an event file descriptor assosiated with a PCI device interrupt. </p>
<p>(Experimental)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event file descriptor on success, negative value on error. </dd></dl>

</div>
</div>
<a id="a69b979316610b357a35d03500c3059af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b979316610b357a35d03500c3059af">&#9670;&nbsp;</a></span>spdk_pci_device_get_serial_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_get_serial_number </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize the PCIe Device Serial Number into the provided buffer. </p>
<p>The buffer will contain a 16-character-long serial number followed by a NULL terminator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">sn</td><td>Buffer to store the serial number in. </td></tr>
    <tr><td class="paramname">len</td><td>Length of buffer. Must be at least 17.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a235f1c632be6dc00aad1cf8fd0314609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235f1c632be6dc00aad1cf8fd0314609">&#9670;&nbsp;</a></span>spdk_pci_device_get_socket_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_get_socket_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NUMA node the PCI device is on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NUMA node index (&gt;= 0). </dd></dl>

</div>
</div>
<a id="a6368feb8685db7cc745f14e184a5e3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6368feb8685db7cc745f14e184a5e3e0">&#9670;&nbsp;</a></span>spdk_pci_device_get_subdevice_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t spdk_pci_device_get_subdevice_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the subdevice ID of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>subdevice ID. </dd></dl>

</div>
</div>
<a id="ae488ab8a8a1b56ae22ca26b00185f7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae488ab8a8a1b56ae22ca26b00185f7f8">&#9670;&nbsp;</a></span>spdk_pci_device_get_subvendor_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t spdk_pci_device_get_subvendor_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the subvendor ID of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>subvendor ID. </dd></dl>

</div>
</div>
<a id="a692040f0dc2155a370c4496a1f863c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692040f0dc2155a370c4496a1f863c90">&#9670;&nbsp;</a></span>spdk_pci_device_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_pci_device_get_type </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the type of the PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string representing the type of the device </dd></dl>

</div>
</div>
<a id="abe6b50f74ddb53ff6ee4552c20a053bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6b50f74ddb53ff6ee4552c20a053bc">&#9670;&nbsp;</a></span>spdk_pci_device_get_vendor_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t spdk_pci_device_get_vendor_id </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the vendor ID of a PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vendor ID. </dd></dl>

</div>
</div>
<a id="aa81297d98a464efeea8b33cee11f35dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81297d98a464efeea8b33cee11f35dc">&#9670;&nbsp;</a></span>spdk_pci_device_is_removed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_pci_device_is_removed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if device was requested to be removed from the process. </p>
<p>This can be caused either by physical device hotremoval or OS-triggered removal. In the latter case, the device may continue to function properly even if this function returns <code>true</code> . The upper-layer driver may check this function periodically and eventually detach the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if device was requested to be removed </dd></dl>

</div>
</div>
<a id="ab1964fc8e4bdbe6c8fc3002f063a6747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1964fc8e4bdbe6c8fc3002f063a6747">&#9670;&nbsp;</a></span>spdk_pci_device_map_bar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_map_bar </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>mapped_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>phys_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a PCI BAR in the current process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">bar</td><td>BAR number. </td></tr>
    <tr><td class="paramname">mapped_addr</td><td>A variable to store the virtual address of the mapping. </td></tr>
    <tr><td class="paramname">phys_addr</td><td>A variable to store the physical address of the mapping. </td></tr>
    <tr><td class="paramname">size</td><td>A variable to store the size of the bar (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a id="a53e5710a5ece84d2d821b91351892da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e5710a5ece84d2d821b91351892da4">&#9670;&nbsp;</a></span>spdk_pci_device_unclaim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_pci_device_unclaim </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undo <a class="el" href="env_8h.html#ab641446baa33ce26187f3baba9e0f914" title="Claim a PCI device for exclusive SPDK userspace access.">spdk_pci_device_claim()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device to unclaim. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80b33324546e79d1478f25c185076336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b33324546e79d1478f25c185076336">&#9670;&nbsp;</a></span>spdk_pci_device_unmap_bar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_device_unmap_bar </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mapped_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmap a PCI BAR from the current process. </p>
<p>This happens automatically when the PCI device is detached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>PCI device. </td></tr>
    <tr><td class="paramname">bar</td><td>BAR number. </td></tr>
    <tr><td class="paramname">mapped_addr</td><td>Virtual address of the bar.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a id="a8e2430eaebf3d756c8608aea6957b614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2430eaebf3d756c8608aea6957b614">&#9670;&nbsp;</a></span>spdk_pci_enumerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_enumerate </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_driver *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="env_8h.html#a0083aec1c2ac9ae023b744a80160af79">spdk_pci_enum_cb</a>&#160;</td>
          <td class="paramname"><em>enum_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>enum_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate all PCI devices supported by the provided driver and try to attach those that weren't attached yet. </p>
<p>The provided callback will be called for each such device and its return code will decide whether that device is attached or not. Attached devices have to be manually detached with <a class="el" href="env_8h.html#aa98502fc8d794fadaae348496d421082" title="Release all resources associated with the given device and detach it.">spdk_pci_device_detach()</a> to be attach-able again.</p>
<p>During enumeration all registered pci devices with exposed access to userspace are getting probed internally unless not explicitly specified on denylist. Because of that it becomes not possible to either use such devices with another application or unbind the driver (e.g. vfio).</p>
<p>2s asynchronous delay is introduced to avoid race conditions between user space software initialization and in-kernel device handling for newly inserted devices. Subsequent enumerate call after the delay shall allow for a successful device attachment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver</td><td>Driver for a specific device type. </td></tr>
    <tr><td class="paramname">enum_cb</td><td>Callback to be called for each non-attached PCI device. </td></tr>
    <tr><td class="paramname">enum_ctx</td><td>Additional context passed to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if an internal error occurred or the provided callback returned -1, 0 otherwise </dd></dl>

</div>
</div>
<a id="ac0a1b068221b7d1f1a1e2981ec3ba4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a1b068221b7d1f1a1e2981ec3ba4d4">&#9670;&nbsp;</a></span>spdk_pci_event_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_event_listen </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin listening for PCI bus events. </p>
<p>This is used to detect hot-insert and hot-remove events. Once the system is listening, events may be retrieved by calling <a class="el" href="env_8h.html#a35497ea1837fa72486971df83005c0a4" title="Get the next PCI bus event.">spdk_pci_get_event()</a> periodically.</p>
<dl class="section return"><dt>Returns</dt><dd>negative errno on failure, otherwise, return a file descriptor that may be later passed to <a class="el" href="env_8h.html#a35497ea1837fa72486971df83005c0a4" title="Get the next PCI bus event.">spdk_pci_get_event()</a>. </dd></dl>

</div>
</div>
<a id="a4705df2fb00412d72deda48ab9bf088a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4705df2fb00412d72deda48ab9bf088a">&#9670;&nbsp;</a></span>spdk_pci_for_each_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_pci_for_each_device </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *ctx, struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *dev)&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the provided function pointer for every enumerated PCI device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context parameter to pass to fn. </td></tr>
    <tr><td class="paramname">fn</td><td>Function to call for each PCI device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cedd84c4dbf700c387d8fb6ebc42578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cedd84c4dbf700c387d8fb6ebc42578">&#9670;&nbsp;</a></span>spdk_pci_get_driver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_pci_driver* spdk_pci_get_driver </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get PCI driver by name (e.g. </p>
<p>"nvme", "vmd", "ioat"). </p>

</div>
</div>
<a id="a35497ea1837fa72486971df83005c0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35497ea1837fa72486971df83005c0a4">&#9670;&nbsp;</a></span>spdk_pci_get_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_get_event </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__event.html">spdk_pci_event</a> *&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next PCI bus event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>A file descriptor returned by <a class="el" href="env_8h.html#ac0a1b068221b7d1f1a1e2981ec3ba4d4" title="Begin listening for PCI bus events.">spdk_pci_event_listen()</a> </td></tr>
    <tr><td class="paramname">event</td><td>An event on the PCI bus</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negative errno on failure. 0 for no event. A positive number when an event has been returned </dd></dl>

</div>
</div>
<a id="a4ed436524e4df7525045e488206aa648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed436524e4df7525045e488206aa648">&#9670;&nbsp;</a></span>spdk_pci_hook_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_hook_device </td>
          <td>(</td>
          <td class="paramtype">struct spdk_pci_driver *&#160;</td>
          <td class="paramname"><em>drv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hook a custom PCI device into the PCI layer. </p>
<p>The device will be attachable, enumerable, and will call provided callbacks on each PCI resource access request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drv</td><td>driver that will be able to attach the device </td></tr>
    <tr><td class="paramname">dev</td><td>fully initialized PCI device struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno otherwise. </dd></dl>

</div>
</div>
<a id="aba107481f435164bef55ae65652775a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba107481f435164bef55ae65652775a8">&#9670;&nbsp;</a></span>spdk_pci_idxd_get_driver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_pci_driver* spdk_pci_idxd_get_driver </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the IDXD PCI driver object. </p>
<dl class="section return"><dt>Returns</dt><dd>PCI driver. </dd></dl>

</div>
</div>
<a id="ad9d208ba1e19b37b76bb993c358b5760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d208ba1e19b37b76bb993c358b5760">&#9670;&nbsp;</a></span>spdk_pci_ioat_get_driver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_pci_driver* spdk_pci_ioat_get_driver </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the I/OAT PCI driver object. </p>
<dl class="section return"><dt>Returns</dt><dd>PCI driver. </dd></dl>

</div>
</div>
<a id="aa4a5c3c4f51c1eaac132f6093fe219f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a5c3c4f51c1eaac132f6093fe219f4">&#9670;&nbsp;</a></span>spdk_pci_nvme_get_driver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_pci_driver* spdk_pci_nvme_get_driver </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NVMe PCI driver object. </p>
<dl class="section return"><dt>Returns</dt><dd>PCI driver. </dd></dl>

</div>
</div>
<a id="af30e499f580512a07adde59837ea6b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30e499f580512a07adde59837ea6b5e">&#9670;&nbsp;</a></span>spdk_pci_register_device_provider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_pci_register_device_provider </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device__provider.html">spdk_pci_device_provider</a> *&#160;</td>
          <td class="paramname"><em>provider</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a PCI device provdier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">provider</td><td>PCI device provider. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca05711bef2f8f8fa648e5715667f623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca05711bef2f8f8fa648e5715667f623">&#9670;&nbsp;</a></span>spdk_pci_register_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_pci_register_error_handler </td>
          <td>(</td>
          <td class="paramtype">spdk_pci_error_handler&#160;</td>
          <td class="paramname"><em>sighandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a signal handler to handle bus errors on the PCI bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sighandler</td><td>Signal bus handler of the PCI bus </td></tr>
    <tr><td class="paramname">ctx</td><td>The arg pass to the registered signal bus handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>negative errno on failure, otherwise it means successful </dd></dl>

</div>
</div>
<a id="ac6cda84fe7f3ca98ee13683207ffeca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6cda84fe7f3ca98ee13683207ffeca5">&#9670;&nbsp;</a></span>spdk_pci_unhook_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_pci_unhook_device </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Un-hook a custom PCI device from the PCI layer. </p>
<p>The device must not be attached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>fully initialized PCI device struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad72f63b1d6c62bfa7cc9fc2683af65d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72f63b1d6c62bfa7cc9fc2683af65d8">&#9670;&nbsp;</a></span>spdk_pci_unregister_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_pci_unregister_error_handler </td>
          <td>(</td>
          <td class="paramtype">spdk_pci_error_handler&#160;</td>
          <td class="paramname"><em>sighandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a signal handler to handle bus errors on the PCI bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sighandler</td><td>Signal bus handler of the PCI bus </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7fabe1b4dba0227ab07e5bd91fe8816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fabe1b4dba0227ab07e5bd91fe8816">&#9670;&nbsp;</a></span>spdk_pci_virtio_get_driver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_pci_driver* spdk_pci_virtio_get_driver </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Virtio PCI driver object. </p>
<dl class="section return"><dt>Returns</dt><dd>PCI driver. </dd></dl>

</div>
</div>
<a id="a9c62369cc020953b05f3bdac9ae67bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c62369cc020953b05f3bdac9ae67bed">&#9670;&nbsp;</a></span>spdk_pci_vmd_get_driver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_pci_driver* spdk_pci_vmd_get_driver </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the VMD PCI driver object. </p>
<dl class="section return"><dt>Returns</dt><dd>PCI driver. </dd></dl>

</div>
</div>
<a id="a798ae910c8563b33eea17af50cabb1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798ae910c8563b33eea17af50cabb1ab">&#9670;&nbsp;</a></span>spdk_process_is_primary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_process_is_primary </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the calling process is primary process. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the calling process is primary process, or false otherwise. </dd></dl>

</div>
</div>
<a id="acbf96e1e440b86ba23728e226b0745c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf96e1e440b86ba23728e226b0745c6">&#9670;&nbsp;</a></span>spdk_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a dma/sharable memory buffer with the given new size and alignment. </p>
<p>Existing contents are preserved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to resize. </td></tr>
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>If non-zero, the allocated buffer is aligned to a multiple of align. In this case, it must be a power of two. The returned buffer is always aligned to at least cache line size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the resized memory buffer. </dd></dl>

</div>
</div>
<a id="a6320a791a777b2d518def6413e543ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6320a791a777b2d518def6413e543ac8">&#9670;&nbsp;</a></span>spdk_ring_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_ring_count </td>
          <td>(</td>
          <td class="paramtype">struct spdk_ring *&#160;</td>
          <td class="paramname"><em>ring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of objects in the ring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>the ring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of objects in the ring. </dd></dl>

</div>
</div>
<a id="a9f9038d37e14d07c89b399ee92bcbb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9038d37e14d07c89b399ee92bcbb87">&#9670;&nbsp;</a></span>spdk_ring_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_ring* spdk_ring_create </td>
          <td>(</td>
          <td class="paramtype">enum spdk_ring_type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a ring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Type for the ring. (SPDK_RING_TYPE_SP_SC or SPDK_RING_TYPE_MP_SC). </td></tr>
    <tr><td class="paramname">count</td><td>Size of the ring in elements. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the created ring. </dd></dl>

</div>
</div>
<a id="a982e1b212d497dbb209902f56b192afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982e1b212d497dbb209902f56b192afb">&#9670;&nbsp;</a></span>spdk_ring_dequeue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_ring_dequeue </td>
          <td>(</td>
          <td class="paramtype">struct spdk_ring *&#160;</td>
          <td class="paramname"><em>ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>objs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dequeue count objects from the ring into the array objs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>A pointer to the ring. </td></tr>
    <tr><td class="paramname">objs</td><td>A pointer to the array to be dequeued. </td></tr>
    <tr><td class="paramname">count</td><td>Maximum number of elements to be dequeued.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of objects dequeued which is less than 'count'. </dd></dl>

</div>
</div>
<a id="a96a046de83d31127e79a7b16760b4776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a046de83d31127e79a7b16760b4776">&#9670;&nbsp;</a></span>spdk_ring_enqueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_ring_enqueue </td>
          <td>(</td>
          <td class="paramtype">struct spdk_ring *&#160;</td>
          <td class="paramname"><em>ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>objs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>free_space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue the array of objects (with length count) on the ring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>A pointer to the ring. </td></tr>
    <tr><td class="paramname">objs</td><td>A pointer to the array to be queued. </td></tr>
    <tr><td class="paramname">count</td><td>Length count of the array of objects. </td></tr>
    <tr><td class="paramname">free_space</td><td>If non-NULL, amount of free space after the enqueue has finished.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of objects enqueued. </dd></dl>

</div>
</div>
<a id="a3f1ec5c3714962d4b01ceb5a50571dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1ec5c3714962d4b01ceb5a50571dca">&#9670;&nbsp;</a></span>spdk_ring_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_ring_free </td>
          <td>(</td>
          <td class="paramtype">struct spdk_ring *&#160;</td>
          <td class="paramname"><em>ring</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the ring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ring</td><td>Ring to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae73d54bd295c1d46aa9a45df17e6aa40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73d54bd295c1d46aa9a45df17e6aa40">&#9670;&nbsp;</a></span>spdk_vtophys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_vtophys </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the physical address of a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A pointer to a buffer. </td></tr>
    <tr><td class="paramname">size</td><td>Contains the size of the memory region pointed to by vaddr. If vaddr is successfully translated, then this is updated with the size of the memory region for which the translation is valid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the physical address of this buffer on success, or SPDK_VTOPHYS_ERROR on failure. </dd></dl>

</div>
</div>
<a id="a3ccd5c242af65c41dbe49ae2d903b5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ccd5c242af65c41dbe49ae2d903b5e4">&#9670;&nbsp;</a></span>spdk_zmalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_zmalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>unused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate dma/sharable memory based on a given dma_flg. </p>
<p>It is a memory buffer with the given size, alignment and socket id. Also, the buffer will be zeroed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size in bytes. </td></tr>
    <tr><td class="paramname">align</td><td>If non-zero, the allocated buffer is aligned to a multiple of align. In this case, it must be a power of two. The returned buffer is always aligned to at least cache line size. </td></tr>
    <tr><td class="paramname">unused</td><td><b>Invalid</b>. If not a NULL, the function will fail and return NULL. </td></tr>
    <tr><td class="paramname">socket_id</td><td>Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY for any socket. </td></tr>
    <tr><td class="paramname">flags</td><td>Combination of SPDK_MALLOC flags (<a class="el" href="env_8h.html#a7f065a5e897ff548b2dbf0996608929a">SPDK_MALLOC_DMA</a>, <a class="el" href="env_8h.html#ad1660ffa6731090ef3f480c295a87dba">SPDK_MALLOC_SHARE</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated memory buffer. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.1 </li>
</ul>
</div>
</div>
</body>
</html>
