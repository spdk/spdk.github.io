<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.13">
  <title>SPDK: Writing a Custom Block Device Module</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-sm-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://ci.spdk.io/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/roadmap/">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('bdev_module.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Writing a Custom Block Device Module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Target Audience</h2>
<p>This programming guide is intended for developers authoring their own block device modules to integrate with SPDK's bdev layer. For a guide on how to use the bdev layer, see <a class="el" href="bdev_pg.html">Block Device Layer Programming Guide</a>.</p>
<h2>Introduction</h2>
<p>A block device module is SPDK's equivalent of a device driver in a traditional operating system. The module provides a set of function pointers that are called to service block device I/O requests. SPDK provides a number of block device modules including NVMe, RAM-disk, and Ceph RBD. However, some users will want to write their own to interact with either custom hardware or to an existing storage software stack. This guide is intended to demonstrate exactly how to write a module.</p>
<h2>Creating A New Module</h2>
<p>Block device modules are located in lib/bdev/&lt;module_name&gt; today. It is not currently possible to place the code for a bdev module elsewhere, but updates to the build system could be made to enable this in the future. To create a module, add a new directory with a single C file and a Makefile. A great starting point is to copy the existing 'null' bdev module.</p>
<p>The primary interface that bdev modules will interact with is in include/spdk_internal/bdev.h. In that header a macro is defined that registers a new bdev module - SPDK_BDEV_MODULE_REGISTER. This macro take as argument a pointer spdk_bdev_module structure that is used to register new bdev module.</p>
<p>The spdk_bdev_module structure describes the module properties like initialization (<code>module_init</code>) and teardown (<code>module_fini</code>) functions, the function that returns context size (<code>get_ctx_size</code>) - scratch space that will be allocated in each I/O request for use by this module, and a callback that will be called each time a new bdev is registered by another module (<code>examine</code>). Please check the documentation of struct spdk_bdev_module for more details.</p>
<h2>Creating Bdevs</h2>
<p>New bdevs are created within the module by calling spdk_bdev_register(). The module must allocate a struct spdk_bdev, fill it out appropriately, and pass it to the register call. The most important field to fill out is <code>fn_table</code>, which points at this data structure:</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Function table for a block device backend.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The backend block device function table provides a set of APIs to allow</span></div><div class="line"><span class="comment"> * communication with a backend. The main commands are read/write API</span></div><div class="line"><span class="comment"> * calls for I/O via submit_request.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">struct </span>spdk_bdev_fn_table {</div><div class="line">        <span class="comment">/* Destroy the backend block device object */</span></div><div class="line">        int (*destruct)(<span class="keywordtype">void</span> *ctx);</div><div class="line"></div><div class="line">        <span class="comment">/* Process the IO. */</span></div><div class="line">        void (*submit_request)(<span class="keyword">struct </span><a class="code" href="structspdk__io__channel.html">spdk_io_channel</a> *ch, <span class="keyword">struct </span>spdk_bdev_io *);</div><div class="line"></div><div class="line">        <span class="comment">/* Check if the block device supports a specific I/O type. */</span></div><div class="line">        bool (*io_type_supported)(<span class="keywordtype">void</span> *ctx, <span class="keyword">enum</span> <a class="code" href="bdev_8h.html#a633029e24ab5ae4a689bffa2565a519f">spdk_bdev_io_type</a>);</div><div class="line"></div><div class="line">        <span class="comment">/* Get an I/O channel for the specific bdev for the calling thread. */</span></div><div class="line">        <span class="keyword">struct </span><a class="code" href="structspdk__io__channel.html">spdk_io_channel</a> *(*get_io_channel)(<span class="keywordtype">void</span> *ctx);</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Output driver-specific configuration to a JSON stream. Optional - may be NULL.</span></div><div class="line"><span class="comment">         *</span></div><div class="line"><span class="comment">         * The JSON write context will be initialized with an open object, so the bdev</span></div><div class="line"><span class="comment">         * driver should write a name (based on the driver name) followed by a JSON value</span></div><div class="line"><span class="comment">         * (most likely another nested object).</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        int (*dump_config_json)(<span class="keywordtype">void</span> *ctx, <span class="keyword">struct </span>spdk_json_write_ctx *w);</div><div class="line"></div><div class="line">        <span class="comment">/* Get spin-time per I/O channel in microseconds.</span></div><div class="line"><span class="comment">         *  Optional - may be NULL.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        uint64_t (*get_spin_time)(<span class="keyword">struct </span><a class="code" href="structspdk__io__channel.html">spdk_io_channel</a> *ch);</div><div class="line">};</div></div><!-- fragment --><p>The bdev module must implement these function callbacks.</p>
<p>The <code>destruct</code> function is called to tear down the device when the system no longer needs it. What <code>destruct</code> does is up to the module - it may just be freeing memory or it may be shutting down a piece of hardware.</p>
<p>The <code>io_type_supported</code> function returns whether a particular I/O type is supported. The available I/O types are:</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">enum</span> <a class="code" href="bdev_8h.html#a633029e24ab5ae4a689bffa2565a519f">spdk_bdev_io_type</a> {</div><div class="line">        SPDK_BDEV_IO_TYPE_INVALID = 0,</div><div class="line">        SPDK_BDEV_IO_TYPE_READ,</div><div class="line">        SPDK_BDEV_IO_TYPE_WRITE,</div><div class="line">        SPDK_BDEV_IO_TYPE_UNMAP,</div><div class="line">        SPDK_BDEV_IO_TYPE_FLUSH,</div><div class="line">        SPDK_BDEV_IO_TYPE_RESET,</div><div class="line">        SPDK_BDEV_IO_TYPE_NVME_ADMIN,</div><div class="line">        SPDK_BDEV_IO_TYPE_NVME_IO,</div><div class="line">        SPDK_BDEV_IO_TYPE_NVME_IO_MD,</div><div class="line">        SPDK_BDEV_IO_TYPE_WRITE_ZEROES,</div><div class="line">};</div></div><!-- fragment --><p>For the simplest bdev modules, only <code>SPDK_BDEV_IO_TYPE_READ</code> and <code>SPDK_BDEV_IO_TYPE_WRITE</code> are necessary. <code>SPDK_BDEV_IO_TYPE_UNMAP</code> is often referred to as "trim" or "deallocate", and is a request to mark a set of blocks as no longer containing valid data. <code>SPDK_BDEV_IO_TYPE_FLUSH</code> is a request to make all previously completed writes durable. Many devices do not require flushes. <code>SPDK_BDEV_IO_TYPE_WRITE_ZEROES</code> is just like a regular write, but does not provide a data buffer (it would have just contained all 0's). If it isn't supported, the generic bdev code is capable of emulating it by sending regular write requests.</p>
<p><code>SPDK_BDEV_IO_TYPE_RESET</code> is a request to abort all I/O and return the underlying device to its initial state. Do not complete the reset request until all I/O has been completed in some way.</p>
<p><code>SPDK_BDEV_IO_TYPE_NVME_ADMIN</code>, <code>SPDK_BDEV_IO_TYPE_NVME_IO</code>, and <code>SPDK_BDEV_IO_TYPE_NVME_IO_MD</code> are all mechanisms for passing raw NVMe commands through the SPDK bdev layer. They're strictly optional, and it probably only makes sense to implement those if the backing storage device is capable of handling NVMe commands.</p>
<p>The <code>get_io_channel</code> function should return an I/O channel. For a detailed explanation of I/O channels, see <a class="el" href="concurrency.html">Message Passing and Concurrency</a>. The generic bdev layer will call <code>get_io_channel</code> one time per thread, cache the result, and pass that result to <code>submit_request</code>. It will use the corresponding channel for the thread it calls <code>submit_request</code> on.</p>
<p>The <code>submit_request</code> function is called to actually submit I/O requests to the block device. Once the I/O request is completed, the module must call spdk_bdev_io_complete(). The I/O does not have to finish within the calling context of <code>submit_request</code>.</p>
<h2>Creating Virtual Bdevs</h2>
<p>Block devices are considered virtual if they handle I/O requests by routing the I/O to other block devices. The canonical example would be a bdev module that implements RAID. Virtual bdevs are created in the same way as regular bdevs, but take one additional step. The module can look up the underlying bdevs it wishes to route I/O to using <a class="el" href="bdev_8h.html#a89c759c53d028e3e408d19156f0e1eb1" title="Get block device by the block device name. ">spdk_bdev_get_by_name()</a>, where the string name is provided by the user in a configuration file or via an RPC. The module then may proceed is normal by opening the bdev to obtain a descriptor, and creating I/O channels for the bdev (probably in response to the <code>get_io_channel</code> callback). The final step is to have the module use its open descriptor to call spdk_bdev_module_claim_bdev(), indicating that it is consuming the underlying bdev. This prevents other users from opening descriptors with write permissions. This effectively 'promotes' the descriptor to write-exclusive and is an operation only available to bdev modules. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
</div>
