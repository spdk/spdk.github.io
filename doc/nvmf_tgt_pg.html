<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.13">
  <title>SPDK: NVMe over Fabrics Target Programming Guide</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-sm-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://ci.spdk.io/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/roadmap/">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('nvmf_tgt_pg.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">NVMe over Fabrics Target Programming Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Target Audience</h2>
<p>This programming guide is intended for developers authoring applications that use the SPDK NVMe-oF target library (<code>lib/nvmf</code>). It is intended to provide background context, architectural insight, and design recommendations. This guide will not cover how to use the SPDK NVMe-oF target application. For a guide on how to use the existing application as-is, see <a class="el" href="nvmf.html">NVMe over Fabrics Target</a>.</p>
<h2>Introduction</h2>
<p>The SPDK NVMe-oF target library is located in <code>lib/nvmf</code>. The library implements all logic required to create an NVMe-oF target application. It is used in the implementation of the example NVMe-oF target application in <code>app/nvmf_tgt</code>, but is intended to be consumed independently.</p>
<p>This guide is written assuming that the reader is familiar with both NVMe and NVMe over Fabrics. The best way to become familiar with those is to read their <a href="http://nvmexpress.org/resources/specifications/">specifications</a>.</p>
<h2>Primitives</h2>
<p>The library exposes a number of primitives - basic objects that the user creates and interacts with. They are:</p>
<p><code>struct spdk_nvmf_tgt</code>: An NVMe-oF target. This concept, surprisingly, does not appear in the NVMe-oF specification. SPDK defines this to mean the collection of subsystems with the associated namespaces, plus the set of transports and their associated network connections. This will be referred to throughout this guide as a <b>target</b>.</p>
<p><code>struct spdk_nvmf_subsystem</code>: An NVMe-oF subsystem, as defined by the NVMe-oF specification. Subsystems contain namespaces and controllers and perform access control. This will be referred to throughout this guide as a <b>subsystem</b>.</p>
<p><code>struct spdk_nvmf_ns</code>: An NVMe-oF namespace, as defined by the NVMe-oF specification. Namespaces are <b>bdevs</b>. See <a class="el" href="bdev.html">Block Device User Guide</a> for an explanation of the SPDK bdev layer. This will be referred to throughout this guide as a <b>namespace</b>.</p>
<p><code>struct spdk_nvmf_qpair</code>: An NVMe-oF queue pair, as defined by the NVMe-oF specification. These map 1:1 to network connections. This will be referred to throughout this guide as a <b>qpair</b>.</p>
<p><code>struct spdk_nvmf_transport</code>: An abstraction for a network fabric, as defined by the NVMe-oF specification. The specification is designed to allow for many different network fabrics, so the code mirrors that and implements a plugin system. Currently, only the RDMA transport is available. This will be referred to throughout this guide as a <b>transport</b>.</p>
<p><code>struct spdk_nvmf_poll_group</code>: An abstraction for a collection of network connections that can be polled as a unit. This is an SPDK-defined concept that does not appear in the NVMe-oF specification. Often, network transports have facilities to check for incoming data on groups of connections more efficiently than checking each one individually (e.g. epoll), so poll groups provide a generic abstraction for that. This will be referred to throughout this guide as a <b>poll group</b>.</p>
<p><code>struct spdk_nvmf_listener</code>: A network address at which the target will accept new connections.</p>
<p><code>struct spdk_nvmf_host</code>: An NVMe-oF NQN representing a host (initiator) system. This is used for access control.</p>
<h2>The Basics</h2>
<p>A user of the NVMe-oF target library begins by creating a target using <a class="el" href="nvmf_8h.html#aa056e2c70b80bd611e21a815eae000e0" title="Construct an NVMe-oF target. ">spdk_nvmf_tgt_create()</a>, setting up a set of addresses to accept connections on by calling <a class="el" href="nvmf_8h.html#a2c31e57f4634daadf4238bf213a989d6" title="Begin accepting new connections at the address provided. ">spdk_nvmf_tgt_listen()</a>, then creating a subsystem using <a class="el" href="nvmf_8h.html#ad1b7f34d31e34d784fb54b70b02bdb15" title="Create an NVMe-oF subsystem. ">spdk_nvmf_subsystem_create()</a>.</p>
<p>Subsystems begin in an inactive state and must be activated by calling <a class="el" href="nvmf_8h.html#a0584bea11782561b13355b89de25b6c0" title="Transition an NVMe-oF subsystem from Inactive to Active state. ">spdk_nvmf_subsystem_start()</a>. Subsystems may be modified at run time, but only when in the paused or inactive state. A running subsystem may be paused by calling <a class="el" href="nvmf_8h.html#a7a8b1ca226480e9582975bd03d3b232d" title="Transition an NVMe-oF subsystem from Active to Paused state. ">spdk_nvmf_subsystem_pause()</a> and resumed by calling <a class="el" href="nvmf_8h.html#aac21e50a3e893cf2629955dd553e9e32" title="Transition an NVMe-oF subsystem from Paused to Active state. ">spdk_nvmf_subsystem_resume()</a>.</p>
<p>Namespaces may be added to the subsystem by calling <a class="el" href="nvmf_8h.html#aef42bb5a50c6f6fa1713c060d66c103d" title="Add a namespace to a subsytem. ">spdk_nvmf_subsystem_add_ns()</a> when the subsystem is inactive or paused. Namespaces are bdevs. See <a class="el" href="bdev.html">Block Device User Guide</a> for more information about the SPDK bdev layer. A bdev may be obtained by calling <a class="el" href="bdev_8h.html#a89c759c53d028e3e408d19156f0e1eb1" title="Get block device by the block device name. ">spdk_bdev_get_by_name()</a>.</p>
<p>Once a subsystem exists and the target is listening on an address, new connections may be accepted by polling <a class="el" href="nvmf_8h.html#aaffa201e13c1a8ee55c74fc0a928908e" title="Poll the target for incoming connections. ">spdk_nvmf_tgt_accept()</a>.</p>
<p>All I/O to a subsystem is driven by a poll group, which polls for incoming network I/O. Poll groups may be created by calling <a class="el" href="nvmf_8h.html#a3b1de2ab69c992ce2c732c354a08238f" title="Create a poll group. ">spdk_nvmf_poll_group_create()</a>. They automatically request to begin polling upon creation on the thread from which they were created. Most importantly, <em>a poll group may only be accessed from the thread it was created on.</em></p>
<p>When <a class="el" href="nvmf_8h.html#aaffa201e13c1a8ee55c74fc0a928908e" title="Poll the target for incoming connections. ">spdk_nvmf_tgt_accept()</a> detects a new connection, it will construct a new struct spdk_nvmf_qpair object and call the user provided <code>new_qpair_fn</code> callback for each new qpair. In response to this callback, the user must assign the qpair to a poll group by calling <a class="el" href="nvmf_8h.html#a37eea41a3c3856e0ea2cd383af20183d" title="Add the given qpair to the poll group. ">spdk_nvmf_poll_group_add()</a>. Remember, a poll group may only be accessed from the thread it was created on, so making a call to <a class="el" href="nvmf_8h.html#a37eea41a3c3856e0ea2cd383af20183d" title="Add the given qpair to the poll group. ">spdk_nvmf_poll_group_add()</a> may require passing a message to the appropriate thread.</p>
<h2>Access Control</h2>
<p>Access control is performed at the subsystem level by adding allowed listen addresses and hosts to a subsystem (see <a class="el" href="nvmf_8h.html#a46521b556107a0ab58998adfeee8795f" title="Accept new connections on the address provided. ">spdk_nvmf_subsystem_add_listener()</a> and <a class="el" href="nvmf_8h.html#a19b3442b7eb75c234c3e3090d2b5add3" title="Allow the given host NQN to connect to the given subsystem. ">spdk_nvmf_subsystem_add_host()</a>). By default, a subsystem will not accept connections from any host or over any established listen address. Listeners and hosts may only be added to inactive or paused subsystems.</p>
<h2>Discovery Subsystems</h2>
<p>A discovery subsystem, as defined by the NVMe-oF specification, is automatically created for each NVMe-oF target constructed. Connections to the discovery subsystem are handled in the same way as any other subsystem - new qpairs are created in response to <a class="el" href="nvmf_8h.html#aaffa201e13c1a8ee55c74fc0a928908e" title="Poll the target for incoming connections. ">spdk_nvmf_tgt_accept()</a> and they must be assigned to a poll group.</p>
<h2>Transports</h2>
<p>The NVMe-oF specification defines multiple network transports (the "Fabrics" in NVMe over Fabrics) and has an extensible system for adding new fabrics in the future. The SPDK NVMe-oF target library implements a plugin system for network transports to mirror the specification. The API a new transport must implement is located in lib/nvmf/transport.h. As of this writing, only an RDMA transport has been implemented.</p>
<p>The SPDK NVMe-oF target is designed to be able to process I/O from multiple fabrics simultaneously.</p>
<h2>Choosing a Threading Model</h2>
<p>The SPDK NVMe-oF target library does not strictly dictate threading model, but poll groups do all of their polling and I/O processing on the thread they are created on. Given that, it almost always makes sense to create one poll group per thread used in the application. New qpairs created in response to <a class="el" href="nvmf_8h.html#aaffa201e13c1a8ee55c74fc0a928908e" title="Poll the target for incoming connections. ">spdk_nvmf_tgt_accept()</a> can be handed out round-robin to the poll groups. This is how the SPDK NVMe-oF target application currently functions.</p>
<p>More advanced algorithms for distributing qpairs to poll groups is possible. For instance, a NUMA-aware algorithm would be an improvement over basic round-robin, where NUMA-aware means assigning qpairs to poll groups running on CPU cores that are on the same NUMA node as the network adapter and storage device. Load-aware algorithms also may have benefits.</p>
<h2>Scaling Across CPU Cores</h2>
<p>Incoming I/O requests are picked up by the poll group polling their assigned qpair. For regular NVMe commands such as READ and WRITE, the I/O request is processed on the initial thread from start to the point where it is submitted to the backing storage device, without interruption. Completions are discovered by polling the backing storage device and also processed to completion on the polling thread. <b>Regular NVMe commands (READ, WRITE, etc.) do not require any cross-thread coordination, and therefore take no locks.</b></p>
<p>NVMe ADMIN commands, which are used for managing the NVMe device itself, may modify global state in the subsystem. For instance, an NVMe ADMIN command may perform namespace management, such as shrinking a namespace. For these commands, the subsystem will temporarily enter a paused state by sending a message to each thread in the system. All new incoming I/O on any thread targeting the subsystem will be queued during this time. Once the subsystem is fully paused, the state change will occur, and messages will be sent to each thread to release queued I/O and resume. Management commands are rare, so this style of coordination is preferable to forcing all commands to take locks in the I/O path.</p>
<h2>Zero Copy Support</h2>
<p>For the RDMA transport, data is transferred from the RDMA NIC to host memory and then host memory to the SSD (or vis. versa), without any intermediate copies. Data is never moved from one location in host memory to another. Other transports in the future may require data copies.</p>
<h2>RDMA</h2>
<p>The SPDK NVMe-oF RDMA transport is implemented on top of the libibverbs and rdmacm libraries, which are packaged and available on most Linux distributions. It does not use a user-space RDMA driver stack through DPDK.</p>
<p>In order to scale to large numbers of connections, the SPDK NVMe-oF RDMA transport allocates a single RDMA completion queue per poll group. All new qpairs assigned to the poll group are given their own RDMA send and receive queues, but share this common completion queue. This allows the poll group to poll a single queue for incoming messages instead of iterating through each one.</p>
<p>Each RDMA request is handled by a state machine that walks the request through a number of states. This keeps the code organized and makes all of the corner cases much more obvious.</p>
<p>RDMA SEND, READ, and WRITE operations are ordered with respect to one another, but RDMA RECVs are not necessarily ordered with SEND acknowledgements. For instance, it is possible to detect an incoming RDMA RECV message containing a new NVMe-oF capsule prior to detecting the acknowledgement of a previous SEND containing an NVMe completion. This is problematic at full queue depth because there may not yet be a free request structure. To handle this, the RDMA request structure is broken into two parts - an rdma_recv and an rdma_request. New RDMA RECVs will always grab a free rdma_recv, but may need to wait in a queue for a SEND acknowledgement before they can acquire a full rdma_request object.</p>
<p>Further, RDMA NICs expose different queue depths for READ/WRITE operations than they do for SEND/RECV operations. The RDMA transport reports available queue depth based on SEND/RECV operation limits and will queue in software as necessary to accomodate (usually lower) limits on READ/WRITE operations. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
</div>
