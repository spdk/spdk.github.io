<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="generator" content="Doxygen 1.9.1" />
  <title>SPDK: sock.h File Reference</title>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  <script type="text/javascript" src="../js/doxyboot.js"></script>
  <script type="text/javascript" src="./navtree.js"></script>
  <link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
<body>
  <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/" aria-label="SPDK">
      <img src="/img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <div class="navbar-nav me-auto">
        <a class="nav-link header-link active" href="../doc/">Documentation</a>
        <a class="nav-link header-link" href="../development/">Development</a>
        <a class="nav-link header-link" href="../community/">Community</a>
        <a class="nav-link header-link" href="../blog/">Blog</a>
      </div>
      <div class="navbar-nav ms-auto me-3">
        <a class="nav-link header-link" href="https://github.com/spdk/spdk">
          <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
      </div>
    </div>
  </nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('sock_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sock.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>TCP socket abstraction layer.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__sock__request.html">spdk_sock_request</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Anywhere this struct is used, an iovec array is assumed to immediately follow the last member in memory, without any padding.  <a href="structspdk__sock__request.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__sock__request_1_1____sock__request__internal.html">spdk_sock_request::__sock_request_internal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">These fields are used by the socket layer and should not be modified.  <a href="structspdk__sock__request_1_1____sock__request__internal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__sock__impl__opts.html">spdk_sock_impl_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPDK socket implementation options.  <a href="structspdk__sock__impl__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__sock__opts.html">spdk_sock_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spdk socket initialization options.  <a href="structspdk__sock__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af21c988574749f3ea04f1e78e9533aab"><td class="memItemLeft" align="right" valign="top"><a id="af21c988574749f3ea04f1e78e9533aab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_SOCK_REQUEST_IOV</b>(req,  i)&#160;&#160;&#160;((struct iovec *)(((uint8_t *)req + sizeof(struct <a class="el" href="structspdk__sock__request.html">spdk_sock_request</a>)) + (sizeof(struct iovec) * i)))</td></tr>
<tr class="separator:af21c988574749f3ea04f1e78e9533aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93d4d352f971092e769f39e1f34d38b"><td class="memItemLeft" align="right" valign="top"><a id="ae93d4d352f971092e769f39e1f34d38b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_TLS_VERSION_1_1</b>&#160;&#160;&#160;11</td></tr>
<tr class="separator:ae93d4d352f971092e769f39e1f34d38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f631331912a745166a23c3eef6323d0"><td class="memItemLeft" align="right" valign="top"><a id="a9f631331912a745166a23c3eef6323d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_TLS_VERSION_1_2</b>&#160;&#160;&#160;12</td></tr>
<tr class="separator:a9f631331912a745166a23c3eef6323d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912fc4b077bcc17c5499ee524fe506f3"><td class="memItemLeft" align="right" valign="top"><a id="a912fc4b077bcc17c5499ee524fe506f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_TLS_VERSION_1_3</b>&#160;&#160;&#160;13</td></tr>
<tr class="separator:a912fc4b077bcc17c5499ee524fe506f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae297ae75e566b35635d20b959daa7741"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#ae297ae75e566b35635d20b959daa7741">spdk_sock_cb</a>) (void *arg, struct spdk_sock_group *group, struct spdk_sock *sock)</td></tr>
<tr class="memdesc:ae297ae75e566b35635d20b959daa7741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for <a class="el" href="sock_8h.html#aa07f7a676410527883e2f8159ea1bfea" title="Add a socket to the group.">spdk_sock_group_add_sock()</a>.  <a href="sock_8h.html#ae297ae75e566b35635d20b959daa7741">More...</a><br /></td></tr>
<tr class="separator:ae297ae75e566b35635d20b959daa7741"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4d72186991093c81a612bb14b740f360"><td class="memItemLeft" align="right" valign="top"><a id="a4d72186991093c81a612bb14b740f360"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_placement_mode</b> { <b>PLACEMENT_NONE</b>
, <b>PLACEMENT_NAPI</b>
, <b>PLACEMENT_CPU</b>
, <b>PLACEMENT_MARK</b>
 }</td></tr>
<tr class="separator:a4d72186991093c81a612bb14b740f360"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ade1623b83eb254b199073e8bb6e5b5f9"><td class="memItemLeft" align="right" valign="top"><a id="ade1623b83eb254b199073e8bb6e5b5f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__sock__opts.html">spdk_sock_opts</a>)==40, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:ade1623b83eb254b199073e8bb6e5b5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cae415827aa6aa31adb05c120ba803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a66cae415827aa6aa31adb05c120ba803">spdk_sock_get_default_opts</a> (struct <a class="el" href="structspdk__sock__opts.html">spdk_sock_opts</a> *opts)</td></tr>
<tr class="memdesc:a66cae415827aa6aa31adb05c120ba803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the default value of opts.  <a href="sock_8h.html#a66cae415827aa6aa31adb05c120ba803">More...</a><br /></td></tr>
<tr class="separator:a66cae415827aa6aa31adb05c120ba803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab596707e3e18b6f3e4ceb365369a3b8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#ab596707e3e18b6f3e4ceb365369a3b8f">spdk_sock_getaddr</a> (struct spdk_sock *sock, char *saddr, int slen, uint16_t *sport, char *caddr, int clen, uint16_t *cport)</td></tr>
<tr class="memdesc:ab596707e3e18b6f3e4ceb365369a3b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get client and server addresses of the given socket.  <a href="sock_8h.html#ab596707e3e18b6f3e4ceb365369a3b8f">More...</a><br /></td></tr>
<tr class="separator:ab596707e3e18b6f3e4ceb365369a3b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe68595096e108a2fa3e419071963e63"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#abe68595096e108a2fa3e419071963e63">spdk_sock_get_impl_name</a> (struct spdk_sock *sock)</td></tr>
<tr class="memdesc:abe68595096e108a2fa3e419071963e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get socket implementation name.  <a href="sock_8h.html#abe68595096e108a2fa3e419071963e63">More...</a><br /></td></tr>
<tr class="separator:abe68595096e108a2fa3e419071963e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2403fc0793791d53756e8c12feaceeff"><td class="memItemLeft" align="right" valign="top">struct spdk_sock *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a2403fc0793791d53756e8c12feaceeff">spdk_sock_connect</a> (const char *ip, int port, const char *impl_name)</td></tr>
<tr class="memdesc:a2403fc0793791d53756e8c12feaceeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a socket using the specific sock implementation, connect the socket to the specified address and port (of the server), and then return the socket.  <a href="sock_8h.html#a2403fc0793791d53756e8c12feaceeff">More...</a><br /></td></tr>
<tr class="separator:a2403fc0793791d53756e8c12feaceeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8c37591bce5d7bcede5413cad350ba"><td class="memItemLeft" align="right" valign="top">struct spdk_sock *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#ada8c37591bce5d7bcede5413cad350ba">spdk_sock_connect_ext</a> (const char *ip, int port, const char *impl_name, struct <a class="el" href="structspdk__sock__opts.html">spdk_sock_opts</a> *opts)</td></tr>
<tr class="memdesc:ada8c37591bce5d7bcede5413cad350ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a socket using the specific sock implementation, connect the socket to the specified address and port (of the server), and then return the socket.  <a href="sock_8h.html#ada8c37591bce5d7bcede5413cad350ba">More...</a><br /></td></tr>
<tr class="separator:ada8c37591bce5d7bcede5413cad350ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87a8349ed85162c22d8fe714eb8b26f"><td class="memItemLeft" align="right" valign="top">struct spdk_sock *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#ad87a8349ed85162c22d8fe714eb8b26f">spdk_sock_listen</a> (const char *ip, int port, const char *impl_name)</td></tr>
<tr class="memdesc:ad87a8349ed85162c22d8fe714eb8b26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a socket using the specific sock implementation, bind the socket to the specified address and port and listen on the socket, and then return the socket.  <a href="sock_8h.html#ad87a8349ed85162c22d8fe714eb8b26f">More...</a><br /></td></tr>
<tr class="separator:ad87a8349ed85162c22d8fe714eb8b26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82e6ab1c31e26a4ea696fdd540ac572"><td class="memItemLeft" align="right" valign="top">struct spdk_sock *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#aa82e6ab1c31e26a4ea696fdd540ac572">spdk_sock_listen_ext</a> (const char *ip, int port, const char *impl_name, struct <a class="el" href="structspdk__sock__opts.html">spdk_sock_opts</a> *opts)</td></tr>
<tr class="memdesc:aa82e6ab1c31e26a4ea696fdd540ac572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a socket using the specific sock implementation, bind the socket to the specified address and port and listen on the socket, and then return the socket.  <a href="sock_8h.html#aa82e6ab1c31e26a4ea696fdd540ac572">More...</a><br /></td></tr>
<tr class="separator:aa82e6ab1c31e26a4ea696fdd540ac572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea2c431e11b3e15e0fba18fb4faa954"><td class="memItemLeft" align="right" valign="top">struct spdk_sock *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a5ea2c431e11b3e15e0fba18fb4faa954">spdk_sock_accept</a> (struct spdk_sock *sock)</td></tr>
<tr class="memdesc:a5ea2c431e11b3e15e0fba18fb4faa954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a new connection from a client on the specified socket and return a socket structure which holds the connection.  <a href="sock_8h.html#a5ea2c431e11b3e15e0fba18fb4faa954">More...</a><br /></td></tr>
<tr class="separator:a5ea2c431e11b3e15e0fba18fb4faa954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407c7aebae3d1a1556109da46a73213e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a407c7aebae3d1a1556109da46a73213e">spdk_sock_close</a> (struct spdk_sock **sock)</td></tr>
<tr class="memdesc:a407c7aebae3d1a1556109da46a73213e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a socket.  <a href="sock_8h.html#a407c7aebae3d1a1556109da46a73213e">More...</a><br /></td></tr>
<tr class="separator:a407c7aebae3d1a1556109da46a73213e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1501ed80f4cbac9912d10f4e1900905d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a1501ed80f4cbac9912d10f4e1900905d">spdk_sock_flush</a> (struct spdk_sock *sock)</td></tr>
<tr class="memdesc:a1501ed80f4cbac9912d10f4e1900905d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush a socket from data gathered in previous writev_async calls.  <a href="sock_8h.html#a1501ed80f4cbac9912d10f4e1900905d">More...</a><br /></td></tr>
<tr class="separator:a1501ed80f4cbac9912d10f4e1900905d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab9e8eaebfc2857e05848580fba864e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#abab9e8eaebfc2857e05848580fba864e">spdk_sock_recv</a> (struct spdk_sock *sock, void *buf, size_t len)</td></tr>
<tr class="memdesc:abab9e8eaebfc2857e05848580fba864e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message from the given socket.  <a href="sock_8h.html#abab9e8eaebfc2857e05848580fba864e">More...</a><br /></td></tr>
<tr class="separator:abab9e8eaebfc2857e05848580fba864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10e77b4f8d7ba40ec75c69247541ef7"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#ad10e77b4f8d7ba40ec75c69247541ef7">spdk_sock_writev</a> (struct spdk_sock *sock, struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:ad10e77b4f8d7ba40ec75c69247541ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write message to the given socket from the I/O vector array.  <a href="sock_8h.html#ad10e77b4f8d7ba40ec75c69247541ef7">More...</a><br /></td></tr>
<tr class="separator:ad10e77b4f8d7ba40ec75c69247541ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa61e0b299d1f0dff273dcd48156d67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a7aa61e0b299d1f0dff273dcd48156d67">spdk_sock_writev_async</a> (struct spdk_sock *sock, struct <a class="el" href="structspdk__sock__request.html">spdk_sock_request</a> *req)</td></tr>
<tr class="memdesc:a7aa61e0b299d1f0dff273dcd48156d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the given socket asynchronously, calling the provided callback when the data has been written.  <a href="sock_8h.html#a7aa61e0b299d1f0dff273dcd48156d67">More...</a><br /></td></tr>
<tr class="separator:a7aa61e0b299d1f0dff273dcd48156d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec412e1537891ed4a02c24615df619b0"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#aec412e1537891ed4a02c24615df619b0">spdk_sock_readv</a> (struct spdk_sock *sock, struct iovec *iov, int iovcnt)</td></tr>
<tr class="memdesc:aec412e1537891ed4a02c24615df619b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read message from the given socket to the I/O vector array.  <a href="sock_8h.html#aec412e1537891ed4a02c24615df619b0">More...</a><br /></td></tr>
<tr class="separator:aec412e1537891ed4a02c24615df619b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adceecd0c5622abd26a1c760d81c5ba79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#adceecd0c5622abd26a1c760d81c5ba79">spdk_sock_recv_next</a> (struct spdk_sock *sock, void **buf, void **ctx)</td></tr>
<tr class="memdesc:adceecd0c5622abd26a1c760d81c5ba79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive the next portion of the stream from the socket.  <a href="sock_8h.html#adceecd0c5622abd26a1c760d81c5ba79">More...</a><br /></td></tr>
<tr class="separator:adceecd0c5622abd26a1c760d81c5ba79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8d8e1b8155267b4b0289710e3b792f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a4e8d8e1b8155267b4b0289710e3b792f">spdk_sock_set_recvlowat</a> (struct spdk_sock *sock, int nbytes)</td></tr>
<tr class="memdesc:a4e8d8e1b8155267b4b0289710e3b792f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value used to specify the low water mark (in bytes) for this socket.  <a href="sock_8h.html#a4e8d8e1b8155267b4b0289710e3b792f">More...</a><br /></td></tr>
<tr class="separator:a4e8d8e1b8155267b4b0289710e3b792f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2209ac3d7d278cede96696116662d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#aec2209ac3d7d278cede96696116662d3">spdk_sock_set_recvbuf</a> (struct spdk_sock *sock, int sz)</td></tr>
<tr class="memdesc:aec2209ac3d7d278cede96696116662d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set receive buffer size for the given socket.  <a href="sock_8h.html#aec2209ac3d7d278cede96696116662d3">More...</a><br /></td></tr>
<tr class="separator:aec2209ac3d7d278cede96696116662d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be72049ed7537c6f8efb99dbb44d20c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a0be72049ed7537c6f8efb99dbb44d20c">spdk_sock_set_sendbuf</a> (struct spdk_sock *sock, int sz)</td></tr>
<tr class="memdesc:a0be72049ed7537c6f8efb99dbb44d20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set send buffer size for the given socket.  <a href="sock_8h.html#a0be72049ed7537c6f8efb99dbb44d20c">More...</a><br /></td></tr>
<tr class="separator:a0be72049ed7537c6f8efb99dbb44d20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fc8fd68b9988e2ec771a82914dcc80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#ae2fc8fd68b9988e2ec771a82914dcc80">spdk_sock_is_ipv6</a> (struct spdk_sock *sock)</td></tr>
<tr class="memdesc:ae2fc8fd68b9988e2ec771a82914dcc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the address of socket is ipv6.  <a href="sock_8h.html#ae2fc8fd68b9988e2ec771a82914dcc80">More...</a><br /></td></tr>
<tr class="separator:ae2fc8fd68b9988e2ec771a82914dcc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c174585e034587164b1a56d6e8a115"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a73c174585e034587164b1a56d6e8a115">spdk_sock_is_ipv4</a> (struct spdk_sock *sock)</td></tr>
<tr class="memdesc:a73c174585e034587164b1a56d6e8a115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the address of socket is ipv4.  <a href="sock_8h.html#a73c174585e034587164b1a56d6e8a115">More...</a><br /></td></tr>
<tr class="separator:a73c174585e034587164b1a56d6e8a115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60886d0bbf4dc4e6722e6300e7b3e10f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a60886d0bbf4dc4e6722e6300e7b3e10f">spdk_sock_is_connected</a> (struct spdk_sock *sock)</td></tr>
<tr class="memdesc:a60886d0bbf4dc4e6722e6300e7b3e10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the socket is currently connected.  <a href="sock_8h.html#a60886d0bbf4dc4e6722e6300e7b3e10f">More...</a><br /></td></tr>
<tr class="separator:a60886d0bbf4dc4e6722e6300e7b3e10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f3441fbe7ea447b7ae03e71e074e27"><td class="memItemLeft" align="right" valign="top">struct spdk_sock_group *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a06f3441fbe7ea447b7ae03e71e074e27">spdk_sock_group_create</a> (void *ctx)</td></tr>
<tr class="memdesc:a06f3441fbe7ea447b7ae03e71e074e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new socket group with user provided pointer.  <a href="sock_8h.html#a06f3441fbe7ea447b7ae03e71e074e27">More...</a><br /></td></tr>
<tr class="separator:a06f3441fbe7ea447b7ae03e71e074e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60bf2833f9b9bd99088c1c0929d6321"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#ae60bf2833f9b9bd99088c1c0929d6321">spdk_sock_group_get_ctx</a> (struct spdk_sock_group *sock_group)</td></tr>
<tr class="memdesc:ae60bf2833f9b9bd99088c1c0929d6321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ctx of the sock group.  <a href="sock_8h.html#ae60bf2833f9b9bd99088c1c0929d6321">More...</a><br /></td></tr>
<tr class="separator:ae60bf2833f9b9bd99088c1c0929d6321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07f7a676410527883e2f8159ea1bfea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#aa07f7a676410527883e2f8159ea1bfea">spdk_sock_group_add_sock</a> (struct spdk_sock_group *group, struct spdk_sock *sock, <a class="el" href="sock_8h.html#ae297ae75e566b35635d20b959daa7741">spdk_sock_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aa07f7a676410527883e2f8159ea1bfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a socket to the group.  <a href="sock_8h.html#aa07f7a676410527883e2f8159ea1bfea">More...</a><br /></td></tr>
<tr class="separator:aa07f7a676410527883e2f8159ea1bfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52142b9c60b305a1eaaf869a321c790"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#ad52142b9c60b305a1eaaf869a321c790">spdk_sock_group_remove_sock</a> (struct spdk_sock_group *group, struct spdk_sock *sock)</td></tr>
<tr class="memdesc:ad52142b9c60b305a1eaaf869a321c790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a socket from the group.  <a href="sock_8h.html#ad52142b9c60b305a1eaaf869a321c790">More...</a><br /></td></tr>
<tr class="separator:ad52142b9c60b305a1eaaf869a321c790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bf8ae4fc3ac1bbc5e2b097a864db79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a41bf8ae4fc3ac1bbc5e2b097a864db79">spdk_sock_group_provide_buf</a> (struct spdk_sock_group *group, void *buf, size_t len, void *ctx)</td></tr>
<tr class="memdesc:a41bf8ae4fc3ac1bbc5e2b097a864db79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a buffer to the group to be used in its receive pool.  <a href="sock_8h.html#a41bf8ae4fc3ac1bbc5e2b097a864db79">More...</a><br /></td></tr>
<tr class="separator:a41bf8ae4fc3ac1bbc5e2b097a864db79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9341be3f9ec5bd7e571f328e749328"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#aca9341be3f9ec5bd7e571f328e749328">spdk_sock_group_poll</a> (struct spdk_sock_group *group)</td></tr>
<tr class="memdesc:aca9341be3f9ec5bd7e571f328e749328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll incoming events for each registered socket.  <a href="sock_8h.html#aca9341be3f9ec5bd7e571f328e749328">More...</a><br /></td></tr>
<tr class="separator:aca9341be3f9ec5bd7e571f328e749328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c5abe4d97ecc3521c37b345f7fbfd4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a73c5abe4d97ecc3521c37b345f7fbfd4">spdk_sock_group_poll_count</a> (struct spdk_sock_group *group, int max_events)</td></tr>
<tr class="memdesc:a73c5abe4d97ecc3521c37b345f7fbfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll incoming events up to max_events for each registered socket.  <a href="sock_8h.html#a73c5abe4d97ecc3521c37b345f7fbfd4">More...</a><br /></td></tr>
<tr class="separator:a73c5abe4d97ecc3521c37b345f7fbfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75fdb315be08263dd42aa20e1ca5df9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#ad75fdb315be08263dd42aa20e1ca5df9">spdk_sock_group_close</a> (struct spdk_sock_group **group)</td></tr>
<tr class="memdesc:ad75fdb315be08263dd42aa20e1ca5df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close all registered sockets of the group and then remove the group.  <a href="sock_8h.html#ad75fdb315be08263dd42aa20e1ca5df9">More...</a><br /></td></tr>
<tr class="separator:ad75fdb315be08263dd42aa20e1ca5df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24c07b476251c95ed574ce3f61a2faa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#ad24c07b476251c95ed574ce3f61a2faa">spdk_sock_get_optimal_sock_group</a> (struct spdk_sock *sock, struct spdk_sock_group **group, struct spdk_sock_group *hint)</td></tr>
<tr class="memdesc:ad24c07b476251c95ed574ce3f61a2faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the optimal sock group for this sock.  <a href="sock_8h.html#ad24c07b476251c95ed574ce3f61a2faa">More...</a><br /></td></tr>
<tr class="separator:ad24c07b476251c95ed574ce3f61a2faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cbdc2532b80f5c9404af222ee03d23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#ab6cbdc2532b80f5c9404af222ee03d23">spdk_sock_impl_get_opts</a> (const char *impl_name, struct <a class="el" href="structspdk__sock__impl__opts.html">spdk_sock_impl_opts</a> *opts, size_t *len)</td></tr>
<tr class="memdesc:ab6cbdc2532b80f5c9404af222ee03d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current socket implementation options.  <a href="sock_8h.html#ab6cbdc2532b80f5c9404af222ee03d23">More...</a><br /></td></tr>
<tr class="separator:ab6cbdc2532b80f5c9404af222ee03d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81541bb1b8ae42b952c82988c482e99d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a81541bb1b8ae42b952c82988c482e99d">spdk_sock_impl_set_opts</a> (const char *impl_name, const struct <a class="el" href="structspdk__sock__impl__opts.html">spdk_sock_impl_opts</a> *opts, size_t len)</td></tr>
<tr class="memdesc:a81541bb1b8ae42b952c82988c482e99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set socket implementation options.  <a href="sock_8h.html#a81541bb1b8ae42b952c82988c482e99d">More...</a><br /></td></tr>
<tr class="separator:a81541bb1b8ae42b952c82988c482e99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec93142cc59937fe35f5e2ddf025ad13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#aec93142cc59937fe35f5e2ddf025ad13">spdk_sock_set_default_impl</a> (const char *impl_name)</td></tr>
<tr class="memdesc:aec93142cc59937fe35f5e2ddf025ad13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the given sock implementation to be used as the default one.  <a href="sock_8h.html#aec93142cc59937fe35f5e2ddf025ad13">More...</a><br /></td></tr>
<tr class="separator:aec93142cc59937fe35f5e2ddf025ad13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673267c4fcf81088ac04f5b9fb46f1cb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a673267c4fcf81088ac04f5b9fb46f1cb">spdk_sock_get_default_impl</a> (void)</td></tr>
<tr class="memdesc:a673267c4fcf81088ac04f5b9fb46f1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the current default implementation.  <a href="sock_8h.html#a673267c4fcf81088ac04f5b9fb46f1cb">More...</a><br /></td></tr>
<tr class="separator:a673267c4fcf81088ac04f5b9fb46f1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255128969e1129a8d9d0c2f2b24697b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_8h.html#a255128969e1129a8d9d0c2f2b24697b5">spdk_sock_write_config_json</a> (struct spdk_json_write_ctx *w)</td></tr>
<tr class="memdesc:a255128969e1129a8d9d0c2f2b24697b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write socket subsystem configuration into provided JSON context.  <a href="sock_8h.html#a255128969e1129a8d9d0c2f2b24697b5">More...</a><br /></td></tr>
<tr class="separator:a255128969e1129a8d9d0c2f2b24697b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>TCP socket abstraction layer. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ae297ae75e566b35635d20b959daa7741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae297ae75e566b35635d20b959daa7741">&#9670;&nbsp;</a></span>spdk_sock_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_sock_cb) (void *arg, struct spdk_sock_group *group, struct spdk_sock *sock)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for <a class="el" href="sock_8h.html#aa07f7a676410527883e2f8159ea1bfea" title="Add a socket to the group.">spdk_sock_group_add_sock()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Argument for the callback function. </td></tr>
    <tr><td class="paramname">group</td><td>Socket group. </td></tr>
    <tr><td class="paramname">sock</td><td>Socket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5ea2c431e11b3e15e0fba18fb4faa954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea2c431e11b3e15e0fba18fb4faa954">&#9670;&nbsp;</a></span>spdk_sock_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_sock* spdk_sock_accept </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a new connection from a client on the specified socket and return a socket structure which holds the connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Listening socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the accepted socket on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a407c7aebae3d1a1556109da46a73213e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407c7aebae3d1a1556109da46a73213e">&#9670;&nbsp;</a></span>spdk_sock_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_close </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock **&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a2403fc0793791d53756e8c12feaceeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2403fc0793791d53756e8c12feaceeff">&#9670;&nbsp;</a></span>spdk_sock_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_sock* spdk_sock_connect </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>impl_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a socket using the specific sock implementation, connect the socket to the specified address and port (of the server), and then return the socket. </p>
<p>This function is used by client.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>IP address of the server. </td></tr>
    <tr><td class="paramname">port</td><td>Port number of the server. </td></tr>
    <tr><td class="paramname">impl_name</td><td>The sock_implementation to use, such as "posix". If impl_name is specified, it will <em>only</em> try to connect on that impl. If it is NULL, it will try all the sock implementations in order and uses the first sock implementation which can connect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the connected socket on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="ada8c37591bce5d7bcede5413cad350ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8c37591bce5d7bcede5413cad350ba">&#9670;&nbsp;</a></span>spdk_sock_connect_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_sock* spdk_sock_connect_ext </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>impl_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__sock__opts.html">spdk_sock_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a socket using the specific sock implementation, connect the socket to the specified address and port (of the server), and then return the socket. </p>
<p>This function is used by client.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>IP address of the server. </td></tr>
    <tr><td class="paramname">port</td><td>Port number of the server. </td></tr>
    <tr><td class="paramname">impl_name</td><td>The sock_implementation to use, such as "posix". If impl_name is specified, it will <em>only</em> try to connect on that impl. If it is NULL, it will try all the sock implementations in order and uses the first sock implementation which can connect. </td></tr>
    <tr><td class="paramname">opts</td><td>The sock option pointer provided by the user which should not be NULL pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the connected socket on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a1501ed80f4cbac9912d10f4e1900905d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1501ed80f4cbac9912d10f4e1900905d">&#9670;&nbsp;</a></span>spdk_sock_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_flush </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush a socket from data gathered in previous writev_async calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to flush.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes sent on success, -1 (with errno set) on failure </dd></dl>

</div>
</div>
<a id="a673267c4fcf81088ac04f5b9fb46f1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673267c4fcf81088ac04f5b9fb46f1cb">&#9670;&nbsp;</a></span>spdk_sock_get_default_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_sock_get_default_impl </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the current default implementation. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the default implementation </dd></dl>

</div>
</div>
<a id="a66cae415827aa6aa31adb05c120ba803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66cae415827aa6aa31adb05c120ba803">&#9670;&nbsp;</a></span>spdk_sock_get_default_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_sock_get_default_opts </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__sock__opts.html">spdk_sock_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the default value of opts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Data structure where SPDK will initialize the default sock options. Users must set opts_size to sizeof(struct spdk_sock_opts). This will ensure that the libraryonly tries to fill as many fields as allocated by the caller. This allows ABI compatibility with future versions of this library that may extend the <a class="el" href="structspdk__sock__opts.html" title="Spdk socket initialization options.">spdk_sock_opts</a> structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe68595096e108a2fa3e419071963e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe68595096e108a2fa3e419071963e63">&#9670;&nbsp;</a></span>spdk_sock_get_impl_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_sock_get_impl_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get socket implementation name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Pointer to SPDK socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Implementation name of given socket. </dd></dl>

</div>
</div>
<a id="ad24c07b476251c95ed574ce3f61a2faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24c07b476251c95ed574ce3f61a2faa">&#9670;&nbsp;</a></span>spdk_sock_get_optimal_sock_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_get_optimal_sock_group </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_sock_group **&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_sock_group *&#160;</td>
          <td class="paramname"><em>hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the optimal sock group for this sock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket </td></tr>
    <tr><td class="paramname">group</td><td>Returns the optimal sock group. If there is no optimal sock group, returns NULL. </td></tr>
    <tr><td class="paramname">hint</td><td>When return is 0 and group is set to NULL, hint is used to set optimal sock group for the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Negated errno on failure. </dd></dl>

</div>
</div>
<a id="ab596707e3e18b6f3e4ceb365369a3b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab596707e3e18b6f3e4ceb365369a3b8f">&#9670;&nbsp;</a></span>spdk_sock_getaddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_getaddr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>saddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>sport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>caddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>cport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get client and server addresses of the given socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to get address. </td></tr>
    <tr><td class="paramname">saddr</td><td>A pointer to the buffer to hold the address of server. </td></tr>
    <tr><td class="paramname">slen</td><td>Length of the buffer 'saddr'. </td></tr>
    <tr><td class="paramname">sport</td><td>A pointer(May be NULL) to the buffer to hold the port info of server. </td></tr>
    <tr><td class="paramname">caddr</td><td>A pointer to the buffer to hold the address of client. </td></tr>
    <tr><td class="paramname">clen</td><td>Length of the buffer 'caddr'. </td></tr>
    <tr><td class="paramname">cport</td><td>A pointer(May be NULL) to the buffer to hold the port info of server.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="aa07f7a676410527883e2f8159ea1bfea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07f7a676410527883e2f8159ea1bfea">&#9670;&nbsp;</a></span>spdk_sock_group_add_sock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_group_add_sock </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock_group *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sock_8h.html#ae297ae75e566b35635d20b959daa7741">spdk_sock_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a socket to the group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Socket group. </td></tr>
    <tr><td class="paramname">sock</td><td>Socket to add. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called when the operation completes. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ad75fdb315be08263dd42aa20e1ca5df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75fdb315be08263dd42aa20e1ca5df9">&#9670;&nbsp;</a></span>spdk_sock_group_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_group_close </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock_group **&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close all registered sockets of the group and then remove the group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Group to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a06f3441fbe7ea447b7ae03e71e074e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f3441fbe7ea447b7ae03e71e074e27">&#9670;&nbsp;</a></span>spdk_sock_group_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_sock_group* spdk_sock_group_create </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new socket group with user provided pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>the context provided by user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the created group on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="ae60bf2833f9b9bd99088c1c0929d6321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60bf2833f9b9bd99088c1c0929d6321">&#9670;&nbsp;</a></span>spdk_sock_group_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_sock_group_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock_group *&#160;</td>
          <td class="paramname"><em>sock_group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ctx of the sock group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock_group</td><td>Socket group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer which is ctx of the sock_group. </dd></dl>

</div>
</div>
<a id="aca9341be3f9ec5bd7e571f328e749328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9341be3f9ec5bd7e571f328e749328">&#9670;&nbsp;</a></span>spdk_sock_group_poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_group_poll </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock_group *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll incoming events for each registered socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Group to poll.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of events on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a73c5abe4d97ecc3521c37b345f7fbfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c5abe4d97ecc3521c37b345f7fbfd4">&#9670;&nbsp;</a></span>spdk_sock_group_poll_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_group_poll_count </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock_group *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll incoming events up to max_events for each registered socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Group to poll. </td></tr>
    <tr><td class="paramname">max_events</td><td>Number of maximum events to poll for each socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of events on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a41bf8ae4fc3ac1bbc5e2b097a864db79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bf8ae4fc3ac1bbc5e2b097a864db79">&#9670;&nbsp;</a></span>spdk_sock_group_provide_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_group_provide_buf </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock_group *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a buffer to the group to be used in its receive pool. </p>
<p>See <a class="el" href="sock_8h.html#adceecd0c5622abd26a1c760d81c5ba79" title="Receive the next portion of the stream from the socket.">spdk_sock_recv_next()</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Socket group. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer the buffer provided. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the buffer. </td></tr>
    <tr><td class="paramname">ctx</td><td>Pointer that will be returned in <a class="el" href="sock_8h.html#adceecd0c5622abd26a1c760d81c5ba79" title="Receive the next portion of the stream from the socket.">spdk_sock_recv_next()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ad52142b9c60b305a1eaaf869a321c790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52142b9c60b305a1eaaf869a321c790">&#9670;&nbsp;</a></span>spdk_sock_group_remove_sock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_group_remove_sock </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock_group *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a socket from the group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Socket group. </td></tr>
    <tr><td class="paramname">sock</td><td>Socket to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ab6cbdc2532b80f5c9404af222ee03d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cbdc2532b80f5c9404af222ee03d23">&#9670;&nbsp;</a></span>spdk_sock_impl_get_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_impl_get_opts </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>impl_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__sock__impl__opts.html">spdk_sock_impl_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current socket implementation options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl_name</td><td>The socket implementation to use, such as "posix". </td></tr>
    <tr><td class="paramname">opts</td><td>Pointer to allocated <a class="el" href="structspdk__sock__impl__opts.html" title="SPDK socket implementation options.">spdk_sock_impl_opts</a> structure that will be filled with actual values. </td></tr>
    <tr><td class="paramname">len</td><td>On input specifies size of passed opts structure. On return it is set to actual size that was filled with values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. errno is set to indicate the reason of failure. </dd></dl>

</div>
</div>
<a id="a81541bb1b8ae42b952c82988c482e99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81541bb1b8ae42b952c82988c482e99d">&#9670;&nbsp;</a></span>spdk_sock_impl_set_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_impl_set_opts </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>impl_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__sock__impl__opts.html">spdk_sock_impl_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set socket implementation options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl_name</td><td>The socket implementation to use, such as "posix". </td></tr>
    <tr><td class="paramname">opts</td><td>Pointer to allocated <a class="el" href="structspdk__sock__impl__opts.html" title="SPDK socket implementation options.">spdk_sock_impl_opts</a> structure with new options values. </td></tr>
    <tr><td class="paramname">len</td><td>Size of passed opts structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. errno is set to indicate the reason of failure. </dd></dl>

</div>
</div>
<a id="a60886d0bbf4dc4e6722e6300e7b3e10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60886d0bbf4dc4e6722e6300e7b3e10f">&#9670;&nbsp;</a></span>spdk_sock_is_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_sock_is_connected </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the socket is currently connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the socket is connected or false otherwise. </dd></dl>

</div>
</div>
<a id="a73c174585e034587164b1a56d6e8a115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c174585e034587164b1a56d6e8a115">&#9670;&nbsp;</a></span>spdk_sock_is_ipv4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_sock_is_ipv4 </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the address of socket is ipv4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the address of socket is ipv4, or false otherwise. </dd></dl>

</div>
</div>
<a id="ae2fc8fd68b9988e2ec771a82914dcc80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fc8fd68b9988e2ec771a82914dcc80">&#9670;&nbsp;</a></span>spdk_sock_is_ipv6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_sock_is_ipv6 </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the address of socket is ipv6. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the address of socket is ipv6, or false otherwise. </dd></dl>

</div>
</div>
<a id="ad87a8349ed85162c22d8fe714eb8b26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87a8349ed85162c22d8fe714eb8b26f">&#9670;&nbsp;</a></span>spdk_sock_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_sock* spdk_sock_listen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>impl_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a socket using the specific sock implementation, bind the socket to the specified address and port and listen on the socket, and then return the socket. </p>
<p>This function is used by server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>IP address to listen on. </td></tr>
    <tr><td class="paramname">port</td><td>Port number. </td></tr>
    <tr><td class="paramname">impl_name</td><td>The sock_implementation to use, such as "posix". If impl_name is specified, it will <em>only</em> try to listen on that impl. If it is NULL, it will try all the sock implementations in order and uses the first sock implementation which can listen.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the listened socket on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="aa82e6ab1c31e26a4ea696fdd540ac572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82e6ab1c31e26a4ea696fdd540ac572">&#9670;&nbsp;</a></span>spdk_sock_listen_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_sock* spdk_sock_listen_ext </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>impl_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__sock__opts.html">spdk_sock_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a socket using the specific sock implementation, bind the socket to the specified address and port and listen on the socket, and then return the socket. </p>
<p>This function is used by server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>IP address to listen on. </td></tr>
    <tr><td class="paramname">port</td><td>Port number. </td></tr>
    <tr><td class="paramname">impl_name</td><td>The sock_implementation to use, such as "posix". If impl_name is specified, it will <em>only</em> try to listen on that impl. If it is NULL, it will try all the sock implementations in order and uses the first sock implementation which can listen. </td></tr>
    <tr><td class="paramname">opts</td><td>The sock option pointer provided by the user, which should not be NULL pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the listened socket on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="aec412e1537891ed4a02c24615df619b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec412e1537891ed4a02c24615df619b0">&#9670;&nbsp;</a></span>spdk_sock_readv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t spdk_sock_readv </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read message from the given socket to the I/O vector array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to receive message. </td></tr>
    <tr><td class="paramname">iov</td><td>I/O vector. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of I/O vectors in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the received message on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="abab9e8eaebfc2857e05848580fba864e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab9e8eaebfc2857e05848580fba864e">&#9670;&nbsp;</a></span>spdk_sock_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t spdk_sock_recv </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a message from the given socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to receive message. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to a buffer to hold the data. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the received message on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="adceecd0c5622abd26a1c760d81c5ba79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adceecd0c5622abd26a1c760d81c5ba79">&#9670;&nbsp;</a></span>spdk_sock_recv_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_recv_next </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive the next portion of the stream from the socket. </p>
<p>A buffer provided to this socket's group's pool using <a class="el" href="sock_8h.html#a41bf8ae4fc3ac1bbc5e2b097a864db79" title="Provides a buffer to the group to be used in its receive pool.">spdk_sock_group_provide_buf()</a> will contain the data and be returned in *buf.</p>
<p>Note that the amount of data in buf is determined entirely by the sock layer. You cannot request to receive only a limited amount here. You simply get whatever the next portion of the stream is, as determined by the sock module. You can place an upper limit on the size of the buffer since these buffers are originally provided to the group through <a class="el" href="sock_8h.html#a41bf8ae4fc3ac1bbc5e2b097a864db79" title="Provides a buffer to the group to be used in its receive pool.">spdk_sock_group_provide_buf()</a>.</p>
<p>This code path will only work if the recvbuf is disabled. To disable the recvbuf, call spdk_sock_set_recvbuf with a size of 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to receive from. </td></tr>
    <tr><td class="paramname">buf</td><td>Populated with the next portion of the stream </td></tr>
    <tr><td class="paramname">ctx</td><td>Returned context pointer from when the buffer was provided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the length of the buffer placed into buf, On failure, -1 with errno set. </dd></dl>

</div>
</div>
<a id="aec93142cc59937fe35f5e2ddf025ad13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec93142cc59937fe35f5e2ddf025ad13">&#9670;&nbsp;</a></span>spdk_sock_set_default_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_set_default_impl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>impl_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the given sock implementation to be used as the default one. </p>
<p>Note: passing a specific sock implementation name in some sock API functions (such as <a class="el" href="sock_8h.html#a2403fc0793791d53756e8c12feaceeff">spdk_sock_connect</a>, <a class="el" href="sock_8h.html#ad87a8349ed85162c22d8fe714eb8b26f">spdk_sock_listen</a> and etc) ignores the default value set by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl_name</td><td>The socket implementation to use, such as "posix". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. errno is set to indicate the reason of failure. </dd></dl>

</div>
</div>
<a id="aec2209ac3d7d278cede96696116662d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec2209ac3d7d278cede96696116662d3">&#9670;&nbsp;</a></span>spdk_sock_set_recvbuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_set_recvbuf </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set receive buffer size for the given socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to set buffer size for. </td></tr>
    <tr><td class="paramname">sz</td><td>Buffer size in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a4e8d8e1b8155267b4b0289710e3b792f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8d8e1b8155267b4b0289710e3b792f">&#9670;&nbsp;</a></span>spdk_sock_set_recvlowat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_set_recvlowat </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value used to specify the low water mark (in bytes) for this socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to set for. </td></tr>
    <tr><td class="paramname">nbytes</td><td>Value for recvlowat.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a0be72049ed7537c6f8efb99dbb44d20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be72049ed7537c6f8efb99dbb44d20c">&#9670;&nbsp;</a></span>spdk_sock_set_sendbuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_sock_set_sendbuf </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set send buffer size for the given socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to set buffer size for. </td></tr>
    <tr><td class="paramname">sz</td><td>Buffer size in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a255128969e1129a8d9d0c2f2b24697b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255128969e1129a8d9d0c2f2b24697b5">&#9670;&nbsp;</a></span>spdk_sock_write_config_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_sock_write_config_json </td>
          <td>(</td>
          <td class="paramtype">struct spdk_json_write_ctx *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write socket subsystem configuration into provided JSON context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>JSON write context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad10e77b4f8d7ba40ec75c69247541ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10e77b4f8d7ba40ec75c69247541ef7">&#9670;&nbsp;</a></span>spdk_sock_writev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t spdk_sock_writev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write message to the given socket from the I/O vector array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to write to. </td></tr>
    <tr><td class="paramname">iov</td><td>I/O vector. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Number of I/O vectors in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of written message on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a7aa61e0b299d1f0dff273dcd48156d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa61e0b299d1f0dff273dcd48156d67">&#9670;&nbsp;</a></span>spdk_sock_writev_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_sock_writev_async </td>
          <td>(</td>
          <td class="paramtype">struct spdk_sock *&#160;</td>
          <td class="paramname"><em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__sock__request.html">spdk_sock_request</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to the given socket asynchronously, calling the provided callback when the data has been written. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>Socket to write to. </td></tr>
    <tr><td class="paramname">req</td><td>The write request to submit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.1 </li>
</ul>
</div>
</div>
</body>
</html>
