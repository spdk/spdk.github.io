<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.15">
  <title>SPDK: Virtualized I/O with Vhost-user</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="two.min.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-xs-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://spdk.io/ci/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://trello.com/b/MN8auadQ/spdk-roadmap">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('vhost_processing.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Virtualized I/O with Vhost-user </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="vhost_processing_toc"></a>
Table of Contents</h1>
<ul>
<li><a class="el" href="vhost_processing.html#vhost_processing_intro">Introduction</a></li>
<li><a class="el" href="vhost_processing.html#vhost_processing_qemu">QEMU</a></li>
<li><a class="el" href="vhost_processing.html#vhost_processing_init">Device initialization</a></li>
<li><a class="el" href="vhost_processing.html#vhost_processing_io_path">I/O path</a></li>
<li><a class="el" href="vhost_processing.html#vhost_spdk_optimizations">SPDK optimizations</a></li>
</ul>
<h1><a class="anchor" id="vhost_processing_intro"></a>
Introduction</h1>
<p>This document is intended to provide an overview of how Vhost works behind the scenes. Code snippets used in this document might have been simplified for the sake of readability and should not be used as an API or implementation reference.</p>
<p>Reading from the <a href="http://docs.oasis-open.org/virtio/virtio/v1.0/virtio-v1.0.html">Virtio specification</a>:</p>
<div class="fragment"><div class="line">The purpose of virtio and [virtio] specification is that virtual environments</div><div class="line">and guests should have a straightforward, efficient, standard and extensible</div><div class="line">mechanism for virtual devices, rather than boutique per-environment or per-OS</div><div class="line">mechanisms.</div></div><!-- fragment --><p>Virtio devices use virtqueues to transport data efficiently. Virtqueue is a set of three different single-producer, single-consumer ring structures designed to store generic scatter-gatter I/O. Virtio is most commonly used in QEMU VMs, where the QEMU itself exposes a virtual PCI device and the guest OS communicates with it using a specific Virtio PCI driver. With only Virtio involved, it's always the QEMU process that handles all I/O traffic.</p>
<p>Vhost is a protocol for devices accessible via inter-process communication. It uses the same virtqueue layout as Virtio to allow Vhost devices to be mapped directly to Virtio devices. This allows a Vhost device, exposed by an SPDK application, to be accessed directly by a guest OS inside a QEMU process with an existing Virtio (PCI) driver. Only the configuration, I/O submission notification, and I/O completion interruption are piped through QEMU. See also <a class="el" href="vhost_processing.html#vhost_spdk_optimizations">SPDK optimizations</a></p>
<p>The initial vhost implementation is a part of the Linux kernel and uses ioctl interface to communicate with userspace applications. What makes it possible for SPDK to expose a vhost device is Vhost-user protocol.</p>
<p>The <a href="https://git.qemu.org/?p=qemu.git;a=blob_plain;f=docs/interop/vhost-user.txt;hb=HEAD">Vhost-user specification</a> describes the protocol as follows:</p>
<div class="fragment"><div class="line">[Vhost-user protocol] is aiming to complement the ioctl interface used to</div><div class="line">control the vhost implementation in the Linux kernel. It implements the control</div><div class="line">plane needed to establish virtqueue sharing with a user space process on the</div><div class="line">same host. It uses communication over a Unix domain socket to share file</div><div class="line">descriptors in the ancillary data of the message.</div><div class="line"></div><div class="line">The protocol defines 2 sides of the communication, master and slave. Master is</div><div class="line">the application that shares its virtqueues, in our case QEMU. Slave is the</div><div class="line">consumer of the virtqueues.</div><div class="line"></div><div class="line">In the current implementation QEMU is the Master, and the Slave is intended to</div><div class="line">be a software Ethernet switch running in user space, such as Snabbswitch.</div><div class="line"></div><div class="line">Master and slave can be either a client (i.e. connecting) or server (listening)</div><div class="line">in the socket communication.</div></div><!-- fragment --><p>SPDK vhost is a Vhost-user slave server. It exposes Unix domain sockets and allows external applications to connect.</p>
<h1><a class="anchor" id="vhost_processing_qemu"></a>
QEMU</h1>
<p>One of major Vhost-user use cases is networking (DPDK) or storage (SPDK) offload in QEMU. The following diagram presents how QEMU-based VM communicates with SPDK Vhost-SCSI device.</p>
<div class="image">
<object type="image/svg+xml" data="qemu_vhost_data_flow.svg">qemu_vhost_data_flow.svg</object>
<div class="caption">
QEMU/SPDK vhost data flow</div></div>
<h1><a class="anchor" id="vhost_processing_init"></a>
Device initialization</h1>
<p>All initialization and management information is exchanged using Vhost-user messages. The connection always starts with the feature negotiation. Both the Master and the Slave exposes a list of their implemented features and upon negotiation they choose a common set of those. Most of these features are implementation-related, but also regard e.g. multiqueue support or live migration.</p>
<p>After the negotiation, the Vhost-user driver shares its memory, so that the vhost device (SPDK) can access it directly. The memory can be fragmented into multiple physically-discontiguous regions and Vhost-user specification puts a limit on their number - currently 8. The driver sends a single message for each region with the following data:</p>
<ul>
<li>file descriptor - for mmap</li>
<li>user address - for memory translations in Vhost-user messages (e.g. translating vring addresses)</li>
<li>guest address - for buffers addresses translations in vrings (for QEMU this is a physical address inside the guest)</li>
<li>user offset - positive offset for the mmap</li>
<li>size</li>
</ul>
<p>The Master will send new memory regions after each memory change - usually hotplug/hotremove. The previous mappings will be removed.</p>
<p>Drivers may also request a device config, consisting of e.g. disk geometry. Vhost-SCSI drivers, however, don't need to implement this functionality as they use common SCSI I/O to inquiry the underlying disk(s).</p>
<p>Afterwards, the driver requests the number of maximum supported queues and starts sending virtqueue data, which consists of:</p>
<ul>
<li>unique virtqueue id</li>
<li>index of the last processed vring descriptor</li>
<li>vring addresses (from user address space)</li>
<li>call descriptor (for interrupting the driver after I/O completions)</li>
<li>kick descriptor (to listen for I/O requests - unused by SPDK)</li>
</ul>
<p>If multiqueue feature has been negotiated, the driver has to send a specific <em>ENABLE</em> message for each extra queue it wants to be polled. Other queues are polled as soon as they're initialized.</p>
<h1><a class="anchor" id="vhost_processing_io_path"></a>
I/O path</h1>
<p>The Master sends I/O by allocating proper buffers in shared memory, filling the request data, and putting guest addresses of those buffers into virtqueues.</p>
<p>A Virtio-Block request looks as follows.</p>
<div class="fragment"><div class="line">struct virtio_blk_req {</div><div class="line">        uint32_t type; // READ, WRITE, FLUSH (read-only)</div><div class="line">        uint64_t offset; // offset in the disk (read-only)</div><div class="line">        struct iovec buffers[]; // scatter-gatter list (read/write)</div><div class="line">        uint8_t status; // I/O completion status (write-only)</div><div class="line">};</div></div><!-- fragment --><p> And a Virtio-SCSI request as follows.</p>
<div class="fragment"><div class="line">struct virtio_scsi_req_cmd {</div><div class="line">  struct virtio_scsi_cmd_req *req; // request data (read-only)</div><div class="line">  struct iovec read_only_buffers[]; // scatter-gatter list for WRITE I/Os</div><div class="line">  struct virtio_scsi_cmd_resp *resp; // response data (write-only)</div><div class="line">  struct iovec write_only_buffers[]; // scatter-gatter list for READ I/Os</div><div class="line">}</div></div><!-- fragment --><p>Virtqueue generally consists of an array of descriptors and each I/O needs to be converted into a chain of such descriptors. A single descriptor can be either readable or writable, so each I/O request consists of at least two (request + response).</p>
<div class="fragment"><div class="line">struct virtq_desc {</div><div class="line">        /* Address (guest-physical). */</div><div class="line">        le64 addr;</div><div class="line">        /* Length. */</div><div class="line">        le32 len;</div><div class="line"></div><div class="line">/* This marks a buffer as continuing via the next field. */</div><div class="line">#define VIRTQ_DESC_F_NEXT   1</div><div class="line">/* This marks a buffer as device write-only (otherwise device read-only). */</div><div class="line">#define VIRTQ_DESC_F_WRITE     2</div><div class="line">        /* The flags as indicated above. */</div><div class="line">        le16 flags;</div><div class="line">        /* Next field if flags &amp; NEXT */</div><div class="line">        le16 next;</div><div class="line">};</div></div><!-- fragment --><p>Legacy Virtio implementations used the name vring alongside virtqueue, and the name vring is still used in virtio data structures inside the code. Instead of <code>struct virtq_desc</code>, the <code>struct vring_desc</code> is much more likely to be found.</p>
<p>The device after polling this descriptor chain needs to translate and transform it back into the original request struct. It needs to know the request layout up-front, so each device backend (Vhost-Block/SCSI) has its own implementation for polling virtqueues. For each descriptor, the device performs a lookup in the Vhost-user memory region table and goes through a gpa_to_vva translation (guest physical address to vhost virtual address). SPDK enforces the request and response data to be contained within a single memory region. I/O buffers do not have such limitations and SPDK may automatically perform additional iovec splitting and gpa_to_vva translations if required. After forming the request structs, SPDK forwards such I/O to the underlying drive and polls for the completion. Once I/O completes, SPDK vhost fills the response buffer with proper data and interrupts the guest by doing an eventfd_write on the call descriptor for proper virtqueue. There are multiple interrupt coalescing features involved, but they are not be discussed in this document.</p>
<h2><a class="anchor" id="vhost_spdk_optimizations"></a>
SPDK optimizations</h2>
<p>Due to its poll-mode nature, SPDK vhost removes the requirement for I/O submission notifications, drastically increasing the vhost server throughput and decreasing the guest overhead of submitting an I/O. A couple of different solutions exist to mitigate the I/O completion interrupt overhead (irqfd, vDPA), but those won't be discussed in this document. For the highest performance, a poll-mode <a class="el" href="virtio.html">Virtio driver</a> can be used, as it suppresses all I/O completion interrupts, making the I/O path to fully bypass the QEMU/KVM overhead. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
</div>
