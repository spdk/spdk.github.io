<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.13">
  <title>SPDK: vhost.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-sm-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://ci.spdk.io/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/roadmap/">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vhost_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vhost.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>SPDK vhost.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac2c4b62eaf6503e5f5e520394f9f9fe1"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a>) (struct spdk_vhost_dev *vdev, void *arg)</td></tr>
<tr class="memdesc:ac2c4b62eaf6503e5f5e520394f9f9fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronized vhost event used for user callbacks.  <a href="#ac2c4b62eaf6503e5f5e520394f9f9fe1">More...</a><br /></td></tr>
<tr class="separator:ac2c4b62eaf6503e5f5e520394f9f9fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a38abeca2169a11feec2ecdce057f3263"><td class="memItemLeft" align="right" valign="top"><a id="a38abeca2169a11feec2ecdce057f3263"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_vhost_init</b> (void)</td></tr>
<tr class="separator:a38abeca2169a11feec2ecdce057f3263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af242f0b790ade11de7627c3376a0d9e4"><td class="memItemLeft" align="right" valign="top"><a id="af242f0b790ade11de7627c3376a0d9e4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_vhost_fini</b> (void)</td></tr>
<tr class="separator:af242f0b790ade11de7627c3376a0d9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad731d99cb58a462e4ec790c346c23255"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#ad731d99cb58a462e4ec790c346c23255">spdk_vhost_startup</a> (void *arg1, void *arg2)</td></tr>
<tr class="memdesc:ad731d99cb58a462e4ec790c346c23255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init vhost application.  <a href="#ad731d99cb58a462e4ec790c346c23255">More...</a><br /></td></tr>
<tr class="separator:ad731d99cb58a462e4ec790c346c23255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7159f8eb1e0d65dad5bedaa6cc5e43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#afd7159f8eb1e0d65dad5bedaa6cc5e43">spdk_vhost_shutdown_cb</a> (void)</td></tr>
<tr class="memdesc:afd7159f8eb1e0d65dad5bedaa6cc5e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinit vhost application.  <a href="#afd7159f8eb1e0d65dad5bedaa6cc5e43">More...</a><br /></td></tr>
<tr class="separator:afd7159f8eb1e0d65dad5bedaa6cc5e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06efc0d096d4414de40ed5c0b394622"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#aa06efc0d096d4414de40ed5c0b394622">spdk_vhost_dev_get_name</a> (struct spdk_vhost_dev *vdev)</td></tr>
<tr class="memdesc:aa06efc0d096d4414de40ed5c0b394622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of the vhost device.  <a href="#aa06efc0d096d4414de40ed5c0b394622">More...</a><br /></td></tr>
<tr class="separator:aa06efc0d096d4414de40ed5c0b394622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef1a4170ddcdf8f0e6dadb4720368e5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#abef1a4170ddcdf8f0e6dadb4720368e5">spdk_vhost_dev_get_cpumask</a> (struct spdk_vhost_dev *vdev)</td></tr>
<tr class="memdesc:abef1a4170ddcdf8f0e6dadb4720368e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cpumask of the vhost device.  <a href="#abef1a4170ddcdf8f0e6dadb4720368e5">More...</a><br /></td></tr>
<tr class="separator:abef1a4170ddcdf8f0e6dadb4720368e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8c054fdc8ed4ad573b2d0bcf2d4797"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a8b8c054fdc8ed4ad573b2d0bcf2d4797">spdk_vhost_set_coalescing</a> (struct spdk_vhost_dev *vdev, uint32_t delay_base_us, uint32_t iops_threshold)</td></tr>
<tr class="memdesc:a8b8c054fdc8ed4ad573b2d0bcf2d4797"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, events are generated when asked, but for high queue depth and high IOPS this prove to be inefficient both for guest kernel that have to handle a lot more IO completions and for SPDK vhost that need to make more syscalls.  <a href="#a8b8c054fdc8ed4ad573b2d0bcf2d4797">More...</a><br /></td></tr>
<tr class="separator:a8b8c054fdc8ed4ad573b2d0bcf2d4797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b54a11439216fb05196474e3ee20d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a01b54a11439216fb05196474e3ee20d1">spdk_vhost_scsi_dev_construct</a> (const char *name, const char *cpumask)</td></tr>
<tr class="memdesc:a01b54a11439216fb05196474e3ee20d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty vhost SCSI device.  <a href="#a01b54a11439216fb05196474e3ee20d1">More...</a><br /></td></tr>
<tr class="separator:a01b54a11439216fb05196474e3ee20d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f0d8aa45d3166969e55998872d20c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#ab3f0d8aa45d3166969e55998872d20c5">spdk_vhost_scsi_dev_remove</a> (struct spdk_vhost_dev *vdev)</td></tr>
<tr class="memdesc:ab3f0d8aa45d3166969e55998872d20c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an empty vhost SCSI device.  <a href="#ab3f0d8aa45d3166969e55998872d20c5">More...</a><br /></td></tr>
<tr class="separator:ab3f0d8aa45d3166969e55998872d20c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546673fa252a8214efd14fc80b78dcb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a546673fa252a8214efd14fc80b78dcb9">spdk_vhost_scsi_dev_add_tgt</a> (struct spdk_vhost_dev *vdev, unsigned scsi_tgt_num, const char *bdev_name)</td></tr>
<tr class="memdesc:a546673fa252a8214efd14fc80b78dcb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and attach new SCSI target to the vhost SCSI device on given (unoccupied) slot.  <a href="#a546673fa252a8214efd14fc80b78dcb9">More...</a><br /></td></tr>
<tr class="separator:a546673fa252a8214efd14fc80b78dcb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540442ab4b6ec0ba4157e514a09f2379"><td class="memItemLeft" align="right" valign="top">struct spdk_scsi_dev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a540442ab4b6ec0ba4157e514a09f2379">spdk_vhost_scsi_dev_get_tgt</a> (struct spdk_vhost_dev *vdev, uint8_t num)</td></tr>
<tr class="memdesc:a540442ab4b6ec0ba4157e514a09f2379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SCSI target from vhost SCSI device on given slot.  <a href="#a540442ab4b6ec0ba4157e514a09f2379">More...</a><br /></td></tr>
<tr class="separator:a540442ab4b6ec0ba4157e514a09f2379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ea27c8ae7616e92d916e5c6fc34231"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#ae1ea27c8ae7616e92d916e5c6fc34231">spdk_vhost_scsi_dev_remove_tgt</a> (struct spdk_vhost_dev *vdev, unsigned scsi_tgt_num, <a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ae1ea27c8ae7616e92d916e5c6fc34231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach and destruct SCSI target from a vhost SCSI device.  <a href="#ae1ea27c8ae7616e92d916e5c6fc34231">More...</a><br /></td></tr>
<tr class="separator:ae1ea27c8ae7616e92d916e5c6fc34231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec56730c6a42b0a186131526026e619"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a5ec56730c6a42b0a186131526026e619">spdk_vhost_blk_construct</a> (const char *name, const char *cpumask, const char *dev_name, bool readonly)</td></tr>
<tr class="memdesc:a5ec56730c6a42b0a186131526026e619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vhost blk device.  <a href="#a5ec56730c6a42b0a186131526026e619">More...</a><br /></td></tr>
<tr class="separator:a5ec56730c6a42b0a186131526026e619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fb61cd32b772e6dc02bf853ff48e30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a22fb61cd32b772e6dc02bf853ff48e30">spdk_vhost_blk_destroy</a> (struct spdk_vhost_dev *dev)</td></tr>
<tr class="memdesc:a22fb61cd32b772e6dc02bf853ff48e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a vhost blk device.  <a href="#a22fb61cd32b772e6dc02bf853ff48e30">More...</a><br /></td></tr>
<tr class="separator:a22fb61cd32b772e6dc02bf853ff48e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549f9903be61ca447578b8bacf9eea81"><td class="memItemLeft" align="right" valign="top">struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a549f9903be61ca447578b8bacf9eea81">spdk_vhost_blk_get_dev</a> (struct spdk_vhost_dev *ctrlr)</td></tr>
<tr class="memdesc:a549f9903be61ca447578b8bacf9eea81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get underlying SPDK bdev from vhost blk device.  <a href="#a549f9903be61ca447578b8bacf9eea81">More...</a><br /></td></tr>
<tr class="separator:a549f9903be61ca447578b8bacf9eea81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44001761e6a888ef1fb0475c4501497c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a44001761e6a888ef1fb0475c4501497c">spdk_vhost_call_external_event</a> (const char *vdev_name, <a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a> fn, void *arg)</td></tr>
<tr class="memdesc:a44001761e6a888ef1fb0475c4501497c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call function on reactor of given vhost device.  <a href="#a44001761e6a888ef1fb0475c4501497c">More...</a><br /></td></tr>
<tr class="separator:a44001761e6a888ef1fb0475c4501497c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041d593f592b76683c6a5f9f5efbc254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a041d593f592b76683c6a5f9f5efbc254">spdk_vhost_call_external_event_foreach</a> (<a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a> fn, void *arg)</td></tr>
<tr class="memdesc:a041d593f592b76683c6a5f9f5efbc254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call function for each available vhost device on it's reactor.  <a href="#a041d593f592b76683c6a5f9f5efbc254">More...</a><br /></td></tr>
<tr class="separator:a041d593f592b76683c6a5f9f5efbc254"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SPDK vhost. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac2c4b62eaf6503e5f5e520394f9f9fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c4b62eaf6503e5f5e520394f9f9fe1">&#9670;&nbsp;</a></span>spdk_vhost_event_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_vhost_event_fn) (struct spdk_vhost_dev *vdev, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronized vhost event used for user callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device </td></tr>
    <tr><td class="paramname">arg</td><td>user-provided parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5ec56730c6a42b0a186131526026e619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec56730c6a42b0a186131526026e619">&#9670;&nbsp;</a></span>spdk_vhost_blk_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_blk_construct </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cpumask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dev_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readonly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a vhost blk device. </p>
<p>This will create a Unix domain socket together with a vhost-user slave server waiting for a connection on this socket. Creating the vdev does not start any I/O pollers and does not hog the CPU. I/O processing starts after receiving proper message on the created socket. See QEMU's vhost-user documentation for details. Vhost blk device is tightly associated with given SPDK bdev. Given bdev can not be changed, unless it has been hotremoved. This would result in all I/O failing with virtio <code>VIRTIO_BLK_S_IOERR</code> error code.</p>
<p>This function is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the vhost blk device. The name will also be used for socket name, which is exactly <code>socket_base_dir/name</code> </td></tr>
    <tr><td class="paramname">mask</td><td>string containing cpumask in hex. The leading <em>0x</em> is allowed but not required. The mask itself can be constructed as: ((1 &lt;&lt; cpu0) | (1 &lt;&lt; cpu1) | ... | (1 &lt;&lt; cpuN)). </td></tr>
    <tr><td class="paramname">dev_name</td><td>bdev name to associate with this vhost device </td></tr>
    <tr><td class="paramname">readonly</td><td>if set, all writes to the device will fail with <code>VIRTIO_BLK_S_IOERR</code> error code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a22fb61cd32b772e6dc02bf853ff48e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22fb61cd32b772e6dc02bf853ff48e30">&#9670;&nbsp;</a></span>spdk_vhost_blk_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_blk_destroy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a vhost blk device. </p>
<p>The device must not have any open connections on it's socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost blk device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a549f9903be61ca447578b8bacf9eea81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549f9903be61ca447578b8bacf9eea81">&#9670;&nbsp;</a></span>spdk_vhost_blk_get_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_bdev* spdk_vhost_blk_get_dev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get underlying SPDK bdev from vhost blk device. </p>
<p>The bdev might be NULL, as it could have been hotremoved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrl</td><td>vhost blk device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPDK bdev associated with given vdev </dd></dl>

</div>
</div>
<a id="a44001761e6a888ef1fb0475c4501497c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44001761e6a888ef1fb0475c4501497c">&#9670;&nbsp;</a></span>spdk_vhost_call_external_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_call_external_event </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>vdev_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call function on reactor of given vhost device. </p>
<p>If device is not in use, the event will be called right away on the caller's thread.</p>
<p>This function is thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev_name</td><td>name of the vhost device to run this event on </td></tr>
    <tr><td class="paramname">fn</td><td>function to be called. The first parameter of callback function is either actual spdk_vhost_dev pointer or NULL in case vdev with given name doesn't exist. The second param is user provided argument <em>arg</em>. </td></tr>
    <tr><td class="paramname">arg</td><td>parameter to be passed to <em>fn</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a041d593f592b76683c6a5f9f5efbc254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041d593f592b76683c6a5f9f5efbc254">&#9670;&nbsp;</a></span>spdk_vhost_call_external_event_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_call_external_event_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call function for each available vhost device on it's reactor. </p>
<p>This will call given function in a chain, meaning that each callback will be called after the previous one has finished. After given function has been called for all vdevs, it will be called once again with first param - vhost device- set to NULL.</p>
<p>This function is thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>function to be called for each vdev. The first param will be either vdev pointer or NULL. The second param is user provided argument <em>arg</em>. </td></tr>
    <tr><td class="paramname">arg</td><td>parameter to be passed to <em>fn</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abef1a4170ddcdf8f0e6dadb4720368e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef1a4170ddcdf8f0e6dadb4720368e5">&#9670;&nbsp;</a></span>spdk_vhost_dev_get_cpumask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_vhost_dev_get_cpumask </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get cpumask of the vhost device. </p>
<p>The mask is constant throughout the lifetime of a vdev. It is be a subset of SPDK app cpumask vhost was started with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>vhost device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cpumask of the vdev. The mask is constructed as: ((1 &lt;&lt; cpu0) | (1 &lt;&lt; cpu1) | ... | (1 &lt;&lt; cpuN)). </dd></dl>

</div>
</div>
<a id="aa06efc0d096d4414de40ed5c0b394622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06efc0d096d4414de40ed5c0b394622">&#9670;&nbsp;</a></span>spdk_vhost_dev_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_vhost_dev_get_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get name of the vhost device. </p>
<p>This is equal to the filename of socket file. The name is constant throughout the lifetime of a vdev.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the vdev </dd></dl>

</div>
</div>
<a id="a546673fa252a8214efd14fc80b78dcb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546673fa252a8214efd14fc80b78dcb9">&#9670;&nbsp;</a></span>spdk_vhost_scsi_dev_add_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_scsi_dev_add_tgt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>scsi_tgt_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bdev_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct and attach new SCSI target to the vhost SCSI device on given (unoccupied) slot. </p>
<p>The device will be created with a single LUN0 associated with given SPDK bdev. Currently only one LUN per device is supported.</p>
<p>If vhost SCSI device has an active socket connection, it is required that it has negotiated <code>VIRTIO_SCSI_F_HOTPLUG</code> feature flag. Otherwise an -ENOTSUP error code is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost SCSI device </td></tr>
    <tr><td class="paramname">scsi_tgt_num</td><td>slot to attach to </td></tr>
    <tr><td class="paramname">bdev_name</td><td>name of the SPDK bdev to associate with SCSI LUN0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a01b54a11439216fb05196474e3ee20d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b54a11439216fb05196474e3ee20d1">&#9670;&nbsp;</a></span>spdk_vhost_scsi_dev_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_scsi_dev_construct </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cpumask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty vhost SCSI device. </p>
<p>This will create a Unix domain socket together with a vhost-user slave server waiting for a connection on this socket. Creating the vdev does not start any I/O pollers and does not hog the CPU. I/O processing starts after receiving proper message on the created socket. See QEMU's vhost-user documentation for details. All physical devices have to be separately attached to this vdev via <code><a class="el" href="vhost_8h.html#a546673fa252a8214efd14fc80b78dcb9" title="Construct and attach new SCSI target to the vhost SCSI device on given (unoccupied) slot...">spdk_vhost_scsi_dev_add_tgt()</a></code>.</p>
<p>This function is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the vhost device. The name will also be used for socket name, which is exactly <code>socket_base_dir/name</code> </td></tr>
    <tr><td class="paramname">mask</td><td>string containing cpumask in hex. The leading <em>0x</em> is allowed but not required. The mask itself can be constructed as: ((1 &lt;&lt; cpu0) | (1 &lt;&lt; cpu1) | ... | (1 &lt;&lt; cpuN)). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a540442ab4b6ec0ba4157e514a09f2379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540442ab4b6ec0ba4157e514a09f2379">&#9670;&nbsp;</a></span>spdk_vhost_scsi_dev_get_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_scsi_dev* spdk_vhost_scsi_dev_get_tgt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SCSI target from vhost SCSI device on given slot. </p>
<p>Max number of available slots is defined by <code>SPDK_VHOST_SCSI_CTRLR_MAX_DEVS</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost SCSI device </td></tr>
    <tr><td class="paramname">num</td><td>slot id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SCSI device on given slot or NULL </dd></dl>

</div>
</div>
<a id="ab3f0d8aa45d3166969e55998872d20c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f0d8aa45d3166969e55998872d20c5">&#9670;&nbsp;</a></span>spdk_vhost_scsi_dev_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_scsi_dev_remove </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an empty vhost SCSI device. </p>
<p>The vdev must not have any SCSI devices attached nor have any open connection on it's socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost SCSI device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="ae1ea27c8ae7616e92d916e5c6fc34231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ea27c8ae7616e92d916e5c6fc34231">&#9670;&nbsp;</a></span>spdk_vhost_scsi_dev_remove_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_scsi_dev_remove_tgt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>scsi_tgt_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach and destruct SCSI target from a vhost SCSI device. </p>
<p>If vhost SCSI device has an active socket connection, it is required that it has negotiated <code>VIRTIO_SCSI_F_HOTPLUG</code> feature flag.Otherwise an -ENOTSUP error code is returned. If the flag has been negotiated, the device will be marked to be deleted. Actual deletion is deferred until after all pending I/O to this device has finished.</p>
<p>Once the target has been deleted (whether or not vhost SCSI device is in use) given callback will be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost SCSI device </td></tr>
    <tr><td class="paramname">scsi_tgt_num</td><td>slot id to delete target from </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback to be fired once target has been successfully deleted. The first parameter of callback function is the vhost SCSI device, the second is user provided argument <em>cb_arg</em>. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>parameter to be passed to <em>cb_fn</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a8b8c054fdc8ed4ad573b2d0bcf2d4797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8c054fdc8ed4ad573b2d0bcf2d4797">&#9670;&nbsp;</a></span>spdk_vhost_set_coalescing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_set_coalescing </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay_base_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iops_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>By default, events are generated when asked, but for high queue depth and high IOPS this prove to be inefficient both for guest kernel that have to handle a lot more IO completions and for SPDK vhost that need to make more syscalls. </p>
<p>If enabled, limit amount of events (IRQs) sent to initiator by SPDK vhost effectively coalescing couple of completions. This of cource introduce IO latency penalty proportional to event delay time.</p>
<p>Actual events delay time when is calculated according to below formula: if (delay_base == 0 || IOPS &lt; iops_threshold) { delay = 0; } else if (IOPS &lt; iops_threshold) { delay = delay_base * (iops - iops_threshold) / iops_threshold; }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device </td></tr>
    <tr><td class="paramname">delay_base_us</td><td>Base delay time in microseconds. If 0, coalescing is disabled. </td></tr>
    <tr><td class="paramname">iops_threshold</td><td>IOPS threshold when coalescing is activated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd7159f8eb1e0d65dad5bedaa6cc5e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7159f8eb1e0d65dad5bedaa6cc5e43">&#9670;&nbsp;</a></span>spdk_vhost_shutdown_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_shutdown_cb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinit vhost application. </p>
<p>This is called once by SPDK app layer. </p>

</div>
</div>
<a id="ad731d99cb58a462e4ec790c346c23255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad731d99cb58a462e4ec790c346c23255">&#9670;&nbsp;</a></span>spdk_vhost_startup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_startup </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Init vhost application. </p>
<p>This is called once by SPDK app layer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg1</td><td>optional path to directory where sockets will be created </td></tr>
    <tr><td class="paramname">arg2</td><td>unused </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
