<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Doxygen 1.10.0" />
	<title>SPDK: vhost.h File Reference</title>
	<script src="https://code.jquery.com/jquery-3.7.1.slim.min.js" integrity="sha256-kmHvs0B+OpCW5GVHUNjv9rOmY0IvSIRcf7zGUDTDQM8=" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.11.8/umd/popper.min.js" integrity="sha512-TPh2Oxlg1zp+kz3nFA0C5vVC6leG/6mm1z9+mA81MI5eaUVqasPLO8Cuk4gMF4gUfP5etR73rgU/8PNMsSesoQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js" integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+" crossorigin="anonymous"></script>
	<script type="text/javascript" src="../js/doxyboot.js"></script>
	<script type="text/javascript">
		$( document ).ready(function() {
			$("#cn_lang_btn").remove();
		});
	</script>
	<script type="text/javascript" src="./navtree.js"></script>
	<link rel="stylesheet" href='https://fonts.googleapis.com/css?family=Roboto:400,900' type='text/css'>
	<link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
	<link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
  <body>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <a class="navbar-brand" href="/" aria-label="SPDK">
    <img src="../img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
  </a>
  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <div class="navbar-nav me-auto">
      <a class="nav-link header-link"
      href="../releases/">
        download
      </a>
      <a class="nav-link header-link active text-white"
      href="/doc/">
        documentation
      </a>
      <a class="nav-link header-link"
      href="../development/">
        development
      </a>
      <a class="nav-link header-link"
      href="/ci/">
        CI status
      </a>
      <a class="nav-link header-link"
      href="../community/">
        community
      </a>
      <a class="nav-link header-link"
      href="../blog/">
        Blog
      </a>
      <a class="nav-link header-link"
      href="https://github.com/orgs/spdk/projects/5">
        Roadmap
      </a>
      <a class="nav-link header-link"
      href="../news/">
        News
      </a>
    </div>
    <div class="navbar-nav ms-auto me-3">
      <a class="nav-link header-link" href="https://github.com/spdk/spdk">
        <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
      </a>
      <a id="cn_lang_btn" href="/cn/doc/" class="nav-link header-link">中文</a>
    </div>
  </div>
</nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('vhost_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">vhost.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>SPDK vhost.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aed34ffbfc5835716ba35a9ee050e1e74" id="r_aed34ffbfc5835716ba35a9ee050e1e74"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed34ffbfc5835716ba35a9ee050e1e74">spdk_vhost_init_cb</a>) (int rc)</td></tr>
<tr class="memdesc:aed34ffbfc5835716ba35a9ee050e1e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for spdk_vhost_blk|scsi_init().  <br /></td></tr>
<tr class="separator:aed34ffbfc5835716ba35a9ee050e1e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b37106ad173f20d05da87f89714700b" id="r_a8b37106ad173f20d05da87f89714700b"><td class="memItemLeft" align="right" valign="top"><a id="a8b37106ad173f20d05da87f89714700b" name="a8b37106ad173f20d05da87f89714700b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_vhost_fini_cb</b>) (void)</td></tr>
<tr class="memdesc:a8b37106ad173f20d05da87f89714700b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for spdk_vhost_blk|scsi_fini(). <br /></td></tr>
<tr class="separator:a8b37106ad173f20d05da87f89714700b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c4b62eaf6503e5f5e520394f9f9fe1" id="r_ac2c4b62eaf6503e5f5e520394f9f9fe1"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a>) (struct spdk_vhost_dev *vdev, void *arg)</td></tr>
<tr class="memdesc:ac2c4b62eaf6503e5f5e520394f9f9fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronized vhost event used for user callbacks.  <br /></td></tr>
<tr class="separator:ac2c4b62eaf6503e5f5e520394f9f9fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a15921078a895d090283fbbeaaddee76c" id="r_a15921078a895d090283fbbeaaddee76c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15921078a895d090283fbbeaaddee76c">spdk_vhost_set_socket_path</a> (const char *basename)</td></tr>
<tr class="memdesc:a15921078a895d090283fbbeaaddee76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the path to the directory where vhost sockets will be created.  <br /></td></tr>
<tr class="separator:a15921078a895d090283fbbeaaddee76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0a16e2e24f4439d1457d9fa2b1a316" id="r_afa0a16e2e24f4439d1457d9fa2b1a316"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa0a16e2e24f4439d1457d9fa2b1a316">spdk_vhost_scsi_init</a> (<a class="el" href="#aed34ffbfc5835716ba35a9ee050e1e74">spdk_vhost_init_cb</a> init_cb)</td></tr>
<tr class="memdesc:afa0a16e2e24f4439d1457d9fa2b1a316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init vhost environment.  <br /></td></tr>
<tr class="separator:afa0a16e2e24f4439d1457d9fa2b1a316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92afea7023f0f61a2038047e2328dd85" id="r_a92afea7023f0f61a2038047e2328dd85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92afea7023f0f61a2038047e2328dd85">spdk_vhost_scsi_fini</a> (<a class="el" href="#a8b37106ad173f20d05da87f89714700b">spdk_vhost_fini_cb</a> fini_cb)</td></tr>
<tr class="memdesc:a92afea7023f0f61a2038047e2328dd85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up the environment of vhost.  <br /></td></tr>
<tr class="separator:a92afea7023f0f61a2038047e2328dd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0631424062751f68ec295722786370a8" id="r_a0631424062751f68ec295722786370a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0631424062751f68ec295722786370a8">spdk_vhost_scsi_config_json</a> (struct spdk_json_write_ctx *w)</td></tr>
<tr class="memdesc:a0631424062751f68ec295722786370a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write vhost subsystem configuration into provided JSON context.  <br /></td></tr>
<tr class="separator:a0631424062751f68ec295722786370a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa85eecef82ce3ee26fd16a210be9466" id="r_afa85eecef82ce3ee26fd16a210be9466"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa85eecef82ce3ee26fd16a210be9466">spdk_vhost_blk_init</a> (<a class="el" href="#aed34ffbfc5835716ba35a9ee050e1e74">spdk_vhost_init_cb</a> init_cb)</td></tr>
<tr class="memdesc:afa85eecef82ce3ee26fd16a210be9466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init vhost environment.  <br /></td></tr>
<tr class="separator:afa85eecef82ce3ee26fd16a210be9466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e41f1b4db2605981b3194b83d90c35a" id="r_a4e41f1b4db2605981b3194b83d90c35a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e41f1b4db2605981b3194b83d90c35a">spdk_vhost_blk_fini</a> (<a class="el" href="#a8b37106ad173f20d05da87f89714700b">spdk_vhost_fini_cb</a> fini_cb)</td></tr>
<tr class="memdesc:a4e41f1b4db2605981b3194b83d90c35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up the environment of vhost.  <br /></td></tr>
<tr class="separator:a4e41f1b4db2605981b3194b83d90c35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad817236a58d94b5993275ae16a567ec" id="r_aad817236a58d94b5993275ae16a567ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad817236a58d94b5993275ae16a567ec">spdk_vhost_blk_config_json</a> (struct spdk_json_write_ctx *w)</td></tr>
<tr class="memdesc:aad817236a58d94b5993275ae16a567ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write vhost subsystem configuration into provided JSON context.  <br /></td></tr>
<tr class="separator:aad817236a58d94b5993275ae16a567ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7159f8eb1e0d65dad5bedaa6cc5e43" id="r_afd7159f8eb1e0d65dad5bedaa6cc5e43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd7159f8eb1e0d65dad5bedaa6cc5e43">spdk_vhost_shutdown_cb</a> (void)</td></tr>
<tr class="memdesc:afd7159f8eb1e0d65dad5bedaa6cc5e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinit vhost application.  <br /></td></tr>
<tr class="separator:afd7159f8eb1e0d65dad5bedaa6cc5e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4fd557673a9bc3518add4f5c0d611b" id="r_afd4fd557673a9bc3518add4f5c0d611b"><td class="memItemLeft" align="right" valign="top"><a id="afd4fd557673a9bc3518add4f5c0d611b" name="afd4fd557673a9bc3518add4f5c0d611b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_vhost_lock</b> (void)</td></tr>
<tr class="memdesc:afd4fd557673a9bc3518add4f5c0d611b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the global vhost mutex synchronizing all the vhost device accesses. <br /></td></tr>
<tr class="separator:afd4fd557673a9bc3518add4f5c0d611b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d81053d41a72f5df978f7c05dfebd7" id="r_a04d81053d41a72f5df978f7c05dfebd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04d81053d41a72f5df978f7c05dfebd7">spdk_vhost_trylock</a> (void)</td></tr>
<tr class="memdesc:a04d81053d41a72f5df978f7c05dfebd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the global vhost mutex synchronizing all the vhost device accesses.  <br /></td></tr>
<tr class="separator:a04d81053d41a72f5df978f7c05dfebd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf01bd5ae7b0d761aa8e0e271de1ee9e" id="r_adf01bd5ae7b0d761aa8e0e271de1ee9e"><td class="memItemLeft" align="right" valign="top"><a id="adf01bd5ae7b0d761aa8e0e271de1ee9e" name="adf01bd5ae7b0d761aa8e0e271de1ee9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_vhost_unlock</b> (void)</td></tr>
<tr class="memdesc:adf01bd5ae7b0d761aa8e0e271de1ee9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the global vhost mutex. <br /></td></tr>
<tr class="separator:adf01bd5ae7b0d761aa8e0e271de1ee9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11404ad0fe29024fcdb4e89c5b7412f9" id="r_a11404ad0fe29024fcdb4e89c5b7412f9"><td class="memItemLeft" align="right" valign="top">struct spdk_vhost_dev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11404ad0fe29024fcdb4e89c5b7412f9">spdk_vhost_dev_find</a> (const char *name)</td></tr>
<tr class="memdesc:a11404ad0fe29024fcdb4e89c5b7412f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a vhost device by name.  <br /></td></tr>
<tr class="separator:a11404ad0fe29024fcdb4e89c5b7412f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85abd2551972d1aeff61cb3edf1ce69c" id="r_a85abd2551972d1aeff61cb3edf1ce69c"><td class="memItemLeft" align="right" valign="top">struct spdk_vhost_dev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85abd2551972d1aeff61cb3edf1ce69c">spdk_vhost_dev_next</a> (struct spdk_vhost_dev *vdev)</td></tr>
<tr class="memdesc:a85abd2551972d1aeff61cb3edf1ce69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next vhost device.  <br /></td></tr>
<tr class="separator:a85abd2551972d1aeff61cb3edf1ce69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7d19d916cd5ef1b89c43501dec52a8" id="r_a3d7d19d916cd5ef1b89c43501dec52a8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d7d19d916cd5ef1b89c43501dec52a8">spdk_vhost_dev_get_name</a> (struct spdk_vhost_dev *vdev)</td></tr>
<tr class="memdesc:a3d7d19d916cd5ef1b89c43501dec52a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the vhost device.  <br /></td></tr>
<tr class="separator:a3d7d19d916cd5ef1b89c43501dec52a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac53e96fabfe23c89968dd9e2595741" id="r_a1ac53e96fabfe23c89968dd9e2595741"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ac53e96fabfe23c89968dd9e2595741">spdk_vhost_dev_get_cpumask</a> (struct spdk_vhost_dev *vdev)</td></tr>
<tr class="memdesc:a1ac53e96fabfe23c89968dd9e2595741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cpuset of the vhost device.  <br /></td></tr>
<tr class="separator:a1ac53e96fabfe23c89968dd9e2595741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8c054fdc8ed4ad573b2d0bcf2d4797" id="r_a8b8c054fdc8ed4ad573b2d0bcf2d4797"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b8c054fdc8ed4ad573b2d0bcf2d4797">spdk_vhost_set_coalescing</a> (struct spdk_vhost_dev *vdev, uint32_t delay_base_us, uint32_t iops_threshold)</td></tr>
<tr class="memdesc:a8b8c054fdc8ed4ad573b2d0bcf2d4797"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, events are generated when asked, but for high queue depth and high IOPS this prove to be inefficient both for guest kernel that have to handle a lot more IO completions and for SPDK vhost that need to make more syscalls.  <br /></td></tr>
<tr class="separator:a8b8c054fdc8ed4ad573b2d0bcf2d4797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be392083ae01ad34cc05b1b5ce2b5e0" id="r_a8be392083ae01ad34cc05b1b5ce2b5e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8be392083ae01ad34cc05b1b5ce2b5e0">spdk_vhost_get_coalescing</a> (struct spdk_vhost_dev *vdev, uint32_t *delay_base_us, uint32_t *iops_threshold)</td></tr>
<tr class="memdesc:a8be392083ae01ad34cc05b1b5ce2b5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get coalescing parameters.  <br /></td></tr>
<tr class="separator:a8be392083ae01ad34cc05b1b5ce2b5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b54a11439216fb05196474e3ee20d1" id="r_a01b54a11439216fb05196474e3ee20d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01b54a11439216fb05196474e3ee20d1">spdk_vhost_scsi_dev_construct</a> (const char *name, const char *cpumask)</td></tr>
<tr class="memdesc:a01b54a11439216fb05196474e3ee20d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty vhost SCSI device.  <br /></td></tr>
<tr class="separator:a01b54a11439216fb05196474e3ee20d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da14c13712918bceab2d7d9c788209b" id="r_a1da14c13712918bceab2d7d9c788209b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1da14c13712918bceab2d7d9c788209b">spdk_vhost_scsi_dev_construct_no_start</a> (const char *name, const char *cpumask)</td></tr>
<tr class="memdesc:a1da14c13712918bceab2d7d9c788209b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty vhost SCSI device like <code>spdk_vhost_scsi_dev_construct</code> but do not start the controller.  <br /></td></tr>
<tr class="separator:a1da14c13712918bceab2d7d9c788209b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5b0a12a12a26d2ddfe6a64f2a8a5e2" id="r_afe5b0a12a12a26d2ddfe6a64f2a8a5e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe5b0a12a12a26d2ddfe6a64f2a8a5e2">spdk_vhost_scsi_dev_add_tgt</a> (struct spdk_vhost_dev *vdev, int scsi_tgt_num, const char *bdev_name)</td></tr>
<tr class="memdesc:afe5b0a12a12a26d2ddfe6a64f2a8a5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and attach new SCSI target to the vhost SCSI device on given (unoccupied) slot.  <br /></td></tr>
<tr class="separator:afe5b0a12a12a26d2ddfe6a64f2a8a5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302117b0673f8dbab456f093e628d0cc" id="r_a302117b0673f8dbab456f093e628d0cc"><td class="memItemLeft" align="right" valign="top">struct spdk_scsi_dev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a302117b0673f8dbab456f093e628d0cc">spdk_vhost_scsi_dev_get_tgt</a> (struct spdk_vhost_dev *vdev, uint8_t num)</td></tr>
<tr class="memdesc:a302117b0673f8dbab456f093e628d0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SCSI target from vhost SCSI device on given slot.  <br /></td></tr>
<tr class="separator:a302117b0673f8dbab456f093e628d0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ea27c8ae7616e92d916e5c6fc34231" id="r_ae1ea27c8ae7616e92d916e5c6fc34231"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1ea27c8ae7616e92d916e5c6fc34231">spdk_vhost_scsi_dev_remove_tgt</a> (struct spdk_vhost_dev *vdev, unsigned scsi_tgt_num, <a class="el" href="#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ae1ea27c8ae7616e92d916e5c6fc34231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach and destruct SCSI target from a vhost SCSI device.  <br /></td></tr>
<tr class="separator:ae1ea27c8ae7616e92d916e5c6fc34231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c49e6e73478eb1974dd38ecfb2eb3d" id="r_ad2c49e6e73478eb1974dd38ecfb2eb3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2c49e6e73478eb1974dd38ecfb2eb3d">spdk_vhost_blk_construct</a> (const char *name, const char *cpumask, const char *dev_name, const char *transport, const struct <a class="el" href="structspdk__json__val.html">spdk_json_val</a> *params)</td></tr>
<tr class="memdesc:ad2c49e6e73478eb1974dd38ecfb2eb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vhost blk device.  <br /></td></tr>
<tr class="separator:ad2c49e6e73478eb1974dd38ecfb2eb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6eba1ce0ac89c3287b755567795869b" id="r_aa6eba1ce0ac89c3287b755567795869b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6eba1ce0ac89c3287b755567795869b">spdk_vhost_dev_remove</a> (struct spdk_vhost_dev *vdev)</td></tr>
<tr class="memdesc:aa6eba1ce0ac89c3287b755567795869b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a vhost device.  <br /></td></tr>
<tr class="separator:aa6eba1ce0ac89c3287b755567795869b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SPDK vhost. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac2c4b62eaf6503e5f5e520394f9f9fe1" name="ac2c4b62eaf6503e5f5e520394f9f9fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c4b62eaf6503e5f5e520394f9f9fe1">&#9670;&#160;</a></span>spdk_vhost_event_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_vhost_event_fn) (struct spdk_vhost_dev *vdev, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronized vhost event used for user callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device. </td></tr>
    <tr><td class="paramname">arg</td><td>user-provided parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="aed34ffbfc5835716ba35a9ee050e1e74" name="aed34ffbfc5835716ba35a9ee050e1e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed34ffbfc5835716ba35a9ee050e1e74">&#9670;&#160;</a></span>spdk_vhost_init_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_vhost_init_cb) (int rc)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for spdk_vhost_blk|scsi_init(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rc</td><td>0 on success, negative errno on failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aad817236a58d94b5993275ae16a567ec" name="aad817236a58d94b5993275ae16a567ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad817236a58d94b5993275ae16a567ec">&#9670;&#160;</a></span>spdk_vhost_blk_config_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_blk_config_json </td>
          <td>(</td>
          <td class="paramtype">struct spdk_json_write_ctx *</td>          <td class="paramname"><span class="paramname"><em>w</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write vhost subsystem configuration into provided JSON context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>JSON write context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2c49e6e73478eb1974dd38ecfb2eb3d" name="ad2c49e6e73478eb1974dd38ecfb2eb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c49e6e73478eb1974dd38ecfb2eb3d">&#9670;&#160;</a></span>spdk_vhost_blk_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_blk_construct </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cpumask</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dev_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>transport</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__json__val.html">spdk_json_val</a> *</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a vhost blk device. </p>
<p>This will create a Unix domain socket together with a vhost-user slave server waiting for a connection on this socket. Creating the vdev does not start any I/O pollers and does not hog the CPU. I/O processing starts after receiving proper message on the created socket. See QEMU's vhost-user documentation for details. Vhost blk device is tightly associated with given SPDK bdev. Given bdev can not be changed, unless it has been hotremoved. This would result in all I/O failing with virtio <code>VIRTIO_BLK_S_IOERR</code> error code.</p>
<p>This function is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the vhost blk device. The name will also be used for socket name, which is exactly <code>socket_base_dir/name</code> </td></tr>
    <tr><td class="paramname">cpumask</td><td>string containing cpumask in hex. The leading <em>0x</em> is allowed but not required. The mask itself can be constructed as: ((1 &lt;&lt; cpu0) | (1 &lt;&lt; cpu1) | ... | (1 &lt;&lt; cpuN)). </td></tr>
    <tr><td class="paramname">dev_name</td><td>bdev name to associate with this vhost device </td></tr>
    <tr><td class="paramname">transport</td><td>virtio blk transport name (default: vhost_user_blk) </td></tr>
    <tr><td class="paramname">params</td><td>JSON value object containing variables: readonly if set, all writes to the device will fail with <code>VIRTIO_BLK_S_IOERR</code> error code. packed_ring this controller supports packed ring if set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a4e41f1b4db2605981b3194b83d90c35a" name="a4e41f1b4db2605981b3194b83d90c35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e41f1b4db2605981b3194b83d90c35a">&#9670;&#160;</a></span>spdk_vhost_blk_fini()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_blk_fini </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8b37106ad173f20d05da87f89714700b">spdk_vhost_fini_cb</a></td>          <td class="paramname"><span class="paramname"><em>fini_cb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up the environment of vhost. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fini_cb</td><td>Function to be called when the cleanup is complete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa85eecef82ce3ee26fd16a210be9466" name="afa85eecef82ce3ee26fd16a210be9466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa85eecef82ce3ee26fd16a210be9466">&#9670;&#160;</a></span>spdk_vhost_blk_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_blk_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aed34ffbfc5835716ba35a9ee050e1e74">spdk_vhost_init_cb</a></td>          <td class="paramname"><span class="paramname"><em>init_cb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Init vhost environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_cb</td><td>Function to be called when the initialization is complete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11404ad0fe29024fcdb4e89c5b7412f9" name="a11404ad0fe29024fcdb4e89c5b7412f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11404ad0fe29024fcdb4e89c5b7412f9">&#9670;&#160;</a></span>spdk_vhost_dev_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_vhost_dev * spdk_vhost_dev_find </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a vhost device by name. </p>
<dl class="section return"><dt>Returns</dt><dd>vhost device or NULL </dd></dl>

</div>
</div>
<a id="a1ac53e96fabfe23c89968dd9e2595741" name="a1ac53e96fabfe23c89968dd9e2595741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac53e96fabfe23c89968dd9e2595741">&#9670;&#160;</a></span>spdk_vhost_dev_get_cpumask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> * spdk_vhost_dev_get_cpumask </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *</td>          <td class="paramname"><span class="paramname"><em>vdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get cpuset of the vhost device. </p>
<p>The cpuset is constant throughout the lifetime of a vdev. It is a subset of SPDK app cpuset vhost was started with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cpuset of the vdev. </dd></dl>

</div>
</div>
<a id="a3d7d19d916cd5ef1b89c43501dec52a8" name="a3d7d19d916cd5ef1b89c43501dec52a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7d19d916cd5ef1b89c43501dec52a8">&#9670;&#160;</a></span>spdk_vhost_dev_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_vhost_dev_get_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *</td>          <td class="paramname"><span class="paramname"><em>vdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the vhost device. </p>
<p>This is equal to the filename of socket file. The name is constant throughout the lifetime of a vdev.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the vdev. </dd></dl>

</div>
</div>
<a id="a85abd2551972d1aeff61cb3edf1ce69c" name="a85abd2551972d1aeff61cb3edf1ce69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85abd2551972d1aeff61cb3edf1ce69c">&#9670;&#160;</a></span>spdk_vhost_dev_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_vhost_dev * spdk_vhost_dev_next </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *</td>          <td class="paramname"><span class="paramname"><em>vdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next vhost device. </p>
<p>If there's no more devices to iterate through, NULL will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device. If NULL, this function will return the very first device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vdev vhost device or NULL </dd></dl>

</div>
</div>
<a id="aa6eba1ce0ac89c3287b755567795869b" name="aa6eba1ce0ac89c3287b755567795869b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6eba1ce0ac89c3287b755567795869b">&#9670;&#160;</a></span>spdk_vhost_dev_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_dev_remove </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *</td>          <td class="paramname"><span class="paramname"><em>vdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a vhost device. </p>
<p>The device must not have any open connections on it's socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost blk device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a8be392083ae01ad34cc05b1b5ce2b5e0" name="a8be392083ae01ad34cc05b1b5ce2b5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be392083ae01ad34cc05b1b5ce2b5e0">&#9670;&#160;</a></span>spdk_vhost_get_coalescing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_get_coalescing </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *</td>          <td class="paramname"><span class="paramname"><em>vdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>delay_base_us</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>iops_threshold</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get coalescing parameters. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8b8c054fdc8ed4ad573b2d0bcf2d4797" title="By default, events are generated when asked, but for high queue depth and high IOPS this prove to be ...">spdk_vhost_set_coalescing</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device. </td></tr>
    <tr><td class="paramname">delay_base_us</td><td>Optional pointer to store base delay time. </td></tr>
    <tr><td class="paramname">iops_threshold</td><td>Optional pointer to store IOPS threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0631424062751f68ec295722786370a8" name="a0631424062751f68ec295722786370a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0631424062751f68ec295722786370a8">&#9670;&#160;</a></span>spdk_vhost_scsi_config_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_scsi_config_json </td>
          <td>(</td>
          <td class="paramtype">struct spdk_json_write_ctx *</td>          <td class="paramname"><span class="paramname"><em>w</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write vhost subsystem configuration into provided JSON context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>JSON write context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe5b0a12a12a26d2ddfe6a64f2a8a5e2" name="afe5b0a12a12a26d2ddfe6a64f2a8a5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5b0a12a12a26d2ddfe6a64f2a8a5e2">&#9670;&#160;</a></span>spdk_vhost_scsi_dev_add_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_scsi_dev_add_tgt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *</td>          <td class="paramname"><span class="paramname"><em>vdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>scsi_tgt_num</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>bdev_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct and attach new SCSI target to the vhost SCSI device on given (unoccupied) slot. </p>
<p>The device will be created with a single LUN0 associated with given SPDK bdev. Currently only one LUN per device is supported.</p>
<p>If the vhost SCSI device has an active connection and has negotiated <code>VIRTIO_SCSI_F_HOTPLUG</code> feature, the new SCSI target should be automatically detected by the other side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost SCSI device. </td></tr>
    <tr><td class="paramname">scsi_tgt_num</td><td>slot to attach to or negative value to use first free. </td></tr>
    <tr><td class="paramname">bdev_name</td><td>name of the SPDK bdev to associate with SCSI LUN0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value &gt;= 0 on success - the SCSI target ID, negative errno code: -EINVAL - one of the arguments is invalid:<ul>
<li>vdev is not vhost SCSI device</li>
<li>SCSI target ID is out of range</li>
<li>bdev name is NULL</li>
<li>can't create SCSI LUN because of other errors e.g.: bdev does not exist -ENOSPC - scsi_tgt_num is -1 and maximum targets in vhost SCSI device reached -EEXIST - SCSI target ID already exists </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a01b54a11439216fb05196474e3ee20d1" name="a01b54a11439216fb05196474e3ee20d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b54a11439216fb05196474e3ee20d1">&#9670;&#160;</a></span>spdk_vhost_scsi_dev_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_scsi_dev_construct </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cpumask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty vhost SCSI device. </p>
<p>This will create a Unix domain socket together with a vhost-user slave server waiting for a connection on this socket. Creating the vdev does not start any I/O pollers and does not hog the CPU. I/O processing starts after receiving proper message on the created socket. See QEMU's vhost-user documentation for details. All physical devices have to be separately attached to this vdev via <code><a class="el" href="#afe5b0a12a12a26d2ddfe6a64f2a8a5e2" title="Construct and attach new SCSI target to the vhost SCSI device on given (unoccupied) slot.">spdk_vhost_scsi_dev_add_tgt()</a></code>.</p>
<p>This function is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the vhost device. The name will also be used for socket name, which is exactly <code>socket_base_dir/name</code> </td></tr>
    <tr><td class="paramname">cpumask</td><td>string containing cpumask in hex. The leading <em>0x</em> is allowed but not required. The mask itself can be constructed as: ((1 &lt;&lt; cpu0) | (1 &lt;&lt; cpu1) | ... | (1 &lt;&lt; cpuN)).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a1da14c13712918bceab2d7d9c788209b" name="a1da14c13712918bceab2d7d9c788209b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da14c13712918bceab2d7d9c788209b">&#9670;&#160;</a></span>spdk_vhost_scsi_dev_construct_no_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_scsi_dev_construct_no_start </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cpumask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an empty vhost SCSI device like <code>spdk_vhost_scsi_dev_construct</code> but do not start the controller. </p>
<p>This function is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the vhost device. The name will also be used for socket name, which is exactly <code>socket_base_dir/name</code> </td></tr>
    <tr><td class="paramname">cpumask</td><td>string containing cpumask in hex. The leading <em>0x</em> is allowed but not required. The mask itself can be constructed as: ((1 &lt;&lt; cpu0) | (1 &lt;&lt; cpu1) | ... | (1 &lt;&lt; cpuN)).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a302117b0673f8dbab456f093e628d0cc" name="a302117b0673f8dbab456f093e628d0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302117b0673f8dbab456f093e628d0cc">&#9670;&#160;</a></span>spdk_vhost_scsi_dev_get_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_scsi_dev * spdk_vhost_scsi_dev_get_tgt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *</td>          <td class="paramname"><span class="paramname"><em>vdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SCSI target from vhost SCSI device on given slot. </p>
<p>Max number of available slots is defined by. <code>SPDK_VHOST_SCSI_CTRLR_MAX_DEVS</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost SCSI device. </td></tr>
    <tr><td class="paramname">num</td><td>slot id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SCSI device on given slot or NULL. </dd></dl>

</div>
</div>
<a id="ae1ea27c8ae7616e92d916e5c6fc34231" name="ae1ea27c8ae7616e92d916e5c6fc34231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ea27c8ae7616e92d916e5c6fc34231">&#9670;&#160;</a></span>spdk_vhost_scsi_dev_remove_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_scsi_dev_remove_tgt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *</td>          <td class="paramname"><span class="paramname"><em>vdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>scsi_tgt_num</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach and destruct SCSI target from a vhost SCSI device. </p>
<p>The device will be deleted after all pending I/O is finished. If the driver supports VIRTIO_SCSI_F_HOTPLUG, then a hotremove notification will be sent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost SCSI device </td></tr>
    <tr><td class="paramname">scsi_tgt_num</td><td>slot id to delete target from </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback to be fired once target has been successfully deleted. The first parameter of callback function is the vhost SCSI device, the second is user provided argument <em>cb_arg</em>. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>parameter to be passed to <em>cb_fn</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a92afea7023f0f61a2038047e2328dd85" name="a92afea7023f0f61a2038047e2328dd85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92afea7023f0f61a2038047e2328dd85">&#9670;&#160;</a></span>spdk_vhost_scsi_fini()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_scsi_fini </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a8b37106ad173f20d05da87f89714700b">spdk_vhost_fini_cb</a></td>          <td class="paramname"><span class="paramname"><em>fini_cb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up the environment of vhost. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fini_cb</td><td>Function to be called when the cleanup is complete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa0a16e2e24f4439d1457d9fa2b1a316" name="afa0a16e2e24f4439d1457d9fa2b1a316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0a16e2e24f4439d1457d9fa2b1a316">&#9670;&#160;</a></span>spdk_vhost_scsi_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_scsi_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aed34ffbfc5835716ba35a9ee050e1e74">spdk_vhost_init_cb</a></td>          <td class="paramname"><span class="paramname"><em>init_cb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Init vhost environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_cb</td><td>Function to be called when the initialization is complete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b8c054fdc8ed4ad573b2d0bcf2d4797" name="a8b8c054fdc8ed4ad573b2d0bcf2d4797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8c054fdc8ed4ad573b2d0bcf2d4797">&#9670;&#160;</a></span>spdk_vhost_set_coalescing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_set_coalescing </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *</td>          <td class="paramname"><span class="paramname"><em>vdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>delay_base_us</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>iops_threshold</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>By default, events are generated when asked, but for high queue depth and high IOPS this prove to be inefficient both for guest kernel that have to handle a lot more IO completions and for SPDK vhost that need to make more syscalls. </p>
<p>If enabled, limit amount of events (IRQs) sent to initiator by SPDK vhost effectively coalescing couple of completions. This of course introduce IO latency penalty proportional to event delay time.</p>
<p>Actual events delay time when is calculated according to below formula: if (delay_base == 0 || IOPS &lt; iops_threshold) { delay = 0; } else if (IOPS &lt; iops_threshold) { delay = delay_base * (iops - iops_threshold) / iops_threshold; }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device. </td></tr>
    <tr><td class="paramname">delay_base_us</td><td>Base delay time in microseconds. If 0, coalescing is disabled. </td></tr>
    <tr><td class="paramname">iops_threshold</td><td>IOPS threshold when coalescing is activated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15921078a895d090283fbbeaaddee76c" name="a15921078a895d090283fbbeaaddee76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15921078a895d090283fbbeaaddee76c">&#9670;&#160;</a></span>spdk_vhost_set_socket_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_set_socket_path </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>basename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the path to the directory where vhost sockets will be created. </p>
<p>This function must be called before spdk_vhost_init().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basename</td><td>Path to vhost socket directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="afd7159f8eb1e0d65dad5bedaa6cc5e43" name="afd7159f8eb1e0d65dad5bedaa6cc5e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7159f8eb1e0d65dad5bedaa6cc5e43">&#9670;&#160;</a></span>spdk_vhost_shutdown_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_shutdown_cb </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinit vhost application. </p>
<p>This is called once by SPDK app layer. </p>

</div>
</div>
<a id="a04d81053d41a72f5df978f7c05dfebd7" name="a04d81053d41a72f5df978f7c05dfebd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d81053d41a72f5df978f7c05dfebd7">&#9670;&#160;</a></span>spdk_vhost_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_trylock </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the global vhost mutex synchronizing all the vhost device accesses. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if the mutex could be locked immediately, negative errno otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.10.0 </li>
</ul>
</div>
</div>
</body>
</html>
