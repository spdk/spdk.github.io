<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.15">
  <title>SPDK: vhost.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="two.min.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-xs-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://spdk.io/ci/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://trello.com/b/MN8auadQ/spdk-roadmap">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('vhost_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vhost.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>SPDK vhost.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aed34ffbfc5835716ba35a9ee050e1e74"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#aed34ffbfc5835716ba35a9ee050e1e74">spdk_vhost_init_cb</a>) (int rc)</td></tr>
<tr class="memdesc:aed34ffbfc5835716ba35a9ee050e1e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for <a class="el" href="vhost_8h.html#ab35076d7e06edf2098b814929a04c7d5" title="Init vhost environment.">spdk_vhost_init()</a>.  <a href="#aed34ffbfc5835716ba35a9ee050e1e74">More...</a><br /></td></tr>
<tr class="separator:aed34ffbfc5835716ba35a9ee050e1e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b37106ad173f20d05da87f89714700b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a8b37106ad173f20d05da87f89714700b">spdk_vhost_fini_cb</a>) (void)</td></tr>
<tr class="memdesc:a8b37106ad173f20d05da87f89714700b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for <a class="el" href="vhost_8h.html#af358eac95a16bd456349fcfaa00379bb" title="Clean up the environment of vhost.">spdk_vhost_fini()</a>.  <a href="#a8b37106ad173f20d05da87f89714700b">More...</a><br /></td></tr>
<tr class="separator:a8b37106ad173f20d05da87f89714700b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c4b62eaf6503e5f5e520394f9f9fe1"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a>) (struct spdk_vhost_dev *vdev, void *arg)</td></tr>
<tr class="memdesc:ac2c4b62eaf6503e5f5e520394f9f9fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronized vhost event used for user callbacks.  <a href="#ac2c4b62eaf6503e5f5e520394f9f9fe1">More...</a><br /></td></tr>
<tr class="separator:ac2c4b62eaf6503e5f5e520394f9f9fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a15921078a895d090283fbbeaaddee76c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a15921078a895d090283fbbeaaddee76c">spdk_vhost_set_socket_path</a> (const char *basename)</td></tr>
<tr class="memdesc:a15921078a895d090283fbbeaaddee76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the path to the directory where vhost sockets will be created.  <a href="#a15921078a895d090283fbbeaaddee76c">More...</a><br /></td></tr>
<tr class="separator:a15921078a895d090283fbbeaaddee76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35076d7e06edf2098b814929a04c7d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#ab35076d7e06edf2098b814929a04c7d5">spdk_vhost_init</a> (<a class="el" href="vhost_8h.html#aed34ffbfc5835716ba35a9ee050e1e74">spdk_vhost_init_cb</a> init_cb)</td></tr>
<tr class="memdesc:ab35076d7e06edf2098b814929a04c7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Init vhost environment.  <a href="#ab35076d7e06edf2098b814929a04c7d5">More...</a><br /></td></tr>
<tr class="separator:ab35076d7e06edf2098b814929a04c7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af358eac95a16bd456349fcfaa00379bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#af358eac95a16bd456349fcfaa00379bb">spdk_vhost_fini</a> (<a class="el" href="vhost_8h.html#a8b37106ad173f20d05da87f89714700b">spdk_vhost_fini_cb</a> fini_cb)</td></tr>
<tr class="memdesc:af358eac95a16bd456349fcfaa00379bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up the environment of vhost.  <a href="#af358eac95a16bd456349fcfaa00379bb">More...</a><br /></td></tr>
<tr class="separator:af358eac95a16bd456349fcfaa00379bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256ce5abb39df6f4627e3fac7863998f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a256ce5abb39df6f4627e3fac7863998f">spdk_vhost_config_json</a> (struct spdk_json_write_ctx *w)</td></tr>
<tr class="memdesc:a256ce5abb39df6f4627e3fac7863998f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write vhost subsystem configuration into provided JSON context.  <a href="#a256ce5abb39df6f4627e3fac7863998f">More...</a><br /></td></tr>
<tr class="separator:a256ce5abb39df6f4627e3fac7863998f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7159f8eb1e0d65dad5bedaa6cc5e43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#afd7159f8eb1e0d65dad5bedaa6cc5e43">spdk_vhost_shutdown_cb</a> (void)</td></tr>
<tr class="memdesc:afd7159f8eb1e0d65dad5bedaa6cc5e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinit vhost application.  <a href="#afd7159f8eb1e0d65dad5bedaa6cc5e43">More...</a><br /></td></tr>
<tr class="separator:afd7159f8eb1e0d65dad5bedaa6cc5e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4fd557673a9bc3518add4f5c0d611b"><td class="memItemLeft" align="right" valign="top"><a id="afd4fd557673a9bc3518add4f5c0d611b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#afd4fd557673a9bc3518add4f5c0d611b">spdk_vhost_lock</a> (void)</td></tr>
<tr class="memdesc:afd4fd557673a9bc3518add4f5c0d611b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the global vhost mutex synchronizing all the vhost device accesses. <br /></td></tr>
<tr class="separator:afd4fd557673a9bc3518add4f5c0d611b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d81053d41a72f5df978f7c05dfebd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a04d81053d41a72f5df978f7c05dfebd7">spdk_vhost_trylock</a> (void)</td></tr>
<tr class="memdesc:a04d81053d41a72f5df978f7c05dfebd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the global vhost mutex synchronizing all the vhost device accesses.  <a href="#a04d81053d41a72f5df978f7c05dfebd7">More...</a><br /></td></tr>
<tr class="separator:a04d81053d41a72f5df978f7c05dfebd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf01bd5ae7b0d761aa8e0e271de1ee9e"><td class="memItemLeft" align="right" valign="top"><a id="adf01bd5ae7b0d761aa8e0e271de1ee9e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#adf01bd5ae7b0d761aa8e0e271de1ee9e">spdk_vhost_unlock</a> (void)</td></tr>
<tr class="memdesc:adf01bd5ae7b0d761aa8e0e271de1ee9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the global vhost mutex. <br /></td></tr>
<tr class="separator:adf01bd5ae7b0d761aa8e0e271de1ee9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ca8ab0522c25869c31c163175e6299"><td class="memItemLeft" align="right" valign="top">struct spdk_vhost_dev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a08ca8ab0522c25869c31c163175e6299">spdk_vhost_dev_find</a> (const char *name)</td></tr>
<tr class="memdesc:a08ca8ab0522c25869c31c163175e6299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a vhost device by name.  <a href="#a08ca8ab0522c25869c31c163175e6299">More...</a><br /></td></tr>
<tr class="separator:a08ca8ab0522c25869c31c163175e6299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed851ed4cfcdf69b6221c8cad4688353"><td class="memItemLeft" align="right" valign="top">struct spdk_vhost_dev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#aed851ed4cfcdf69b6221c8cad4688353">spdk_vhost_dev_next</a> (struct spdk_vhost_dev *vdev)</td></tr>
<tr class="memdesc:aed851ed4cfcdf69b6221c8cad4688353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next vhost device.  <a href="#aed851ed4cfcdf69b6221c8cad4688353">More...</a><br /></td></tr>
<tr class="separator:aed851ed4cfcdf69b6221c8cad4688353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06efc0d096d4414de40ed5c0b394622"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#aa06efc0d096d4414de40ed5c0b394622">spdk_vhost_dev_get_name</a> (struct spdk_vhost_dev *vdev)</td></tr>
<tr class="memdesc:aa06efc0d096d4414de40ed5c0b394622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the vhost device.  <a href="#aa06efc0d096d4414de40ed5c0b394622">More...</a><br /></td></tr>
<tr class="separator:aa06efc0d096d4414de40ed5c0b394622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6002d25166c3003efd3b6edb51cb84c0"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a6002d25166c3003efd3b6edb51cb84c0">spdk_vhost_dev_get_cpumask</a> (struct spdk_vhost_dev *vdev)</td></tr>
<tr class="memdesc:a6002d25166c3003efd3b6edb51cb84c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get cpuset of the vhost device.  <a href="#a6002d25166c3003efd3b6edb51cb84c0">More...</a><br /></td></tr>
<tr class="separator:a6002d25166c3003efd3b6edb51cb84c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8c054fdc8ed4ad573b2d0bcf2d4797"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a8b8c054fdc8ed4ad573b2d0bcf2d4797">spdk_vhost_set_coalescing</a> (struct spdk_vhost_dev *vdev, uint32_t delay_base_us, uint32_t iops_threshold)</td></tr>
<tr class="memdesc:a8b8c054fdc8ed4ad573b2d0bcf2d4797"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, events are generated when asked, but for high queue depth and high IOPS this prove to be inefficient both for guest kernel that have to handle a lot more IO completions and for SPDK vhost that need to make more syscalls.  <a href="#a8b8c054fdc8ed4ad573b2d0bcf2d4797">More...</a><br /></td></tr>
<tr class="separator:a8b8c054fdc8ed4ad573b2d0bcf2d4797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be392083ae01ad34cc05b1b5ce2b5e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a8be392083ae01ad34cc05b1b5ce2b5e0">spdk_vhost_get_coalescing</a> (struct spdk_vhost_dev *vdev, uint32_t *delay_base_us, uint32_t *iops_threshold)</td></tr>
<tr class="memdesc:a8be392083ae01ad34cc05b1b5ce2b5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get coalescing parameters.  <a href="#a8be392083ae01ad34cc05b1b5ce2b5e0">More...</a><br /></td></tr>
<tr class="separator:a8be392083ae01ad34cc05b1b5ce2b5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b54a11439216fb05196474e3ee20d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a01b54a11439216fb05196474e3ee20d1">spdk_vhost_scsi_dev_construct</a> (const char *name, const char *cpumask)</td></tr>
<tr class="memdesc:a01b54a11439216fb05196474e3ee20d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty vhost SCSI device.  <a href="#a01b54a11439216fb05196474e3ee20d1">More...</a><br /></td></tr>
<tr class="separator:a01b54a11439216fb05196474e3ee20d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5b0a12a12a26d2ddfe6a64f2a8a5e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#afe5b0a12a12a26d2ddfe6a64f2a8a5e2">spdk_vhost_scsi_dev_add_tgt</a> (struct spdk_vhost_dev *vdev, int scsi_tgt_num, const char *bdev_name)</td></tr>
<tr class="memdesc:afe5b0a12a12a26d2ddfe6a64f2a8a5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and attach new SCSI target to the vhost SCSI device on given (unoccupied) slot.  <a href="#afe5b0a12a12a26d2ddfe6a64f2a8a5e2">More...</a><br /></td></tr>
<tr class="separator:afe5b0a12a12a26d2ddfe6a64f2a8a5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540442ab4b6ec0ba4157e514a09f2379"><td class="memItemLeft" align="right" valign="top">struct spdk_scsi_dev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a540442ab4b6ec0ba4157e514a09f2379">spdk_vhost_scsi_dev_get_tgt</a> (struct spdk_vhost_dev *vdev, uint8_t num)</td></tr>
<tr class="memdesc:a540442ab4b6ec0ba4157e514a09f2379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SCSI target from vhost SCSI device on given slot.  <a href="#a540442ab4b6ec0ba4157e514a09f2379">More...</a><br /></td></tr>
<tr class="separator:a540442ab4b6ec0ba4157e514a09f2379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ea27c8ae7616e92d916e5c6fc34231"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#ae1ea27c8ae7616e92d916e5c6fc34231">spdk_vhost_scsi_dev_remove_tgt</a> (struct spdk_vhost_dev *vdev, unsigned scsi_tgt_num, <a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ae1ea27c8ae7616e92d916e5c6fc34231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach and destruct SCSI target from a vhost SCSI device.  <a href="#ae1ea27c8ae7616e92d916e5c6fc34231">More...</a><br /></td></tr>
<tr class="separator:ae1ea27c8ae7616e92d916e5c6fc34231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2095d6d1e85f5841375ac04b5cff50ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a2095d6d1e85f5841375ac04b5cff50ec">spdk_vhost_blk_construct</a> (const char *name, const char *cpumask, const char *dev_name, bool readonly, bool packed_ring)</td></tr>
<tr class="memdesc:a2095d6d1e85f5841375ac04b5cff50ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vhost blk device.  <a href="#a2095d6d1e85f5841375ac04b5cff50ec">More...</a><br /></td></tr>
<tr class="separator:a2095d6d1e85f5841375ac04b5cff50ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6eba1ce0ac89c3287b755567795869b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#aa6eba1ce0ac89c3287b755567795869b">spdk_vhost_dev_remove</a> (struct spdk_vhost_dev *vdev)</td></tr>
<tr class="memdesc:aa6eba1ce0ac89c3287b755567795869b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a vhost device.  <a href="#aa6eba1ce0ac89c3287b755567795869b">More...</a><br /></td></tr>
<tr class="separator:aa6eba1ce0ac89c3287b755567795869b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549f9903be61ca447578b8bacf9eea81"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vhost_8h.html#a549f9903be61ca447578b8bacf9eea81">spdk_vhost_blk_get_dev</a> (struct spdk_vhost_dev *ctrlr)</td></tr>
<tr class="memdesc:a549f9903be61ca447578b8bacf9eea81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get underlying SPDK bdev from vhost blk device.  <a href="#a549f9903be61ca447578b8bacf9eea81">More...</a><br /></td></tr>
<tr class="separator:a549f9903be61ca447578b8bacf9eea81"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SPDK vhost. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac2c4b62eaf6503e5f5e520394f9f9fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c4b62eaf6503e5f5e520394f9f9fe1">&#9670;&nbsp;</a></span>spdk_vhost_event_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_vhost_event_fn) (struct spdk_vhost_dev *vdev, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronized vhost event used for user callbacks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device. </td></tr>
    <tr><td class="paramname">arg</td><td>user-provided parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a8b37106ad173f20d05da87f89714700b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b37106ad173f20d05da87f89714700b">&#9670;&nbsp;</a></span>spdk_vhost_fini_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_vhost_fini_cb) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for <a class="el" href="vhost_8h.html#af358eac95a16bd456349fcfaa00379bb" title="Clean up the environment of vhost.">spdk_vhost_fini()</a>. </p>

</div>
</div>
<a id="aed34ffbfc5835716ba35a9ee050e1e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed34ffbfc5835716ba35a9ee050e1e74">&#9670;&nbsp;</a></span>spdk_vhost_init_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_vhost_init_cb) (int rc)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for <a class="el" href="vhost_8h.html#ab35076d7e06edf2098b814929a04c7d5" title="Init vhost environment.">spdk_vhost_init()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rc</td><td>0 on success, negative errno on failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2095d6d1e85f5841375ac04b5cff50ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2095d6d1e85f5841375ac04b5cff50ec">&#9670;&nbsp;</a></span>spdk_vhost_blk_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_blk_construct </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cpumask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dev_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readonly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>packed_ring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a vhost blk device. </p>
<p>This will create a Unix domain socket together with a vhost-user slave server waiting for a connection on this socket. Creating the vdev does not start any I/O pollers and does not hog the CPU. I/O processing starts after receiving proper message on the created socket. See QEMU's vhost-user documentation for details. Vhost blk device is tightly associated with given SPDK bdev. Given bdev can not be changed, unless it has been hotremoved. This would result in all I/O failing with virtio <code>VIRTIO_BLK_S_IOERR</code> error code.</p>
<p>This function is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the vhost blk device. The name will also be used for socket name, which is exactly <code>socket_base_dir/name</code> </td></tr>
    <tr><td class="paramname">cpumask</td><td>string containing cpumask in hex. The leading <em>0x</em> is allowed but not required. The mask itself can be constructed as: ((1 &lt;&lt; cpu0) | (1 &lt;&lt; cpu1) | ... | (1 &lt;&lt; cpuN)). </td></tr>
    <tr><td class="paramname">dev_name</td><td>bdev name to associate with this vhost device </td></tr>
    <tr><td class="paramname">readonly</td><td>if set, all writes to the device will fail with <code>VIRTIO_BLK_S_IOERR</code> error code. </td></tr>
    <tr><td class="paramname">packed_ring</td><td>this controller supports packed ring if set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a549f9903be61ca447578b8bacf9eea81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a549f9903be61ca447578b8bacf9eea81">&#9670;&nbsp;</a></span>spdk_vhost_blk_get_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a>* spdk_vhost_blk_get_dev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get underlying SPDK bdev from vhost blk device. </p>
<p>The bdev might be NULL, as it could have been hotremoved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>vhost blk device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SPDK bdev associated with given vdev. </dd></dl>

</div>
</div>
<a id="a256ce5abb39df6f4627e3fac7863998f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256ce5abb39df6f4627e3fac7863998f">&#9670;&nbsp;</a></span>spdk_vhost_config_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_config_json </td>
          <td>(</td>
          <td class="paramtype">struct spdk_json_write_ctx *&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write vhost subsystem configuration into provided JSON context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>JSON write context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08ca8ab0522c25869c31c163175e6299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ca8ab0522c25869c31c163175e6299">&#9670;&nbsp;</a></span>spdk_vhost_dev_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_vhost_dev* spdk_vhost_dev_find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a vhost device by name. </p>
<dl class="section return"><dt>Returns</dt><dd>vhost device or NULL </dd></dl>

</div>
</div>
<a id="a6002d25166c3003efd3b6edb51cb84c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6002d25166c3003efd3b6edb51cb84c0">&#9670;&nbsp;</a></span>spdk_vhost_dev_get_cpumask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a>* spdk_vhost_dev_get_cpumask </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get cpuset of the vhost device. </p>
<p>The cpuset is constant throughout the lifetime of a vdev. It is a subset of SPDK app cpuset vhost was started with.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cpuset of the vdev. </dd></dl>

</div>
</div>
<a id="aa06efc0d096d4414de40ed5c0b394622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06efc0d096d4414de40ed5c0b394622">&#9670;&nbsp;</a></span>spdk_vhost_dev_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_vhost_dev_get_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the vhost device. </p>
<p>This is equal to the filename of socket file. The name is constant throughout the lifetime of a vdev.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the vdev. </dd></dl>

</div>
</div>
<a id="aed851ed4cfcdf69b6221c8cad4688353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed851ed4cfcdf69b6221c8cad4688353">&#9670;&nbsp;</a></span>spdk_vhost_dev_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_vhost_dev* spdk_vhost_dev_next </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next vhost device. </p>
<p>If there's no more devices to iterate through, NULL will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device. If NULL, this function will return the very first device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vdev vhost device or NULL </dd></dl>

</div>
</div>
<a id="aa6eba1ce0ac89c3287b755567795869b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6eba1ce0ac89c3287b755567795869b">&#9670;&nbsp;</a></span>spdk_vhost_dev_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_dev_remove </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a vhost device. </p>
<p>The device must not have any open connections on it's socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost blk device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="af358eac95a16bd456349fcfaa00379bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af358eac95a16bd456349fcfaa00379bb">&#9670;&nbsp;</a></span>spdk_vhost_fini()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_fini </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vhost_8h.html#a8b37106ad173f20d05da87f89714700b">spdk_vhost_fini_cb</a>&#160;</td>
          <td class="paramname"><em>fini_cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up the environment of vhost. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fini_cb</td><td>Function to be called when the cleanup is complete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8be392083ae01ad34cc05b1b5ce2b5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be392083ae01ad34cc05b1b5ce2b5e0">&#9670;&nbsp;</a></span>spdk_vhost_get_coalescing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_get_coalescing </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>delay_base_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>iops_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get coalescing parameters. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vhost_8h.html#a8b8c054fdc8ed4ad573b2d0bcf2d4797" title="By default, events are generated when asked, but for high queue depth and high IOPS this prove to be ...">spdk_vhost_set_coalescing</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device. </td></tr>
    <tr><td class="paramname">delay_base_us</td><td>Optional pointer to store base delay time. </td></tr>
    <tr><td class="paramname">iops_threshold</td><td>Optional pointer to store IOPS threshold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab35076d7e06edf2098b814929a04c7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35076d7e06edf2098b814929a04c7d5">&#9670;&nbsp;</a></span>spdk_vhost_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vhost_8h.html#aed34ffbfc5835716ba35a9ee050e1e74">spdk_vhost_init_cb</a>&#160;</td>
          <td class="paramname"><em>init_cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Init vhost environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init_cb</td><td>Function to be called when the initialization is complete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe5b0a12a12a26d2ddfe6a64f2a8a5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5b0a12a12a26d2ddfe6a64f2a8a5e2">&#9670;&nbsp;</a></span>spdk_vhost_scsi_dev_add_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_scsi_dev_add_tgt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scsi_tgt_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bdev_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct and attach new SCSI target to the vhost SCSI device on given (unoccupied) slot. </p>
<p>The device will be created with a single LUN0 associated with given SPDK bdev. Currently only one LUN per device is supported.</p>
<p>If the vhost SCSI device has an active connection and has negotiated <code>VIRTIO_SCSI_F_HOTPLUG</code> feature, the new SCSI target should be automatically detected by the other side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost SCSI device. </td></tr>
    <tr><td class="paramname">scsi_tgt_num</td><td>slot to attach to or negative value to use first free. </td></tr>
    <tr><td class="paramname">bdev_name</td><td>name of the SPDK bdev to associate with SCSI LUN0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value &gt;= 0 on success - the SCSI target ID, negative errno code: -EINVAL - one of the arguments is invalid:<ul>
<li>vdev is not vhost SCSI device</li>
<li>SCSI target ID is out of range</li>
<li>bdev name is NULL</li>
<li>can't create SCSI LUN because of other errors e.g.: bdev does not exist -ENOSPC - scsi_tgt_num is -1 and maximum targets in vhost SCSI device reached -EEXIST - SCSI target ID already exists </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a01b54a11439216fb05196474e3ee20d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b54a11439216fb05196474e3ee20d1">&#9670;&nbsp;</a></span>spdk_vhost_scsi_dev_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_scsi_dev_construct </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cpumask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an empty vhost SCSI device. </p>
<p>This will create a Unix domain socket together with a vhost-user slave server waiting for a connection on this socket. Creating the vdev does not start any I/O pollers and does not hog the CPU. I/O processing starts after receiving proper message on the created socket. See QEMU's vhost-user documentation for details. All physical devices have to be separately attached to this vdev via <code><a class="el" href="vhost_8h.html#afe5b0a12a12a26d2ddfe6a64f2a8a5e2" title="Construct and attach new SCSI target to the vhost SCSI device on given (unoccupied) slot.">spdk_vhost_scsi_dev_add_tgt()</a></code>.</p>
<p>This function is thread-safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the vhost device. The name will also be used for socket name, which is exactly <code>socket_base_dir/name</code> </td></tr>
    <tr><td class="paramname">cpumask</td><td>string containing cpumask in hex. The leading <em>0x</em> is allowed but not required. The mask itself can be constructed as: ((1 &lt;&lt; cpu0) | (1 &lt;&lt; cpu1) | ... | (1 &lt;&lt; cpuN)).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a540442ab4b6ec0ba4157e514a09f2379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a540442ab4b6ec0ba4157e514a09f2379">&#9670;&nbsp;</a></span>spdk_vhost_scsi_dev_get_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_scsi_dev* spdk_vhost_scsi_dev_get_tgt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SCSI target from vhost SCSI device on given slot. </p>
<p>Max number of available slots is defined by. <code>SPDK_VHOST_SCSI_CTRLR_MAX_DEVS</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost SCSI device. </td></tr>
    <tr><td class="paramname">num</td><td>slot id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SCSI device on given slot or NULL. </dd></dl>

</div>
</div>
<a id="ae1ea27c8ae7616e92d916e5c6fc34231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ea27c8ae7616e92d916e5c6fc34231">&#9670;&nbsp;</a></span>spdk_vhost_scsi_dev_remove_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_scsi_dev_remove_tgt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>scsi_tgt_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vhost_8h.html#ac2c4b62eaf6503e5f5e520394f9f9fe1">spdk_vhost_event_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach and destruct SCSI target from a vhost SCSI device. </p>
<p>The device will be deleted after all pending I/O is finished. If the driver supports VIRTIO_SCSI_F_HOTPLUG, then a hotremove notification will be sent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost SCSI device </td></tr>
    <tr><td class="paramname">scsi_tgt_num</td><td>slot id to delete target from </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback to be fired once target has been successfully deleted. The first parameter of callback function is the vhost SCSI device, the second is user provided argument <em>cb_arg</em>. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>parameter to be passed to <em>cb_fn</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="a8b8c054fdc8ed4ad573b2d0bcf2d4797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8c054fdc8ed4ad573b2d0bcf2d4797">&#9670;&nbsp;</a></span>spdk_vhost_set_coalescing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_set_coalescing </td>
          <td>(</td>
          <td class="paramtype">struct spdk_vhost_dev *&#160;</td>
          <td class="paramname"><em>vdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay_base_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>iops_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>By default, events are generated when asked, but for high queue depth and high IOPS this prove to be inefficient both for guest kernel that have to handle a lot more IO completions and for SPDK vhost that need to make more syscalls. </p>
<p>If enabled, limit amount of events (IRQs) sent to initiator by SPDK vhost effectively coalescing couple of completions. This of cource introduce IO latency penalty proportional to event delay time.</p>
<p>Actual events delay time when is calculated according to below formula: if (delay_base == 0 || IOPS &lt; iops_threshold) { delay = 0; } else if (IOPS &lt; iops_threshold) { delay = delay_base * (iops - iops_threshold) / iops_threshold; }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vdev</td><td>vhost device. </td></tr>
    <tr><td class="paramname">delay_base_us</td><td>Base delay time in microseconds. If 0, coalescing is disabled. </td></tr>
    <tr><td class="paramname">iops_threshold</td><td>IOPS threshold when coalescing is activated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15921078a895d090283fbbeaaddee76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15921078a895d090283fbbeaaddee76c">&#9670;&nbsp;</a></span>spdk_vhost_set_socket_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_set_socket_path </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>basename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the path to the directory where vhost sockets will be created. </p>
<p>This function must be called before <a class="el" href="vhost_8h.html#ab35076d7e06edf2098b814929a04c7d5" title="Init vhost environment.">spdk_vhost_init()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basename</td><td>Path to vhost socket directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on error. </dd></dl>

</div>
</div>
<a id="afd7159f8eb1e0d65dad5bedaa6cc5e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7159f8eb1e0d65dad5bedaa6cc5e43">&#9670;&nbsp;</a></span>spdk_vhost_shutdown_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_vhost_shutdown_cb </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinit vhost application. </p>
<p>This is called once by SPDK app layer. </p>

</div>
</div>
<a id="a04d81053d41a72f5df978f7c05dfebd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d81053d41a72f5df978f7c05dfebd7">&#9670;&nbsp;</a></span>spdk_vhost_trylock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_vhost_trylock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the global vhost mutex synchronizing all the vhost device accesses. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if the mutex could be locked immediately, negative errno otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
