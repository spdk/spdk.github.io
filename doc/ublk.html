<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="generator" content="Doxygen 1.9.1" />
  <title>SPDK: ublk Target</title>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  <script type="text/javascript" src="../js/doxyboot.js"></script>
  <script type="text/javascript" src="./navtree.js"></script>
  <link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
<body>
  <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/" aria-label="SPDK">
      <img src="/img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <div class="navbar-nav mr-auto">
        <a class="nav-link header-link active" href="../doc/">Documentation</a>
        <a class="nav-link header-link" href="../development/">Development</a>
        <a class="nav-link header-link" href="../community/">Community</a>
        <a class="nav-link header-link" href="../blog/">Blog</a>
      </div>
      <div class="navbar-nav ml-auto mr-3">
        <a class="nav-link header-link" href="https://github.com/spdk/spdk">
          <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
      </div>
    </div>
  </nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('ublk.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ublk Target </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_ublk"></a> </p>
<h1><a class="anchor" id="ublk_toc"></a>
Table of Contents</h1>
<ul>
<li><a class="el" href="ublk.html#ublk_intro">Introduction</a></li>
<li><a class="el" href="ublk.html#ublk_internal">ublk Internal</a></li>
<li><a class="el" href="ublk.html#ublk_impl">SPDK Implementation</a></li>
<li><a class="el" href="ublk.html#ublk_op">Operation</a></li>
</ul>
<h1><a class="anchor" id="ublk_intro"></a>
Introduction</h1>
<p><a href="https://docs.kernel.org/block/ublk.html">ublk</a> (or ubd) is a generic framework for implementing generic userspace block device based on <code>io_uring</code>. It is designed to create a highly efficient data path for userspace storage software to provide high-performance block device service in local host.</p>
<p>The whole ublk service involves three parts: ublk driver, ublk server and ublk workload.</p>
<p><img src="ublk_service.svg" alt="" style="pointer-events: none;" class="inline" title="ublk service stack"/></p>
<ul>
<li><b>ublk driver</b> is a kernel driver added to kernel 6.0. It delivers I/O requests from a ublk block device(<code>/dev/ublkbN</code>) into a ublk server.</li>
<li><b>ublk workload</b> can be any local host process which submits I/O requests to a ublk block device or a kernel filesystem on top of the ublk block device.</li>
<li><b>ublk server</b> is the userspace storage software that fetches the I/O requests delivered by the ublk driver. The ublk server will process the I/O requests with its specific block service logic and connected backends. Once the ublk server gets the response from the connected backends, it communicates with the ublk driver and completes the I/O requests.</li>
</ul>
<p>SPDK ublk target acts as a ublk server. It can handle ublk I/O requests within the whole SPDK userspace storage software stack.</p>
<p>A typical usage scenario is for container attached storage:</p>
<ul>
<li>Real storage resources are assigned to SPDK, like physical NVMe devices and distributed block storage.</li>
<li>SPDK creates refined block devices via ublk kernel module on top of its organized storage resources, based on user configuration.</li>
<li>Container orchestrator and runtime can then mount and stage the ublk block devices for container instances to use.</li>
</ul>
<h1><a class="anchor" id="ublk_internal"></a>
ublk Internal</h1>
<p>Previously, the design of putting I/O processing logic into userspace software always has a noticeable interaction overhead between the kernel module and userspace part.</p>
<p>ublk utilizes <code>io_uring</code> which has been proven to be very efficient in decreasing the interaction overhead. The I/O request is delivered to the userspace ublk server via the newly added <code>io_uring</code> command. A shared buffer via <code>mmap</code> is used for sharing I/O descriptor to userspace from the kernel driver. The I/O data is copied only once between the specified userspace buffer address and request/bio's pages by the ublk driver.</p>
<h2>Control Plane</h2>
<p>A control device is create by ublk kernel module at <code>/dev/ublk-control</code>. Userspace server sends control commands to kernel module via the control device using <code>io_uring</code>.</p>
<p>Control commands includes add, configure, and start new ublk block device. Retrieving device information, stop and delete existing ublk block device are also there.</p>
<p>The add device command creates a bulk char device <code>/dev/ublkcN</code>. It will be used by the ublk userspace server to <code>mmap</code> I/O descriptor buffer. The start device command exposes a ublk block device <code>/dev/ublkbN</code>. The block device can be formatted and mounted by a kernel filesystem, or read/written directly by other processes.</p>
<h2>Data Plane</h2>
<p>The datapath between ublk server and kernel driver includes <code>io_uring</code> and shared memory buffer. The shared memory buffer is an array of I/O descriptors. Each SQE (Submission Queue Entry) in <code>io_uring</code> is assigned one I/O descriptor and one user buffer address. When ublk kernel driver receives I/O requests from upper layer, the information of I/O requests will be filled into I/O descriptors by ublk kernel driver. The I/O data is copied between the specified user buffer address and request/bio's pages at the proper time.</p>
<p>At start, the ublk server needs to fill the <code>io_uring</code> SQ (Submission Queue). Each SQE is marked with an operation flag <code>UBLK_IO_FETCH_REQ</code> which means the SQE is ready to get I/O request.</p>
<p>When a CQE (Completion Queue Entry) is returned from the <code>io_uring</code> indicating I/O request, the ublk server gets the position of the I/O descriptor from CQE. The ublk server handles the I/O request based on information in the I/O descriptor.</p>
<p>After the ublk server completes the I/O request, it updates the I/O's completion status and ublk operation flag. This time, the operation flag is <code>UBLK_IO_COMMIT_AND_FETCH_REQ</code> which informs kernel module that one I/O request is completed, and also the SQE slot is free to fetch new I/O request.</p>
<p><code>UBLK_IO_COMMIT_AND_FETCH_REQ</code> is designed for efficiency in ublk. In runtime, the ublk server needs to commit I/O results back, and then provide new free SQE slots for fetching new I/O requests. Without <code>UBLK_IO_COMMIT_AND_FETCH_REQ</code> flag, <code>io_uring_submit()</code> should be called twice, once for committing I/O results back, once for providing free SQE slots. With <code>UBLK_IO_COMMIT_AND_FETCH_REQ</code> flag, calling <code>io_uring_submit()</code> once is enough because the ublk driver realizes that the submitted SQEs are reused both for committing back I/O results and fetching new requests.</p>
<h1><a class="anchor" id="ublk_impl"></a>
SPDK Implementation</h1>
<p>SPDK ublk target is implemented as a high performance ublk server.</p>
<p>It creates one ublk spdk_thread on each spdk_reactor by default or on user specified reactors. When adding a new ublk block device, SPDK ublk target will assign queues of ublk block device to ublk spdk_threads in round-robin. That means one ublk device queue will only be processed by one spdk_thread. One ublk device with multiple queues can get multiple spdk reactors involved to process its I/O requests; One spdk_thread created by ublk target may process multiple queues, each from different ublk devices. In this way, spdk reactors can be fully utilized to achieve best performance, when there are only a few ublk devices.</p>
<p>ublk is <code>io_uring</code> based. All ublk I/O queues are mapped to <code>io_uring</code>. ublk spdk_thread gets I/O requests from available CQEs by polling all its assigned <code>io_uring</code>s. When there are completed I/O requests, ublk spdk_thread will submit them as SQE back to <code>io_uring</code> in batch.</p>
<p>Currently, ublk driver has a system thread context limitation that one ublk device queue can be only processed in the context of system thread which initialized the it. SPDK can't schedule ublk spdk_thread between different SPDK reactors. In other words, SPDK dynamic scheduler can't rebalance ublk workload by rescheduling ublk spdk_thread.</p>
<h1><a class="anchor" id="ublk_op"></a>
Operation</h1>
<h2>Enabling SPDK ublk target</h2>
<p>Build SPDK with SPDK ublk target enabled.</p>
<div class="fragment"><div class="line">./configure --with-ublk</div>
<div class="line">make -j</div>
</div><!-- fragment --><p>SPDK ublk target related libaries will then be linked into SPDK appliation <code>spdk_tgt</code>. Setup some hugepages for the SPDK, and then run the SPDK application <code>spdk_tgt</code>.</p>
<div class="fragment"><div class="line">scripts/setup.sh</div>
<div class="line">build/bin/spdk_tgt &amp;</div>
</div><!-- fragment --><p>Once the <code>spdk_tgt</code> is initialized, user can enable SPDK ublk feature by creating ublk target. However, before creating ublk target, ublk kernel module <code>ublk_drv</code> should be loaded using <code>modprobe</code>.</p>
<div class="fragment"><div class="line">modprobe ublk_drv</div>
<div class="line">scripts/rpc.py ublk_create_target</div>
</div><!-- fragment --><h2>Creating ublk block device</h2>
<p>SPDK bdevs are block devices which will be exposed to the local host kernel as ublk block devices. SPDK supports several different types of storage backends, including NVMe, Linux AIO, malloc ramdisk and Ceph RBD. Refer to <a class="el" href="bdev.html">Block Device User Guide</a> for additional information on configuring SPDK storage backends.</p>
<p>This guide will use a malloc bdev (ramdisk) named Malloc0. The following RPC will create a 256MB malloc bdev with 512-byte block size.</p>
<div class="fragment"><div class="line">scripts/rpc.py bdev_malloc_create 256 512 -b Malloc0</div>
</div><!-- fragment --><p>The following RPC will create a ublk block device exposing Malloc0 bdev. The created ublk block device has ID 1. It internally has 2 queues with queue depth 128.</p>
<div class="fragment"><div class="line">scripts/rpc.py ublk_start_disk Malloc0 1 -q 2 -d 128</div>
</div><!-- fragment --><p>This RPC will reply back the ID of ublk block device. </p><div class="fragment"><div class="line">1</div>
</div><!-- fragment --><p>The position of ublk block device is determined by its ID. It is created at <code>/dev/ublkb${ID}</code>. So the device we just created will be accessible to other processes via <code>/dev/ublkb1</code>. Now applications like FIO or DD can work on <code>/dev/ublkb1</code> directly.</p>
<div class="fragment"><div class="line">dd of=/dev/ublkb1 if=/dev/zero bs=512 count=64</div>
</div><!-- fragment --><p>A ublk block device is a generic kernel block device that can be formatted and mounted by kernel file system.</p>
<div class="fragment"><div class="line">mkfs /dev/ublkb1</div>
<div class="line">mount /dev/ublkb1 /mnt/</div>
<div class="line">mkdir /mnt/testdir</div>
<div class="line">echo &quot;Helloï¼ŒSPDK ublk Target&quot; &gt; /mnt/testdir/testfile</div>
<div class="line">umount /mnt</div>
</div><!-- fragment --><h2>Deleting ublk block device and exit</h2>
<p>After usage, ublk block device can be stopped and deleted by RPC <code>ublk_stop_disk</code> with its ID. Specify ID 1, then device <code>/dev/ublkb1</code> will be removed.</p>
<div class="fragment"><div class="line">scripts/rpc.py ublk_stop_disk 1</div>
</div><!-- fragment --><p>If ublk is not used anymore, SPDK ublk target can be destroyed to free related SPDK resources.</p>
<div class="fragment"><div class="line">scripts/rpc.py ublk_destroy_target</div>
</div><!-- fragment --><p>Of course, SPDK ublk target and all ublk block devices would be destroyed automatically when SPDK application is terminated. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.1 </li>
</ul>
</div>
</div>
</body>
</html>
