<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="generator" content="Doxygen 1.9.1" />
  <title>SPDK: nvme.h File Reference</title>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  <script type="text/javascript" src="../js/doxyboot.js"></script>
  <script type="text/javascript" src="./navtree.js"></script>
  <link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
<body>
  <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/" aria-label="SPDK">
      <img src="/img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <div class="navbar-nav mr-auto">
        <a class="nav-link header-link active" href="../doc/">Documentation</a>
        <a class="nav-link header-link" href="../development/">Development</a>
        <a class="nav-link header-link" href="../community/">Community</a>
        <a class="nav-link header-link" href="../blog/">Blog</a>
      </div>
      <div class="navbar-nav ml-auto mr-3">
        <a class="nav-link header-link" href="https://github.com/spdk/spdk">
          <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
      </div>
    </div>
  </nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('nvme_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nvme.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>NVMe driver public API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe controller initialization options.  <a href="structspdk__nvme__ctrlr__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__accel__fn__table.html">spdk_nvme_accel_fn_table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function table for the NVMe accelerator device.  <a href="structspdk__nvme__accel__fn__table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe transport identifier.  <a href="structspdk__nvme__transport__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__host__id.html">spdk_nvme_host_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe host identifier.  <a href="structspdk__nvme__host__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__rdma__device__stat.html">spdk_nvme_rdma_device_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__pcie__stat.html">spdk_nvme_pcie_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__tcp__stat.html">spdk_nvme_tcp_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__transport__poll__group__stat.html">spdk_nvme_transport_poll_group_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__poll__group__stat.html">spdk_nvme_poll_group_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__ns__cmd__ext__io__opts.html">spdk_nvme_ns_cmd_ext_io_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure with optional IO request parameters.  <a href="structspdk__nvme__ns__cmd__ext__io__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__io__qpair__opts.html">spdk_nvme_io_qpair_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe I/O queue pair initialization options.  <a href="structspdk__nvme__io__qpair__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__rdma__hooks.html">spdk_nvme_rdma_hooks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RDMA Transport Hooks.  <a href="structspdk__nvme__rdma__hooks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__transport__ops.html">spdk_nvme_transport_ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__transport__opts.html">spdk_nvme_transport_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe transport options.  <a href="structspdk__nvme__transport__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab50510ef1ca103e1324417f2b2c80c95"><td class="memItemLeft" align="right" valign="top"><a id="ab50510ef1ca103e1324417f2b2c80c95"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_TRANSPORT_NAME_FC</b>&#160;&#160;&#160;&quot;FC&quot;</td></tr>
<tr class="separator:ab50510ef1ca103e1324417f2b2c80c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa027ac1fbd4b1aa4c992843aac953aac"><td class="memItemLeft" align="right" valign="top"><a id="aa027ac1fbd4b1aa4c992843aac953aac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_TRANSPORT_NAME_PCIE</b>&#160;&#160;&#160;&quot;PCIE&quot;</td></tr>
<tr class="separator:aa027ac1fbd4b1aa4c992843aac953aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80940dd87891e9632f6a309ec75f822"><td class="memItemLeft" align="right" valign="top"><a id="af80940dd87891e9632f6a309ec75f822"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_TRANSPORT_NAME_RDMA</b>&#160;&#160;&#160;&quot;RDMA&quot;</td></tr>
<tr class="separator:af80940dd87891e9632f6a309ec75f822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7c74143a1df7101e6c81a24c9f01a0"><td class="memItemLeft" align="right" valign="top"><a id="a0b7c74143a1df7101e6c81a24c9f01a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_TRANSPORT_NAME_TCP</b>&#160;&#160;&#160;&quot;TCP&quot;</td></tr>
<tr class="separator:a0b7c74143a1df7101e6c81a24c9f01a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f6e3956c2d99568a36f7b48941134a"><td class="memItemLeft" align="right" valign="top"><a id="a68f6e3956c2d99568a36f7b48941134a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_TRANSPORT_NAME_VFIOUSER</b>&#160;&#160;&#160;&quot;VFIOUSER&quot;</td></tr>
<tr class="separator:a68f6e3956c2d99568a36f7b48941134a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3e787dfb5847e18568831e760af1f3"><td class="memItemLeft" align="right" valign="top"><a id="a2a3e787dfb5847e18568831e760af1f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_TRANSPORT_NAME_CUSTOM</b>&#160;&#160;&#160;&quot;CUSTOM&quot;</td></tr>
<tr class="separator:a2a3e787dfb5847e18568831e760af1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d857d25bb764050417a01ae2245bc0f"><td class="memItemLeft" align="right" valign="top"><a id="a3d857d25bb764050417a01ae2245bc0f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVMF_PRIORITY_MAX_LEN</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a3d857d25bb764050417a01ae2245bc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6da5f02442d41a5233de049fb950a8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_TRANSPORT_REGISTER</b>(name,  transport_ops)</td></tr>
<tr class="separator:ac6da5f02442d41a5233de049fb950a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afff8aaa490f2db1119b20e36253196b7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#afff8aaa490f2db1119b20e36253196b7">spdk_nvme_accel_completion_cb</a>) (void *cb_arg, int status)</td></tr>
<tr class="memdesc:afff8aaa490f2db1119b20e36253196b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe acceleration operation callback.  <a href="nvme_8h.html#afff8aaa490f2db1119b20e36253196b7">More...</a><br /></td></tr>
<tr class="separator:afff8aaa490f2db1119b20e36253196b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2d01bfe80469fd5841cddaf8e1537f"><td class="memItemLeft" align="right" valign="top"><a id="a3b2d01bfe80469fd5841cddaf8e1537f"></a>
typedef enum <a class="el" href="nvme_8h.html#ab41e2d311eb6663957cd2f18bc8fb890">spdk_nvme_qp_failure_reason</a>&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_qp_failure_reason</b></td></tr>
<tr class="separator:a3b2d01bfe80469fd5841cddaf8e1537f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae15274f006778f31211e555a5cab825"><td class="memItemLeft" align="right" valign="top"><a id="aae15274f006778f31211e555a5cab825"></a>
typedef enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_transport_type_t</b></td></tr>
<tr class="separator:aae15274f006778f31211e555a5cab825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f40d5179f8424b466a30ba0610ab4c"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a95f40d5179f8424b466a30ba0610ab4c">spdk_nvme_probe_cb</a>) (void *cb_ctx, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts)</td></tr>
<tr class="memdesc:a95f40d5179f8424b466a30ba0610ab4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> enumeration.  <a href="nvme_8h.html#a95f40d5179f8424b466a30ba0610ab4c">More...</a><br /></td></tr>
<tr class="separator:a95f40d5179f8424b466a30ba0610ab4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eaa795f075495337b270667661ce5d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a>) (void *cb_ctx, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct spdk_nvme_ctrlr *ctrlr, const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts)</td></tr>
<tr class="memdesc:ac1eaa795f075495337b270667661ce5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for spdk_nvme_attach() to report a device that has been attached to the userspace NVMe driver.  <a href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">More...</a><br /></td></tr>
<tr class="separator:ac1eaa795f075495337b270667661ce5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f1aa545be57a03bb2dd0c6180172b6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a>) (void *cb_ctx, struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a05f1aa545be57a03bb2dd0c6180172b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for spdk_nvme_remove() to report that a device attached to the userspace NVMe driver has been removed from the system.  <a href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">More...</a><br /></td></tr>
<tr class="separator:a05f1aa545be57a03bb2dd0c6180172b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9335ab01f188f75b67c39b79b9206941"><td class="memItemLeft" align="right" valign="top"><a id="a9335ab01f188f75b67c39b79b9206941"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_pcie_hotplug_filter_cb</b>) (const struct <a class="el" href="structspdk__pci__addr.html">spdk_pci_addr</a> *addr)</td></tr>
<tr class="separator:a9335ab01f188f75b67c39b79b9206941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1786f9616afc773b20f752dc98ecd465"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>) (void *ctx, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *cpl)</td></tr>
<tr class="memdesc:a1786f9616afc773b20f752dc98ecd465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for callback function invoked when a command is completed.  <a href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">More...</a><br /></td></tr>
<tr class="separator:a1786f9616afc773b20f752dc98ecd465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d066bb761dc3481f081d0d6924766ee"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a1d066bb761dc3481f081d0d6924766ee">spdk_nvme_aer_cb</a>) (void *aer_cb_arg, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *cpl)</td></tr>
<tr class="memdesc:a1d066bb761dc3481f081d0d6924766ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for callback function invoked when an asynchronous event request command is completed.  <a href="nvme_8h.html#a1d066bb761dc3481f081d0d6924766ee">More...</a><br /></td></tr>
<tr class="separator:a1d066bb761dc3481f081d0d6924766ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fe1c01a447be8fcd29821a668227a0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a53fe1c01a447be8fcd29821a668227a0">spdk_nvme_timeout_cb</a>) (void *cb_arg, struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, uint16_t cid)</td></tr>
<tr class="memdesc:a53fe1c01a447be8fcd29821a668227a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for the callback function invoked when a timeout is detected on a request.  <a href="nvme_8h.html#a53fe1c01a447be8fcd29821a668227a0">More...</a><br /></td></tr>
<tr class="separator:a53fe1c01a447be8fcd29821a668227a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4bc7c0002363701bc9363ab2291e6e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a4e4bc7c0002363701bc9363ab2291e6e">spdk_nvme_discovery_cb</a>) (void *cb_arg, int rc, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *cpl, struct <a class="el" href="structspdk__nvmf__discovery__log__page.html">spdk_nvmf_discovery_log_page</a> *log_page)</td></tr>
<tr class="memdesc:a4e4bc7c0002363701bc9363ab2291e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for the callback function when a <a class="el" href="nvme_8h.html#a87a228bf5b96e89305e52721d81920d7">spdk_nvme_ctrlr_get_discovery_log_page</a> operation is completed.  <a href="nvme_8h.html#a4e4bc7c0002363701bc9363ab2291e6e">More...</a><br /></td></tr>
<tr class="separator:a4e4bc7c0002363701bc9363ab2291e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add892b5eaa7208ca3b08382431713390"><td class="memItemLeft" align="right" valign="top"><a id="add892b5eaa7208ca3b08382431713390"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#add892b5eaa7208ca3b08382431713390">spdk_nvme_disconnected_qpair_cb</a>) (struct spdk_nvme_qpair *qpair, void *poll_group_ctx)</td></tr>
<tr class="memdesc:add892b5eaa7208ca3b08382431713390"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function alerts the user to disconnected qpairs when calling spdk_nvme_poll_group_process_completions. <br /></td></tr>
<tr class="separator:add892b5eaa7208ca3b08382431713390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1fcb43970ea531567ee00d4ee0675b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>) (void *cb_arg, uint32_t offset)</td></tr>
<tr class="memdesc:a0e1fcb43970ea531567ee00d4ee0675b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart the SGL walk to the specified offset when the command has scattered payloads.  <a href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">More...</a><br /></td></tr>
<tr class="separator:a0e1fcb43970ea531567ee00d4ee0675b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab95bea86f498c08510f6f0bcd2eb09"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>) (void *cb_arg, void **address, uint32_t *length)</td></tr>
<tr class="memdesc:a4ab95bea86f498c08510f6f0bcd2eb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill out *address and *length with the current SGL entry and advance to the next entry for the next time the callback is invoked.  <a href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">More...</a><br /></td></tr>
<tr class="separator:a4ab95bea86f498c08510f6f0bcd2eb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0893350626b0eff85b931c570876f28a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a0893350626b0eff85b931c570876f28a">spdk_nvme_reg_cb</a>) (void *ctx, uint64_t value, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *cpl)</td></tr>
<tr class="memdesc:a0893350626b0eff85b931c570876f28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for callback invoked after completing a register read/write operation.  <a href="nvme_8h.html#a0893350626b0eff85b931c570876f28a">More...</a><br /></td></tr>
<tr class="separator:a0893350626b0eff85b931c570876f28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab41e2d311eb6663957cd2f18bc8fb890"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab41e2d311eb6663957cd2f18bc8fb890">spdk_nvme_qp_failure_reason</a> { <b>SPDK_NVME_QPAIR_FAILURE_NONE</b> = 0
, <b>SPDK_NVME_QPAIR_FAILURE_LOCAL</b>
, <b>SPDK_NVME_QPAIR_FAILURE_REMOTE</b>
, <b>SPDK_NVME_QPAIR_FAILURE_UNKNOWN</b>
 }</td></tr>
<tr class="memdesc:ab41e2d311eb6663957cd2f18bc8fb890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reason for qpair disconnect at the transport layer.  <a href="nvme_8h.html#ab41e2d311eb6663957cd2f18bc8fb890">More...</a><br /></td></tr>
<tr class="separator:ab41e2d311eb6663957cd2f18bc8fb890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87a03c28984a2c0499d50ef5e9d0ece"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a> { <br />
&#160;&#160;<a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ecea162afc05d1ae756b8a7969be140035ea">SPDK_NVME_TRANSPORT_PCIE</a> = 256
, <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ecea140f1cb4edf258bddffeb1c7277d93d8">SPDK_NVME_TRANSPORT_RDMA</a> = SPDK_NVMF_TRTYPE_RDMA
, <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0eceabbda195aa6d0a4ad7b437ed5e9a0d01f">SPDK_NVME_TRANSPORT_FC</a> = SPDK_NVMF_TRTYPE_FC
, <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ecea1b74e6a5b484b71142aa6ac9821a6de3">SPDK_NVME_TRANSPORT_TCP</a> = SPDK_NVMF_TRTYPE_TCP
, <br />
&#160;&#160;<a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ecea4a7f3a344a32bd10b0594726fa4eaa33">SPDK_NVME_TRANSPORT_VFIOUSER</a> = 1024
, <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ecead9c4d8737f8d49b432c3f2d9d0f86a0a">SPDK_NVME_TRANSPORT_CUSTOM</a> = 4096
, <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ecead22a6399d96bc2c38efb261319c04ffc">SPDK_NVME_TRANSPORT_CUSTOM_FABRICS</a> = 4097
<br />
 }</td></tr>
<tr class="memdesc:ae87a03c28984a2c0499d50ef5e9d0ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe library transports.  <a href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">More...</a><br /></td></tr>
<tr class="separator:ae87a03c28984a2c0499d50ef5e9d0ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add21ceb016f09949ac6cef50e0566818"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#add21ceb016f09949ac6cef50e0566818">spdk_nvme_ctrlr_flags</a> { <br />
&#160;&#160;<a class="el" href="nvme_8h.html#add21ceb016f09949ac6cef50e0566818a06c93626e819195260a55c69dba063c6">SPDK_NVME_CTRLR_SGL_SUPPORTED</a> = 1 &lt;&lt; 0
, <a class="el" href="nvme_8h.html#add21ceb016f09949ac6cef50e0566818a7bddfe71a101581b0daa4812fbd93268">SPDK_NVME_CTRLR_SECURITY_SEND_RECV_SUPPORTED</a> = 1 &lt;&lt; 1
, <a class="el" href="nvme_8h.html#add21ceb016f09949ac6cef50e0566818ab7e2345d658ff0069c99427a5e0177d3">SPDK_NVME_CTRLR_WRR_SUPPORTED</a> = 1 &lt;&lt; 2
, <a class="el" href="nvme_8h.html#add21ceb016f09949ac6cef50e0566818ab2a269826d7e50f062924065df9cf6ec">SPDK_NVME_CTRLR_COMPARE_AND_WRITE_SUPPORTED</a> = 1 &lt;&lt; 3
, <br />
&#160;&#160;<a class="el" href="nvme_8h.html#add21ceb016f09949ac6cef50e0566818afb90e96b743634d16ce84716e3250e0d">SPDK_NVME_CTRLR_SGL_REQUIRES_DWORD_ALIGNMENT</a> = 1 &lt;&lt; 4
, <a class="el" href="nvme_8h.html#add21ceb016f09949ac6cef50e0566818a47e0066f0e7c2c8f3d0fba8ce612dc73">SPDK_NVME_CTRLR_ZONE_APPEND_SUPPORTED</a> = 1 &lt;&lt; 5
, <a class="el" href="nvme_8h.html#add21ceb016f09949ac6cef50e0566818a2ecf8c85bee974f9e7f35a684dff76ac">SPDK_NVME_CTRLR_DIRECTIVES_SUPPORTED</a> = 1 &lt;&lt; 6
<br />
 }</td></tr>
<tr class="separator:add21ceb016f09949ac6cef50e0566818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018f3b986b4345ee0c6931be9718c163"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163">spdk_nvme_ns_flags</a> { <br />
&#160;&#160;<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163a80dcd48a57fa9e14efba4757300ad729">SPDK_NVME_NS_DEALLOCATE_SUPPORTED</a> = 1 &lt;&lt; 0
, <a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163ad403aafc70c00560a1db768029933400">SPDK_NVME_NS_FLUSH_SUPPORTED</a> = 1 &lt;&lt; 1
, <a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163a60edfdee88fbe811250e2f8ff63597d0">SPDK_NVME_NS_RESERVATION_SUPPORTED</a> = 1 &lt;&lt; 2
, <a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163a4e691401f3709b7cd66bd32c28ae109b">SPDK_NVME_NS_WRITE_ZEROES_SUPPORTED</a> = 1 &lt;&lt; 3
, <br />
&#160;&#160;<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163afe158b050528f0f3341e5af3129c61a7">SPDK_NVME_NS_DPS_PI_SUPPORTED</a> = 1 &lt;&lt; 4
, <a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163a91203896ead47bbe22e9f7db8a63c14f">SPDK_NVME_NS_EXTENDED_LBA_SUPPORTED</a> = 1 &lt;&lt; 5
, <a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163afe42f7e0cdcb93109b55b77cf89efd27">SPDK_NVME_NS_WRITE_UNCORRECTABLE_SUPPORTED</a> = 1 &lt;&lt; 6
, <a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163a568a13a9686985d4aa24543b52c122d6">SPDK_NVME_NS_COMPARE_SUPPORTED</a> = 1 &lt;&lt; 7
<br />
 }</td></tr>
<tr class="memdesc:a018f3b986b4345ee0c6931be9718c163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace command support flags.  <a href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163">More...</a><br /></td></tr>
<tr class="separator:a018f3b986b4345ee0c6931be9718c163"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aed8e34da22ea23b3c1e012f52c198132"><td class="memItemLeft" align="right" valign="top"><a id="aed8e34da22ea23b3c1e012f52c198132"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a>)==818, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:aed8e34da22ea23b3c1e012f52c198132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c91e2e6ae899f37b5a89c28a2207cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a39c91e2e6ae899f37b5a89c28a2207cf">spdk_nvme_ctrlr_is_discovery</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a39c91e2e6ae899f37b5a89c28a2207cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether a ctrlr handle is associated with a Discovery controller.  <a href="nvme_8h.html#a39c91e2e6ae899f37b5a89c28a2207cf">More...</a><br /></td></tr>
<tr class="separator:a39c91e2e6ae899f37b5a89c28a2207cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8a76223de34edcae773a19a2a7263a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ace8a76223de34edcae773a19a2a7263a">spdk_nvme_ctrlr_is_fabrics</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:ace8a76223de34edcae773a19a2a7263a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether a ctrlr handle is associated with a fabrics controller.  <a href="nvme_8h.html#ace8a76223de34edcae773a19a2a7263a">More...</a><br /></td></tr>
<tr class="separator:ace8a76223de34edcae773a19a2a7263a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31bc692c6b3a84e2355eb63a8b01ccf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac31bc692c6b3a84e2355eb63a8b01ccf">spdk_nvme_ctrlr_get_default_ctrlr_opts</a> (struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:ac31bc692c6b3a84e2355eb63a8b01ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default options for the creation of a specific NVMe controller.  <a href="nvme_8h.html#ac31bc692c6b3a84e2355eb63a8b01ccf">More...</a><br /></td></tr>
<tr class="separator:ac31bc692c6b3a84e2355eb63a8b01ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba334622a95701d8fefad9cb2705df74"><td class="memItemLeft" align="right" valign="top"><a id="aba334622a95701d8fefad9cb2705df74"></a>
const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_ctrlr_get_opts</b> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="separator:aba334622a95701d8fefad9cb2705df74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d50c30580eef93831a6e473dfc00051"><td class="memItemLeft" align="right" valign="top"><a id="a9d50c30580eef93831a6e473dfc00051"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_trtype_is_fabrics</b> (enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a> trtype)</td></tr>
<tr class="separator:a9d50c30580eef93831a6e473dfc00051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7d8b5592cb9674eb0e270e33a8902d"><td class="memItemLeft" align="right" valign="top"><a id="a1c7d8b5592cb9674eb0e270e33a8902d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__ns__cmd__ext__io__opts.html">spdk_nvme_ns_cmd_ext_io_opts</a>)==48, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a1c7d8b5592cb9674eb0e270e33a8902d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37484cc5d14777e4ae1fde031d0edf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac37484cc5d14777e4ae1fde031d0edf2">spdk_nvme_transport_id_parse</a> (struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, const char *str)</td></tr>
<tr class="memdesc:ac37484cc5d14777e4ae1fde031d0edf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the string representation of a transport ID.  <a href="nvme_8h.html#ac37484cc5d14777e4ae1fde031d0edf2">More...</a><br /></td></tr>
<tr class="separator:ac37484cc5d14777e4ae1fde031d0edf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ab0982e7e0191fd16f041a268966b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab5ab0982e7e0191fd16f041a268966b5">spdk_nvme_trid_populate_transport</a> (struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a> trtype)</td></tr>
<tr class="memdesc:ab5ab0982e7e0191fd16f041a268966b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in the trtype and trstring fields of this trid based on a known transport type.  <a href="nvme_8h.html#ab5ab0982e7e0191fd16f041a268966b5">More...</a><br /></td></tr>
<tr class="separator:ab5ab0982e7e0191fd16f041a268966b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad068dd50f11160450098712422116785"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad068dd50f11160450098712422116785">spdk_nvme_host_id_parse</a> (struct <a class="el" href="structspdk__nvme__host__id.html">spdk_nvme_host_id</a> *hostid, const char *str)</td></tr>
<tr class="memdesc:ad068dd50f11160450098712422116785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the string representation of a host ID.  <a href="nvme_8h.html#ad068dd50f11160450098712422116785">More...</a><br /></td></tr>
<tr class="separator:ad068dd50f11160450098712422116785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0eb5d0f2e974c4d85fa251796486a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a5d0eb5d0f2e974c4d85fa251796486a3">spdk_nvme_transport_id_populate_trstring</a> (struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, const char *trstring)</td></tr>
<tr class="memdesc:a5d0eb5d0f2e974c4d85fa251796486a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the string representation of a transport ID transport type into the trid struct.  <a href="nvme_8h.html#a5d0eb5d0f2e974c4d85fa251796486a3">More...</a><br /></td></tr>
<tr class="separator:a5d0eb5d0f2e974c4d85fa251796486a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2afed1cce9d9334dfd127db416ada4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab2afed1cce9d9334dfd127db416ada4c">spdk_nvme_transport_id_parse_trtype</a> (enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a> *trtype, const char *str)</td></tr>
<tr class="memdesc:ab2afed1cce9d9334dfd127db416ada4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the string representation of a transport ID transport type.  <a href="nvme_8h.html#ab2afed1cce9d9334dfd127db416ada4c">More...</a><br /></td></tr>
<tr class="separator:ab2afed1cce9d9334dfd127db416ada4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a982eb5b757eae63fbc9305627090b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa3a982eb5b757eae63fbc9305627090b">spdk_nvme_transport_id_trtype_str</a> (enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a> trtype)</td></tr>
<tr class="memdesc:aa3a982eb5b757eae63fbc9305627090b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the string representation of a transport ID transport type.  <a href="nvme_8h.html#aa3a982eb5b757eae63fbc9305627090b">More...</a><br /></td></tr>
<tr class="separator:aa3a982eb5b757eae63fbc9305627090b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb95c5452e84e2c5c1984341fc816ea7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#afb95c5452e84e2c5c1984341fc816ea7">spdk_nvme_transport_id_adrfam_str</a> (enum <a class="el" href="nvmf__spec_8h.html#a08f0090d242e2607ab11f148dcd797c6">spdk_nvmf_adrfam</a> adrfam)</td></tr>
<tr class="memdesc:afb95c5452e84e2c5c1984341fc816ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the string representation of a transport ID address family.  <a href="nvme_8h.html#afb95c5452e84e2c5c1984341fc816ea7">More...</a><br /></td></tr>
<tr class="separator:afb95c5452e84e2c5c1984341fc816ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7868a6f646a6d1bd70d5c1b8ce5757f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#af7868a6f646a6d1bd70d5c1b8ce5757f">spdk_nvme_transport_id_parse_adrfam</a> (enum <a class="el" href="nvmf__spec_8h.html#a08f0090d242e2607ab11f148dcd797c6">spdk_nvmf_adrfam</a> *adrfam, const char *str)</td></tr>
<tr class="memdesc:af7868a6f646a6d1bd70d5c1b8ce5757f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the string representation of a transport ID address family.  <a href="nvme_8h.html#af7868a6f646a6d1bd70d5c1b8ce5757f">More...</a><br /></td></tr>
<tr class="separator:af7868a6f646a6d1bd70d5c1b8ce5757f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9878deb91f677a9a9583342f07dcef41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a9878deb91f677a9a9583342f07dcef41">spdk_nvme_transport_id_compare</a> (const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid1, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid2)</td></tr>
<tr class="memdesc:a9878deb91f677a9a9583342f07dcef41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two transport IDs.  <a href="nvme_8h.html#a9878deb91f677a9a9583342f07dcef41">More...</a><br /></td></tr>
<tr class="separator:a9878deb91f677a9a9583342f07dcef41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f14ec05ce3af11f089a79d47739bd74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a0f14ec05ce3af11f089a79d47739bd74">spdk_nvme_prchk_flags_parse</a> (uint32_t *prchk_flags, const char *str)</td></tr>
<tr class="memdesc:a0f14ec05ce3af11f089a79d47739bd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the string representation of PI check settings (prchk:guard|reftag)  <a href="nvme_8h.html#a0f14ec05ce3af11f089a79d47739bd74">More...</a><br /></td></tr>
<tr class="separator:a0f14ec05ce3af11f089a79d47739bd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae125f35c7ab6fd2f5e63bfac804f25e6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae125f35c7ab6fd2f5e63bfac804f25e6">spdk_nvme_prchk_flags_str</a> (uint32_t prchk_flags)</td></tr>
<tr class="memdesc:ae125f35c7ab6fd2f5e63bfac804f25e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the string representation of PI check settings (prchk:guard|reftag)  <a href="nvme_8h.html#ae125f35c7ab6fd2f5e63bfac804f25e6">More...</a><br /></td></tr>
<tr class="separator:ae125f35c7ab6fd2f5e63bfac804f25e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5735e7600f79c45871b3dc3adb292f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab5735e7600f79c45871b3dc3adb292f2">spdk_nvme_transport_available</a> (enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a> trtype)</td></tr>
<tr class="memdesc:ab5735e7600f79c45871b3dc3adb292f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the NVMe library can handle a specific NVMe over Fabrics transport type.  <a href="nvme_8h.html#ab5735e7600f79c45871b3dc3adb292f2">More...</a><br /></td></tr>
<tr class="separator:ab5735e7600f79c45871b3dc3adb292f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4541db53f0daadcb4fc1d4f950b4bb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab4541db53f0daadcb4fc1d4f950b4bb5">spdk_nvme_transport_available_by_name</a> (const char *transport_name)</td></tr>
<tr class="memdesc:ab4541db53f0daadcb4fc1d4f950b4bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the NVMe library can handle a specific NVMe over Fabrics transport type.  <a href="nvme_8h.html#ab4541db53f0daadcb4fc1d4f950b4bb5">More...</a><br /></td></tr>
<tr class="separator:ab4541db53f0daadcb4fc1d4f950b4bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976b90cbbc1aa8a4117837758f65e6c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a976b90cbbc1aa8a4117837758f65e6c7">spdk_nvme_pcie_set_hotplug_filter</a> (spdk_nvme_pcie_hotplug_filter_cb filter_cb)</td></tr>
<tr class="memdesc:a976b90cbbc1aa8a4117837758f65e6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the associated function to allow filtering of hot-inserted PCIe SSDs.  <a href="nvme_8h.html#a976b90cbbc1aa8a4117837758f65e6c7">More...</a><br /></td></tr>
<tr class="separator:a976b90cbbc1aa8a4117837758f65e6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225bbc386ec518ae21bd5536f21db45d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d">spdk_nvme_probe</a> (const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, void *cb_ctx, <a class="el" href="nvme_8h.html#a95f40d5179f8424b466a30ba0610ab4c">spdk_nvme_probe_cb</a> probe_cb, <a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a> attach_cb, <a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a> remove_cb)</td></tr>
<tr class="memdesc:a225bbc386ec518ae21bd5536f21db45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device found if desired.  <a href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d">More...</a><br /></td></tr>
<tr class="separator:a225bbc386ec518ae21bd5536f21db45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26375a74c2c935ec32f0c41a7ed93df"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_ctrlr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae26375a74c2c935ec32f0c41a7ed93df">spdk_nvme_connect</a> (const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:ae26375a74c2c935ec32f0c41a7ed93df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the NVMe driver to the device located at the given transport ID.  <a href="nvme_8h.html#ae26375a74c2c935ec32f0c41a7ed93df">More...</a><br /></td></tr>
<tr class="separator:ae26375a74c2c935ec32f0c41a7ed93df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a8762934973d124cbad92fce47a351"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_probe_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae8a8762934973d124cbad92fce47a351">spdk_nvme_connect_async</a> (const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts, <a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a> attach_cb)</td></tr>
<tr class="memdesc:ae8a8762934973d124cbad92fce47a351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the NVMe driver to the device located at the given transport ID.  <a href="nvme_8h.html#ae8a8762934973d124cbad92fce47a351">More...</a><br /></td></tr>
<tr class="separator:ae8a8762934973d124cbad92fce47a351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02411bf7ae4827a350711e688316997e"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_probe_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a02411bf7ae4827a350711e688316997e">spdk_nvme_probe_async</a> (const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, void *cb_ctx, <a class="el" href="nvme_8h.html#a95f40d5179f8424b466a30ba0610ab4c">spdk_nvme_probe_cb</a> probe_cb, <a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a> attach_cb, <a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a> remove_cb)</td></tr>
<tr class="memdesc:a02411bf7ae4827a350711e688316997e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probe and add controllers to the probe context list.  <a href="nvme_8h.html#a02411bf7ae4827a350711e688316997e">More...</a><br /></td></tr>
<tr class="separator:a02411bf7ae4827a350711e688316997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedea919a47bdd811b604656e29e3fcef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aedea919a47bdd811b604656e29e3fcef">spdk_nvme_probe_poll_async</a> (struct spdk_nvme_probe_ctx *probe_ctx)</td></tr>
<tr class="memdesc:aedea919a47bdd811b604656e29e3fcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proceed with attaching controllers associated with the probe context.  <a href="nvme_8h.html#aedea919a47bdd811b604656e29e3fcef">More...</a><br /></td></tr>
<tr class="separator:aedea919a47bdd811b604656e29e3fcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b63c225c3cce6da60fdbfb6f54b11e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2">spdk_nvme_detach</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a4b63c225c3cce6da60fdbfb6f54b11e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach specified device returned by <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>'s attach_cb from the NVMe driver.  <a href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2">More...</a><br /></td></tr>
<tr class="separator:a4b63c225c3cce6da60fdbfb6f54b11e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f8edb4791c426ccec2b815ca0ed791"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a30f8edb4791c426ccec2b815ca0ed791">spdk_nvme_detach_async</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_detach_ctx **detach_ctx)</td></tr>
<tr class="memdesc:a30f8edb4791c426ccec2b815ca0ed791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a context to track detachment of multiple controllers if this call is the first successful start of detachment in a sequence, or use the passed context otherwise.  <a href="nvme_8h.html#a30f8edb4791c426ccec2b815ca0ed791">More...</a><br /></td></tr>
<tr class="separator:a30f8edb4791c426ccec2b815ca0ed791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19178860f90bdd522eaa329d0ff837fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a19178860f90bdd522eaa329d0ff837fe">spdk_nvme_detach_poll_async</a> (struct spdk_nvme_detach_ctx *detach_ctx)</td></tr>
<tr class="memdesc:a19178860f90bdd522eaa329d0ff837fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll detachment of multiple controllers until they complete.  <a href="nvme_8h.html#a19178860f90bdd522eaa329d0ff837fe">More...</a><br /></td></tr>
<tr class="separator:a19178860f90bdd522eaa329d0ff837fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053bcfa48d3c4b20ac4a408fa5e61418"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a053bcfa48d3c4b20ac4a408fa5e61418">spdk_nvme_detach_poll</a> (struct spdk_nvme_detach_ctx *detach_ctx)</td></tr>
<tr class="memdesc:a053bcfa48d3c4b20ac4a408fa5e61418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continue calling <a class="el" href="nvme_8h.html#a19178860f90bdd522eaa329d0ff837fe" title="Poll detachment of multiple controllers until they complete.">spdk_nvme_detach_poll_async()</a> internally until it returns 0.  <a href="nvme_8h.html#a053bcfa48d3c4b20ac4a408fa5e61418">More...</a><br /></td></tr>
<tr class="separator:a053bcfa48d3c4b20ac4a408fa5e61418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eacd62ee8fbab40e1066bc0a53485f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6eacd62ee8fbab40e1066bc0a53485f3">spdk_nvme_ctrlr_set_trid</a> (struct spdk_nvme_ctrlr *ctrlr, struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:a6eacd62ee8fbab40e1066bc0a53485f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the transport ID for a given controller.  <a href="nvme_8h.html#a6eacd62ee8fbab40e1066bc0a53485f3">More...</a><br /></td></tr>
<tr class="separator:a6eacd62ee8fbab40e1066bc0a53485f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab29a85672c9837b13e3041da7efce5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aab29a85672c9837b13e3041da7efce5e">spdk_nvme_ctrlr_set_remove_cb</a> (struct spdk_nvme_ctrlr *ctrlr, <a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a> remove_cb, void *remove_ctx)</td></tr>
<tr class="memdesc:aab29a85672c9837b13e3041da7efce5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the remove callback and context to be invoked if the controller is removed.  <a href="nvme_8h.html#aab29a85672c9837b13e3041da7efce5e">More...</a><br /></td></tr>
<tr class="separator:aab29a85672c9837b13e3041da7efce5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13ccd2ea831842a5008eb95a32545c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae13ccd2ea831842a5008eb95a32545c3">spdk_nvme_ctrlr_reset</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:ae13ccd2ea831842a5008eb95a32545c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a full hardware reset of the NVMe controller.  <a href="nvme_8h.html#ae13ccd2ea831842a5008eb95a32545c3">More...</a><br /></td></tr>
<tr class="separator:ae13ccd2ea831842a5008eb95a32545c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458a65224a0f20c73d0acb44715d86dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a458a65224a0f20c73d0acb44715d86dc">spdk_nvme_ctrlr_disconnect</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a458a65224a0f20c73d0acb44715d86dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the given NVMe controller.  <a href="nvme_8h.html#a458a65224a0f20c73d0acb44715d86dc">More...</a><br /></td></tr>
<tr class="separator:a458a65224a0f20c73d0acb44715d86dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26e52f0881a802f40c5f7d1f19e19e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad26e52f0881a802f40c5f7d1f19e19e3">spdk_nvme_ctrlr_reconnect_async</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:ad26e52f0881a802f40c5f7d1f19e19e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start re-enabling the given NVMe controller in a full reset sequence.  <a href="nvme_8h.html#ad26e52f0881a802f40c5f7d1f19e19e3">More...</a><br /></td></tr>
<tr class="separator:ad26e52f0881a802f40c5f7d1f19e19e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd56920dfc24752852b2c63fa5e4fd46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#acd56920dfc24752852b2c63fa5e4fd46">spdk_nvme_ctrlr_reconnect_poll_async</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:acd56920dfc24752852b2c63fa5e4fd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proceed with re-enabling the given NVMe controller.  <a href="nvme_8h.html#acd56920dfc24752852b2c63fa5e4fd46">More...</a><br /></td></tr>
<tr class="separator:acd56920dfc24752852b2c63fa5e4fd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0547769c5a00f5b502ea4f71f2fff947"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a0547769c5a00f5b502ea4f71f2fff947">spdk_nvme_ctrlr_reset_subsystem</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a0547769c5a00f5b502ea4f71f2fff947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a NVMe subsystem reset.  <a href="nvme_8h.html#a0547769c5a00f5b502ea4f71f2fff947">More...</a><br /></td></tr>
<tr class="separator:a0547769c5a00f5b502ea4f71f2fff947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7578aeee6b6a092a4a4013a2f32ce5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a4b7578aeee6b6a092a4a4013a2f32ce5">spdk_nvme_ctrlr_fail</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a4b7578aeee6b6a092a4a4013a2f32ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fail the given NVMe controller.  <a href="nvme_8h.html#a4b7578aeee6b6a092a4a4013a2f32ce5">More...</a><br /></td></tr>
<tr class="separator:a4b7578aeee6b6a092a4a4013a2f32ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdd28db5de54dfee308ea0a3c4f1442"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a1cdd28db5de54dfee308ea0a3c4f1442">spdk_nvme_ctrlr_is_failed</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a1cdd28db5de54dfee308ea0a3c4f1442"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the failed status of a given controller.  <a href="nvme_8h.html#a1cdd28db5de54dfee308ea0a3c4f1442">More...</a><br /></td></tr>
<tr class="separator:a1cdd28db5de54dfee308ea0a3c4f1442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9daf15b5008ac36c12e7b8db7bdec9"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__nvme__ctrlr__data.html">spdk_nvme_ctrlr_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a5a9daf15b5008ac36c12e7b8db7bdec9">spdk_nvme_ctrlr_get_data</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a5a9daf15b5008ac36c12e7b8db7bdec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the identify controller data as defined by the NVMe specification.  <a href="nvme_8h.html#a5a9daf15b5008ac36c12e7b8db7bdec9">More...</a><br /></td></tr>
<tr class="separator:a5a9daf15b5008ac36c12e7b8db7bdec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46348531c83fd61acad1a55236d7d576"><td class="memItemLeft" align="right" valign="top">union <a class="el" href="unionspdk__nvme__csts__register.html">spdk_nvme_csts_register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a46348531c83fd61acad1a55236d7d576">spdk_nvme_ctrlr_get_regs_csts</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a46348531c83fd61acad1a55236d7d576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller CSTS (Status) register.  <a href="nvme_8h.html#a46348531c83fd61acad1a55236d7d576">More...</a><br /></td></tr>
<tr class="separator:a46348531c83fd61acad1a55236d7d576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7312bd0bc396b6c714b6cca7073d3f6d"><td class="memItemLeft" align="right" valign="top">union <a class="el" href="unionspdk__nvme__cc__register.html">spdk_nvme_cc_register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7312bd0bc396b6c714b6cca7073d3f6d">spdk_nvme_ctrlr_get_regs_cc</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a7312bd0bc396b6c714b6cca7073d3f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller CC (Configuration) register.  <a href="nvme_8h.html#a7312bd0bc396b6c714b6cca7073d3f6d">More...</a><br /></td></tr>
<tr class="separator:a7312bd0bc396b6c714b6cca7073d3f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6943191f9c88c3cec504f87672b9acf8"><td class="memItemLeft" align="right" valign="top">union <a class="el" href="unionspdk__nvme__cap__register.html">spdk_nvme_cap_register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6943191f9c88c3cec504f87672b9acf8">spdk_nvme_ctrlr_get_regs_cap</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a6943191f9c88c3cec504f87672b9acf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller CAP (Capabilities) register.  <a href="nvme_8h.html#a6943191f9c88c3cec504f87672b9acf8">More...</a><br /></td></tr>
<tr class="separator:a6943191f9c88c3cec504f87672b9acf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf238fdce21d10c923a384e18b013dd"><td class="memItemLeft" align="right" valign="top">union <a class="el" href="unionspdk__nvme__vs__register.html">spdk_nvme_vs_register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aacf238fdce21d10c923a384e18b013dd">spdk_nvme_ctrlr_get_regs_vs</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:aacf238fdce21d10c923a384e18b013dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller VS (Version) register.  <a href="nvme_8h.html#aacf238fdce21d10c923a384e18b013dd">More...</a><br /></td></tr>
<tr class="separator:aacf238fdce21d10c923a384e18b013dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260b335960b9d81ac1a2601b003b99cd"><td class="memItemLeft" align="right" valign="top">union <a class="el" href="unionspdk__nvme__cmbsz__register.html">spdk_nvme_cmbsz_register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a260b335960b9d81ac1a2601b003b99cd">spdk_nvme_ctrlr_get_regs_cmbsz</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a260b335960b9d81ac1a2601b003b99cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller CMBSZ (Controller Memory Buffer Size) register.  <a href="nvme_8h.html#a260b335960b9d81ac1a2601b003b99cd">More...</a><br /></td></tr>
<tr class="separator:a260b335960b9d81ac1a2601b003b99cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae98a4e77ad7bf29414a10966597416c"><td class="memItemLeft" align="right" valign="top">union <a class="el" href="unionspdk__nvme__pmrcap__register.html">spdk_nvme_pmrcap_register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aae98a4e77ad7bf29414a10966597416c">spdk_nvme_ctrlr_get_regs_pmrcap</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:aae98a4e77ad7bf29414a10966597416c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller PMRCAP (Persistent Memory Region Capabilities) register.  <a href="nvme_8h.html#aae98a4e77ad7bf29414a10966597416c">More...</a><br /></td></tr>
<tr class="separator:aae98a4e77ad7bf29414a10966597416c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f87fef46a6101cc2e9b594d448cb37"><td class="memItemLeft" align="right" valign="top">union <a class="el" href="unionspdk__nvme__bpinfo__register.html">spdk_nvme_bpinfo_register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad9f87fef46a6101cc2e9b594d448cb37">spdk_nvme_ctrlr_get_regs_bpinfo</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:ad9f87fef46a6101cc2e9b594d448cb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller BPINFO (Boot Partition Information) register.  <a href="nvme_8h.html#ad9f87fef46a6101cc2e9b594d448cb37">More...</a><br /></td></tr>
<tr class="separator:ad9f87fef46a6101cc2e9b594d448cb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7642f1fc6eec21b93b5f60e386e3e36c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7642f1fc6eec21b93b5f60e386e3e36c">spdk_nvme_ctrlr_get_pmrsz</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a7642f1fc6eec21b93b5f60e386e3e36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller PMR size.  <a href="nvme_8h.html#a7642f1fc6eec21b93b5f60e386e3e36c">More...</a><br /></td></tr>
<tr class="separator:a7642f1fc6eec21b93b5f60e386e3e36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b18deae44682a51177e8a4193af602"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a02b18deae44682a51177e8a4193af602">spdk_nvme_ctrlr_get_num_ns</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a02b18deae44682a51177e8a4193af602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum NSID value that will ever be used for the given controller.  <a href="nvme_8h.html#a02b18deae44682a51177e8a4193af602">More...</a><br /></td></tr>
<tr class="separator:a02b18deae44682a51177e8a4193af602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d8173db83accb35f0c5fe1ec8261bf"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a60d8173db83accb35f0c5fe1ec8261bf">spdk_nvme_ctrlr_get_pci_device</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a60d8173db83accb35f0c5fe1ec8261bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the PCI device of a given NVMe controller.  <a href="nvme_8h.html#a60d8173db83accb35f0c5fe1ec8261bf">More...</a><br /></td></tr>
<tr class="separator:a60d8173db83accb35f0c5fe1ec8261bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac750410c9b53a0435d0111ae1e98913e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac750410c9b53a0435d0111ae1e98913e">spdk_nvme_ctrlr_get_max_xfer_size</a> (const struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:ac750410c9b53a0435d0111ae1e98913e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum data transfer size of a given NVMe controller.  <a href="nvme_8h.html#ac750410c9b53a0435d0111ae1e98913e">More...</a><br /></td></tr>
<tr class="separator:ac750410c9b53a0435d0111ae1e98913e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcdb6e7c22b0ef87ed927bf97952c19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#abbcdb6e7c22b0ef87ed927bf97952c19">spdk_nvme_ctrlr_is_active_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid)</td></tr>
<tr class="memdesc:abbcdb6e7c22b0ef87ed927bf97952c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the nsid is an active nv for the given NVMe controller.  <a href="nvme_8h.html#abbcdb6e7c22b0ef87ed927bf97952c19">More...</a><br /></td></tr>
<tr class="separator:abbcdb6e7c22b0ef87ed927bf97952c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e69f39c7cb8a9e1c3e00af7804c8bd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a59e69f39c7cb8a9e1c3e00af7804c8bd">spdk_nvme_ctrlr_get_first_active_ns</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a59e69f39c7cb8a9e1c3e00af7804c8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nsid of the first active namespace.  <a href="nvme_8h.html#a59e69f39c7cb8a9e1c3e00af7804c8bd">More...</a><br /></td></tr>
<tr class="separator:a59e69f39c7cb8a9e1c3e00af7804c8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd528b0df0a564c218dc2745c3af159"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#abcd528b0df0a564c218dc2745c3af159">spdk_nvme_ctrlr_get_next_active_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t prev_nsid)</td></tr>
<tr class="memdesc:abcd528b0df0a564c218dc2745c3af159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next active namespace given the previous nsid.  <a href="nvme_8h.html#abcd528b0df0a564c218dc2745c3af159">More...</a><br /></td></tr>
<tr class="separator:abcd528b0df0a564c218dc2745c3af159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc6bb842e168a68972ec46cc35591ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7dc6bb842e168a68972ec46cc35591ae">spdk_nvme_ctrlr_is_log_page_supported</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t log_page)</td></tr>
<tr class="memdesc:a7dc6bb842e168a68972ec46cc35591ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a particular log page is supported by the given NVMe controller.  <a href="nvme_8h.html#a7dc6bb842e168a68972ec46cc35591ae">More...</a><br /></td></tr>
<tr class="separator:a7dc6bb842e168a68972ec46cc35591ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909b61e141b56eaa5895482aa1f18a3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a909b61e141b56eaa5895482aa1f18a3b">spdk_nvme_ctrlr_is_feature_supported</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t feature_code)</td></tr>
<tr class="memdesc:a909b61e141b56eaa5895482aa1f18a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a particular feature is supported by the given NVMe controller.  <a href="nvme_8h.html#a909b61e141b56eaa5895482aa1f18a3b">More...</a><br /></td></tr>
<tr class="separator:a909b61e141b56eaa5895482aa1f18a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1505fc1ef6e8ccb00134c1fa15e0368b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a1505fc1ef6e8ccb00134c1fa15e0368b">spdk_nvme_ctrlr_register_aer_callback</a> (struct spdk_nvme_ctrlr *ctrlr, <a class="el" href="nvme_8h.html#a1d066bb761dc3481f081d0d6924766ee">spdk_nvme_aer_cb</a> aer_cb_fn, void *aer_cb_arg)</td></tr>
<tr class="memdesc:a1505fc1ef6e8ccb00134c1fa15e0368b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register callback function invoked when an AER command is completed for the given NVMe controller.  <a href="nvme_8h.html#a1505fc1ef6e8ccb00134c1fa15e0368b">More...</a><br /></td></tr>
<tr class="separator:a1505fc1ef6e8ccb00134c1fa15e0368b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7708f291658bf471e399354d1247fabf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7708f291658bf471e399354d1247fabf">spdk_nvme_ctrlr_disable_read_changed_ns_list_log_page</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a7708f291658bf471e399354d1247fabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable reading the CHANGED_NS_LIST log page for the specified controller.  <a href="nvme_8h.html#a7708f291658bf471e399354d1247fabf">More...</a><br /></td></tr>
<tr class="separator:a7708f291658bf471e399354d1247fabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2957853179526e6176cf7623b19552b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae2957853179526e6176cf7623b19552b">spdk_nvme_ctrlr_register_timeout_callback</a> (struct spdk_nvme_ctrlr *ctrlr, uint64_t timeout_io_us, uint64_t timeout_admin_us, <a class="el" href="nvme_8h.html#a53fe1c01a447be8fcd29821a668227a0">spdk_nvme_timeout_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ae2957853179526e6176cf7623b19552b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register for timeout callback on a controller.  <a href="nvme_8h.html#ae2957853179526e6176cf7623b19552b">More...</a><br /></td></tr>
<tr class="separator:ae2957853179526e6176cf7623b19552b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a228bf5b96e89305e52721d81920d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a87a228bf5b96e89305e52721d81920d7">spdk_nvme_ctrlr_get_discovery_log_page</a> (struct spdk_nvme_ctrlr *ctrlr, <a class="el" href="nvme_8h.html#a4e4bc7c0002363701bc9363ab2291e6e">spdk_nvme_discovery_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a87a228bf5b96e89305e52721d81920d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a full discovery log page from the specified controller.  <a href="nvme_8h.html#a87a228bf5b96e89305e52721d81920d7">More...</a><br /></td></tr>
<tr class="separator:a87a228bf5b96e89305e52721d81920d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba57917b55ff781230c632b6a19897be"><td class="memItemLeft" align="right" valign="top"><a id="aba57917b55ff781230c632b6a19897be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__io__qpair__opts.html">spdk_nvme_io_qpair_opts</a>)==72, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:aba57917b55ff781230c632b6a19897be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6964d09dc51882fae6f2a7cf94afc741"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6964d09dc51882fae6f2a7cf94afc741">spdk_nvme_ctrlr_get_default_io_qpair_opts</a> (struct spdk_nvme_ctrlr *ctrlr, struct <a class="el" href="structspdk__nvme__io__qpair__opts.html">spdk_nvme_io_qpair_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:a6964d09dc51882fae6f2a7cf94afc741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default options for I/O qpair creation for a specific NVMe controller.  <a href="nvme_8h.html#a6964d09dc51882fae6f2a7cf94afc741">More...</a><br /></td></tr>
<tr class="separator:a6964d09dc51882fae6f2a7cf94afc741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f745d239dab9b8f934fae2ad4984a2"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_qpair *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2">spdk_nvme_ctrlr_alloc_io_qpair</a> (struct spdk_nvme_ctrlr *ctrlr, const struct <a class="el" href="structspdk__nvme__io__qpair__opts.html">spdk_nvme_io_qpair_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:a13f745d239dab9b8f934fae2ad4984a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an I/O queue pair (submission and completion queue).  <a href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2">More...</a><br /></td></tr>
<tr class="separator:a13f745d239dab9b8f934fae2ad4984a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0ade8aa72185765104da188581da49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a5c0ade8aa72185765104da188581da49">spdk_nvme_ctrlr_connect_io_qpair</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair)</td></tr>
<tr class="memdesc:a5c0ade8aa72185765104da188581da49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect a newly created I/O qpair.  <a href="nvme_8h.html#a5c0ade8aa72185765104da188581da49">More...</a><br /></td></tr>
<tr class="separator:a5c0ade8aa72185765104da188581da49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba2d2f9571a62a47e04ef16e65f9e7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a2ba2d2f9571a62a47e04ef16e65f9e7b">spdk_nvme_ctrlr_disconnect_io_qpair</a> (struct spdk_nvme_qpair *qpair)</td></tr>
<tr class="memdesc:a2ba2d2f9571a62a47e04ef16e65f9e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the given I/O qpair.  <a href="nvme_8h.html#a2ba2d2f9571a62a47e04ef16e65f9e7b">More...</a><br /></td></tr>
<tr class="separator:a2ba2d2f9571a62a47e04ef16e65f9e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e04d50b1f27f6cd163a4ea2024a6fbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a1e04d50b1f27f6cd163a4ea2024a6fbb">spdk_nvme_ctrlr_reconnect_io_qpair</a> (struct spdk_nvme_qpair *qpair)</td></tr>
<tr class="memdesc:a1e04d50b1f27f6cd163a4ea2024a6fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to reconnect the given qpair.  <a href="nvme_8h.html#a1e04d50b1f27f6cd163a4ea2024a6fbb">More...</a><br /></td></tr>
<tr class="separator:a1e04d50b1f27f6cd163a4ea2024a6fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c11b5ae0a1f6d70f3ab99a13765ea75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvme_8h.html#ab41e2d311eb6663957cd2f18bc8fb890">spdk_nvme_qp_failure_reason</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a4c11b5ae0a1f6d70f3ab99a13765ea75">spdk_nvme_ctrlr_get_admin_qp_failure_reason</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a4c11b5ae0a1f6d70f3ab99a13765ea75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reason the admin qpair for a given controller is disconnected.  <a href="nvme_8h.html#a4c11b5ae0a1f6d70f3ab99a13765ea75">More...</a><br /></td></tr>
<tr class="separator:a4c11b5ae0a1f6d70f3ab99a13765ea75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ec189f50d0f78d73a54413370401f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a85ec189f50d0f78d73a54413370401f5">spdk_nvme_ctrlr_free_io_qpair</a> (struct spdk_nvme_qpair *qpair)</td></tr>
<tr class="memdesc:a85ec189f50d0f78d73a54413370401f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an I/O queue pair that was allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>.  <a href="nvme_8h.html#a85ec189f50d0f78d73a54413370401f5">More...</a><br /></td></tr>
<tr class="separator:a85ec189f50d0f78d73a54413370401f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c00b191b38472b57b06f3f394353ad3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a8c00b191b38472b57b06f3f394353ad3">spdk_nvme_ctrlr_io_cmd_raw_no_payload_build</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a8c00b191b38472b57b06f3f394353ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the given NVM I/O command, I/O buffers, lists and all to the NVMe controller.  <a href="nvme_8h.html#a8c00b191b38472b57b06f3f394353ad3">More...</a><br /></td></tr>
<tr class="separator:a8c00b191b38472b57b06f3f394353ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3def668122e76abbfb74305f118291"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a1e3def668122e76abbfb74305f118291">spdk_nvme_ctrlr_cmd_io_raw</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, uint32_t len, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a1e3def668122e76abbfb74305f118291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the given NVM I/O command to the NVMe controller.  <a href="nvme_8h.html#a1e3def668122e76abbfb74305f118291">More...</a><br /></td></tr>
<tr class="separator:a1e3def668122e76abbfb74305f118291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2d8453bb2478c7b1a70c0a09c7ef4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#afd2d8453bb2478c7b1a70c0a09c7ef4b">spdk_nvme_ctrlr_cmd_io_raw_with_md</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, uint32_t len, void *md_buf, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:afd2d8453bb2478c7b1a70c0a09c7ef4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the given NVM I/O command with metadata to the NVMe controller.  <a href="nvme_8h.html#afd2d8453bb2478c7b1a70c0a09c7ef4b">More...</a><br /></td></tr>
<tr class="separator:afd2d8453bb2478c7b1a70c0a09c7ef4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa331d140870e977722bfbb6826524782"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa331d140870e977722bfbb6826524782">spdk_nvme_qpair_process_completions</a> (struct spdk_nvme_qpair *qpair, uint32_t max_completions)</td></tr>
<tr class="memdesc:aa331d140870e977722bfbb6826524782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process any outstanding completions for I/O submitted on a queue pair.  <a href="nvme_8h.html#aa331d140870e977722bfbb6826524782">More...</a><br /></td></tr>
<tr class="separator:aa331d140870e977722bfbb6826524782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2015f3c7dd76113e89a732eabe400ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="nvme_8h.html#ab41e2d311eb6663957cd2f18bc8fb890">spdk_nvme_qp_failure_reason</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae2015f3c7dd76113e89a732eabe400ff">spdk_nvme_qpair_get_failure_reason</a> (struct spdk_nvme_qpair *qpair)</td></tr>
<tr class="memdesc:ae2015f3c7dd76113e89a732eabe400ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reason the qpair is disconnected.  <a href="nvme_8h.html#ae2015f3c7dd76113e89a732eabe400ff">More...</a><br /></td></tr>
<tr class="separator:ae2015f3c7dd76113e89a732eabe400ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0538f261b89d0cdb455638dba52ea4b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a0538f261b89d0cdb455638dba52ea4b8">spdk_nvme_qpair_set_abort_dnr</a> (struct spdk_nvme_qpair *qpair, bool dnr)</td></tr>
<tr class="memdesc:a0538f261b89d0cdb455638dba52ea4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control if DNR is set or not for aborted commands.  <a href="nvme_8h.html#a0538f261b89d0cdb455638dba52ea4b8">More...</a><br /></td></tr>
<tr class="separator:a0538f261b89d0cdb455638dba52ea4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2a9d3b715649b4d0a0e89196a13e6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#afe2a9d3b715649b4d0a0e89196a13e6d">spdk_nvme_ctrlr_cmd_admin_raw</a> (struct spdk_nvme_ctrlr *ctrlr, struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, uint32_t len, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:afe2a9d3b715649b4d0a0e89196a13e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the given admin command to the NVMe controller.  <a href="nvme_8h.html#afe2a9d3b715649b4d0a0e89196a13e6d">More...</a><br /></td></tr>
<tr class="separator:afe2a9d3b715649b4d0a0e89196a13e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10282695461985f58f54de022911745e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a10282695461985f58f54de022911745e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process any outstanding completions for admin commands.  <a href="nvme_8h.html#a10282695461985f58f54de022911745e">More...</a><br /></td></tr>
<tr class="separator:a10282695461985f58f54de022911745e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f01fb8a5f404e41e6fa224a7942be08"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_ns *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6f01fb8a5f404e41e6fa224a7942be08">spdk_nvme_ctrlr_get_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t ns_id)</td></tr>
<tr class="memdesc:a6f01fb8a5f404e41e6fa224a7942be08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to a namespace for the given controller.  <a href="nvme_8h.html#a6f01fb8a5f404e41e6fa224a7942be08">More...</a><br /></td></tr>
<tr class="separator:a6f01fb8a5f404e41e6fa224a7942be08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c881cccf7873bbe4605320ffb0a81c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a88c881cccf7873bbe4605320ffb0a81c">spdk_nvme_ctrlr_cmd_get_log_page</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t log_page, uint32_t nsid, void *payload, uint32_t payload_size, uint64_t offset, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a88c881cccf7873bbe4605320ffb0a81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific log page from the NVMe controller.  <a href="nvme_8h.html#a88c881cccf7873bbe4605320ffb0a81c">More...</a><br /></td></tr>
<tr class="separator:a88c881cccf7873bbe4605320ffb0a81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffdfb142fa1db573a8c8515113f726c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#acffdfb142fa1db573a8c8515113f726c">spdk_nvme_ctrlr_cmd_get_log_page_ext</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t log_page, uint32_t nsid, void *payload, uint32_t payload_size, uint64_t offset, uint32_t cdw10, uint32_t cdw11, uint32_t cdw14, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:acffdfb142fa1db573a8c8515113f726c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific log page from the NVMe controller.  <a href="nvme_8h.html#acffdfb142fa1db573a8c8515113f726c">More...</a><br /></td></tr>
<tr class="separator:acffdfb142fa1db573a8c8515113f726c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724ed20a1a5adaf30c48db8c28d29677"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a724ed20a1a5adaf30c48db8c28d29677">spdk_nvme_ctrlr_cmd_abort</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, uint16_t cid, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a724ed20a1a5adaf30c48db8c28d29677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort a specific previously-submitted NVMe command.  <a href="nvme_8h.html#a724ed20a1a5adaf30c48db8c28d29677">More...</a><br /></td></tr>
<tr class="separator:a724ed20a1a5adaf30c48db8c28d29677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02bff8a2cebfc7eb69e5cf23cd36afd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa02bff8a2cebfc7eb69e5cf23cd36afd">spdk_nvme_ctrlr_cmd_abort_ext</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, void *cmd_cb_arg, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aa02bff8a2cebfc7eb69e5cf23cd36afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort previously submitted commands which have cmd_cb_arg as its callback argument.  <a href="nvme_8h.html#aa02bff8a2cebfc7eb69e5cf23cd36afd">More...</a><br /></td></tr>
<tr class="separator:aa02bff8a2cebfc7eb69e5cf23cd36afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9507cb98ee30e5df98474bc82190476"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa9507cb98ee30e5df98474bc82190476">spdk_nvme_ctrlr_cmd_set_feature</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t feature, uint32_t cdw11, uint32_t cdw12, void *payload, uint32_t payload_size, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aa9507cb98ee30e5df98474bc82190476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set specific feature for the given NVMe controller.  <a href="nvme_8h.html#aa9507cb98ee30e5df98474bc82190476">More...</a><br /></td></tr>
<tr class="separator:aa9507cb98ee30e5df98474bc82190476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4ebba22f1585b98e4ca20932d75434"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6b4ebba22f1585b98e4ca20932d75434">spdk_nvme_ctrlr_cmd_get_feature</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t feature, uint32_t cdw11, void *payload, uint32_t payload_size, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a6b4ebba22f1585b98e4ca20932d75434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get specific feature from given NVMe controller.  <a href="nvme_8h.html#a6b4ebba22f1585b98e4ca20932d75434">More...</a><br /></td></tr>
<tr class="separator:a6b4ebba22f1585b98e4ca20932d75434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0f038c06c49df0e75148faf6cc4b51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#abc0f038c06c49df0e75148faf6cc4b51">spdk_nvme_ctrlr_cmd_get_feature_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t feature, uint32_t cdw11, void *payload, uint32_t payload_size, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t ns_id)</td></tr>
<tr class="memdesc:abc0f038c06c49df0e75148faf6cc4b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get specific feature from given NVMe controller.  <a href="nvme_8h.html#abc0f038c06c49df0e75148faf6cc4b51">More...</a><br /></td></tr>
<tr class="separator:abc0f038c06c49df0e75148faf6cc4b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fda1acce45c71590ed0db99220d26b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a63fda1acce45c71590ed0db99220d26b">spdk_nvme_ctrlr_cmd_set_feature_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t feature, uint32_t cdw11, uint32_t cdw12, void *payload, uint32_t payload_size, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t ns_id)</td></tr>
<tr class="memdesc:a63fda1acce45c71590ed0db99220d26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set specific feature for the given NVMe controller and namespace ID.  <a href="nvme_8h.html#a63fda1acce45c71590ed0db99220d26b">More...</a><br /></td></tr>
<tr class="separator:a63fda1acce45c71590ed0db99220d26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bcc2decc2d4ce01b041601c5cdecea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae7bcc2decc2d4ce01b041601c5cdecea">spdk_nvme_ctrlr_cmd_security_receive</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t secp, uint16_t spsp, uint8_t nssf, void *payload, uint32_t payload_size, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ae7bcc2decc2d4ce01b041601c5cdecea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive security protocol data from controller.  <a href="nvme_8h.html#ae7bcc2decc2d4ce01b041601c5cdecea">More...</a><br /></td></tr>
<tr class="separator:ae7bcc2decc2d4ce01b041601c5cdecea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7a6bb3ac85f99f936290f679399039"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a0e7a6bb3ac85f99f936290f679399039">spdk_nvme_ctrlr_cmd_security_send</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t secp, uint16_t spsp, uint8_t nssf, void *payload, uint32_t payload_size, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a0e7a6bb3ac85f99f936290f679399039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send security protocol data to controller.  <a href="nvme_8h.html#a0e7a6bb3ac85f99f936290f679399039">More...</a><br /></td></tr>
<tr class="separator:a0e7a6bb3ac85f99f936290f679399039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5175d6805225d84d6e4aa4e0f1546c69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a5175d6805225d84d6e4aa4e0f1546c69">spdk_nvme_ctrlr_security_receive</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t secp, uint16_t spsp, uint8_t nssf, void *payload, size_t size)</td></tr>
<tr class="memdesc:a5175d6805225d84d6e4aa4e0f1546c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive security protocol data from controller.  <a href="nvme_8h.html#a5175d6805225d84d6e4aa4e0f1546c69">More...</a><br /></td></tr>
<tr class="separator:a5175d6805225d84d6e4aa4e0f1546c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4ab089f73f3f43e9c5b8e6415e6f50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ada4ab089f73f3f43e9c5b8e6415e6f50">spdk_nvme_ctrlr_security_send</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t secp, uint16_t spsp, uint8_t nssf, void *payload, size_t size)</td></tr>
<tr class="memdesc:ada4ab089f73f3f43e9c5b8e6415e6f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send security protocol data to controller.  <a href="nvme_8h.html#ada4ab089f73f3f43e9c5b8e6415e6f50">More...</a><br /></td></tr>
<tr class="separator:ada4ab089f73f3f43e9c5b8e6415e6f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7094727eb390b36b56817b83d39d998"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab7094727eb390b36b56817b83d39d998">spdk_nvme_ctrlr_cmd_directive_receive</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, uint32_t doper, uint32_t dtype, uint32_t dspec, void *payload, uint32_t payload_size, uint32_t cdw12, uint32_t cdw13, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ab7094727eb390b36b56817b83d39d998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data related to a specific Directive Type from the controller.  <a href="nvme_8h.html#ab7094727eb390b36b56817b83d39d998">More...</a><br /></td></tr>
<tr class="separator:ab7094727eb390b36b56817b83d39d998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6d60e18019d520ac51ec2a5a598c48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ada6d60e18019d520ac51ec2a5a598c48">spdk_nvme_ctrlr_cmd_directive_send</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, uint32_t doper, uint32_t dtype, uint32_t dspec, void *payload, uint32_t payload_size, uint32_t cdw12, uint32_t cdw13, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ada6d60e18019d520ac51ec2a5a598c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data related to a specific Directive Type to the controller.  <a href="nvme_8h.html#ada6d60e18019d520ac51ec2a5a598c48">More...</a><br /></td></tr>
<tr class="separator:ada6d60e18019d520ac51ec2a5a598c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af654a7a016511f265b29294fd06ce26e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#af654a7a016511f265b29294fd06ce26e">spdk_nvme_ctrlr_get_flags</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:af654a7a016511f265b29294fd06ce26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get supported flags of the controller.  <a href="nvme_8h.html#af654a7a016511f265b29294fd06ce26e">More...</a><br /></td></tr>
<tr class="separator:af654a7a016511f265b29294fd06ce26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae935583b7f95b13fbd2dd41255490da0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae935583b7f95b13fbd2dd41255490da0">spdk_nvme_ctrlr_attach_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, struct <a class="el" href="structspdk__nvme__ctrlr__list.html">spdk_nvme_ctrlr_list</a> *payload)</td></tr>
<tr class="memdesc:ae935583b7f95b13fbd2dd41255490da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach the specified namespace to controllers.  <a href="nvme_8h.html#ae935583b7f95b13fbd2dd41255490da0">More...</a><br /></td></tr>
<tr class="separator:ae935583b7f95b13fbd2dd41255490da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab562f58b5903071929d6a559fe984d0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab562f58b5903071929d6a559fe984d0a">spdk_nvme_ctrlr_detach_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, struct <a class="el" href="structspdk__nvme__ctrlr__list.html">spdk_nvme_ctrlr_list</a> *payload)</td></tr>
<tr class="memdesc:ab562f58b5903071929d6a559fe984d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach the specified namespace from controllers.  <a href="nvme_8h.html#ab562f58b5903071929d6a559fe984d0a">More...</a><br /></td></tr>
<tr class="separator:ab562f58b5903071929d6a559fe984d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace23485fea91d126a13fe706ce6d8843"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ace23485fea91d126a13fe706ce6d8843">spdk_nvme_ctrlr_create_ns</a> (struct spdk_nvme_ctrlr *ctrlr, struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a> *payload)</td></tr>
<tr class="memdesc:ace23485fea91d126a13fe706ce6d8843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a namespace.  <a href="nvme_8h.html#ace23485fea91d126a13fe706ce6d8843">More...</a><br /></td></tr>
<tr class="separator:ace23485fea91d126a13fe706ce6d8843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c62e2d4555a5ebc3a3b6f9632c51e1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7c62e2d4555a5ebc3a3b6f9632c51e1a">spdk_nvme_ctrlr_delete_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid)</td></tr>
<tr class="memdesc:a7c62e2d4555a5ebc3a3b6f9632c51e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a namespace.  <a href="nvme_8h.html#a7c62e2d4555a5ebc3a3b6f9632c51e1a">More...</a><br /></td></tr>
<tr class="separator:a7c62e2d4555a5ebc3a3b6f9632c51e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb6973133e1fd5e7a1522ab104ac92b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a9bb6973133e1fd5e7a1522ab104ac92b">spdk_nvme_ctrlr_format</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, struct <a class="el" href="structspdk__nvme__format.html">spdk_nvme_format</a> *format)</td></tr>
<tr class="memdesc:a9bb6973133e1fd5e7a1522ab104ac92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format NVM.  <a href="nvme_8h.html#a9bb6973133e1fd5e7a1522ab104ac92b">More...</a><br /></td></tr>
<tr class="separator:a9bb6973133e1fd5e7a1522ab104ac92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7938b258a7614073065be4f6a35bd0e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7938b258a7614073065be4f6a35bd0e2">spdk_nvme_ctrlr_update_firmware</a> (struct spdk_nvme_ctrlr *ctrlr, void *payload, uint32_t size, int slot, enum <a class="el" href="nvme__spec_8h.html#ae4da1c1bec22eb22d1af72bbf37af36e">spdk_nvme_fw_commit_action</a> commit_action, struct <a class="el" href="structspdk__nvme__status.html">spdk_nvme_status</a> *completion_status)</td></tr>
<tr class="memdesc:a7938b258a7614073065be4f6a35bd0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download a new firmware image.  <a href="nvme_8h.html#a7938b258a7614073065be4f6a35bd0e2">More...</a><br /></td></tr>
<tr class="separator:a7938b258a7614073065be4f6a35bd0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b6a2ec4fdc37279739c31bde8ff1f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa6b6a2ec4fdc37279739c31bde8ff1f7">spdk_nvme_ctrlr_read_boot_partition_start</a> (struct spdk_nvme_ctrlr *ctrlr, void *payload, uint32_t bprsz, uint32_t bprof, uint32_t bpid)</td></tr>
<tr class="memdesc:aa6b6a2ec4fdc37279739c31bde8ff1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the Read from a Boot Partition.  <a href="nvme_8h.html#aa6b6a2ec4fdc37279739c31bde8ff1f7">More...</a><br /></td></tr>
<tr class="separator:aa6b6a2ec4fdc37279739c31bde8ff1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9439b3f5985d8597ea9c8a41b92edb9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a9439b3f5985d8597ea9c8a41b92edb9f">spdk_nvme_ctrlr_read_boot_partition_poll</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a9439b3f5985d8597ea9c8a41b92edb9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll the status of the Read from a Boot Partition.  <a href="nvme_8h.html#a9439b3f5985d8597ea9c8a41b92edb9f">More...</a><br /></td></tr>
<tr class="separator:a9439b3f5985d8597ea9c8a41b92edb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5da9877e5b3a256478f6dc698fbb0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a3e5da9877e5b3a256478f6dc698fbb0c">spdk_nvme_ctrlr_write_boot_partition</a> (struct spdk_nvme_ctrlr *ctrlr, void *payload, uint32_t size, uint32_t bpid, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a3e5da9877e5b3a256478f6dc698fbb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a Boot Partition.  <a href="nvme_8h.html#a3e5da9877e5b3a256478f6dc698fbb0c">More...</a><br /></td></tr>
<tr class="separator:a3e5da9877e5b3a256478f6dc698fbb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887db5ce5c84eba37a4d82f5d180d020"><td class="memItemLeft" align="right" valign="top">volatile struct <a class="el" href="structspdk__nvme__registers.html">spdk_nvme_registers</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a887db5ce5c84eba37a4d82f5d180d020">spdk_nvme_ctrlr_get_registers</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a887db5ce5c84eba37a4d82f5d180d020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return virtual address of PCIe NVM I/O registers.  <a href="nvme_8h.html#a887db5ce5c84eba37a4d82f5d180d020">More...</a><br /></td></tr>
<tr class="separator:a887db5ce5c84eba37a4d82f5d180d020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3ac9bb888c2b660191f94d208caaf1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7a3ac9bb888c2b660191f94d208caaf1">spdk_nvme_ctrlr_reserve_cmb</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a7a3ac9bb888c2b660191f94d208caaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve the controller memory buffer for data transfer use.  <a href="nvme_8h.html#a7a3ac9bb888c2b660191f94d208caaf1">More...</a><br /></td></tr>
<tr class="separator:a7a3ac9bb888c2b660191f94d208caaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fcdfd45c5b8a6a6ac4b99fff9c66b1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae4fcdfd45c5b8a6a6ac4b99fff9c66b1">spdk_nvme_ctrlr_map_cmb</a> (struct spdk_nvme_ctrlr *ctrlr, size_t *size)</td></tr>
<tr class="memdesc:ae4fcdfd45c5b8a6a6ac4b99fff9c66b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a previously reserved controller memory buffer so that it's data is visible from the CPU.  <a href="nvme_8h.html#ae4fcdfd45c5b8a6a6ac4b99fff9c66b1">More...</a><br /></td></tr>
<tr class="separator:ae4fcdfd45c5b8a6a6ac4b99fff9c66b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645844b863c5c40a0f3eb0c72d80e0ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a645844b863c5c40a0f3eb0c72d80e0ff">spdk_nvme_ctrlr_unmap_cmb</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a645844b863c5c40a0f3eb0c72d80e0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a controller memory I/O buffer.  <a href="nvme_8h.html#a645844b863c5c40a0f3eb0c72d80e0ff">More...</a><br /></td></tr>
<tr class="separator:a645844b863c5c40a0f3eb0c72d80e0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006a6050d45feefadbf0ce978ca009de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a006a6050d45feefadbf0ce978ca009de">spdk_nvme_ctrlr_enable_pmr</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a006a6050d45feefadbf0ce978ca009de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the Persistent Memory Region.  <a href="nvme_8h.html#a006a6050d45feefadbf0ce978ca009de">More...</a><br /></td></tr>
<tr class="separator:a006a6050d45feefadbf0ce978ca009de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a3c1f4f6b5595426fb9bd8974a85fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#af8a3c1f4f6b5595426fb9bd8974a85fe">spdk_nvme_ctrlr_disable_pmr</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:af8a3c1f4f6b5595426fb9bd8974a85fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the Persistent Memory Region.  <a href="nvme_8h.html#af8a3c1f4f6b5595426fb9bd8974a85fe">More...</a><br /></td></tr>
<tr class="separator:af8a3c1f4f6b5595426fb9bd8974a85fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f53b3be86d9561f0dfbc87ee827821"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a85f53b3be86d9561f0dfbc87ee827821">spdk_nvme_ctrlr_map_pmr</a> (struct spdk_nvme_ctrlr *ctrlr, size_t *size)</td></tr>
<tr class="memdesc:a85f53b3be86d9561f0dfbc87ee827821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the Persistent Memory Region so that it's data is visible from the CPU.  <a href="nvme_8h.html#a85f53b3be86d9561f0dfbc87ee827821">More...</a><br /></td></tr>
<tr class="separator:a85f53b3be86d9561f0dfbc87ee827821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bd04caa1e443e7709540e0dac7d4ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a07bd04caa1e443e7709540e0dac7d4ee">spdk_nvme_ctrlr_unmap_pmr</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a07bd04caa1e443e7709540e0dac7d4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the Persistent Memory Region.  <a href="nvme_8h.html#a07bd04caa1e443e7709540e0dac7d4ee">More...</a><br /></td></tr>
<tr class="separator:a07bd04caa1e443e7709540e0dac7d4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7ae9abf97b7c6b57777d06eaa1258a"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#abb7ae9abf97b7c6b57777d06eaa1258a">spdk_nvme_ctrlr_get_transport_id</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:abb7ae9abf97b7c6b57777d06eaa1258a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transport ID for a given NVMe controller.  <a href="nvme_8h.html#abb7ae9abf97b7c6b57777d06eaa1258a">More...</a><br /></td></tr>
<tr class="separator:abb7ae9abf97b7c6b57777d06eaa1258a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8505b00dfaa6123d784c17c293cf3ffc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a8505b00dfaa6123d784c17c293cf3ffc">spdk_nvme_ctrlr_alloc_qid</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a8505b00dfaa6123d784c17c293cf3ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alloc NVMe I/O queue identifier.  <a href="nvme_8h.html#a8505b00dfaa6123d784c17c293cf3ffc">More...</a><br /></td></tr>
<tr class="separator:a8505b00dfaa6123d784c17c293cf3ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2054305f5c7453045eab833b1d4281"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a4c2054305f5c7453045eab833b1d4281">spdk_nvme_ctrlr_free_qid</a> (struct spdk_nvme_ctrlr *ctrlr, uint16_t qid)</td></tr>
<tr class="memdesc:a4c2054305f5c7453045eab833b1d4281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free NVMe I/O queue identifier.  <a href="nvme_8h.html#a4c2054305f5c7453045eab833b1d4281">More...</a><br /></td></tr>
<tr class="separator:a4c2054305f5c7453045eab833b1d4281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7c3d1cbb9ef2dbe39344ad65490f2d"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_poll_group *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#afb7c3d1cbb9ef2dbe39344ad65490f2d">spdk_nvme_poll_group_create</a> (void *ctx, struct <a class="el" href="structspdk__nvme__accel__fn__table.html">spdk_nvme_accel_fn_table</a> *table)</td></tr>
<tr class="memdesc:afb7c3d1cbb9ef2dbe39344ad65490f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new poll group.  <a href="nvme_8h.html#afb7c3d1cbb9ef2dbe39344ad65490f2d">More...</a><br /></td></tr>
<tr class="separator:afb7c3d1cbb9ef2dbe39344ad65490f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a891c5683c340e0426cd0268d29d689"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_poll_group *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a8a891c5683c340e0426cd0268d29d689">spdk_nvme_qpair_get_optimal_poll_group</a> (struct spdk_nvme_qpair *qpair)</td></tr>
<tr class="memdesc:a8a891c5683c340e0426cd0268d29d689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a optimal poll group.  <a href="nvme_8h.html#a8a891c5683c340e0426cd0268d29d689">More...</a><br /></td></tr>
<tr class="separator:a8a891c5683c340e0426cd0268d29d689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4eafe3d6b7b4a0a1c317a49b3ba1e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ade4eafe3d6b7b4a0a1c317a49b3ba1e5">spdk_nvme_poll_group_add</a> (struct spdk_nvme_poll_group *group, struct spdk_nvme_qpair *qpair)</td></tr>
<tr class="memdesc:ade4eafe3d6b7b4a0a1c317a49b3ba1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an spdk_nvme_qpair to a poll group.  <a href="nvme_8h.html#ade4eafe3d6b7b4a0a1c317a49b3ba1e5">More...</a><br /></td></tr>
<tr class="separator:ade4eafe3d6b7b4a0a1c317a49b3ba1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef925aeb99c7791bcec5c7305c03422"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a2ef925aeb99c7791bcec5c7305c03422">spdk_nvme_poll_group_remove</a> (struct spdk_nvme_poll_group *group, struct spdk_nvme_qpair *qpair)</td></tr>
<tr class="memdesc:a2ef925aeb99c7791bcec5c7305c03422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a disconnected spdk_nvme_qpair from a poll group.  <a href="nvme_8h.html#a2ef925aeb99c7791bcec5c7305c03422">More...</a><br /></td></tr>
<tr class="separator:a2ef925aeb99c7791bcec5c7305c03422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cea1ea33592903a9478d75f809ded6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac4cea1ea33592903a9478d75f809ded6">spdk_nvme_poll_group_destroy</a> (struct spdk_nvme_poll_group *group)</td></tr>
<tr class="memdesc:ac4cea1ea33592903a9478d75f809ded6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an empty poll group.  <a href="nvme_8h.html#ac4cea1ea33592903a9478d75f809ded6">More...</a><br /></td></tr>
<tr class="separator:ac4cea1ea33592903a9478d75f809ded6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89c07198e8be3384ee6a0adc8439621"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac89c07198e8be3384ee6a0adc8439621">spdk_nvme_poll_group_process_completions</a> (struct spdk_nvme_poll_group *group, uint32_t completions_per_qpair, <a class="el" href="nvme_8h.html#add892b5eaa7208ca3b08382431713390">spdk_nvme_disconnected_qpair_cb</a> disconnected_qpair_cb)</td></tr>
<tr class="memdesc:ac89c07198e8be3384ee6a0adc8439621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll for completions on all qpairs in this poll group.  <a href="nvme_8h.html#ac89c07198e8be3384ee6a0adc8439621">More...</a><br /></td></tr>
<tr class="separator:ac89c07198e8be3384ee6a0adc8439621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8083fac113bd027ff1f8c93fe704d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aba8083fac113bd027ff1f8c93fe704d6">spdk_nvme_poll_group_all_connected</a> (struct spdk_nvme_poll_group *group)</td></tr>
<tr class="memdesc:aba8083fac113bd027ff1f8c93fe704d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all qpairs in the poll group are connected.  <a href="nvme_8h.html#aba8083fac113bd027ff1f8c93fe704d6">More...</a><br /></td></tr>
<tr class="separator:aba8083fac113bd027ff1f8c93fe704d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a353011316a46ee6e6857f7286488d1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a2a353011316a46ee6e6857f7286488d1">spdk_nvme_poll_group_get_ctx</a> (struct spdk_nvme_poll_group *group)</td></tr>
<tr class="memdesc:a2a353011316a46ee6e6857f7286488d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the user context for this specific poll group.  <a href="nvme_8h.html#a2a353011316a46ee6e6857f7286488d1">More...</a><br /></td></tr>
<tr class="separator:a2a353011316a46ee6e6857f7286488d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18820817137a7fca589be8c08feedcc0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a18820817137a7fca589be8c08feedcc0">spdk_nvme_poll_group_get_stats</a> (struct spdk_nvme_poll_group *group, struct <a class="el" href="structspdk__nvme__poll__group__stat.html">spdk_nvme_poll_group_stat</a> **stats)</td></tr>
<tr class="memdesc:a18820817137a7fca589be8c08feedcc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves transport statistics for the given poll group.  <a href="nvme_8h.html#a18820817137a7fca589be8c08feedcc0">More...</a><br /></td></tr>
<tr class="separator:a18820817137a7fca589be8c08feedcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2448353b0d3024bb3b05d7b45eb8285"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae2448353b0d3024bb3b05d7b45eb8285">spdk_nvme_poll_group_free_stats</a> (struct spdk_nvme_poll_group *group, struct <a class="el" href="structspdk__nvme__poll__group__stat.html">spdk_nvme_poll_group_stat</a> *stat)</td></tr>
<tr class="memdesc:ae2448353b0d3024bb3b05d7b45eb8285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees poll group statistics retrieved using <b>spdk_nvme_poll_group_get_stats</b> function.  <a href="nvme_8h.html#ae2448353b0d3024bb3b05d7b45eb8285">More...</a><br /></td></tr>
<tr class="separator:ae2448353b0d3024bb3b05d7b45eb8285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1863b5dccf2bcc49fe92275bc1e5a2a"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab1863b5dccf2bcc49fe92275bc1e5a2a">spdk_nvme_ns_get_data</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:ab1863b5dccf2bcc49fe92275bc1e5a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the identify namespace data as defined by the NVMe specification.  <a href="nvme_8h.html#ab1863b5dccf2bcc49fe92275bc1e5a2a">More...</a><br /></td></tr>
<tr class="separator:ab1863b5dccf2bcc49fe92275bc1e5a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54052303ef2870d6d1856f79ef6ff88a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a54052303ef2870d6d1856f79ef6ff88a">spdk_nvme_ns_get_id</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a54052303ef2870d6d1856f79ef6ff88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the namespace id (index number) from the given namespace handle.  <a href="nvme_8h.html#a54052303ef2870d6d1856f79ef6ff88a">More...</a><br /></td></tr>
<tr class="separator:a54052303ef2870d6d1856f79ef6ff88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2640aeebb82108e9b507dcccb1e564c2"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_ctrlr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a2640aeebb82108e9b507dcccb1e564c2">spdk_nvme_ns_get_ctrlr</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a2640aeebb82108e9b507dcccb1e564c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the controller with which this namespace is associated.  <a href="nvme_8h.html#a2640aeebb82108e9b507dcccb1e564c2">More...</a><br /></td></tr>
<tr class="separator:a2640aeebb82108e9b507dcccb1e564c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af755eb3e5a5f767a5bdc544d85667898"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#af755eb3e5a5f767a5bdc544d85667898">spdk_nvme_ns_is_active</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:af755eb3e5a5f767a5bdc544d85667898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a namespace is active.  <a href="nvme_8h.html#af755eb3e5a5f767a5bdc544d85667898">More...</a><br /></td></tr>
<tr class="separator:af755eb3e5a5f767a5bdc544d85667898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aac85501f13bff557d3a224d8ec156"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac2aac85501f13bff557d3a224d8ec156">spdk_nvme_ns_get_max_io_xfer_size</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:ac2aac85501f13bff557d3a224d8ec156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum transfer size, in bytes, for an I/O sent to the given namespace.  <a href="nvme_8h.html#ac2aac85501f13bff557d3a224d8ec156">More...</a><br /></td></tr>
<tr class="separator:ac2aac85501f13bff557d3a224d8ec156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d24c0b2b0b2a22b0c0af2ca2e157e04"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a0d24c0b2b0b2a22b0c0af2ca2e157e04">spdk_nvme_ns_get_sector_size</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a0d24c0b2b0b2a22b0c0af2ca2e157e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sector size, in bytes, of the given namespace.  <a href="nvme_8h.html#a0d24c0b2b0b2a22b0c0af2ca2e157e04">More...</a><br /></td></tr>
<tr class="separator:a0d24c0b2b0b2a22b0c0af2ca2e157e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3f5c5a738dc7ad7e3b2913bff4324c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a8f3f5c5a738dc7ad7e3b2913bff4324c">spdk_nvme_ns_get_extended_sector_size</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a8f3f5c5a738dc7ad7e3b2913bff4324c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the extended sector size, in bytes, of the given namespace.  <a href="nvme_8h.html#a8f3f5c5a738dc7ad7e3b2913bff4324c">More...</a><br /></td></tr>
<tr class="separator:a8f3f5c5a738dc7ad7e3b2913bff4324c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c522609f730db26f66e7f5b6b3501e0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7c522609f730db26f66e7f5b6b3501e0">spdk_nvme_ns_get_num_sectors</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a7c522609f730db26f66e7f5b6b3501e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of sectors for the given namespace.  <a href="nvme_8h.html#a7c522609f730db26f66e7f5b6b3501e0">More...</a><br /></td></tr>
<tr class="separator:a7c522609f730db26f66e7f5b6b3501e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8fb1bbe066260faf305581e16dde86"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a9e8fb1bbe066260faf305581e16dde86">spdk_nvme_ns_get_size</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a9e8fb1bbe066260faf305581e16dde86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size, in bytes, of the given namespace.  <a href="nvme_8h.html#a9e8fb1bbe066260faf305581e16dde86">More...</a><br /></td></tr>
<tr class="separator:a9e8fb1bbe066260faf305581e16dde86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85806a7605a104a705e7f9d3d087e4cb"><td class="memItemLeft" align="right" valign="top">enum spdk_nvme_pi_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a85806a7605a104a705e7f9d3d087e4cb">spdk_nvme_ns_get_pi_type</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a85806a7605a104a705e7f9d3d087e4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end-to-end data protection information type of the given namespace.  <a href="nvme_8h.html#a85806a7605a104a705e7f9d3d087e4cb">More...</a><br /></td></tr>
<tr class="separator:a85806a7605a104a705e7f9d3d087e4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48657f8cb6561b35e1c1b0bc18376d2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2">spdk_nvme_ns_get_md_size</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:ab48657f8cb6561b35e1c1b0bc18376d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the metadata size, in bytes, of the given namespace.  <a href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2">More...</a><br /></td></tr>
<tr class="separator:ab48657f8cb6561b35e1c1b0bc18376d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95da4dc7b98bfeed010a4a7a899e0ac7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a95da4dc7b98bfeed010a4a7a899e0ac7">spdk_nvme_ns_get_format_index</a> (const struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a> *nsdata)</td></tr>
<tr class="memdesc:a95da4dc7b98bfeed010a4a7a899e0ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the format index of the given namespace.  <a href="nvme_8h.html#a95da4dc7b98bfeed010a4a7a899e0ac7">More...</a><br /></td></tr>
<tr class="separator:a95da4dc7b98bfeed010a4a7a899e0ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad367fec5a8963f5d930dfae485de6b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aad367fec5a8963f5d930dfae485de6b3">spdk_nvme_ns_supports_extended_lba</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:aad367fec5a8963f5d930dfae485de6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether if the namespace can support extended LBA when end-to-end data protection enabled.  <a href="nvme_8h.html#aad367fec5a8963f5d930dfae485de6b3">More...</a><br /></td></tr>
<tr class="separator:aad367fec5a8963f5d930dfae485de6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb2087b31ac4b4807a77b9b97d55b2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aacb2087b31ac4b4807a77b9b97d55b2c">spdk_nvme_ns_supports_compare</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:aacb2087b31ac4b4807a77b9b97d55b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether if the namespace supports compare operation.  <a href="nvme_8h.html#aacb2087b31ac4b4807a77b9b97d55b2c">More...</a><br /></td></tr>
<tr class="separator:aacb2087b31ac4b4807a77b9b97d55b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42040dca95489218417539d2c08d815e"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="nvme__spec_8h.html#a1c06fbd66f7572c43c51e6f106215b8d">spdk_nvme_dealloc_logical_block_read_value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a42040dca95489218417539d2c08d815e">spdk_nvme_ns_get_dealloc_logical_block_read_value</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a42040dca95489218417539d2c08d815e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the value returned when reading deallocated blocks.  <a href="nvme_8h.html#a42040dca95489218417539d2c08d815e">More...</a><br /></td></tr>
<tr class="separator:a42040dca95489218417539d2c08d815e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58edc3021f8adcbecce5d3ebc5b6789"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#af58edc3021f8adcbecce5d3ebc5b6789">spdk_nvme_ns_get_optimal_io_boundary</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:af58edc3021f8adcbecce5d3ebc5b6789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the optimal I/O boundary, in blocks, for the given namespace.  <a href="nvme_8h.html#af58edc3021f8adcbecce5d3ebc5b6789">More...</a><br /></td></tr>
<tr class="separator:af58edc3021f8adcbecce5d3ebc5b6789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c20210c6490d4545b40e43faa8af23"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a67c20210c6490d4545b40e43faa8af23">spdk_nvme_ns_get_nguid</a> (const struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a67c20210c6490d4545b40e43faa8af23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NGUID for the given namespace.  <a href="nvme_8h.html#a67c20210c6490d4545b40e43faa8af23">More...</a><br /></td></tr>
<tr class="separator:a67c20210c6490d4545b40e43faa8af23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c559063408299a4612fd2e62f97bc63"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__uuid.html">spdk_uuid</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6c559063408299a4612fd2e62f97bc63">spdk_nvme_ns_get_uuid</a> (const struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a6c559063408299a4612fd2e62f97bc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the UUID for the given namespace.  <a href="nvme_8h.html#a6c559063408299a4612fd2e62f97bc63">More...</a><br /></td></tr>
<tr class="separator:a6c559063408299a4612fd2e62f97bc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8740d083341479c3c22861f16582795c"><td class="memItemLeft" align="right" valign="top">enum spdk_nvme_csi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a8740d083341479c3c22861f16582795c">spdk_nvme_ns_get_csi</a> (const struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a8740d083341479c3c22861f16582795c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Command Set Identifier for the given namespace.  <a href="nvme_8h.html#a8740d083341479c3c22861f16582795c">More...</a><br /></td></tr>
<tr class="separator:a8740d083341479c3c22861f16582795c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eff1c1b6fbfb348a1f158b3cf70626f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a5eff1c1b6fbfb348a1f158b3cf70626f">spdk_nvme_ns_get_flags</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a5eff1c1b6fbfb348a1f158b3cf70626f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flags for the given namespace.  <a href="nvme_8h.html#a5eff1c1b6fbfb348a1f158b3cf70626f">More...</a><br /></td></tr>
<tr class="separator:a5eff1c1b6fbfb348a1f158b3cf70626f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2886938b54c456dfb12861305bed24"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aae2886938b54c456dfb12861305bed24">spdk_nvme_ns_get_ana_group_id</a> (const struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:aae2886938b54c456dfb12861305bed24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ANA group ID for the given namespace.  <a href="nvme_8h.html#aae2886938b54c456dfb12861305bed24">More...</a><br /></td></tr>
<tr class="separator:aae2886938b54c456dfb12861305bed24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204d7f2669bc34a9d45ec28d3a661b21"><td class="memItemLeft" align="right" valign="top">enum spdk_nvme_ana_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a204d7f2669bc34a9d45ec28d3a661b21">spdk_nvme_ns_get_ana_state</a> (const struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a204d7f2669bc34a9d45ec28d3a661b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ANA state for the given namespace.  <a href="nvme_8h.html#a204d7f2669bc34a9d45ec28d3a661b21">More...</a><br /></td></tr>
<tr class="separator:a204d7f2669bc34a9d45ec28d3a661b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3065f669d8b605efdcadffbf94a50538"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a3065f669d8b605efdcadffbf94a50538">spdk_nvme_ns_cmd_write</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags)</td></tr>
<tr class="memdesc:a3065f669d8b605efdcadffbf94a50538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write I/O to the specified NVMe namespace.  <a href="nvme_8h.html#a3065f669d8b605efdcadffbf94a50538">More...</a><br /></td></tr>
<tr class="separator:a3065f669d8b605efdcadffbf94a50538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcbb5d31f0b572847cc8ae8b07dfcfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#adfcbb5d31f0b572847cc8ae8b07dfcfb">spdk_nvme_ns_cmd_writev</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn)</td></tr>
<tr class="memdesc:adfcbb5d31f0b572847cc8ae8b07dfcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write I/O to the specified NVMe namespace.  <a href="nvme_8h.html#adfcbb5d31f0b572847cc8ae8b07dfcfb">More...</a><br /></td></tr>
<tr class="separator:adfcbb5d31f0b572847cc8ae8b07dfcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d42660e3de76f75f4b5d79ed9b1d01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab4d42660e3de76f75f4b5d79ed9b1d01">spdk_nvme_ns_cmd_writev_with_md</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn, void *metadata, uint16_t apptag_mask, uint16_t apptag)</td></tr>
<tr class="memdesc:ab4d42660e3de76f75f4b5d79ed9b1d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write I/O to the specified NVMe namespace.  <a href="nvme_8h.html#ab4d42660e3de76f75f4b5d79ed9b1d01">More...</a><br /></td></tr>
<tr class="separator:ab4d42660e3de76f75f4b5d79ed9b1d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c98eff7f5474a7044112202fbbf77bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7c98eff7f5474a7044112202fbbf77bb">spdk_nvme_ns_cmd_writev_ext</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn, struct <a class="el" href="structspdk__nvme__ns__cmd__ext__io__opts.html">spdk_nvme_ns_cmd_ext_io_opts</a> *opts)</td></tr>
<tr class="memdesc:a7c98eff7f5474a7044112202fbbf77bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write I/O to the specified NVMe namespace.  <a href="nvme_8h.html#a7c98eff7f5474a7044112202fbbf77bb">More...</a><br /></td></tr>
<tr class="separator:a7c98eff7f5474a7044112202fbbf77bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2aa2be0d657be0c63d5abc02b274ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#adc2aa2be0d657be0c63d5abc02b274ec">spdk_nvme_ns_cmd_write_with_md</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, void *metadata, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, uint16_t apptag_mask, uint16_t apptag)</td></tr>
<tr class="memdesc:adc2aa2be0d657be0c63d5abc02b274ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write I/O to the specified NVMe namespace.  <a href="nvme_8h.html#adc2aa2be0d657be0c63d5abc02b274ec">More...</a><br /></td></tr>
<tr class="separator:adc2aa2be0d657be0c63d5abc02b274ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02e8c701c5496f163a69917ad5397dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#af02e8c701c5496f163a69917ad5397dd">spdk_nvme_ns_cmd_write_zeroes</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags)</td></tr>
<tr class="memdesc:af02e8c701c5496f163a69917ad5397dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write zeroes I/O to the specified NVMe namespace.  <a href="nvme_8h.html#af02e8c701c5496f163a69917ad5397dd">More...</a><br /></td></tr>
<tr class="separator:af02e8c701c5496f163a69917ad5397dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686bdbdf30351e164ce8f8c317621ace"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a686bdbdf30351e164ce8f8c317621ace">spdk_nvme_ns_cmd_verify</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags)</td></tr>
<tr class="memdesc:a686bdbdf30351e164ce8f8c317621ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a verify I/O to the specified NVMe namespace.  <a href="nvme_8h.html#a686bdbdf30351e164ce8f8c317621ace">More...</a><br /></td></tr>
<tr class="separator:a686bdbdf30351e164ce8f8c317621ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f23130b6ebdb7b3e4086545e422e59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab2f23130b6ebdb7b3e4086545e422e59">spdk_nvme_ns_cmd_write_uncorrectable</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ab2f23130b6ebdb7b3e4086545e422e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write uncorrectable I/O to the specified NVMe namespace.  <a href="nvme_8h.html#ab2f23130b6ebdb7b3e4086545e422e59">More...</a><br /></td></tr>
<tr class="separator:ab2f23130b6ebdb7b3e4086545e422e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084c6ecb53bd810fbb5051100b79bec5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a084c6ecb53bd810fbb5051100b79bec5">spdk_nvme_ns_cmd_read</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags)</td></tr>
<tr class="memdesc:a084c6ecb53bd810fbb5051100b79bec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a read I/O to the specified NVMe namespace.  <a href="nvme_8h.html#a084c6ecb53bd810fbb5051100b79bec5">More...</a><br /></td></tr>
<tr class="separator:a084c6ecb53bd810fbb5051100b79bec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb47ce7de6b6e963ec9fb8de261466ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#acb47ce7de6b6e963ec9fb8de261466ae">spdk_nvme_ns_cmd_readv</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn)</td></tr>
<tr class="memdesc:acb47ce7de6b6e963ec9fb8de261466ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read I/O to the specified NVMe namespace.  <a href="nvme_8h.html#acb47ce7de6b6e963ec9fb8de261466ae">More...</a><br /></td></tr>
<tr class="separator:acb47ce7de6b6e963ec9fb8de261466ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08afb91732d92d84a054012cd3d236aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a08afb91732d92d84a054012cd3d236aa">spdk_nvme_ns_cmd_readv_with_md</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn, void *metadata, uint16_t apptag_mask, uint16_t apptag)</td></tr>
<tr class="memdesc:a08afb91732d92d84a054012cd3d236aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read I/O to the specified NVMe namespace.  <a href="nvme_8h.html#a08afb91732d92d84a054012cd3d236aa">More...</a><br /></td></tr>
<tr class="separator:a08afb91732d92d84a054012cd3d236aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a40bbc5ff993609f20d6b4f2a35f93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#af4a40bbc5ff993609f20d6b4f2a35f93">spdk_nvme_ns_cmd_readv_ext</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn, struct <a class="el" href="structspdk__nvme__ns__cmd__ext__io__opts.html">spdk_nvme_ns_cmd_ext_io_opts</a> *opts)</td></tr>
<tr class="memdesc:af4a40bbc5ff993609f20d6b4f2a35f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read I/O to the specified NVMe namespace.  <a href="nvme_8h.html#af4a40bbc5ff993609f20d6b4f2a35f93">More...</a><br /></td></tr>
<tr class="separator:af4a40bbc5ff993609f20d6b4f2a35f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2913b93326e636eca6dfe7b42e349fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa2913b93326e636eca6dfe7b42e349fe">spdk_nvme_ns_cmd_read_with_md</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, void *metadata, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, uint16_t apptag_mask, uint16_t apptag)</td></tr>
<tr class="memdesc:aa2913b93326e636eca6dfe7b42e349fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a read I/O to the specified NVMe namespace.  <a href="nvme_8h.html#aa2913b93326e636eca6dfe7b42e349fe">More...</a><br /></td></tr>
<tr class="separator:aa2913b93326e636eca6dfe7b42e349fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c646dd18675c54ffcf834ce699658d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac0c646dd18675c54ffcf834ce699658d">spdk_nvme_ns_cmd_dataset_management</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint32_t type, const struct <a class="el" href="structspdk__nvme__dsm__range.html">spdk_nvme_dsm_range</a> *ranges, uint16_t num_ranges, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ac0c646dd18675c54ffcf834ce699658d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a data set management request to the specified NVMe namespace.  <a href="nvme_8h.html#ac0c646dd18675c54ffcf834ce699658d">More...</a><br /></td></tr>
<tr class="separator:ac0c646dd18675c54ffcf834ce699658d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6604babca780495c910145f915d5ea2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad6604babca780495c910145f915d5ea2">spdk_nvme_ns_cmd_copy</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, const struct <a class="el" href="structspdk__nvme__scc__source__range.html">spdk_nvme_scc_source_range</a> *ranges, uint16_t num_ranges, uint64_t dest_lba, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ad6604babca780495c910145f915d5ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a simple copy command request to the specified NVMe namespace.  <a href="nvme_8h.html#ad6604babca780495c910145f915d5ea2">More...</a><br /></td></tr>
<tr class="separator:ad6604babca780495c910145f915d5ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0b134e140121bb9bd8664d4a43a5c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aed0b134e140121bb9bd8664d4a43a5c6">spdk_nvme_ns_cmd_flush</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aed0b134e140121bb9bd8664d4a43a5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a flush request to the specified NVMe namespace.  <a href="nvme_8h.html#aed0b134e140121bb9bd8664d4a43a5c6">More...</a><br /></td></tr>
<tr class="separator:aed0b134e140121bb9bd8664d4a43a5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c140c47970bafbfec36bf6e4c37704"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad5c140c47970bafbfec36bf6e4c37704">spdk_nvme_ns_cmd_reservation_register</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__reservation__register__data.html">spdk_nvme_reservation_register_data</a> *payload, bool ignore_key, enum <a class="el" href="nvme__spec_8h.html#a178a7468a0a9c3e814ca2ba80e3406e5">spdk_nvme_reservation_register_action</a> action, enum <a class="el" href="nvme__spec_8h.html#a05b2db4a398c119c029c234a68760c73">spdk_nvme_reservation_register_cptpl</a> cptpl, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ad5c140c47970bafbfec36bf6e4c37704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a reservation register to the specified NVMe namespace.  <a href="nvme_8h.html#ad5c140c47970bafbfec36bf6e4c37704">More...</a><br /></td></tr>
<tr class="separator:ad5c140c47970bafbfec36bf6e4c37704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b1d9de51027da9a66fe12e2ce28132"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa2b1d9de51027da9a66fe12e2ce28132">spdk_nvme_ns_cmd_reservation_release</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__reservation__key__data.html">spdk_nvme_reservation_key_data</a> *payload, bool ignore_key, enum <a class="el" href="nvme__spec_8h.html#a6fa8ea66c4927d8bb4d81d76867e851a">spdk_nvme_reservation_release_action</a> action, enum <a class="el" href="nvme__spec_8h.html#aa7e108757c0eebbac7e13b598a378210">spdk_nvme_reservation_type</a> type, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aa2b1d9de51027da9a66fe12e2ce28132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a reservation release to the specified NVMe namespace.  <a href="nvme_8h.html#aa2b1d9de51027da9a66fe12e2ce28132">More...</a><br /></td></tr>
<tr class="separator:aa2b1d9de51027da9a66fe12e2ce28132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8028f294d09711401d098e89d87f38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#abb8028f294d09711401d098e89d87f38">spdk_nvme_ns_cmd_reservation_acquire</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__reservation__acquire__data.html">spdk_nvme_reservation_acquire_data</a> *payload, bool ignore_key, enum <a class="el" href="nvme__spec_8h.html#a95b3685443c2716ee0d125c30182aeac">spdk_nvme_reservation_acquire_action</a> action, enum <a class="el" href="nvme__spec_8h.html#aa7e108757c0eebbac7e13b598a378210">spdk_nvme_reservation_type</a> type, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:abb8028f294d09711401d098e89d87f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a reservation acquire to the specified NVMe namespace.  <a href="nvme_8h.html#abb8028f294d09711401d098e89d87f38">More...</a><br /></td></tr>
<tr class="separator:abb8028f294d09711401d098e89d87f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7b5944bda3fe9ef1c83fcd2025b39a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a9a7b5944bda3fe9ef1c83fcd2025b39a">spdk_nvme_ns_cmd_reservation_report</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, uint32_t len, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a9a7b5944bda3fe9ef1c83fcd2025b39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a reservation report to the specified NVMe namespace.  <a href="nvme_8h.html#a9a7b5944bda3fe9ef1c83fcd2025b39a">More...</a><br /></td></tr>
<tr class="separator:a9a7b5944bda3fe9ef1c83fcd2025b39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37d0d0eaebbc73c1dcaa246a3d1253a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac37d0d0eaebbc73c1dcaa246a3d1253a">spdk_nvme_ns_cmd_io_mgmt_recv</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, uint32_t len, uint8_t mo, uint16_t mos, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ac37d0d0eaebbc73c1dcaa246a3d1253a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an I/O management receive command to the specified NVMe namespace.  <a href="nvme_8h.html#ac37d0d0eaebbc73c1dcaa246a3d1253a">More...</a><br /></td></tr>
<tr class="separator:ac37d0d0eaebbc73c1dcaa246a3d1253a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d713cade7319ea13dcebe41fff2431"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac2d713cade7319ea13dcebe41fff2431">spdk_nvme_ns_cmd_io_mgmt_send</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, uint32_t len, uint8_t mo, uint16_t mos, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ac2d713cade7319ea13dcebe41fff2431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an I/O management send command to the specified NVMe namespace.  <a href="nvme_8h.html#ac2d713cade7319ea13dcebe41fff2431">More...</a><br /></td></tr>
<tr class="separator:ac2d713cade7319ea13dcebe41fff2431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8aa3c9ff510fe73945549077df18436"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad8aa3c9ff510fe73945549077df18436">spdk_nvme_ns_cmd_compare</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags)</td></tr>
<tr class="memdesc:ad8aa3c9ff510fe73945549077df18436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a compare I/O to the specified NVMe namespace.  <a href="nvme_8h.html#ad8aa3c9ff510fe73945549077df18436">More...</a><br /></td></tr>
<tr class="separator:ad8aa3c9ff510fe73945549077df18436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d6b722c8837593dec16f30376d182"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a108d6b722c8837593dec16f30376d182">spdk_nvme_ns_cmd_comparev</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn)</td></tr>
<tr class="memdesc:a108d6b722c8837593dec16f30376d182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a compare I/O to the specified NVMe namespace.  <a href="nvme_8h.html#a108d6b722c8837593dec16f30376d182">More...</a><br /></td></tr>
<tr class="separator:a108d6b722c8837593dec16f30376d182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e7d5f0f025d25026f1225d2f6c9a4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a47e7d5f0f025d25026f1225d2f6c9a4b">spdk_nvme_ns_cmd_comparev_with_md</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn, void *metadata, uint16_t apptag_mask, uint16_t apptag)</td></tr>
<tr class="memdesc:a47e7d5f0f025d25026f1225d2f6c9a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a compare I/O to the specified NVMe namespace.  <a href="nvme_8h.html#a47e7d5f0f025d25026f1225d2f6c9a4b">More...</a><br /></td></tr>
<tr class="separator:a47e7d5f0f025d25026f1225d2f6c9a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf7a40872bfe623a5dfa31922263532"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a4bf7a40872bfe623a5dfa31922263532">spdk_nvme_ns_cmd_compare_with_md</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, void *metadata, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, uint16_t apptag_mask, uint16_t apptag)</td></tr>
<tr class="memdesc:a4bf7a40872bfe623a5dfa31922263532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a compare I/O to the specified NVMe namespace.  <a href="nvme_8h.html#a4bf7a40872bfe623a5dfa31922263532">More...</a><br /></td></tr>
<tr class="separator:a4bf7a40872bfe623a5dfa31922263532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6188764b8c71b2f64a74077d6bfabf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#acf6188764b8c71b2f64a74077d6bfabf">spdk_nvme_qpair_add_cmd_error_injection</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, uint8_t opc, bool do_not_submit, uint64_t timeout_in_us, uint32_t err_count, uint8_t sct, uint8_t sc)</td></tr>
<tr class="memdesc:acf6188764b8c71b2f64a74077d6bfabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject an error for the next request with a given opcode.  <a href="nvme_8h.html#acf6188764b8c71b2f64a74077d6bfabf">More...</a><br /></td></tr>
<tr class="separator:acf6188764b8c71b2f64a74077d6bfabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad720b23786450b5a2b2d7d65c6dd6b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad720b23786450b5a2b2d7d65c6dd6b7c">spdk_nvme_qpair_remove_cmd_error_injection</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, uint8_t opc)</td></tr>
<tr class="memdesc:ad720b23786450b5a2b2d7d65c6dd6b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the specified NVMe command with error status.  <a href="nvme_8h.html#ad720b23786450b5a2b2d7d65c6dd6b7c">More...</a><br /></td></tr>
<tr class="separator:ad720b23786450b5a2b2d7d65c6dd6b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f179ad680512c168148e13aa74b3f4b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a5f179ad680512c168148e13aa74b3f4b">spdk_nvme_cpl_get_status_string</a> (const struct <a class="el" href="structspdk__nvme__status.html">spdk_nvme_status</a> *status)</td></tr>
<tr class="memdesc:a5f179ad680512c168148e13aa74b3f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given NVMe status, return ASCII string for that error.  <a href="nvme_8h.html#a5f179ad680512c168148e13aa74b3f4b">More...</a><br /></td></tr>
<tr class="separator:a5f179ad680512c168148e13aa74b3f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f2ca4a3d3d7ae892943410ca1a07e0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a14f2ca4a3d3d7ae892943410ca1a07e0">spdk_nvme_cpl_get_status_type_string</a> (const struct <a class="el" href="structspdk__nvme__status.html">spdk_nvme_status</a> *status)</td></tr>
<tr class="memdesc:a14f2ca4a3d3d7ae892943410ca1a07e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given NVMe status, return ASCII string for the type of that error.  <a href="nvme_8h.html#a14f2ca4a3d3d7ae892943410ca1a07e0">More...</a><br /></td></tr>
<tr class="separator:a14f2ca4a3d3d7ae892943410ca1a07e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06275147a2cbb800440686b8ba9a73b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac06275147a2cbb800440686b8ba9a73b">spdk_nvme_qpair_print_command</a> (struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd)</td></tr>
<tr class="memdesc:ac06275147a2cbb800440686b8ba9a73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints (SPDK_NOTICELOG) the contents of an NVMe submission queue entry (command).  <a href="nvme_8h.html#ac06275147a2cbb800440686b8ba9a73b">More...</a><br /></td></tr>
<tr class="separator:ac06275147a2cbb800440686b8ba9a73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b2335194f9c4c24a5e2c15a9432f4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad4b2335194f9c4c24a5e2c15a9432f4a">spdk_nvme_qpair_print_completion</a> (struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *cpl)</td></tr>
<tr class="memdesc:ad4b2335194f9c4c24a5e2c15a9432f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints (SPDK_NOTICELOG) the contents of an NVMe completion queue entry.  <a href="nvme_8h.html#ad4b2335194f9c4c24a5e2c15a9432f4a">More...</a><br /></td></tr>
<tr class="separator:ad4b2335194f9c4c24a5e2c15a9432f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6ae73013499c8fc3c197f47231b8d2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#add6ae73013499c8fc3c197f47231b8d2">spdk_nvme_qpair_get_id</a> (struct spdk_nvme_qpair *qpair)</td></tr>
<tr class="memdesc:add6ae73013499c8fc3c197f47231b8d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the NVMe qpair ID for the specified qpair.  <a href="nvme_8h.html#add6ae73013499c8fc3c197f47231b8d2">More...</a><br /></td></tr>
<tr class="separator:add6ae73013499c8fc3c197f47231b8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fff8d7ba08d00a5e4f322dd1b6af2d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a54fff8d7ba08d00a5e4f322dd1b6af2d">spdk_nvme_qpair_get_num_outstanding_reqs</a> (struct spdk_nvme_qpair *qpair)</td></tr>
<tr class="memdesc:a54fff8d7ba08d00a5e4f322dd1b6af2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of outstanding requests for the specified qpair.  <a href="nvme_8h.html#a54fff8d7ba08d00a5e4f322dd1b6af2d">More...</a><br /></td></tr>
<tr class="separator:a54fff8d7ba08d00a5e4f322dd1b6af2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8145be511777b2c8dc218b1c1e1e2c89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a8145be511777b2c8dc218b1c1e1e2c89">spdk_nvme_print_command</a> (uint16_t qid, struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd)</td></tr>
<tr class="memdesc:a8145be511777b2c8dc218b1c1e1e2c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints (SPDK_NOTICELOG) the contents of an NVMe submission queue entry (command).  <a href="nvme_8h.html#a8145be511777b2c8dc218b1c1e1e2c89">More...</a><br /></td></tr>
<tr class="separator:a8145be511777b2c8dc218b1c1e1e2c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe027f765f35a6cf532c236a90df5b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aebe027f765f35a6cf532c236a90df5b7">spdk_nvme_print_completion</a> (uint16_t qid, struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *cpl)</td></tr>
<tr class="memdesc:aebe027f765f35a6cf532c236a90df5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints (SPDK_NOTICELOG) the contents of an NVMe completion queue entry.  <a href="nvme_8h.html#aebe027f765f35a6cf532c236a90df5b7">More...</a><br /></td></tr>
<tr class="separator:aebe027f765f35a6cf532c236a90df5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cdb425c9fad7b94ad0b8f5c27bb8b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a82cdb425c9fad7b94ad0b8f5c27bb8b2">spdk_nvme_rdma_init_hooks</a> (struct <a class="el" href="structspdk__nvme__rdma__hooks.html">spdk_nvme_rdma_hooks</a> *hooks)</td></tr>
<tr class="memdesc:a82cdb425c9fad7b94ad0b8f5c27bb8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global hooks for the RDMA transport, if necessary.  <a href="nvme_8h.html#a82cdb425c9fad7b94ad0b8f5c27bb8b2">More...</a><br /></td></tr>
<tr class="separator:a82cdb425c9fad7b94ad0b8f5c27bb8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa645963334716b9b7276a7269eb2e379"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa645963334716b9b7276a7269eb2e379">spdk_nvme_cuse_get_ctrlr_name</a> (struct spdk_nvme_ctrlr *ctrlr, char *name, size_t *size)</td></tr>
<tr class="memdesc:aa645963334716b9b7276a7269eb2e379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of cuse device associated with NVMe controller.  <a href="nvme_8h.html#aa645963334716b9b7276a7269eb2e379">More...</a><br /></td></tr>
<tr class="separator:aa645963334716b9b7276a7269eb2e379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf38d8b0e0625dc192a83926952283a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a8cf38d8b0e0625dc192a83926952283a">spdk_nvme_cuse_get_ns_name</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, char *name, size_t *size)</td></tr>
<tr class="memdesc:a8cf38d8b0e0625dc192a83926952283a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of cuse device associated with NVMe namespace.  <a href="nvme_8h.html#a8cf38d8b0e0625dc192a83926952283a">More...</a><br /></td></tr>
<tr class="separator:a8cf38d8b0e0625dc192a83926952283a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba8ee34c024d648a81d903b155cff97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a5ba8ee34c024d648a81d903b155cff97">spdk_nvme_cuse_register</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a5ba8ee34c024d648a81d903b155cff97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a character device at the path specified (Experimental)  <a href="nvme_8h.html#a5ba8ee34c024d648a81d903b155cff97">More...</a><br /></td></tr>
<tr class="separator:a5ba8ee34c024d648a81d903b155cff97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd4f33cc8dc7741290b9cdf02fc691c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a2cd4f33cc8dc7741290b9cdf02fc691c">spdk_nvme_cuse_unregister</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a2cd4f33cc8dc7741290b9cdf02fc691c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a previously created character device (Experimental)  <a href="nvme_8h.html#a2cd4f33cc8dc7741290b9cdf02fc691c">More...</a><br /></td></tr>
<tr class="separator:a2cd4f33cc8dc7741290b9cdf02fc691c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6647280570446fbde28b92332be1108d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6647280570446fbde28b92332be1108d">spdk_nvme_ctrlr_get_memory_domains</a> (const struct spdk_nvme_ctrlr *ctrlr, struct spdk_memory_domain **domains, int array_size)</td></tr>
<tr class="memdesc:a6647280570446fbde28b92332be1108d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SPDK memory domains used by the given nvme controller.  <a href="nvme_8h.html#a6647280570446fbde28b92332be1108d">More...</a><br /></td></tr>
<tr class="separator:a6647280570446fbde28b92332be1108d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8157e10a468a618d04accf1830d59cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac8157e10a468a618d04accf1830d59cd">spdk_nvme_cuse_update_namespaces</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:ac8157e10a468a618d04accf1830d59cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update and populate namespace CUSE devices (Experimental)  <a href="nvme_8h.html#ac8157e10a468a618d04accf1830d59cd">More...</a><br /></td></tr>
<tr class="separator:ac8157e10a468a618d04accf1830d59cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4165e918b05158286f5984a136acbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6e4165e918b05158286f5984a136acbf">spdk_nvme_transport_register</a> (const struct <a class="el" href="structspdk__nvme__transport__ops.html">spdk_nvme_transport_ops</a> *ops)</td></tr>
<tr class="memdesc:a6e4165e918b05158286f5984a136acbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the operations for a given transport type.  <a href="nvme_8h.html#a6e4165e918b05158286f5984a136acbf">More...</a><br /></td></tr>
<tr class="separator:a6e4165e918b05158286f5984a136acbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826ab00cf15a96e4962de4a7afa46ab3"><td class="memItemLeft" align="right" valign="top"><a id="a826ab00cf15a96e4962de4a7afa46ab3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvme__transport__opts.html">spdk_nvme_transport_opts</a>)==12, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a826ab00cf15a96e4962de4a7afa46ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9e59ab20d92979f2995646c8191e9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#acb9e59ab20d92979f2995646c8191e9a">spdk_nvme_transport_get_opts</a> (struct <a class="el" href="structspdk__nvme__transport__opts.html">spdk_nvme_transport_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:acb9e59ab20d92979f2995646c8191e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current NVMe transport options.  <a href="nvme_8h.html#acb9e59ab20d92979f2995646c8191e9a">More...</a><br /></td></tr>
<tr class="separator:acb9e59ab20d92979f2995646c8191e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327cc2f4818d3111bdc8485a9b844d4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a327cc2f4818d3111bdc8485a9b844d4f">spdk_nvme_transport_set_opts</a> (const struct <a class="el" href="structspdk__nvme__transport__opts.html">spdk_nvme_transport_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:a327cc2f4818d3111bdc8485a9b844d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the NVMe transport options.  <a href="nvme_8h.html#a327cc2f4818d3111bdc8485a9b844d4f">More...</a><br /></td></tr>
<tr class="separator:a327cc2f4818d3111bdc8485a9b844d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>NVMe driver public API. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac6da5f02442d41a5233de049fb950a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6da5f02442d41a5233de049fb950a8f">&#9670;&nbsp;</a></span>SPDK_NVME_TRANSPORT_REGISTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPDK_NVME_TRANSPORT_REGISTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">transport_ops&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __attribute__((constructor)) _spdk_nvme_transport_register_##name(<span class="keywordtype">void</span>) \</div>
<div class="line">{ \</div>
<div class="line">        spdk_nvme_transport_register(transport_ops); \</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="afff8aaa490f2db1119b20e36253196b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff8aaa490f2db1119b20e36253196b7">&#9670;&nbsp;</a></span>spdk_nvme_accel_completion_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_accel_completion_cb) (void *cb_arg, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NVMe acceleration operation callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>The user provided arg which is passed to the corresponding accelerated function call defined in struct <a class="el" href="structspdk__nvme__accel__fn__table.html" title="Function table for the NVMe accelerator device.">spdk_nvme_accel_fn_table</a>. </td></tr>
    <tr><td class="paramname">status</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d066bb761dc3481f081d0d6924766ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d066bb761dc3481f081d0d6924766ee">&#9670;&nbsp;</a></span>spdk_nvme_aer_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_aer_cb) (void *aer_cb_arg, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *cpl)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature for callback function invoked when an asynchronous event request command is completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aer_cb_arg</td><td>Context specified by spdk_nvme_register_aer_callback(). </td></tr>
    <tr><td class="paramname">cpl</td><td>Completion queue entry that contains the completion status of the asynchronous event request that was completed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1eaa795f075495337b270667661ce5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1eaa795f075495337b270667661ce5d">&#9670;&nbsp;</a></span>spdk_nvme_attach_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_attach_cb) (void *cb_ctx, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct spdk_nvme_ctrlr *ctrlr, const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for spdk_nvme_attach() to report a device that has been attached to the userspace NVMe driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_ctx</td><td>Opaque value passed to <a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d" title="Callback for spdk_nvme_attach() to report a device that has been attached to the userspace NVMe drive...">spdk_nvme_attach_cb()</a>. </td></tr>
    <tr><td class="paramname">trid</td><td>NVMe transport identifier. </td></tr>
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">opts</td><td>NVMe controller initialization options that were actually used. Options may differ from the requested options from the attach call depending on what the controller supports. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1786f9616afc773b20f752dc98ecd465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1786f9616afc773b20f752dc98ecd465">&#9670;&nbsp;</a></span>spdk_nvme_cmd_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_cmd_cb) (void *ctx, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *cpl)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature for callback function invoked when a command is completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Callback context provided when the command was submitted. </td></tr>
    <tr><td class="paramname">cpl</td><td>Completion queue entry that contains the completion status. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e4bc7c0002363701bc9363ab2291e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4bc7c0002363701bc9363ab2291e6e">&#9670;&nbsp;</a></span>spdk_nvme_discovery_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_discovery_cb) (void *cb_arg, int rc, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *cpl, struct <a class="el" href="structspdk__nvmf__discovery__log__page.html">spdk_nvmf_discovery_log_page</a> *log_page)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature for the callback function when a <a class="el" href="nvme_8h.html#a87a228bf5b96e89305e52721d81920d7">spdk_nvme_ctrlr_get_discovery_log_page</a> operation is completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Argument passed to callback function. </td></tr>
    <tr><td class="paramname">rc</td><td>Status of operation. 0 means success, and that the cpl argument is valid. Failure indicated by negative errno value. </td></tr>
    <tr><td class="paramname">cpl</td><td>NVMe completion status of the operation. NULL if rc != 0. If multiple completions with error status occurred during the operation, the cpl value for the first error will be used here. </td></tr>
    <tr><td class="paramname">log_page</td><td>Pointer to the full discovery log page. The application is responsible for freeing this buffer using free(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95f40d5179f8424b466a30ba0610ab4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f40d5179f8424b466a30ba0610ab4c">&#9670;&nbsp;</a></span>spdk_nvme_probe_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* spdk_nvme_probe_cb) (void *cb_ctx, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> enumeration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_ctx</td><td>Opaque value passed to <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>. </td></tr>
    <tr><td class="paramname">trid</td><td>NVMe transport identifier. </td></tr>
    <tr><td class="paramname">opts</td><td>NVMe controller initialization options. This structure will be populated with the default values on entry, and the user callback may update any options to request a different value. The controller may not support all requested parameters, so the final values will be provided during the attach callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true to attach to this device. </dd></dl>

</div>
</div>
<a id="a0893350626b0eff85b931c570876f28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0893350626b0eff85b931c570876f28a">&#9670;&nbsp;</a></span>spdk_nvme_reg_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_reg_cb) (void *ctx, uint64_t value, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *cpl)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature for callback invoked after completing a register read/write operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context passed by the user. </td></tr>
    <tr><td class="paramname">value</td><td>Value of the register, undefined in case of a failure. </td></tr>
    <tr><td class="paramname">cpl</td><td>Completion queue entry that contains the status of the command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05f1aa545be57a03bb2dd0c6180172b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f1aa545be57a03bb2dd0c6180172b6">&#9670;&nbsp;</a></span>spdk_nvme_remove_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_remove_cb) (void *cb_ctx, struct spdk_nvme_ctrlr *ctrlr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for spdk_nvme_remove() to report that a device attached to the userspace NVMe driver has been removed from the system. </p>
<p>The controller will remain in a failed state (any new I/O submitted will fail).</p>
<p>The controller must be detached from the userspace driver by calling <a class="el" href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2" title="Detach specified device returned by spdk_nvme_probe()&#39;s attach_cb from the NVMe driver.">spdk_nvme_detach()</a> once the controller is no longer in use. It is up to the library user to ensure that no other threads are using the controller before calling <a class="el" href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2" title="Detach specified device returned by spdk_nvme_probe()&#39;s attach_cb from the NVMe driver.">spdk_nvme_detach()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_ctx</td><td>Opaque value passed to <a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6" title="Callback for spdk_nvme_remove() to report that a device attached to the userspace NVMe driver has bee...">spdk_nvme_remove_cb()</a>. </td></tr>
    <tr><td class="paramname">ctrlr</td><td>NVMe controller instance that was removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ab95bea86f498c08510f6f0bcd2eb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab95bea86f498c08510f6f0bcd2eb09">&#9670;&nbsp;</a></span>spdk_nvme_req_next_sge_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_nvme_req_next_sge_cb) (void *cb_arg, void **address, uint32_t *length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill out *address and *length with the current SGL entry and advance to the next entry for the next time the callback is invoked. </p>
<p>The described segment must be physically contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Argument passed to readv/writev. </td></tr>
    <tr><td class="paramname">address</td><td>Virtual address of this segment, a value of UINT64_MAX means the segment should be described via Bit Bucket SGL. </td></tr>
    <tr><td class="paramname">length</td><td>Length of this physical segment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e1fcb43970ea531567ee00d4ee0675b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1fcb43970ea531567ee00d4ee0675b">&#9670;&nbsp;</a></span>spdk_nvme_req_reset_sgl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_req_reset_sgl_cb) (void *cb_arg, uint32_t offset)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restart the SGL walk to the specified offset when the command has scattered payloads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Argument passed to readv/writev. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset for SGL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53fe1c01a447be8fcd29821a668227a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fe1c01a447be8fcd29821a668227a0">&#9670;&nbsp;</a></span>spdk_nvme_timeout_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_timeout_cb) (void *cb_arg, struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, uint16_t cid)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature for the callback function invoked when a timeout is detected on a request. </p>
<p>For timeouts detected on the admin queue pair, the qpair returned here will be NULL. If the controller has a serious error condition and is unable to communicate with driver via completion queue, the controller can set Controller Fatal Status field to 1, then reset is required to recover from such error. Users may detect Controller Fatal Status when timeout happens.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Argument passed to callback function. </td></tr>
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">qpair</td><td>Opaque handle to a queue pair. </td></tr>
    <tr><td class="paramname">cid</td><td>Command ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="add21ceb016f09949ac6cef50e0566818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add21ceb016f09949ac6cef50e0566818">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme_8h.html#add21ceb016f09949ac6cef50e0566818">spdk_nvme_ctrlr_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="add21ceb016f09949ac6cef50e0566818a06c93626e819195260a55c69dba063c6"></a>SPDK_NVME_CTRLR_SGL_SUPPORTED&#160;</td><td class="fielddoc"><p>SGL is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="add21ceb016f09949ac6cef50e0566818a7bddfe71a101581b0daa4812fbd93268"></a>SPDK_NVME_CTRLR_SECURITY_SEND_RECV_SUPPORTED&#160;</td><td class="fielddoc"><p>security send/receive is supported </p>
</td></tr>
<tr><td class="fieldname"><a id="add21ceb016f09949ac6cef50e0566818ab7e2345d658ff0069c99427a5e0177d3"></a>SPDK_NVME_CTRLR_WRR_SUPPORTED&#160;</td><td class="fielddoc"><p>Weighted Round Robin is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="add21ceb016f09949ac6cef50e0566818ab2a269826d7e50f062924065df9cf6ec"></a>SPDK_NVME_CTRLR_COMPARE_AND_WRITE_SUPPORTED&#160;</td><td class="fielddoc"><p>Compare and write fused operations supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="add21ceb016f09949ac6cef50e0566818afb90e96b743634d16ce84716e3250e0d"></a>SPDK_NVME_CTRLR_SGL_REQUIRES_DWORD_ALIGNMENT&#160;</td><td class="fielddoc"><p>Dword alignment is required for SGL. </p>
</td></tr>
<tr><td class="fieldname"><a id="add21ceb016f09949ac6cef50e0566818a47e0066f0e7c2c8f3d0fba8ce612dc73"></a>SPDK_NVME_CTRLR_ZONE_APPEND_SUPPORTED&#160;</td><td class="fielddoc"><p>Zone Append is supported (within Zoned Namespaces) </p>
</td></tr>
<tr><td class="fieldname"><a id="add21ceb016f09949ac6cef50e0566818a2ecf8c85bee974f9e7f35a684dff76ac"></a>SPDK_NVME_CTRLR_DIRECTIVES_SUPPORTED&#160;</td><td class="fielddoc"><p>The Directives is supported. </p>
</td></tr>
</table>

</div>
</div>
<a id="a018f3b986b4345ee0c6931be9718c163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018f3b986b4345ee0c6931be9718c163">&#9670;&nbsp;</a></span>spdk_nvme_ns_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163">spdk_nvme_ns_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Namespace command support flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163a80dcd48a57fa9e14efba4757300ad729"></a>SPDK_NVME_NS_DEALLOCATE_SUPPORTED&#160;</td><td class="fielddoc"><p>The deallocate command is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163ad403aafc70c00560a1db768029933400"></a>SPDK_NVME_NS_FLUSH_SUPPORTED&#160;</td><td class="fielddoc"><p>The flush command is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163a60edfdee88fbe811250e2f8ff63597d0"></a>SPDK_NVME_NS_RESERVATION_SUPPORTED&#160;</td><td class="fielddoc"><p>The reservation command is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163a4e691401f3709b7cd66bd32c28ae109b"></a>SPDK_NVME_NS_WRITE_ZEROES_SUPPORTED&#160;</td><td class="fielddoc"><p>The write zeroes command is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163afe158b050528f0f3341e5af3129c61a7"></a>SPDK_NVME_NS_DPS_PI_SUPPORTED&#160;</td><td class="fielddoc"><p>The end-to-end data protection is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163a91203896ead47bbe22e9f7db8a63c14f"></a>SPDK_NVME_NS_EXTENDED_LBA_SUPPORTED&#160;</td><td class="fielddoc"><p>The extended lba format is supported, metadata is transferred as a contiguous part of the logical block that it is associated with. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163afe42f7e0cdcb93109b55b77cf89efd27"></a>SPDK_NVME_NS_WRITE_UNCORRECTABLE_SUPPORTED&#160;</td><td class="fielddoc"><p>The write uncorrectable command is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163a568a13a9686985d4aa24543b52c122d6"></a>SPDK_NVME_NS_COMPARE_SUPPORTED&#160;</td><td class="fielddoc"><p>The compare command is supported. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab41e2d311eb6663957cd2f18bc8fb890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41e2d311eb6663957cd2f18bc8fb890">&#9670;&nbsp;</a></span>spdk_nvme_qp_failure_reason</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme_8h.html#ab41e2d311eb6663957cd2f18bc8fb890">spdk_nvme_qp_failure_reason</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reason for qpair disconnect at the transport layer. </p>
<p>NONE implies that the qpair is still connected while UNKNOWN means that the qpair is disconnected, but the cause was not apparent. </p>

</div>
</div>
<a id="ae87a03c28984a2c0499d50ef5e9d0ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87a03c28984a2c0499d50ef5e9d0ece">&#9670;&nbsp;</a></span>spdk_nvme_transport_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NVMe library transports. </p>
<p>NOTE: These are mapped directly to the NVMe over Fabrics TRTYPE values, except for PCIe, which is a special case since NVMe over Fabrics does not define a TRTYPE for local PCIe.</p>
<p>Currently, this uses 256 for PCIe which is intentionally outside of the 8-bit range of TRTYPE. If the NVMe-oF specification ever defines a PCIe TRTYPE, this should be updated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae87a03c28984a2c0499d50ef5e9d0ecea162afc05d1ae756b8a7969be140035ea"></a>SPDK_NVME_TRANSPORT_PCIE&#160;</td><td class="fielddoc"><p>PCIe Transport (locally attached devices) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae87a03c28984a2c0499d50ef5e9d0ecea140f1cb4edf258bddffeb1c7277d93d8"></a>SPDK_NVME_TRANSPORT_RDMA&#160;</td><td class="fielddoc"><p>RDMA Transport (RoCE, iWARP, etc.) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae87a03c28984a2c0499d50ef5e9d0eceabbda195aa6d0a4ad7b437ed5e9a0d01f"></a>SPDK_NVME_TRANSPORT_FC&#160;</td><td class="fielddoc"><p>Fibre Channel (FC) Transport. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae87a03c28984a2c0499d50ef5e9d0ecea1b74e6a5b484b71142aa6ac9821a6de3"></a>SPDK_NVME_TRANSPORT_TCP&#160;</td><td class="fielddoc"><p>TCP Transport. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae87a03c28984a2c0499d50ef5e9d0ecea4a7f3a344a32bd10b0594726fa4eaa33"></a>SPDK_NVME_TRANSPORT_VFIOUSER&#160;</td><td class="fielddoc"><p>Custom VFIO User Transport (Not spec defined) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae87a03c28984a2c0499d50ef5e9d0ecead9c4d8737f8d49b432c3f2d9d0f86a0a"></a>SPDK_NVME_TRANSPORT_CUSTOM&#160;</td><td class="fielddoc"><p>Custom Transport (Not spec defined) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae87a03c28984a2c0499d50ef5e9d0ecead22a6399d96bc2c38efb261319c04ffc"></a>SPDK_NVME_TRANSPORT_CUSTOM_FABRICS&#160;</td><td class="fielddoc"><p>Custom Fabric Transport (Not spec defined) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae26375a74c2c935ec32f0c41a7ed93df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26375a74c2c935ec32f0c41a7ed93df">&#9670;&nbsp;</a></span>spdk_nvme_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_ctrlr* spdk_nvme_connect </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>opts_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect the NVMe driver to the device located at the given transport ID. </p>
<p>This function is not thread safe and should only be called from one thread at a time while no other threads are actively using this NVMe device.</p>
<p>If called from a secondary process, only the device that has been attached to the userspace driver in the primary process will be connected.</p>
<p>If connecting to multiple controllers, it is suggested to use <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> and filter the requested controllers with the probe callback. For PCIe controllers, <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> will be more efficient since the controller resets will happen in parallel.</p>
<p>To stop using the the controller and release its associated resources, call <a class="el" href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2" title="Detach specified device returned by spdk_nvme_probe()&#39;s attach_cb from the NVMe driver.">spdk_nvme_detach()</a> with the spdk_nvme_ctrlr instance returned by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid</td><td>The transport ID indicating which device to connect. If the trtype is PCIe, this will connect the local PCIe bus. If the trtype is RDMA, the traddr and trsvcid must point at the location of an NVMe-oF service. </td></tr>
    <tr><td class="paramname">opts</td><td>NVMe controller initialization options. Default values will be used if the user does not specify the options. The controller may not support all requested parameters. </td></tr>
    <tr><td class="paramname">opts_size</td><td>Must be set to sizeof(struct spdk_nvme_ctrlr_opts), or 0 if opts is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the connected NVMe controller or NULL if there is any failure. </dd></dl>

</div>
</div>
<a id="ae8a8762934973d124cbad92fce47a351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a8762934973d124cbad92fce47a351">&#9670;&nbsp;</a></span>spdk_nvme_connect_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_probe_ctx* spdk_nvme_connect_async </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a>&#160;</td>
          <td class="paramname"><em>attach_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect the NVMe driver to the device located at the given transport ID. </p>
<p>The function will return a probe context on success, controller associates with the context is not ready for use, user must call <a class="el" href="nvme_8h.html#aedea919a47bdd811b604656e29e3fcef" title="Proceed with attaching controllers associated with the probe context.">spdk_nvme_probe_poll_async()</a> until <a class="el" href="nvme_8h.html#aedea919a47bdd811b604656e29e3fcef" title="Proceed with attaching controllers associated with the probe context.">spdk_nvme_probe_poll_async()</a> returns 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid</td><td>The transport ID indicating which device to connect. If the trtype is PCIe, this will connect the local PCIe bus. If the trtype is RDMA, the traddr and trsvcid must point at the location of an NVMe-oF service. </td></tr>
    <tr><td class="paramname">opts</td><td>NVMe controller initialization options. Default values will be used if the user does not specify the options. The controller may not support all requested parameters. </td></tr>
    <tr><td class="paramname">attach_cb</td><td>will be called once the NVMe controller has been attached to the userspace driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>probe context on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="a5f179ad680512c168148e13aa74b3f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f179ad680512c168148e13aa74b3f4b">&#9670;&nbsp;</a></span>spdk_nvme_cpl_get_status_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvme_cpl_get_status_string </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__status.html">spdk_nvme_status</a> *&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given NVMe status, return ASCII string for that error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Status from NVMe completion queue element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns status as an ASCII string. </dd></dl>

</div>
</div>
<a id="a14f2ca4a3d3d7ae892943410ca1a07e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f2ca4a3d3d7ae892943410ca1a07e0">&#9670;&nbsp;</a></span>spdk_nvme_cpl_get_status_type_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvme_cpl_get_status_type_string </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__status.html">spdk_nvme_status</a> *&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given NVMe status, return ASCII string for the type of that error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Status from NVMe completion queue element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns status type as an ASCII string. </dd></dl>

</div>
</div>
<a id="a13f745d239dab9b8f934fae2ad4984a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f745d239dab9b8f934fae2ad4984a2">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_alloc_io_qpair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_qpair* spdk_nvme_ctrlr_alloc_io_qpair </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__io__qpair__opts.html">spdk_nvme_io_qpair_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>opts_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an I/O queue pair (submission and completion queue). </p>
<p>This function by default also performs any connection activities required for a newly created qpair. To avoid that behavior, the user should set the create_only flag in the opts structure to true.</p>
<p>Each queue pair should only be used from a single thread at a time (mutual exclusion must be enforced by the user).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller for which to allocate the I/O queue pair. </td></tr>
    <tr><td class="paramname">opts</td><td>I/O qpair creation options, or NULL to use the defaults as returned by <a class="el" href="nvme_8h.html#a6964d09dc51882fae6f2a7cf94afc741" title="Get the default options for I/O qpair creation for a specific NVMe controller.">spdk_nvme_ctrlr_get_default_io_qpair_opts()</a>. </td></tr>
    <tr><td class="paramname">opts_size</td><td>Must be set to sizeof(struct spdk_nvme_io_qpair_opts), or 0 if opts is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated I/O queue pair. </dd></dl>

</div>
</div>
<a id="a8505b00dfaa6123d784c17c293cf3ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8505b00dfaa6123d784c17c293cf3ffc">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_alloc_qid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t spdk_nvme_ctrlr_alloc_qid </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alloc NVMe I/O queue identifier. </p>
<p>This function is only needed for the non-standard case of allocating queues using the raw command interface. In most cases <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2">spdk_nvme_ctrlr_alloc_io_qpair</a> should be sufficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>qid on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ae935583b7f95b13fbd2dd41255490da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae935583b7f95b13fbd2dd41255490da0">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_attach_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_attach_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__ctrlr__list.html">spdk_nvme_ctrlr_list</a> *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach the specified namespace to controllers. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to use for command submission. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace identifier for namespace to attach. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the controller list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if resources could not be allocated for this request. </dd></dl>

</div>
</div>
<a id="a724ed20a1a5adaf30c48db8c28d29677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724ed20a1a5adaf30c48db8c28d29677">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_abort </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>cid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort a specific previously-submitted NVMe command. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#ae2957853179526e6176cf7623b19552b" title="Register for timeout callback on a controller.">spdk_nvme_ctrlr_register_timeout_callback()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to which the command was submitted. </td></tr>
    <tr><td class="paramname">qpair</td><td>NVMe queue pair to which the command was submitted. For admin commands, pass NULL for the qpair. </td></tr>
    <tr><td class="paramname">cid</td><td>Command ID of the command to abort. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the abort has completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="aa02bff8a2cebfc7eb69e5cf23cd36afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02bff8a2cebfc7eb69e5cf23cd36afd">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_abort_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_abort_ext </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cmd_cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort previously submitted commands which have cmd_cb_arg as its callback argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to which the commands were submitted. </td></tr>
    <tr><td class="paramname">qpair</td><td>NVMe queue pair to which the commands were submitted. For admin commands, pass NULL for the qpair. </td></tr>
    <tr><td class="paramname">cmd_cb_arg</td><td>Callback argument for the NVMe commands which this function attempts to abort. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when this function has completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno otherwise. </dd></dl>

</div>
</div>
<a id="afe2a9d3b715649b4d0a0e89196a13e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2a9d3b715649b4d0a0e89196a13e6d">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_admin_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_admin_raw </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the given admin command to the NVMe controller. </p>
<p>This is a low level interface for submitting admin commands directly. Prefer the spdk_nvme_ctrlr_cmd_* functions instead. The validity of the command will not be checked!</p>
<p>When constructing the nvme_command it is not necessary to fill out the PRP list/SGL or the CID. The driver will handle both of those for you.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands.">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">cmd</td><td>NVM admin command to submit. </td></tr>
    <tr><td class="paramname">buf</td><td>Virtual memory address of a single physically contiguous buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Size of buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function invoked when the admin command completes. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="ab7094727eb390b36b56817b83d39d998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7094727eb390b36b56817b83d39d998">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_directive_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_directive_receive </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>doper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dspec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data related to a specific Directive Type from the controller. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands.">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to use for directive receive command submission. </td></tr>
    <tr><td class="paramname">nsid</td><td>Specific Namespace Identifier. </td></tr>
    <tr><td class="paramname">doper</td><td>Directive Operation defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>. </td></tr>
    <tr><td class="paramname">dtype</td><td>Directive Type defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>. </td></tr>
    <tr><td class="paramname">dspec</td><td>Directive Specific defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">cdw12</td><td>Command dword 12. </td></tr>
    <tr><td class="paramname">cdw13</td><td>Command dword 13. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the command has been completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request. </dd></dl>

</div>
</div>
<a id="ada6d60e18019d520ac51ec2a5a598c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6d60e18019d520ac51ec2a5a598c48">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_directive_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_directive_send </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>doper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dspec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data related to a specific Directive Type to the controller. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands.">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to use for directive send command submission. </td></tr>
    <tr><td class="paramname">nsid</td><td>Specific Namespace Identifier. </td></tr>
    <tr><td class="paramname">doper</td><td>Directive Operation defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>. </td></tr>
    <tr><td class="paramname">dtype</td><td>Directive Type defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>. </td></tr>
    <tr><td class="paramname">dspec</td><td>Directive Specific defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">cdw12</td><td>Command dword 12. </td></tr>
    <tr><td class="paramname">cdw13</td><td>Command dword 13. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the command has been completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request. </dd></dl>

</div>
</div>
<a id="a6b4ebba22f1585b98e4ca20932d75434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4ebba22f1585b98e4ca20932d75434">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_get_feature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_get_feature </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get specific feature from given NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands.">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#aa9507cb98ee30e5df98474bc82190476" title="Set specific feature for the given NVMe controller.">spdk_nvme_ctrlr_cmd_set_feature()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to query. </td></tr>
    <tr><td class="paramname">feature</td><td>The feature identifier. </td></tr>
    <tr><td class="paramname">cdw11</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the feature has been retrieved. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, -ENOMEM if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="abc0f038c06c49df0e75148faf6cc4b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0f038c06c49df0e75148faf6cc4b51">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_get_feature_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_get_feature_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ns_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get specific feature from given NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to query. </td></tr>
    <tr><td class="paramname">feature</td><td>The feature identifier. </td></tr>
    <tr><td class="paramname">cdw11</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the feature has been retrieved. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">ns_id</td><td>The namespace identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, -ENOMEM if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer.</dd></dl>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a63fda1acce45c71590ed0db99220d26b" title="Set specific feature for the given NVMe controller and namespace ID.">spdk_nvme_ctrlr_cmd_set_feature_ns()</a> </dd></dl>

</div>
</div>
<a id="a88c881cccf7873bbe4605320ffb0a81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c881cccf7873bbe4605320ffb0a81c">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_get_log_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_get_log_page </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>log_page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific log page from the NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands.">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a7dc6bb842e168a68972ec46cc35591ae" title="Determine if a particular log page is supported by the given NVMe controller.">spdk_nvme_ctrlr_is_log_page_supported()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">log_page</td><td>The log page identifier. </td></tr>
    <tr><td class="paramname">nsid</td><td>Depending on the log page, this may be 0, a namespace identifier, or SPDK_NVME_GLOBAL_NS_TAG. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes within the log page to start retrieving log page data. May only be non-zero if the controller supports extended data for Get Log Page as reported in the controller data log page attributes. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the log page has been retrieved. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="acffdfb142fa1db573a8c8515113f726c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffdfb142fa1db573a8c8515113f726c">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_get_log_page_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_get_log_page_ext </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>log_page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw14</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific log page from the NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>This function allows specifying extra fields in cdw10 and cdw11 such as Retain Asynchronous Event and Log Specific Field.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands.">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a7dc6bb842e168a68972ec46cc35591ae" title="Determine if a particular log page is supported by the given NVMe controller.">spdk_nvme_ctrlr_is_log_page_supported()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">log_page</td><td>The log page identifier. </td></tr>
    <tr><td class="paramname">nsid</td><td>Depending on the log page, this may be 0, a namespace identifier, or SPDK_NVME_GLOBAL_NS_TAG. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes within the log page to start retrieving log page data. May only be non-zero if the controller supports extended data for Get Log Page as reported in the controller data log page attributes. </td></tr>
    <tr><td class="paramname">cdw10</td><td>Value to specify for cdw10. Specify 0 for numdl - it will be set by this function based on the payload_size parameter. Specify 0 for lid - it will be set by this function based on the log_page parameter. </td></tr>
    <tr><td class="paramname">cdw11</td><td>Value to specify for cdw11. Specify 0 for numdu - it will be set by this function based on the payload_size. </td></tr>
    <tr><td class="paramname">cdw14</td><td>Value to specify for cdw14. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the log page has been retrieved. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="a1e3def668122e76abbfb74305f118291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3def668122e76abbfb74305f118291">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_io_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_io_raw </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the given NVM I/O command to the NVMe controller. </p>
<p>This is a low level interface for submitting I/O commands directly. Prefer the spdk_nvme_ns_cmd_* functions instead. The validity of the command will not be checked!</p>
<p>When constructing the nvme_command it is not necessary to fill out the PRP list/SGL or the CID. The driver will handle both of those for you.</p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O qpair to submit command. </td></tr>
    <tr><td class="paramname">cmd</td><td>NVM I/O command to submit. </td></tr>
    <tr><td class="paramname">buf</td><td>Virtual memory address of a single physically contiguous buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Size of buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function invoked when the I/O command completes. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="afd2d8453bb2478c7b1a70c0a09c7ef4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2d8453bb2478c7b1a70c0a09c7ef4b">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_io_raw_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_io_raw_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>md_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the given NVM I/O command with metadata to the NVMe controller. </p>
<p>This is a low level interface for submitting I/O commands directly. Prefer the spdk_nvme_ns_cmd_* functions instead. The validity of the command will not be checked!</p>
<p>When constructing the nvme_command it is not necessary to fill out the PRP list/SGL or the CID. The driver will handle both of those for you.</p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O qpair to submit command. </td></tr>
    <tr><td class="paramname">cmd</td><td>NVM I/O command to submit. </td></tr>
    <tr><td class="paramname">buf</td><td>Virtual memory address of a single physically contiguous buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Size of buffer. </td></tr>
    <tr><td class="paramname">md_buf</td><td>Virtual memory address of a single physically contiguous metadata buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function invoked when the I/O command completes. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="ae7bcc2decc2d4ce01b041601c5cdecea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bcc2decc2d4ce01b041601c5cdecea">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_security_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_security_receive </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>secp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>spsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nssf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive security protocol data from controller. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to use for security receive command submission. </td></tr>
    <tr><td class="paramname">secp</td><td>Security Protocol that is used. </td></tr>
    <tr><td class="paramname">spsp</td><td>Security Protocol Specific field. </td></tr>
    <tr><td class="paramname">nssf</td><td>NVMe Security Specific field. Indicate RPMB target when using Security Protocol EAh. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the command has been completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request. </dd></dl>

</div>
</div>
<a id="a0e7a6bb3ac85f99f936290f679399039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e7a6bb3ac85f99f936290f679399039">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_security_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_security_send </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>secp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>spsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nssf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send security protocol data to controller. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to use for security send command submission. </td></tr>
    <tr><td class="paramname">secp</td><td>Security Protocol that is used. </td></tr>
    <tr><td class="paramname">spsp</td><td>Security Protocol Specific field. </td></tr>
    <tr><td class="paramname">nssf</td><td>NVMe Security Specific field. Indicate RPMB target when using Security Protocol EAh. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the command has been completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request. </dd></dl>

</div>
</div>
<a id="aa9507cb98ee30e5df98474bc82190476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9507cb98ee30e5df98474bc82190476">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_set_feature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_set_feature </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set specific feature for the given NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands.">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a6b4ebba22f1585b98e4ca20932d75434" title="Get specific feature from given NVMe controller.">spdk_nvme_ctrlr_cmd_get_feature()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to manipulate. </td></tr>
    <tr><td class="paramname">feature</td><td>The feature identifier. </td></tr>
    <tr><td class="paramname">cdw11</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">cdw12</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the feature has been set. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="a63fda1acce45c71590ed0db99220d26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fda1acce45c71590ed0db99220d26b">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_set_feature_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_set_feature_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ns_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set specific feature for the given NVMe controller and namespace ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to manipulate. </td></tr>
    <tr><td class="paramname">feature</td><td>The feature identifier. </td></tr>
    <tr><td class="paramname">cdw11</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">cdw12</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the feature has been set. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">ns_id</td><td>The namespace identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, -ENOMEM if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer.</dd></dl>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#abc0f038c06c49df0e75148faf6cc4b51" title="Get specific feature from given NVMe controller.">spdk_nvme_ctrlr_cmd_get_feature_ns()</a> </dd></dl>

</div>
</div>
<a id="a5c0ade8aa72185765104da188581da49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0ade8aa72185765104da188581da49">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_connect_io_qpair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_connect_io_qpair </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect a newly created I/O qpair. </p>
<p>This function does any connection activities required for a newly created qpair. It should be called after spdk_nvme_ctrlr_alloc_io_qpair has been called with the create_only flag set to true in the <a class="el" href="structspdk__nvme__io__qpair__opts.html" title="NVMe I/O queue pair initialization options.">spdk_nvme_io_qpair_opts</a> structure.</p>
<p>This call will fail if performed on a qpair that is already connected. For reconnecting qpairs, see spdk_nvme_ctrlr_reconnect_io_qpair.</p>
<p>For fabrics like TCP and RDMA, this function actually sends the commands over the wire that connect the qpair. For PCIe, this function performs some internal state machine operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller for which to allocate the I/O queue pair. </td></tr>
    <tr><td class="paramname">qpair</td><td>Opaque handle to the qpair to connect.</td></tr>
  </table>
  </dd>
</dl>
<p>return 0 on success or negated errno on failure. Specifically -EISCONN if the qpair is already connected. </p>

</div>
</div>
<a id="ace23485fea91d126a13fe706ce6d8843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace23485fea91d126a13fe706ce6d8843">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_create_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ctrlr_create_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a> *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a namespace. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to create namespace on. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the NVMe namespace data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Namespace ID (&gt;= 1) if successfully created, or 0 if the request failed. </dd></dl>

</div>
</div>
<a id="a7c62e2d4555a5ebc3a3b6f9632c51e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c62e2d4555a5ebc3a3b6f9632c51e1a">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_delete_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_delete_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a namespace. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to delete namespace from. </td></tr>
    <tr><td class="paramname">nsid</td><td>The namespace identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request </dd></dl>

</div>
</div>
<a id="ab562f58b5903071929d6a559fe984d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab562f58b5903071929d6a559fe984d0a">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_detach_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_detach_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__ctrlr__list.html">spdk_nvme_ctrlr_list</a> *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach the specified namespace from controllers. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to use for command submission. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace ID to detach. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the controller list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if resources could not be allocated for this request </dd></dl>

</div>
</div>
<a id="af8a3c1f4f6b5595426fb9bd8974a85fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a3c1f4f6b5595426fb9bd8974a85fe">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_disable_pmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_disable_pmr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the Persistent Memory Region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Controller that contains the Persistent Memory Region</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Negated errno on the following error conditions: -ENOTSUP: PMR is not supported by the Controller. -EIO: Registers access failure. -EINVAL: PMR Time Units Invalid or PMR is already disabled. -ETIMEDOUT: Timed out to Disable PMR. -ENOSYS: Transport does not support Disable PMR function. </dd></dl>

</div>
</div>
<a id="a7708f291658bf471e399354d1247fabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7708f291658bf471e399354d1247fabf">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_disable_read_changed_ns_list_log_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_disable_read_changed_ns_list_log_page </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable reading the CHANGED_NS_LIST log page for the specified controller. </p>
<p>Applications that register an AER callback may wish to read the CHANGED_NS_LIST log page itself, rather than relying on the driver to do it. Calling this function will ensure that the driver does not read this log page if the controller returns a NS_ATTR_CHANGED AEN.</p>
<p>Reading of this log page can alternatively be disabled by setting the disable_read_changed_ns_list_log_page flag in the <a class="el" href="structspdk__nvme__ctrlr__opts.html" title="NVMe controller initialization options.">spdk_nvme_ctrlr_opts</a> when attaching the controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller on which to disable the log page read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a458a65224a0f20c73d0acb44715d86dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458a65224a0f20c73d0acb44715d86dc">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_disconnect </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect the given NVMe controller. </p>
<p>This function is used as the first operation of a full reset sequence of the given NVMe controller. The NVMe controller is ready to reconnect after completing this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -EBUSY if controller is already resetting, or -ENXIO if controller has been removed. </dd></dl>

</div>
</div>
<a id="a2ba2d2f9571a62a47e04ef16e65f9e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba2d2f9571a62a47e04ef16e65f9e7b">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_disconnect_io_qpair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_disconnect_io_qpair </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect the given I/O qpair. </p>
<p>This function must be called from the same thread as spdk_nvme_qpair_process_completions and the spdk_nvme_ns_cmd_* functions.</p>
<p>After disconnect, calling spdk_nvme_qpair_process_completions or one of the spdk_nvme_ns_cmd* on a qpair will result in a return value of -ENXIO. A disconnected qpair may be reconnected with either the spdk_nvme_ctrlr_connect_io_qpair or spdk_nvme_ctrlr_reconnect_io_qpair APIs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The qpair to disconnect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a006a6050d45feefadbf0ce978ca009de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006a6050d45feefadbf0ce978ca009de">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_enable_pmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_enable_pmr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the Persistent Memory Region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Controller that contains the Persistent Memory Region</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Negated errno on the following error conditions: -ENOTSUP: PMR is not supported by the Controller. -EIO: Registers access failure. -EINVAL: PMR Time Units Invalid or PMR is already enabled. -ETIMEDOUT: Timed out to Enable PMR. -ENOSYS: Transport does not support Enable PMR function. </dd></dl>

</div>
</div>
<a id="a4b7578aeee6b6a092a4a4013a2f32ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7578aeee6b6a092a4a4013a2f32ce5">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_fail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_fail </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fail the given NVMe controller. </p>
<p>This function gives the application the opportunity to fail a controller at will. When a controller is failed, any calls to process completions or submit I/O on qpairs associated with that controller will fail with an error code of -ENXIO. The controller can only be taken from the failed state by calling spdk_nvme_ctrlr_reset. After the controller has been successfully reset, any I/O pending when the controller was moved to failed will be aborted back to the application and can be resubmitted. I/O can then resume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to an NVMe controller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bb6973133e1fd5e7a1522ab104ac92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb6973133e1fd5e7a1522ab104ac92b">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_format </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__format.html">spdk_nvme_format</a> *&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format NVM. </p>
<p>This function requests a low-level format of the media.</p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to format. </td></tr>
    <tr><td class="paramname">nsid</td><td>The namespace identifier. May be SPDK_NVME_GLOBAL_NS_TAG to format all namespaces. </td></tr>
    <tr><td class="paramname">format</td><td>The format information for the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request </dd></dl>

</div>
</div>
<a id="a85ec189f50d0f78d73a54413370401f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ec189f50d0f78d73a54413370401f5">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_free_io_qpair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_free_io_qpair </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an I/O queue pair that was allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. </p>
<p>The qpair must not be accessed after calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>I/O queue pair to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. This function will never return any value other than 0. </dd></dl>

</div>
</div>
<a id="a4c2054305f5c7453045eab833b1d4281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c2054305f5c7453045eab833b1d4281">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_free_qid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_free_qid </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>qid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free NVMe I/O queue identifier. </p>
<p>This function must only be called with qids previously allocated with <a class="el" href="nvme_8h.html#a8505b00dfaa6123d784c17c293cf3ffc">spdk_nvme_ctrlr_alloc_qid</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">qid</td><td>NVMe Queue Identifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c11b5ae0a1f6d70f3ab99a13765ea75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c11b5ae0a1f6d70f3ab99a13765ea75">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_admin_qp_failure_reason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvme_8h.html#ab41e2d311eb6663957cd2f18bc8fb890">spdk_nvme_qp_failure_reason</a> spdk_nvme_ctrlr_get_admin_qp_failure_reason </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the reason the admin qpair for a given controller is disconnected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>The controller to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a valid spdk_nvme_qp_failure_reason. </dd></dl>

</div>
</div>
<a id="a5a9daf15b5008ac36c12e7b8db7bdec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9daf15b5008ac36c12e7b8db7bdec9">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__nvme__ctrlr__data.html">spdk_nvme_ctrlr_data</a>* spdk_nvme_ctrlr_get_data </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the identify controller data as defined by the NVMe specification. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the identify controller data. </dd></dl>

</div>
</div>
<a id="ac31bc692c6b3a84e2355eb63a8b01ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31bc692c6b3a84e2355eb63a8b01ccf">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_default_ctrlr_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_get_default_ctrlr_opts </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>opts_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default options for the creation of a specific NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">opts</td><td>Will be filled with the default option. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">opts_size</td><td>Must be set to sizeof(struct spdk_nvme_ctrlr_opts). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6964d09dc51882fae6f2a7cf94afc741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6964d09dc51882fae6f2a7cf94afc741">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_default_io_qpair_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_get_default_io_qpair_opts </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__io__qpair__opts.html">spdk_nvme_io_qpair_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>opts_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default options for I/O qpair creation for a specific NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ctrlr</td><td>NVMe controller to retrieve the defaults from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">opts</td><td>Will be filled with the default options for <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">opts_size</td><td>Must be set to sizeof(struct spdk_nvme_io_qpair_opts). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87a228bf5b96e89305e52721d81920d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a228bf5b96e89305e52721d81920d7">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_discovery_log_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_get_discovery_log_page </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4e4bc7c0002363701bc9363ab2291e6e">spdk_nvme_discovery_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a full discovery log page from the specified controller. </p>
<p>This function will first read the discovery log header to determine the total number of valid entries in the discovery log, then it will allocate a buffer to hold the entire log and issue multiple GET_LOG_PAGE commands to get all of the entries.</p>
<p>The application is responsible for calling <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions</a> to trigger processing of completions submitted by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Pointer to the discovery controller. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Function to call when the operation is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59e69f39c7cb8a9e1c3e00af7804c8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e69f39c7cb8a9e1c3e00af7804c8bd">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_first_active_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ctrlr_get_first_active_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nsid of the first active namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nsid of the first active namespace, 0 if there are no active namespaces. </dd></dl>

</div>
</div>
<a id="af654a7a016511f265b29294fd06ce26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af654a7a016511f265b29294fd06ce26e">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_nvme_ctrlr_get_flags </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get supported flags of the controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to get flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>supported flags of this controller. </dd></dl>

</div>
</div>
<a id="ac750410c9b53a0435d0111ae1e98913e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac750410c9b53a0435d0111ae1e98913e">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_max_xfer_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ctrlr_get_max_xfer_size </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum data transfer size of a given NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum data transfer size of the NVMe controller in bytes.</dd></dl>
<p>The I/O command helper functions, such as <a class="el" href="nvme_8h.html#a084c6ecb53bd810fbb5051100b79bec5" title="Submits a read I/O to the specified NVMe namespace.">spdk_nvme_ns_cmd_read()</a>, will split large I/Os automatically; however, it is up to the user to obey this limit for commands submitted with the raw command functions, such as <a class="el" href="nvme_8h.html#a1e3def668122e76abbfb74305f118291" title="Send the given NVM I/O command to the NVMe controller.">spdk_nvme_ctrlr_cmd_io_raw()</a>. </p>

</div>
</div>
<a id="a6647280570446fbde28b92332be1108d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6647280570446fbde28b92332be1108d">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_memory_domains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_get_memory_domains </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_memory_domain **&#160;</td>
          <td class="paramname"><em>domains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>array_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SPDK memory domains used by the given nvme controller. </p>
<p>The user can call this function with <b>domains</b> set to NULL and <b>array_size</b> set to 0 to get the number of memory domains used by nvme controller</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to the NVMe controller. </td></tr>
    <tr><td class="paramname">domains</td><td>Pointer to an array of memory domains to be filled by this function. The user should allocate big enough array to keep all memory domains used by nvme controller </td></tr>
    <tr><td class="paramname">array_size</td><td>size of <b>domains</b> array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of entries in <b>domains</b> array or negated errno. If returned value is bigger than <b>array_size</b> passed by the user then the user should increase the size of <b>domains</b> array and call this function again. There is no guarantees that the content of <b>domains</b> array is valid in that case. -EINVAL if input parameters were invalid </dd></dl>

</div>
</div>
<a id="abcd528b0df0a564c218dc2745c3af159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd528b0df0a564c218dc2745c3af159">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_next_active_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ctrlr_get_next_active_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>prev_nsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next active namespace given the previous nsid. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">prev_nsid</td><td>Namespace id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a next active namespace given the previous nsid, 0 when there are no more active namespaces. </dd></dl>

</div>
</div>
<a id="a6f01fb8a5f404e41e6fa224a7942be08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f01fb8a5f404e41e6fa224a7942be08">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_ns* spdk_nvme_ctrlr_get_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ns_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to a namespace for the given controller. </p>
<p>Namespaces are numbered from 1 to the total number of namespaces. There will never be any gaps in the numbering. The number of namespaces is obtained by calling <a class="el" href="nvme_8h.html#a02b18deae44682a51177e8a4193af602" title="Get the maximum NSID value that will ever be used for the given controller.">spdk_nvme_ctrlr_get_num_ns()</a>.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">ns_id</td><td>Namespace id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the namespace. </dd></dl>

</div>
</div>
<a id="a02b18deae44682a51177e8a4193af602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b18deae44682a51177e8a4193af602">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_num_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ctrlr_get_num_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum NSID value that will ever be used for the given controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>This is equivalent to calling <a class="el" href="nvme_8h.html#a5a9daf15b5008ac36c12e7b8db7bdec9" title="Get the identify controller data as defined by the NVMe specification.">spdk_nvme_ctrlr_get_data()</a> to get the <a class="el" href="structspdk__nvme__ctrlr__data.html">spdk_nvme_ctrlr_data</a> and then reading the nn field.</p>
<p>The NN field in the NVMe specification represents the maximum value that a namespace ID can ever have. Prior to NVMe 1.2, this was also the number of active namespaces, but from 1.2 onward the list of namespaces may be sparsely populated. Unfortunately, the meaning of this field is often misinterpreted by drive manufacturers and NVMe-oF implementers so it is not considered reliable. AVOID USING THIS FUNCTION WHENEVER POSSIBLE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of namespaces. </dd></dl>

</div>
</div>
<a id="a60d8173db83accb35f0c5fe1ec8261bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d8173db83accb35f0c5fe1ec8261bf">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_pci_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a>* spdk_nvme_ctrlr_get_pci_device </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the PCI device of a given NVMe controller. </p>
<p>This only works for local (PCIe-attached) NVMe controllers; other transports will return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PCI device of the NVMe controller, or NULL if not available. </dd></dl>

</div>
</div>
<a id="a7642f1fc6eec21b93b5f60e386e3e36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7642f1fc6eec21b93b5f60e386e3e36c">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_pmrsz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_nvme_ctrlr_get_pmrsz </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NVMe controller PMR size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the NVMe controller PMR size or 0 if PMR is not supported. </dd></dl>

</div>
</div>
<a id="a887db5ce5c84eba37a4d82f5d180d020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887db5ce5c84eba37a4d82f5d180d020">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile struct <a class="el" href="structspdk__nvme__registers.html">spdk_nvme_registers</a>* spdk_nvme_ctrlr_get_registers </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return virtual address of PCIe NVM I/O registers. </p>
<p>This function returns a pointer to the PCIe I/O registers for a controller or NULL if unsupported for this transport.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Controller whose registers are to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to virtual address of register bank, or NULL. </dd></dl>

</div>
</div>
<a id="ad9f87fef46a6101cc2e9b594d448cb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f87fef46a6101cc2e9b594d448cb37">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_regs_bpinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="unionspdk__nvme__bpinfo__register.html">spdk_nvme_bpinfo_register</a> spdk_nvme_ctrlr_get_regs_bpinfo </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NVMe controller BPINFO (Boot Partition Information) register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the NVMe controller BPINFO (Boot Partition Information) register. </dd></dl>

</div>
</div>
<a id="a6943191f9c88c3cec504f87672b9acf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6943191f9c88c3cec504f87672b9acf8">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_regs_cap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="unionspdk__nvme__cap__register.html">spdk_nvme_cap_register</a> spdk_nvme_ctrlr_get_regs_cap </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NVMe controller CAP (Capabilities) register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the NVMe controller CAP (Capabilities) register. </dd></dl>

</div>
</div>
<a id="a7312bd0bc396b6c714b6cca7073d3f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7312bd0bc396b6c714b6cca7073d3f6d">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_regs_cc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="unionspdk__nvme__cc__register.html">spdk_nvme_cc_register</a> spdk_nvme_ctrlr_get_regs_cc </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NVMe controller CC (Configuration) register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the NVMe controller CC (Configuration) register. </dd></dl>

</div>
</div>
<a id="a260b335960b9d81ac1a2601b003b99cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260b335960b9d81ac1a2601b003b99cd">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_regs_cmbsz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="unionspdk__nvme__cmbsz__register.html">spdk_nvme_cmbsz_register</a> spdk_nvme_ctrlr_get_regs_cmbsz </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NVMe controller CMBSZ (Controller Memory Buffer Size) register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the NVMe controller CMBSZ (Controller Memory Buffer Size) register. </dd></dl>

</div>
</div>
<a id="a46348531c83fd61acad1a55236d7d576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46348531c83fd61acad1a55236d7d576">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_regs_csts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="unionspdk__nvme__csts__register.html">spdk_nvme_csts_register</a> spdk_nvme_ctrlr_get_regs_csts </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NVMe controller CSTS (Status) register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the NVMe controller CSTS (Status) register. </dd></dl>

</div>
</div>
<a id="aae98a4e77ad7bf29414a10966597416c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae98a4e77ad7bf29414a10966597416c">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_regs_pmrcap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="unionspdk__nvme__pmrcap__register.html">spdk_nvme_pmrcap_register</a> spdk_nvme_ctrlr_get_regs_pmrcap </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NVMe controller PMRCAP (Persistent Memory Region Capabilities) register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the NVMe controller PMRCAP (Persistent Memory Region Capabilities) register. </dd></dl>

</div>
</div>
<a id="aacf238fdce21d10c923a384e18b013dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf238fdce21d10c923a384e18b013dd">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_regs_vs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="unionspdk__nvme__vs__register.html">spdk_nvme_vs_register</a> spdk_nvme_ctrlr_get_regs_vs </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NVMe controller VS (Version) register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the NVMe controller VS (Version) register. </dd></dl>

</div>
</div>
<a id="abb7ae9abf97b7c6b57777d06eaa1258a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7ae9abf97b7c6b57777d06eaa1258a">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_transport_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a>* spdk_nvme_ctrlr_get_transport_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transport ID for a given NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Controller to get the transport ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the controller's transport ID. </dd></dl>

</div>
</div>
<a id="a8c00b191b38472b57b06f3f394353ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c00b191b38472b57b06f3f394353ad3">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_io_cmd_raw_no_payload_build()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_io_cmd_raw_no_payload_build </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the given NVM I/O command, I/O buffers, lists and all to the NVMe controller. </p>
<p>This is a low level interface for submitting I/O commands directly.</p>
<p>This function allows a caller to submit an I/O request that is COMPLETELY pre-defined, right down to the "physical" memory buffers. It is intended for testing hardware, specifying exact buffer location, alignment, and offset. It also allows for specific choice of PRP and SGLs.</p>
<p>The driver sets the CID. EVERYTHING else is assumed set by the caller. Needless to say, this is potentially extremely dangerous for both the host (accidental/malicious storage usage/corruption), and the device. Thus its intent is for very specific hardware testing and environment reproduction.</p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<p>This function can only be used on PCIe controllers and qpairs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O qpair to submit command. </td></tr>
    <tr><td class="paramname">cmd</td><td>NVM I/O command to submit. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function invoked when the I/O command completes. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="abbcdb6e7c22b0ef87ed927bf97952c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcdb6e7c22b0ef87ed927bf97952c19">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_is_active_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ctrlr_is_active_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the nsid is an active nv for the given NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if nsid is an active ns, or false otherwise. </dd></dl>

</div>
</div>
<a id="a39c91e2e6ae899f37b5a89c28a2207cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c91e2e6ae899f37b5a89c28a2207cf">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_is_discovery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ctrlr_is_discovery </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate whether a ctrlr handle is associated with a Discovery controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a discovery controller, else false. </dd></dl>

</div>
</div>
<a id="ace8a76223de34edcae773a19a2a7263a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8a76223de34edcae773a19a2a7263a">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_is_fabrics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ctrlr_is_fabrics </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate whether a ctrlr handle is associated with a fabrics controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a fabrics controller, else false. </dd></dl>

</div>
</div>
<a id="a1cdd28db5de54dfee308ea0a3c4f1442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdd28db5de54dfee308ea0a3c4f1442">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_is_failed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ctrlr_is_failed </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the failed status of a given controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to an NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the controller is failed, false otherwise. </dd></dl>

</div>
</div>
<a id="a909b61e141b56eaa5895482aa1f18a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909b61e141b56eaa5895482aa1f18a3b">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_is_feature_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ctrlr_is_feature_supported </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>feature_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a particular feature is supported by the given NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a6b4ebba22f1585b98e4ca20932d75434" title="Get specific feature from given NVMe controller.">spdk_nvme_ctrlr_cmd_get_feature()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">feature_code</td><td>Feature to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if supported, or false otherwise. </dd></dl>

</div>
</div>
<a id="a7dc6bb842e168a68972ec46cc35591ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc6bb842e168a68972ec46cc35591ae">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_is_log_page_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ctrlr_is_log_page_supported </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>log_page</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a particular log page is supported by the given NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a88c881cccf7873bbe4605320ffb0a81c" title="Get a specific log page from the NVMe controller.">spdk_nvme_ctrlr_cmd_get_log_page()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">log_page</td><td>Log page to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if supported, or false otherwise. </dd></dl>

</div>
</div>
<a id="ae4fcdfd45c5b8a6a6ac4b99fff9c66b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4fcdfd45c5b8a6a6ac4b99fff9c66b1">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_map_cmb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_nvme_ctrlr_map_cmb </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a previously reserved controller memory buffer so that it's data is visible from the CPU. </p>
<p>This operation is not always possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Controller that contains the memory buffer </td></tr>
    <tr><td class="paramname">size</td><td>Size of buffer that was mapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to controller memory buffer, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a85f53b3be86d9561f0dfbc87ee827821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f53b3be86d9561f0dfbc87ee827821">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_map_pmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_nvme_ctrlr_map_pmr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map the Persistent Memory Region so that it's data is visible from the CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Controller that contains the Persistent Memory Region </td></tr>
    <tr><td class="paramname">size</td><td>Size of the region that was mapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to Persistent Memory Region, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a10282695461985f58f54de022911745e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10282695461985f58f54de022911745e">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_process_admin_completions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t spdk_nvme_ctrlr_process_admin_completions </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process any outstanding completions for admin commands. </p>
<p>This will process completions for admin commands submitted on any thread.</p>
<p>This call is non-blocking, i.e. it only processes completions that are ready at the time of this function call. It does not wait for outstanding commands to finish.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of completions processed (may be 0) or negated on error. -ENXIO in the special case that the qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="a9439b3f5985d8597ea9c8a41b92edb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9439b3f5985d8597ea9c8a41b92edb9f">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_read_boot_partition_poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_read_boot_partition_poll </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll the status of the Read from a Boot Partition. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to perform the Boot Partition read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if Boot Partition read is successful. Negated errno on the following error conditions: -EIO: Registers access failure. -EINVAL: Invalid read status or the Boot Partition read is not initiated yet. -EAGAIN: If the read is still in progress; users must call spdk_nvme_ctrlr_read_boot_partition_poll again to check the read status. </dd></dl>

</div>
</div>
<a id="aa6b6a2ec4fdc37279739c31bde8ff1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b6a2ec4fdc37279739c31bde8ff1f7">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_read_boot_partition_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_read_boot_partition_start </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bprsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bprof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bpid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the Read from a Boot Partition. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to perform the Boot Partition read. </td></tr>
    <tr><td class="paramname">payload</td><td>The data buffer for Boot Partition read. </td></tr>
    <tr><td class="paramname">bprsz</td><td>Read size in multiples of 4 KiB to copy into the Boot Partition Memory Buffer. </td></tr>
    <tr><td class="paramname">bprof</td><td>Boot Partition offset to read from in 4 KiB units. </td></tr>
    <tr><td class="paramname">bpid</td><td>Boot Partition identifier for the Boot Partition read operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if Boot Partition read is successful. Negated errno on the following error conditions: -ENOMEM: if resources could not be allocated. -ENOTSUP: Boot Partition is not supported by the Controller. -EIO: Registers access failure. -EINVAL: Parameters are invalid. -EFAULT: Invalid address was specified as part of payload. -EALREADY: Boot Partition read already initiated. </dd></dl>

</div>
</div>
<a id="ad26e52f0881a802f40c5f7d1f19e19e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26e52f0881a802f40c5f7d1f19e19e3">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_reconnect_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_reconnect_async </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start re-enabling the given NVMe controller in a full reset sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e04d50b1f27f6cd163a4ea2024a6fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e04d50b1f27f6cd163a4ea2024a6fbb">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_reconnect_io_qpair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_reconnect_io_qpair </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to reconnect the given qpair. </p>
<p>This function is intended to be called on qpairs that have already been connected, but have since entered a failed state as indicated by a return value of -ENXIO from either spdk_nvme_qpair_process_completions or one of the spdk_nvme_ns_cmd_* functions. This function must be called from the same thread as spdk_nvme_qpair_process_completions and the spdk_nvme_ns_cmd_* functions.</p>
<p>Calling this function has the same effect as calling spdk_nvme_ctrlr_disconnect_io_qpair followed by spdk_nvme_ctrlr_connect_io_qpair.</p>
<p>This function may be called on newly created qpairs, but it does extra checks and attempts to disconnect the qpair before connecting it. The recommended API for newly created qpairs is spdk_nvme_ctrlr_connect_io_qpair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The qpair to reconnect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or if the qpair was already connected. -EAGAIN if the driver was unable to reconnect during this call, but the controller is still connected and is either resetting or enabled. -ENODEV if the controller is removed. In this case, the controller cannot be recovered and the application will have to destroy it and the associated qpairs. -ENXIO if the controller is in a failed state but is not yet resetting. In this case, the application should call spdk_nvme_ctrlr_reset to reset the entire controller. </dd></dl>

</div>
</div>
<a id="acd56920dfc24752852b2c63fa5e4fd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd56920dfc24752852b2c63fa5e4fd46">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_reconnect_poll_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_reconnect_poll_async </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Proceed with re-enabling the given NVMe controller. </p>
<p>Users must call this function in a full reset sequence until it returns a value other than -EAGAIN.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if the given NVMe controller is enabled, or -EBUSY if there are still pending operations to enable it. </dd></dl>

</div>
</div>
<a id="a1505fc1ef6e8ccb00134c1fa15e0368b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1505fc1ef6e8ccb00134c1fa15e0368b">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_register_aer_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_register_aer_callback </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1d066bb761dc3481f081d0d6924766ee">spdk_nvme_aer_cb</a>&#160;</td>
          <td class="paramname"><em>aer_cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aer_cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register callback function invoked when an AER command is completed for the given NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">aer_cb_fn</td><td>Callback function invoked when an asynchronous event request command is completed. </td></tr>
    <tr><td class="paramname">aer_cb_arg</td><td>Argument passed to callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2957853179526e6176cf7623b19552b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2957853179526e6176cf7623b19552b">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_register_timeout_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_register_timeout_callback </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_io_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_admin_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a53fe1c01a447be8fcd29821a668227a0">spdk_nvme_timeout_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register for timeout callback on a controller. </p>
<p>The application can choose to register for timeout callback or not register for timeout callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller on which to monitor for timeout. </td></tr>
    <tr><td class="paramname">timeout_io_us</td><td>Timeout value in microseconds for io commands. </td></tr>
    <tr><td class="paramname">timeout_admin_us</td><td>Timeout value in microseconds for admin commands. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A function pointer that points to the callback function. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a3ac9bb888c2b660191f94d208caaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3ac9bb888c2b660191f94d208caaf1">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_reserve_cmb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_reserve_cmb </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve the controller memory buffer for data transfer use. </p>
<p>This function reserves the full size of the controller memory buffer for use in data transfers. If submission queues or completion queues are already placed in the controller memory buffer, this call will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Controller from which to allocate memory buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the controller memory buffer on success. Negated errno on failure. </dd></dl>

</div>
</div>
<a id="ae13ccd2ea831842a5008eb95a32545c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13ccd2ea831842a5008eb95a32545c3">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_reset </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a full hardware reset of the NVMe controller. </p>
<p>This function should be called from a single thread while no other threads are actively using the NVMe device.</p>
<p>Any pointers returned from <a class="el" href="nvme_8h.html#a6f01fb8a5f404e41e6fa224a7942be08" title="Get a handle to a namespace for the given controller.">spdk_nvme_ctrlr_get_ns()</a>, <a class="el" href="nvme_8h.html#ab1863b5dccf2bcc49fe92275bc1e5a2a" title="Get the identify namespace data as defined by the NVMe specification.">spdk_nvme_ns_get_data()</a>, <a class="el" href="nvme__zns_8h.html#a2060f12903d107efb4d7c26a9c0a83a8" title="Get the Zoned Namespace Command Set Specific Identify Namespace data as defined by the NVMe Zoned Nam...">spdk_nvme_zns_ns_get_data()</a>, and <a class="el" href="nvme__zns_8h.html#a7e44f2e8ad190636f5b7e18bbfe3d301" title="Get the Zoned Namespace Command Set Specific Identify Controller data as defined by the NVMe Zoned Na...">spdk_nvme_zns_ctrlr_get_data()</a> may be invalidated by calling this function. The number of namespaces as returned by <a class="el" href="nvme_8h.html#a02b18deae44682a51177e8a4193af602" title="Get the maximum NSID value that will ever be used for the given controller.">spdk_nvme_ctrlr_get_num_ns()</a> may also change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a0547769c5a00f5b502ea4f71f2fff947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0547769c5a00f5b502ea4f71f2fff947">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_reset_subsystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_reset_subsystem </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a NVMe subsystem reset. </p>
<p>This function should be called from a single thread while no other threads are actively using the NVMe device. A subsystem reset is typically seen by the OS as a hot remove, followed by a hot add event.</p>
<p>Any pointers returned from <a class="el" href="nvme_8h.html#a6f01fb8a5f404e41e6fa224a7942be08" title="Get a handle to a namespace for the given controller.">spdk_nvme_ctrlr_get_ns()</a>, <a class="el" href="nvme_8h.html#ab1863b5dccf2bcc49fe92275bc1e5a2a" title="Get the identify namespace data as defined by the NVMe specification.">spdk_nvme_ns_get_data()</a>, <a class="el" href="nvme__zns_8h.html#a2060f12903d107efb4d7c26a9c0a83a8" title="Get the Zoned Namespace Command Set Specific Identify Namespace data as defined by the NVMe Zoned Nam...">spdk_nvme_zns_ns_get_data()</a>, and <a class="el" href="nvme__zns_8h.html#a7e44f2e8ad190636f5b7e18bbfe3d301" title="Get the Zoned Namespace Command Set Specific Identify Controller data as defined by the NVMe Zoned Na...">spdk_nvme_zns_ctrlr_get_data()</a> may be invalidated by calling this function. The number of namespaces as returned by <a class="el" href="nvme_8h.html#a02b18deae44682a51177e8a4193af602" title="Get the maximum NSID value that will ever be used for the given controller.">spdk_nvme_ctrlr_get_num_ns()</a> may also change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure, -ENOTSUP if subsystem reset is not supported. </dd></dl>

</div>
</div>
<a id="a5175d6805225d84d6e4aa4e0f1546c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5175d6805225d84d6e4aa4e0f1546c69">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_security_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_security_receive </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>secp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>spsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nssf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive security protocol data from controller. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to use for security receive command submission. </td></tr>
    <tr><td class="paramname">secp</td><td>Security Protocol that is used. </td></tr>
    <tr><td class="paramname">spsp</td><td>Security Protocol Specific field. </td></tr>
    <tr><td class="paramname">nssf</td><td>NVMe Security Specific field. Indicate RPMB target when using Security Protocol EAh. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of payload buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request. </dd></dl>

</div>
</div>
<a id="ada4ab089f73f3f43e9c5b8e6415e6f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4ab089f73f3f43e9c5b8e6415e6f50">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_security_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_security_send </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>secp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>spsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nssf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send security protocol data to controller. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to use for security send command submission. </td></tr>
    <tr><td class="paramname">secp</td><td>Security Protocol that is used. </td></tr>
    <tr><td class="paramname">spsp</td><td>Security Protocol Specific field. </td></tr>
    <tr><td class="paramname">nssf</td><td>NVMe Security Specific field. Indicate RPMB target when using Security Protocol EAh. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of payload buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request. </dd></dl>

</div>
</div>
<a id="aab29a85672c9837b13e3041da7efce5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab29a85672c9837b13e3041da7efce5e">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_set_remove_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_set_remove_cb </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a>&#160;</td>
          <td class="paramname"><em>remove_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>remove_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the remove callback and context to be invoked if the controller is removed. </p>
<p>This will override any remove_cb and/or ctx specified when the controller was probed.</p>
<p>This function may only be called from the primary process. This function has no effect if called from a secondary process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to an NVMe controller. </td></tr>
    <tr><td class="paramname">remove_cb</td><td>remove callback </td></tr>
    <tr><td class="paramname">remove_ctx</td><td>remove callback context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6eacd62ee8fbab40e1066bc0a53485f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eacd62ee8fbab40e1066bc0a53485f3">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_set_trid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_set_trid </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the transport ID for a given controller. </p>
<p>This function allows the user to set a new trid for a controller only if the controller is failed. The controller's failed state can be obtained from <a class="el" href="nvme_8h.html#a1cdd28db5de54dfee308ea0a3c4f1442" title="This function returns the failed status of a given controller.">spdk_nvme_ctrlr_is_failed()</a>. The controller can also be forced to the failed state using <a class="el" href="nvme_8h.html#a4b7578aeee6b6a092a4a4013a2f32ce5" title="Fail the given NVMe controller.">spdk_nvme_ctrlr_fail()</a>.</p>
<p>This function also requires that the transport type and subnqn of the new trid be the same as the old trid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to an NVMe controller. </td></tr>
    <tr><td class="paramname">trid</td><td>The new transport ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -EINVAL if the trid is invalid, -EPERM if the ctrlr is not failed. </dd></dl>

</div>
</div>
<a id="a645844b863c5c40a0f3eb0c72d80e0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645844b863c5c40a0f3eb0c72d80e0ff">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_unmap_cmb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_unmap_cmb </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a controller memory I/O buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Controller from which to unmap the memory buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07bd04caa1e443e7709540e0dac7d4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bd04caa1e443e7709540e0dac7d4ee">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_unmap_pmr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_unmap_pmr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the Persistent Memory Region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Controller from which to unmap the Persistent Memory Region.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno on failure. -ENXIO: Either PMR is not supported by the Controller or the PMR is already unmapped. -ENOSYS: Transport does not support Unmap PMR function. </dd></dl>

</div>
</div>
<a id="a7938b258a7614073065be4f6a35bd0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7938b258a7614073065be4f6a35bd0e2">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_update_firmware()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_update_firmware </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#ae4da1c1bec22eb22d1af72bbf37af36e">spdk_nvme_fw_commit_action</a>&#160;</td>
          <td class="paramname"><em>commit_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__status.html">spdk_nvme_status</a> *&#160;</td>
          <td class="paramname"><em>completion_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Download a new firmware image. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to perform firmware operation on. </td></tr>
    <tr><td class="paramname">payload</td><td>The data buffer for the firmware image. </td></tr>
    <tr><td class="paramname">size</td><td>The data size will be downloaded. </td></tr>
    <tr><td class="paramname">slot</td><td>The slot that the firmware image will be committed to. </td></tr>
    <tr><td class="paramname">commit_action</td><td>The action to perform when firmware is committed. </td></tr>
    <tr><td class="paramname">completion_status</td><td>output parameter. Contains the completion status of the firmware commit operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if resources could not be allocated for this request, -1 if the size is not multiple of 4. </dd></dl>

</div>
</div>
<a id="a3e5da9877e5b3a256478f6dc698fbb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5da9877e5b3a256478f6dc698fbb0c">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_write_boot_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_write_boot_partition </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to a Boot Partition. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>. Users will get the completion after the data is downloaded, image is replaced and Boot Partition is activated or when the sequence encounters an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to perform the Boot Partition write. </td></tr>
    <tr><td class="paramname">payload</td><td>The data buffer for Boot Partition write. </td></tr>
    <tr><td class="paramname">size</td><td>Data size to write to the Boot Partition. </td></tr>
    <tr><td class="paramname">bpid</td><td>Boot Partition identifier for the Boot Partition write operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the operation is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if Boot Partition write submit is successful. Negated errno on the following error conditions: -ENOMEM: if resources could not be allocated. -ENOTSUP: Boot Partition is not supported by the Controller. -EIO: Registers access failure. -EINVAL: Parameters are invalid. </dd></dl>

</div>
</div>
<a id="aa645963334716b9b7276a7269eb2e379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa645963334716b9b7276a7269eb2e379">&#9670;&nbsp;</a></span>spdk_nvme_cuse_get_ctrlr_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_cuse_get_ctrlr_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get name of cuse device associated with NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">name</td><td>Buffer of be filled with cuse device name. </td></tr>
    <tr><td class="paramname">size</td><td>Size of name buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Negated errno on the following error conditions: -ENODEV: No cuse device registered for the controller. -ENSPC: Too small buffer size passed. Value of size pointer changed to the required length. </dd></dl>

</div>
</div>
<a id="a8cf38d8b0e0625dc192a83926952283a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf38d8b0e0625dc192a83926952283a">&#9670;&nbsp;</a></span>spdk_nvme_cuse_get_ns_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_cuse_get_ns_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get name of cuse device associated with NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace id. </td></tr>
    <tr><td class="paramname">name</td><td>Buffer of be filled with cuse device name. </td></tr>
    <tr><td class="paramname">size</td><td>Size of name buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Negated errno on the following error conditions: -ENODEV: No cuse device registered for the namespace. -ENSPC: Too small buffer size passed. Value of size pointer changed to the required length. </dd></dl>

</div>
</div>
<a id="a5ba8ee34c024d648a81d903b155cff97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba8ee34c024d648a81d903b155cff97">&#9670;&nbsp;</a></span>spdk_nvme_cuse_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_cuse_register </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a character device at the path specified (Experimental) </p>
<p>The character device can handle ioctls and is compatible with a standard Linux kernel NVMe device. Tools such as nvme-cli can be used to configure SPDK devices through this interface.</p>
<p>The user is expected to be polling the admin qpair for this controller periodically for the CUSE device to function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to the NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Negated errno on failure. </dd></dl>

</div>
</div>
<a id="a2cd4f33cc8dc7741290b9cdf02fc691c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd4f33cc8dc7741290b9cdf02fc691c">&#9670;&nbsp;</a></span>spdk_nvme_cuse_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_cuse_unregister </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a previously created character device (Experimental) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to the NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Negated errno on failure. </dd></dl>

</div>
</div>
<a id="ac8157e10a468a618d04accf1830d59cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8157e10a468a618d04accf1830d59cd">&#9670;&nbsp;</a></span>spdk_nvme_cuse_update_namespaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_cuse_update_namespaces </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update and populate namespace CUSE devices (Experimental) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to the NVMe controller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b63c225c3cce6da60fdbfb6f54b11e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b63c225c3cce6da60fdbfb6f54b11e2">&#9670;&nbsp;</a></span>spdk_nvme_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_detach </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach specified device returned by <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>'s attach_cb from the NVMe driver. </p>
<p>On success, the spdk_nvme_ctrlr handle is no longer valid.</p>
<p>This function should be called from a single thread while no other threads are actively using the NVMe device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a30f8edb4791c426ccec2b815ca0ed791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f8edb4791c426ccec2b815ca0ed791">&#9670;&nbsp;</a></span>spdk_nvme_detach_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_detach_async </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_detach_ctx **&#160;</td>
          <td class="paramname"><em>detach_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a context to track detachment of multiple controllers if this call is the first successful start of detachment in a sequence, or use the passed context otherwise. </p>
<p>Then, start detaching the specified device returned by <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>'s attach_cb from the NVMe driver, and append this detachment to the context.</p>
<p>User must call <a class="el" href="nvme_8h.html#a19178860f90bdd522eaa329d0ff837fe" title="Poll detachment of multiple controllers until they complete.">spdk_nvme_detach_poll_async()</a> to complete the detachment.</p>
<p>If the context is not allocated before this call, and if the specified device is detached locally from the caller process but any other process still attaches it or failed to be detached, context is not allocated.</p>
<p>This function should be called from a single thread while no other threads are actively using the NVMe device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">detach_ctx</td><td>Reference to the context in a sequence. An new context is allocated if this call is the first successful start of detachment in a sequence, or use the passed context. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a053bcfa48d3c4b20ac4a408fa5e61418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053bcfa48d3c4b20ac4a408fa5e61418">&#9670;&nbsp;</a></span>spdk_nvme_detach_poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_detach_poll </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_detach_ctx *&#160;</td>
          <td class="paramname"><em>detach_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Continue calling <a class="el" href="nvme_8h.html#a19178860f90bdd522eaa329d0ff837fe" title="Poll detachment of multiple controllers until they complete.">spdk_nvme_detach_poll_async()</a> internally until it returns 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detach_ctx</td><td>Context to track the detachment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19178860f90bdd522eaa329d0ff837fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19178860f90bdd522eaa329d0ff837fe">&#9670;&nbsp;</a></span>spdk_nvme_detach_poll_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_detach_poll_async </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_detach_ctx *&#160;</td>
          <td class="paramname"><em>detach_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll detachment of multiple controllers until they complete. </p>
<p>User must call this function until it returns 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detach_ctx</td><td>Context to track the detachment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if all detachments complete; the context is also freed and no longer valid. </dd>
<dd>
-EAGAIN if any detachment is still in progress; users must call <a class="el" href="nvme_8h.html#a19178860f90bdd522eaa329d0ff837fe" title="Poll detachment of multiple controllers until they complete.">spdk_nvme_detach_poll_async()</a> again to continue progress. </dd></dl>

</div>
</div>
<a id="ad068dd50f11160450098712422116785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad068dd50f11160450098712422116785">&#9670;&nbsp;</a></span>spdk_nvme_host_id_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_host_id_parse </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__host__id.html">spdk_nvme_host_id</a> *&#160;</td>
          <td class="paramname"><em>hostid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the string representation of a host ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostid</td><td>Output host ID structure (must be allocated and initialized by caller). </td></tr>
    <tr><td class="paramname">str</td><td>Input string representation of a transport ID to parse (hostid is a sub-configuration).</td></tr>
  </table>
  </dd>
</dl>
<p>str must be a zero-terminated C string containing one or more key:value pairs separated by whitespace.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Key   </th><th class="markdownTableHeadNone">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">hostaddr   </td><td class="markdownTableBodyNone">Transport address (e.g. 192.168.100.8 for RDMA)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">hostsvcid   </td><td class="markdownTableBodyNone">Transport service identifier (e.g. 4420)   </td></tr>
</table>
<p>Unspecified fields of trid are left unmodified, so the caller must initialize hostid (for example, memset() to 0) before calling this function.</p>
<p>This function should not be used with Fiber Channel or PCIe as these transports do not require host information for connections.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if parsing was successful and hostid is filled out, or negated errno values on failure. </dd></dl>

</div>
</div>
<a id="ad8aa3c9ff510fe73945549077df18436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8aa3c9ff510fe73945549077df18436">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_compare </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a compare I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the compare I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to the data payload. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to compare the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the compare operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>, for this I/O.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a4bf7a40872bfe623a5dfa31922263532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf7a40872bfe623a5dfa31922263532">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_compare_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_compare_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a compare I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the compare I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to the data payload. </td></tr>
    <tr><td class="paramname">metadata</td><td>Virtual address pointer to the metadata payload, the length of metadata is specified by <a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2" title="Get the metadata size, in bytes, of the given namespace.">spdk_nvme_ns_get_md_size()</a>. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to compare the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the compare operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>, for this I/O. </td></tr>
    <tr><td class="paramname">apptag_mask</td><td>Application tag mask. </td></tr>
    <tr><td class="paramname">apptag</td><td>Application tag to use end-to-end protection information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a108d6b722c8837593dec16f30376d182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108d6b722c8837593dec16f30376d182">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_comparev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_comparev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a compare I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the compare I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to compare the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the compare operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>, for this I/O. </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>Callback function to reset scattered payload. </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>Callback function to iterate each scattered payload memory segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a47e7d5f0f025d25026f1225d2f6c9a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e7d5f0f025d25026f1225d2f6c9a4b">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_comparev_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_comparev_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a compare I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the compare I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to compare the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the compare operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>, for this I/O. </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>Callback function to reset scattered payload. </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>Callback function to iterate each scattered payload memory segment. </td></tr>
    <tr><td class="paramname">metadata</td><td>Virtual address pointer to the metadata payload, the length of metadata is specified by <a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2" title="Get the metadata size, in bytes, of the given namespace.">spdk_nvme_ns_get_md_size()</a> </td></tr>
    <tr><td class="paramname">apptag_mask</td><td>Application tag mask. </td></tr>
    <tr><td class="paramname">apptag</td><td>Application tag to use end-to-end protection information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="ad6604babca780495c910145f915d5ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6604babca780495c910145f915d5ea2">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_copy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__scc__source__range.html">spdk_nvme_scc_source_range</a> *&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>dest_lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a simple copy command request to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<p>This is a convenience wrapper that will automatically allocate and construct the correct data buffers. Therefore, ranges does not need to be allocated from pinned memory and can be placed on the stack. If a higher performance, zero-copy version of SCC is required, simply build and submit a raw command using <a class="el" href="nvme_8h.html#a1e3def668122e76abbfb74305f118291" title="Send the given NVM I/O command to the NVMe controller.">spdk_nvme_ctrlr_cmd_io_raw()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the SCC request </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">ranges</td><td>An array of <a class="el" href="structspdk__nvme__scc__source__range.html">spdk_nvme_scc_source_range</a> elements describing the LBAs to operate on. </td></tr>
    <tr><td class="paramname">num_ranges</td><td>The number of elements in the ranges array. </td></tr>
    <tr><td class="paramname">dest_lba</td><td>Destination LBA to copy the data. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -ENOMEM: The request cannot be allocated. -EINVAL: Invalid ranges. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="ac0c646dd18675c54ffcf834ce699658d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c646dd18675c54ffcf834ce699658d">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_dataset_management()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_dataset_management </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__dsm__range.html">spdk_nvme_dsm_range</a> *&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a data set management request to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<p>This is a convenience wrapper that will automatically allocate and construct the correct data buffers. Therefore, ranges does not need to be allocated from pinned memory and can be placed on the stack. If a higher performance, zero-copy version of DSM is required, simply build and submit a raw command using <a class="el" href="nvme_8h.html#a1e3def668122e76abbfb74305f118291" title="Send the given NVM I/O command to the NVMe controller.">spdk_nvme_ctrlr_cmd_io_raw()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the DSM request </td></tr>
    <tr><td class="paramname">type</td><td>A bit field constructed from <a class="el" href="nvme__spec_8h.html#a553aa11d679deea767299b75e8ff5fca">spdk_nvme_dsm_attribute</a>. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">ranges</td><td>An array of <a class="el" href="structspdk__nvme__dsm__range.html">spdk_nvme_dsm_range</a> elements describing the LBAs to operate on. </td></tr>
    <tr><td class="paramname">num_ranges</td><td>The number of elements in the ranges array. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="aed0b134e140121bb9bd8664d4a43a5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0b134e140121bb9bd8664d4a43a5c6">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_flush </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a flush request to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the flush request. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="ac37d0d0eaebbc73c1dcaa246a3d1253a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37d0d0eaebbc73c1dcaa246a3d1253a">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_io_mgmt_recv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_io_mgmt_recv </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an I/O management receive command to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the I/O mgmt receive request. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer for I/O mgmt receive data. </td></tr>
    <tr><td class="paramname">len</td><td>Length bytes for I/O mgmt receive data structure. </td></tr>
    <tr><td class="paramname">mo</td><td>Management operation to perform. </td></tr>
    <tr><td class="paramname">mos</td><td>Management operation specific field for the mo. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="ac2d713cade7319ea13dcebe41fff2431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d713cade7319ea13dcebe41fff2431">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_io_mgmt_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_io_mgmt_send </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an I/O management send command to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the I/O mgmt send request. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer for I/O mgmt send data. </td></tr>
    <tr><td class="paramname">len</td><td>Length bytes for I/O mgmt send data structure. </td></tr>
    <tr><td class="paramname">mo</td><td>Management operation to perform. </td></tr>
    <tr><td class="paramname">mos</td><td>Management operation specific field for the mo. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a084c6ecb53bd810fbb5051100b79bec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084c6ecb53bd810fbb5051100b79bec5">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_read </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a read I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the read I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to the data payload. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to read the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the read operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>, for this I/O.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="aa2913b93326e636eca6dfe7b42e349fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2913b93326e636eca6dfe7b42e349fe">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_read_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_read_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a read I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the read I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">payload</td><td>virtual address pointer to the data payload </td></tr>
    <tr><td class="paramname">metadata</td><td>virtual address pointer to the metadata payload, the length of metadata is specified by <a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2" title="Get the metadata size, in bytes, of the given namespace.">spdk_nvme_ns_get_md_size()</a>. </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA to read the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the read operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>, for this I/O. </td></tr>
    <tr><td class="paramname">apptag_mask</td><td>Application tag mask. </td></tr>
    <tr><td class="paramname">apptag</td><td>Application tag to use end-to-end protection information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="acb47ce7de6b6e963ec9fb8de261466ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb47ce7de6b6e963ec9fb8de261466ae">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_readv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_readv </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the read I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to read the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the read operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>, for this I/O. </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>Callback function to reset scattered payload. </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>Callback function to iterate each scattered payload memory segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="af4a40bbc5ff993609f20d6b4f2a35f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a40bbc5ff993609f20d6b4f2a35f93">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_readv_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_readv_ext </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__ns__cmd__ext__io__opts.html">spdk_nvme_ns_cmd_ext_io_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the read I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA to read the data </td></tr>
    <tr><td class="paramname">lba_count</td><td>length (in sectors) for the read operation </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>callback function to reset scattered payload </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>callback function to iterate each scattered payload memory segment </td></tr>
    <tr><td class="paramname">opts</td><td>Optional structure with extended IO request options. If provided, the caller must guarantee that this structure is accessible until IO completes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. -EFAULT: Invalid address was specified as part of payload. cb_fn is also called with error status including dnr=1 in this case. </dd></dl>

</div>
</div>
<a id="a08afb91732d92d84a054012cd3d236aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08afb91732d92d84a054012cd3d236aa">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_readv_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_readv_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the read I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA to read the data </td></tr>
    <tr><td class="paramname">lba_count</td><td>length (in sectors) for the read operation </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function </td></tr>
    <tr><td class="paramname">io_flags</td><td>set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>, for this I/O </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>callback function to reset scattered payload </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>callback function to iterate each scattered payload memory segment </td></tr>
    <tr><td class="paramname">metadata</td><td>virtual address pointer to the metadata payload, the length of metadata is specified by <a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2" title="Get the metadata size, in bytes, of the given namespace.">spdk_nvme_ns_get_md_size()</a> </td></tr>
    <tr><td class="paramname">apptag_mask</td><td>application tag mask. </td></tr>
    <tr><td class="paramname">apptag</td><td>application tag to use end-to-end protection information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="abb8028f294d09711401d098e89d87f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8028f294d09711401d098e89d87f38">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_reservation_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_reservation_acquire </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__reservation__acquire__data.html">spdk_nvme_reservation_acquire_data</a> *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#a95b3685443c2716ee0d125c30182aeac">spdk_nvme_reservation_acquire_action</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#aa7e108757c0eebbac7e13b598a378210">spdk_nvme_reservation_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a reservation acquire to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the reservation acquire request. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to reservation acquire data. </td></tr>
    <tr><td class="paramname">ignore_key</td><td>'1' the current reservation key check is disabled. </td></tr>
    <tr><td class="paramname">action</td><td>Specifies the reservation acquire action. </td></tr>
    <tr><td class="paramname">type</td><td>Reservation type for the namespace. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="ad5c140c47970bafbfec36bf6e4c37704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c140c47970bafbfec36bf6e4c37704">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_reservation_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_reservation_register </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__reservation__register__data.html">spdk_nvme_reservation_register_data</a> *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#a178a7468a0a9c3e814ca2ba80e3406e5">spdk_nvme_reservation_register_action</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#a05b2db4a398c119c029c234a68760c73">spdk_nvme_reservation_register_cptpl</a>&#160;</td>
          <td class="paramname"><em>cptpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a reservation register to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the reservation register request. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to the reservation register data. </td></tr>
    <tr><td class="paramname">ignore_key</td><td>'1' the current reservation key check is disabled. </td></tr>
    <tr><td class="paramname">action</td><td>Specifies the registration action. </td></tr>
    <tr><td class="paramname">cptpl</td><td>Change the Persist Through Power Loss state. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="aa2b1d9de51027da9a66fe12e2ce28132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b1d9de51027da9a66fe12e2ce28132">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_reservation_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_reservation_release </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__reservation__key__data.html">spdk_nvme_reservation_key_data</a> *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#a6fa8ea66c4927d8bb4d81d76867e851a">spdk_nvme_reservation_release_action</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#aa7e108757c0eebbac7e13b598a378210">spdk_nvme_reservation_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a reservation release to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the reservation release request. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to current reservation key. </td></tr>
    <tr><td class="paramname">ignore_key</td><td>'1' the current reservation key check is disabled. </td></tr>
    <tr><td class="paramname">action</td><td>Specifies the reservation release action. </td></tr>
    <tr><td class="paramname">type</td><td>Reservation type for the namespace. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a9a7b5944bda3fe9ef1c83fcd2025b39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7b5944bda3fe9ef1c83fcd2025b39a">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_reservation_report()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_reservation_report </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a reservation report to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the reservation report request. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer for reservation status data. </td></tr>
    <tr><td class="paramname">len</td><td>Length bytes for reservation status data structure. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a686bdbdf30351e164ce8f8c317621ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686bdbdf30351e164ce8f8c317621ace">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_verify </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a verify I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the verify I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to verify the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the verify operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">spdk/nvme_spec.h</a>, for this I/O.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a3065f669d8b605efdcadffbf94a50538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3065f669d8b605efdcadffbf94a50538">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_write </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to the data payload. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to write the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the write operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">spdk/nvme_spec.h</a>, for this I/O.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="ab2f23130b6ebdb7b3e4086545e422e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f23130b6ebdb7b3e4086545e422e59">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_write_uncorrectable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_write_uncorrectable </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write uncorrectable I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write uncorrectable I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA for this command. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the write uncorrectable operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="adc2aa2be0d657be0c63d5abc02b274ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2aa2be0d657be0c63d5abc02b274ec">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_write_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_write_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to the data payload. </td></tr>
    <tr><td class="paramname">metadata</td><td>Virtual address pointer to the metadata payload, the length of metadata is specified by <a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2" title="Get the metadata size, in bytes, of the given namespace.">spdk_nvme_ns_get_md_size()</a>. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to write the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the write operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">spdk/nvme_spec.h</a>, for this I/O. </td></tr>
    <tr><td class="paramname">apptag_mask</td><td>Application tag mask. </td></tr>
    <tr><td class="paramname">apptag</td><td>Application tag to use end-to-end protection information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="af02e8c701c5496f163a69917ad5397dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02e8c701c5496f163a69917ad5397dd">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_write_zeroes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_write_zeroes </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write zeroes I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write zeroes I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA for this command. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the write zero operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">spdk/nvme_spec.h</a>, for this I/O.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="adfcbb5d31f0b572847cc8ae8b07dfcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcbb5d31f0b572847cc8ae8b07dfcfb">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_writev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_writev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to write the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the write operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>, for this I/O. </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>Callback function to reset scattered payload. </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>Callback function to iterate each scattered payload memory segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a7c98eff7f5474a7044112202fbbf77bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c98eff7f5474a7044112202fbbf77bb">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_writev_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_writev_ext </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__ns__cmd__ext__io__opts.html">spdk_nvme_ns_cmd_ext_io_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA to write the data </td></tr>
    <tr><td class="paramname">lba_count</td><td>length (in sectors) for the write operation </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>callback function to reset scattered payload </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>callback function to iterate each scattered payload memory segment </td></tr>
    <tr><td class="paramname">opts</td><td>Optional structure with extended IO request options. If provided, the caller must guarantee that this structure is accessible until IO completes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. -EFAULT: Invalid address was specified as part of payload. cb_fn is also called with error status including dnr=1 in this case. </dd></dl>

</div>
</div>
<a id="ab4d42660e3de76f75f4b5d79ed9b1d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d42660e3de76f75f4b5d79ed9b1d01">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_writev_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_writev_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue).">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA to write the data </td></tr>
    <tr><td class="paramname">lba_count</td><td>length (in sectors) for the write operation </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function </td></tr>
    <tr><td class="paramname">io_flags</td><td>set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions.">nvme_spec.h</a>, for this I/O </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>callback function to reset scattered payload </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>callback function to iterate each scattered payload memory segment </td></tr>
    <tr><td class="paramname">metadata</td><td>virtual address pointer to the metadata payload, the length of metadata is specified by <a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2" title="Get the metadata size, in bytes, of the given namespace.">spdk_nvme_ns_get_md_size()</a> </td></tr>
    <tr><td class="paramname">apptag_mask</td><td>application tag mask. </td></tr>
    <tr><td class="paramname">apptag</td><td>application tag to use end-to-end protection information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="aae2886938b54c456dfb12861305bed24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2886938b54c456dfb12861305bed24">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_ana_group_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_ana_group_id </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ANA group ID for the given namespace. </p>
<p>This function should be called only if <a class="el" href="nvme_8h.html#a7dc6bb842e168a68972ec46cc35591ae" title="Determine if a particular log page is supported by the given NVMe controller.">spdk_nvme_ctrlr_is_log_page_supported()</a> returns true for the controller and log page ID SPDK_NVME_LOG_ASYMMETRIC_NAMESPACE_ACCESS.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ANA group ID for the given namespace. </dd></dl>

</div>
</div>
<a id="a204d7f2669bc34a9d45ec28d3a661b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204d7f2669bc34a9d45ec28d3a661b21">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_ana_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum spdk_nvme_ana_state spdk_nvme_ns_get_ana_state </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ANA state for the given namespace. </p>
<p>This function should be called only if <a class="el" href="nvme_8h.html#a7dc6bb842e168a68972ec46cc35591ae" title="Determine if a particular log page is supported by the given NVMe controller.">spdk_nvme_ctrlr_is_log_page_supported()</a> returns true for the controller and log page ID SPDK_NVME_LOG_ASYMMETRIC_NAMESPACE_ACCESS.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ANA state for the given namespace. </dd></dl>

</div>
</div>
<a id="a8740d083341479c3c22861f16582795c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8740d083341479c3c22861f16582795c">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_csi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum spdk_nvme_csi spdk_nvme_ns_get_csi </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Command Set Identifier for the given namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the namespace Command Set Identifier. </dd></dl>

</div>
</div>
<a id="a2640aeebb82108e9b507dcccb1e564c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2640aeebb82108e9b507dcccb1e564c2">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_ctrlr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_ctrlr* spdk_nvme_ns_get_ctrlr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the controller with which this namespace is associated. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the controller. </dd></dl>

</div>
</div>
<a id="ab1863b5dccf2bcc49fe92275bc1e5a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1863b5dccf2bcc49fe92275bc1e5a2a">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a>* spdk_nvme_ns_get_data </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the identify namespace data as defined by the NVMe specification. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the namespace data. </dd></dl>

</div>
</div>
<a id="a42040dca95489218417539d2c08d815e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42040dca95489218417539d2c08d815e">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_dealloc_logical_block_read_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme__spec_8h.html#a1c06fbd66f7572c43c51e6f106215b8d">spdk_nvme_dealloc_logical_block_read_value</a> spdk_nvme_ns_get_dealloc_logical_block_read_value </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the value returned when reading deallocated blocks. </p>
<p>If deallocated blocks return 0, the deallocate command can be used as a more efficient alternative to the write_zeroes command, especially for large requests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logical block read value. </dd></dl>

</div>
</div>
<a id="a8f3f5c5a738dc7ad7e3b2913bff4324c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3f5c5a738dc7ad7e3b2913bff4324c">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_extended_sector_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_extended_sector_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the extended sector size, in bytes, of the given namespace. </p>
<p>This function returns the size of the data sector plus metadata.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<p>/return the extended sector size in bytes. </p>

</div>
</div>
<a id="a5eff1c1b6fbfb348a1f158b3cf70626f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eff1c1b6fbfb348a1f158b3cf70626f">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_flags </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the flags for the given namespace. </p>
<p>See spdk_nvme_ns_flags for the possible flags returned.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the flags for the given namespace. </dd></dl>

</div>
</div>
<a id="a95da4dc7b98bfeed010a4a7a899e0ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95da4dc7b98bfeed010a4a7a899e0ac7">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_format_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_format_index </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a> *&#160;</td>
          <td class="paramname"><em>nsdata</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the format index of the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nsdata</td><td>pointer to the NVMe namespace data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the format index of the given namespace. </dd></dl>

</div>
</div>
<a id="a54052303ef2870d6d1856f79ef6ff88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54052303ef2870d6d1856f79ef6ff88a">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the namespace id (index number) from the given namespace handle. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>namespace id. </dd></dl>

</div>
</div>
<a id="ac2aac85501f13bff557d3a224d8ec156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2aac85501f13bff557d3a224d8ec156">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_max_io_xfer_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_max_io_xfer_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum transfer size, in bytes, for an I/O sent to the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum transfer size in bytes. </dd></dl>

</div>
</div>
<a id="ab48657f8cb6561b35e1c1b0bc18376d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48657f8cb6561b35e1c1b0bc18376d2">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_md_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_md_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the metadata size, in bytes, of the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the metadata size of the given namespace in bytes. </dd></dl>

</div>
</div>
<a id="a67c20210c6490d4545b40e43faa8af23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c20210c6490d4545b40e43faa8af23">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_nguid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* spdk_nvme_ns_get_nguid </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NGUID for the given namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to namespace NGUID, or NULL if ns does not have a NGUID. </dd></dl>

</div>
</div>
<a id="a7c522609f730db26f66e7f5b6b3501e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c522609f730db26f66e7f5b6b3501e0">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_num_sectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_nvme_ns_get_num_sectors </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of sectors for the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of sectors. </dd></dl>

</div>
</div>
<a id="af58edc3021f8adcbecce5d3ebc5b6789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58edc3021f8adcbecce5d3ebc5b6789">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_optimal_io_boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_optimal_io_boundary </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the optimal I/O boundary, in blocks, for the given namespace. </p>
<p>Read and write commands should not cross the optimal I/O boundary for best performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optimal granularity of I/O commands, in blocks, or 0 if no optimal granularity is reported. </dd></dl>

</div>
</div>
<a id="a85806a7605a104a705e7f9d3d087e4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85806a7605a104a705e7f9d3d087e4cb">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_pi_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum spdk_nvme_pi_type spdk_nvme_ns_get_pi_type </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the end-to-end data protection information type of the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end-to-end data protection information type. </dd></dl>

</div>
</div>
<a id="a0d24c0b2b0b2a22b0c0af2ca2e157e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d24c0b2b0b2a22b0c0af2ca2e157e04">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_sector_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_sector_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sector size, in bytes, of the given namespace. </p>
<p>This function returns the size of the data sector only. It does not include metadata size.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<p>/return the sector size in bytes. </p>

</div>
</div>
<a id="a9e8fb1bbe066260faf305581e16dde86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8fb1bbe066260faf305581e16dde86">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_nvme_ns_get_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size, in bytes, of the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the given namespace in bytes. </dd></dl>

</div>
</div>
<a id="a6c559063408299a4612fd2e62f97bc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c559063408299a4612fd2e62f97bc63">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_uuid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__uuid.html">spdk_uuid</a>* spdk_nvme_ns_get_uuid </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the UUID for the given namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to namespace UUID, or NULL if ns does not have a UUID. </dd></dl>

</div>
</div>
<a id="af755eb3e5a5f767a5bdc544d85667898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af755eb3e5a5f767a5bdc544d85667898">&#9670;&nbsp;</a></span>spdk_nvme_ns_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ns_is_active </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a namespace is active. </p>
<p>Inactive namespaces cannot be the target of I/O commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if active, or false if inactive. </dd></dl>

</div>
</div>
<a id="aacb2087b31ac4b4807a77b9b97d55b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb2087b31ac4b4807a77b9b97d55b2c">&#9670;&nbsp;</a></span>spdk_nvme_ns_supports_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ns_supports_compare </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether if the namespace supports compare operation. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the namespace supports compare operation, or false otherwise. </dd></dl>

</div>
</div>
<a id="aad367fec5a8963f5d930dfae485de6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad367fec5a8963f5d930dfae485de6b3">&#9670;&nbsp;</a></span>spdk_nvme_ns_supports_extended_lba()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ns_supports_extended_lba </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether if the namespace can support extended LBA when end-to-end data protection enabled. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the namespace can support extended LBA when end-to-end data protection enabled, or false otherwise. </dd></dl>

</div>
</div>
<a id="a976b90cbbc1aa8a4117837758f65e6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976b90cbbc1aa8a4117837758f65e6c7">&#9670;&nbsp;</a></span>spdk_nvme_pcie_set_hotplug_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_pcie_set_hotplug_filter </td>
          <td>(</td>
          <td class="paramtype">spdk_nvme_pcie_hotplug_filter_cb&#160;</td>
          <td class="paramname"><em>filter_cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the associated function to allow filtering of hot-inserted PCIe SSDs. </p>
<p>If an application is using <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> to detect hot-inserted SSDs, this function may be used to register a function to filter those SSDs. If the filter function returns true, the nvme library will notify the SPDK env layer to allow probing of the device.</p>
<p>Registering a filter function is optional. If none is registered, the nvme library will allow probing of all hot-inserted SSDs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter_cb</td><td>Filter function callback routine </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade4eafe3d6b7b4a0a1c317a49b3ba1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4eafe3d6b7b4a0a1c317a49b3ba1e5">&#9670;&nbsp;</a></span>spdk_nvme_poll_group_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_poll_group_add </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_poll_group *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an spdk_nvme_qpair to a poll group. </p>
<p>qpairs may only be added to a poll group if they are in the disconnected state; i.e. either they were just allocated and not yet connected or they have been disconnected with a call to spdk_nvme_ctrlr_disconnect_io_qpair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The group to which the qpair will be added. </td></tr>
    <tr><td class="paramname">qpair</td><td>The qpair to add to the poll group.</td></tr>
  </table>
  </dd>
</dl>
<p>return 0 on success, -EINVAL if the qpair is not in the disabled state, -ENODEV if the transport doesn't exist, -ENOMEM on memory allocation failures, or -EPROTO on a protocol (transport) specific failure. </p>

</div>
</div>
<a id="aba8083fac113bd027ff1f8c93fe704d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8083fac113bd027ff1f8c93fe704d6">&#9670;&nbsp;</a></span>spdk_nvme_poll_group_all_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_poll_group_all_connected </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_poll_group *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all qpairs in the poll group are connected. </p>
<p>This function allows the caller to check if all qpairs in a poll group are connected. This API is generally only suitable during application startup, to check when a large number of async connections have completed.</p>
<p>It is useful for applications like benchmarking tools to create a large number of qpairs, but then ensuring they are all fully connected before proceeding with I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The group on which to poll connecting qpairs.</td></tr>
  </table>
  </dd>
</dl>
<p>return 0 if all qpairs are in CONNECTED state, -EIO if any connections failed to connect, -EAGAIN if any qpairs are still trying to connected. </p>

</div>
</div>
<a id="afb7c3d1cbb9ef2dbe39344ad65490f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7c3d1cbb9ef2dbe39344ad65490f2d">&#9670;&nbsp;</a></span>spdk_nvme_poll_group_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_poll_group* spdk_nvme_poll_group_create </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__accel__fn__table.html">spdk_nvme_accel_fn_table</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new poll group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>A user supplied context that can be retrieved later with spdk_nvme_poll_group_get_ctx </td></tr>
    <tr><td class="paramname">table</td><td>The call back table defined by users which contains the accelerated functions which can be used to accelerate some operations such as crc32c.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new poll group, or NULL on error. </dd></dl>

</div>
</div>
<a id="ac4cea1ea33592903a9478d75f809ded6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4cea1ea33592903a9478d75f809ded6">&#9670;&nbsp;</a></span>spdk_nvme_poll_group_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_poll_group_destroy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_poll_group *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an empty poll group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The group to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>return 0 on success, -EBUSY if the poll group is not empty. </p>

</div>
</div>
<a id="ae2448353b0d3024bb3b05d7b45eb8285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2448353b0d3024bb3b05d7b45eb8285">&#9670;&nbsp;</a></span>spdk_nvme_poll_group_free_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_poll_group_free_stats </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_poll_group *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__poll__group__stat.html">spdk_nvme_poll_group_stat</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees poll group statistics retrieved using <b>spdk_nvme_poll_group_get_stats</b> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Pointer to a poll group </td></tr>
    <tr><td class="paramname">stat</td><td>Pointer to statistics to be released </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a353011316a46ee6e6857f7286488d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a353011316a46ee6e6857f7286488d1">&#9670;&nbsp;</a></span>spdk_nvme_poll_group_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_nvme_poll_group_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_poll_group *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the user context for this specific poll group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The poll group from which to retrieve the context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the user provided poll group context. </dd></dl>

</div>
</div>
<a id="a18820817137a7fca589be8c08feedcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18820817137a7fca589be8c08feedcc0">&#9670;&nbsp;</a></span>spdk_nvme_poll_group_get_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_poll_group_get_stats </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_poll_group *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__poll__group__stat.html">spdk_nvme_poll_group_stat</a> **&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves transport statistics for the given poll group. </p>
<p>Note: the structure returned by this function should later be freed with <b>spdk_nvme_poll_group_free_stats</b> function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Pointer to NVME poll group </td></tr>
    <tr><td class="paramname">stats</td><td>Double pointer to statistics to be filled by this function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or negated errno on failure </dd></dl>

</div>
</div>
<a id="ac89c07198e8be3384ee6a0adc8439621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89c07198e8be3384ee6a0adc8439621">&#9670;&nbsp;</a></span>spdk_nvme_poll_group_process_completions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t spdk_nvme_poll_group_process_completions </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_poll_group *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>completions_per_qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#add892b5eaa7208ca3b08382431713390">spdk_nvme_disconnected_qpair_cb</a>&#160;</td>
          <td class="paramname"><em>disconnected_qpair_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll for completions on all qpairs in this poll group. </p>
<p>the disconnected_qpair_cb will be called for all disconnected qpairs in the poll group including qpairs which fail within the context of this call. The user is responsible for trying to reconnect or destroy those qpairs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The group on which to poll for completions. </td></tr>
    <tr><td class="paramname">completions_per_qpair</td><td>The maximum number of completions per qpair. </td></tr>
    <tr><td class="paramname">disconnected_qpair_cb</td><td>A callback function of type spdk_nvme_disconnected_qpair_cb. Must be non-NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>return The number of completions across all qpairs, -EINVAL if no disconnected_qpair_cb is passed, or -EIO if the shared completion queue cannot be polled for the RDMA transport. </p>

</div>
</div>
<a id="a2ef925aeb99c7791bcec5c7305c03422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef925aeb99c7791bcec5c7305c03422">&#9670;&nbsp;</a></span>spdk_nvme_poll_group_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_poll_group_remove </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_poll_group *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a disconnected spdk_nvme_qpair from a poll group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The group from which to remove the qpair. </td></tr>
    <tr><td class="paramname">qpair</td><td>The qpair to remove from the poll group.</td></tr>
  </table>
  </dd>
</dl>
<p>return 0 on success, -ENOENT if the qpair is not found in the group, -EINVAL if the qpair is not disconnected in the group, or -EPROTO on a protocol (transport) specific failure. </p>

</div>
</div>
<a id="a0f14ec05ce3af11f089a79d47739bd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f14ec05ce3af11f089a79d47739bd74">&#9670;&nbsp;</a></span>spdk_nvme_prchk_flags_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_prchk_flags_parse </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>prchk_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the string representation of PI check settings (prchk:guard|reftag) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prchk_flags</td><td>Output PI check flags. </td></tr>
    <tr><td class="paramname">str</td><td>Input string representation of PI check settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if parsing was successful and prchk_flags is set, or negated errno values on failure. </dd></dl>

</div>
</div>
<a id="ae125f35c7ab6fd2f5e63bfac804f25e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae125f35c7ab6fd2f5e63bfac804f25e6">&#9670;&nbsp;</a></span>spdk_nvme_prchk_flags_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvme_prchk_flags_str </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>prchk_flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the string representation of PI check settings (prchk:guard|reftag) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prchk_flags</td><td>PI check flags to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>static string constant describing PI check settings. If prchk_flags is 0, NULL is returned. </dd></dl>

</div>
</div>
<a id="a8145be511777b2c8dc218b1c1e1e2c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8145be511777b2c8dc218b1c1e1e2c89">&#9670;&nbsp;</a></span>spdk_nvme_print_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_print_command </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>qid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints (SPDK_NOTICELOG) the contents of an NVMe submission queue entry (command). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qid</td><td>Queue identifier. </td></tr>
    <tr><td class="paramname">cmd</td><td>Pointer to the submission queue command to be formatted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebe027f765f35a6cf532c236a90df5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe027f765f35a6cf532c236a90df5b7">&#9670;&nbsp;</a></span>spdk_nvme_print_completion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_print_completion </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>qid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *&#160;</td>
          <td class="paramname"><em>cpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints (SPDK_NOTICELOG) the contents of an NVMe completion queue entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qid</td><td>Queue identifier. </td></tr>
    <tr><td class="paramname">cpl</td><td>Pointer to the completion queue element to be formatted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a225bbc386ec518ae21bd5536f21db45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225bbc386ec518ae21bd5536f21db45d">&#9670;&nbsp;</a></span>spdk_nvme_probe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_probe </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a95f40d5179f8424b466a30ba0610ab4c">spdk_nvme_probe_cb</a>&#160;</td>
          <td class="paramname"><em>probe_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a>&#160;</td>
          <td class="paramname"><em>attach_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a>&#160;</td>
          <td class="paramname"><em>remove_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device found if desired. </p>
<p>This function is not thread safe and should only be called from one thread at a time while no other threads are actively using any NVMe devices.</p>
<p>If called from a secondary process, only devices that have been attached to the userspace driver in the primary process will be probed.</p>
<p>If called more than once, only devices that are not already attached to the SPDK NVMe driver will be reported.</p>
<p>To stop using the the controller and release its associated resources, call <a class="el" href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2" title="Detach specified device returned by spdk_nvme_probe()&#39;s attach_cb from the NVMe driver.">spdk_nvme_detach()</a> with the spdk_nvme_ctrlr instance from the attach_cb() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid</td><td>The transport ID indicating which bus to enumerate. If the trtype is PCIe or trid is NULL, this will scan the local PCIe bus. If the trtype is RDMA, the traddr and trsvcid must point at the location of an NVMe-oF discovery service. </td></tr>
    <tr><td class="paramname">cb_ctx</td><td>Opaque value which will be passed back in cb_ctx parameter of the callbacks. </td></tr>
    <tr><td class="paramname">probe_cb</td><td>will be called once per NVMe device found in the system. </td></tr>
    <tr><td class="paramname">attach_cb</td><td>will be called for devices for which probe_cb returned true once that NVMe controller has been attached to the userspace driver. </td></tr>
    <tr><td class="paramname">remove_cb</td><td>will be called for devices that were attached in a previous <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> call but are no longer attached to the system. Optional; specify NULL if removal notices are not desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a02411bf7ae4827a350711e688316997e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02411bf7ae4827a350711e688316997e">&#9670;&nbsp;</a></span>spdk_nvme_probe_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_probe_ctx* spdk_nvme_probe_async </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a95f40d5179f8424b466a30ba0610ab4c">spdk_nvme_probe_cb</a>&#160;</td>
          <td class="paramname"><em>probe_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a>&#160;</td>
          <td class="paramname"><em>attach_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a>&#160;</td>
          <td class="paramname"><em>remove_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Probe and add controllers to the probe context list. </p>
<p>Users must call <a class="el" href="nvme_8h.html#aedea919a47bdd811b604656e29e3fcef" title="Proceed with attaching controllers associated with the probe context.">spdk_nvme_probe_poll_async()</a> to initialize controllers in the probe context list to the READY state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid</td><td>The transport ID indicating which bus to enumerate. If the trtype is PCIe or trid is NULL, this will scan the local PCIe bus. If the trtype is RDMA, the traddr and trsvcid must point at the location of an NVMe-oF discovery service. </td></tr>
    <tr><td class="paramname">cb_ctx</td><td>Opaque value which will be passed back in cb_ctx parameter of the callbacks. </td></tr>
    <tr><td class="paramname">probe_cb</td><td>will be called once per NVMe device found in the system. </td></tr>
    <tr><td class="paramname">attach_cb</td><td>will be called for devices for which probe_cb returned true once that NVMe controller has been attached to the userspace driver. </td></tr>
    <tr><td class="paramname">remove_cb</td><td>will be called for devices that were attached in a previous <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> call but are no longer attached to the system. Optional; specify NULL if removal notices are not desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>probe context on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="aedea919a47bdd811b604656e29e3fcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedea919a47bdd811b604656e29e3fcef">&#9670;&nbsp;</a></span>spdk_nvme_probe_poll_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_probe_poll_async </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_probe_ctx *&#160;</td>
          <td class="paramname"><em>probe_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Proceed with attaching controllers associated with the probe context. </p>
<p>The probe context is one returned from a previous call to <a class="el" href="nvme_8h.html#a02411bf7ae4827a350711e688316997e" title="Probe and add controllers to the probe context list.">spdk_nvme_probe_async()</a>. Users must call this function on the probe context until it returns 0.</p>
<p>If any controllers fail to attach, there is no explicit notification. Users can detect attachment failure by comparing attach_cb invocations with the number of times where the user returned true for the probe_cb.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probe_ctx</td><td>Context used to track probe actions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if all probe operations are complete; the probe_ctx is also freed and no longer valid. </dd>
<dd>
-EAGAIN if there are still pending probe operations; user must call spdk_nvme_probe_poll_async again to continue progress. </dd></dl>

</div>
</div>
<a id="acf6188764b8c71b2f64a74077d6bfabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6188764b8c71b2f64a74077d6bfabf">&#9670;&nbsp;</a></span>spdk_nvme_qpair_add_cmd_error_injection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_qpair_add_cmd_error_injection </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_not_submit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_in_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>err_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject an error for the next request with a given opcode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to add the error command, NULL for Admin queue pair. </td></tr>
    <tr><td class="paramname">opc</td><td>Opcode for Admin or I/O commands. </td></tr>
    <tr><td class="paramname">do_not_submit</td><td>True if matching requests should not be submitted to the controller, but instead completed manually after timeout_in_us has expired. False if matching requests should be submitted to the controller and have their completion status modified after the controller completes the request. </td></tr>
    <tr><td class="paramname">timeout_in_us</td><td>Wait specified microseconds when do_not_submit is true. </td></tr>
    <tr><td class="paramname">err_count</td><td>Number of matching requests to inject errors. </td></tr>
    <tr><td class="paramname">sct</td><td>Status code type. </td></tr>
    <tr><td class="paramname">sc</td><td>Status code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully enabled, ENOMEM if an error command structure cannot be allocated.</dd></dl>
<p>The function can be called multiple times to inject errors for different commands. If the opcode matches an existing entry, the existing entry will be updated with the values specified. </p>

</div>
</div>
<a id="ae2015f3c7dd76113e89a732eabe400ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2015f3c7dd76113e89a732eabe400ff">&#9670;&nbsp;</a></span>spdk_nvme_qpair_get_failure_reason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="nvme_8h.html#ab41e2d311eb6663957cd2f18bc8fb890">spdk_nvme_qp_failure_reason</a> spdk_nvme_qpair_get_failure_reason </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the reason the qpair is disconnected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The qpair to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a valid spdk_nvme_qp_failure_reason. </dd></dl>

</div>
</div>
<a id="add6ae73013499c8fc3c197f47231b8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6ae73013499c8fc3c197f47231b8d2">&#9670;&nbsp;</a></span>spdk_nvme_qpair_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t spdk_nvme_qpair_get_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the NVMe qpair ID for the specified qpair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>Pointer to the NVMe queue pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID for the specified qpair. </dd></dl>

</div>
</div>
<a id="a54fff8d7ba08d00a5e4f322dd1b6af2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54fff8d7ba08d00a5e4f322dd1b6af2d">&#9670;&nbsp;</a></span>spdk_nvme_qpair_get_num_outstanding_reqs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_qpair_get_num_outstanding_reqs </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of outstanding requests for the specified qpair. </p>
<p>This number is not decremented until after a request's callback function is completed.</p>
<p>This number is not matched necessarily to the number of NVMe commands submitted by the user. For example, nvme driver may split a request due to MDTS limitations, that will also allocate a request for the parent, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>Pointer to the NVMe queue pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of outstanding requests for the specified qpair. </dd></dl>

</div>
</div>
<a id="a8a891c5683c340e0426cd0268d29d689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a891c5683c340e0426cd0268d29d689">&#9670;&nbsp;</a></span>spdk_nvme_qpair_get_optimal_poll_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_poll_group* spdk_nvme_qpair_get_optimal_poll_group </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a optimal poll group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The qpair to get the optimal poll group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the optimal poll group, or NULL if not found. </dd></dl>

</div>
</div>
<a id="ac06275147a2cbb800440686b8ba9a73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06275147a2cbb800440686b8ba9a73b">&#9670;&nbsp;</a></span>spdk_nvme_qpair_print_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_qpair_print_command </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints (SPDK_NOTICELOG) the contents of an NVMe submission queue entry (command). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>Pointer to the NVMe queue pair - used to determine admin versus I/O queue. </td></tr>
    <tr><td class="paramname">cmd</td><td>Pointer to the submission queue command to be formatted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4b2335194f9c4c24a5e2c15a9432f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b2335194f9c4c24a5e2c15a9432f4a">&#9670;&nbsp;</a></span>spdk_nvme_qpair_print_completion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_qpair_print_completion </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *&#160;</td>
          <td class="paramname"><em>cpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints (SPDK_NOTICELOG) the contents of an NVMe completion queue entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>Pointer to the NVMe queue pair - presently unused. </td></tr>
    <tr><td class="paramname">cpl</td><td>Pointer to the completion queue element to be formatted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa331d140870e977722bfbb6826524782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa331d140870e977722bfbb6826524782">&#9670;&nbsp;</a></span>spdk_nvme_qpair_process_completions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t spdk_nvme_qpair_process_completions </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_completions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process any outstanding completions for I/O submitted on a queue pair. </p>
<p>This call is non-blocking, i.e. it only processes completions that are ready at the time of this function call. It does not wait for outstanding commands to finish.</p>
<p>For each completed command, the request's callback function will be called if specified as non-NULL when the request was submitted.</p>
<p>The caller must ensure that each queue pair is only used from one thread at a time.</p>
<p>This function may be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a1786f9616afc773b20f752dc98ecd465" title="Signature for callback function invoked when a command is completed.">spdk_nvme_cmd_cb</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>Queue pair to check for completions. </td></tr>
    <tr><td class="paramname">max_completions</td><td>Limit the number of completions to be processed in one call, or 0 for unlimited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of completions processed (may be 0) or negated on error. -ENXIO in the special case that the qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="ad720b23786450b5a2b2d7d65c6dd6b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad720b23786450b5a2b2d7d65c6dd6b7c">&#9670;&nbsp;</a></span>spdk_nvme_qpair_remove_cmd_error_injection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_qpair_remove_cmd_error_injection </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>opc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the specified NVMe command with error status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to remove the error command, \ NULL for Admin queue pair. </td></tr>
    <tr><td class="paramname">opc</td><td>Opcode for Admin or I/O commands.</td></tr>
  </table>
  </dd>
</dl>
<p>The function will remove specified command in the error list. </p>

</div>
</div>
<a id="a0538f261b89d0cdb455638dba52ea4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0538f261b89d0cdb455638dba52ea4b8">&#9670;&nbsp;</a></span>spdk_nvme_qpair_set_abort_dnr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_qpair_set_abort_dnr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dnr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control if DNR is set or not for aborted commands. </p>
<p>The default value is false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The qpair to set. </td></tr>
    <tr><td class="paramname">dnr</td><td>Set the DNR bit to 1 if true or 0 if false for aborted commands. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82cdb425c9fad7b94ad0b8f5c27bb8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cdb425c9fad7b94ad0b8f5c27bb8b2">&#9670;&nbsp;</a></span>spdk_nvme_rdma_init_hooks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_rdma_init_hooks </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__rdma__hooks.html">spdk_nvme_rdma_hooks</a> *&#160;</td>
          <td class="paramname"><em>hooks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global hooks for the RDMA transport, if necessary. </p>
<p>This call is optional and must be performed prior to probing for any devices. By default, the RDMA transport will use the ibverbs library to create protection domains and register memory. This is a mechanism to subvert that and use an existing registration.</p>
<p>This function may only be called one time per process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hooks</td><td>for initializing global hooks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5735e7600f79c45871b3dc3adb292f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5735e7600f79c45871b3dc3adb292f2">&#9670;&nbsp;</a></span>spdk_nvme_transport_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_transport_available </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a>&#160;</td>
          <td class="paramname"><em>trtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the NVMe library can handle a specific NVMe over Fabrics transport type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trtype</td><td>NVMe over Fabrics transport type to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if trtype is supported or false if it is not supported or if SPDK_NVME_TRANSPORT_CUSTOM is supplied as trtype since it can represent multiple transports. </dd></dl>

</div>
</div>
<a id="ab4541db53f0daadcb4fc1d4f950b4bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4541db53f0daadcb4fc1d4f950b4bb5">&#9670;&nbsp;</a></span>spdk_nvme_transport_available_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_transport_available_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>transport_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the NVMe library can handle a specific NVMe over Fabrics transport type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport_name</td><td>Name of the NVMe over Fabrics transport type to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if transport_name is supported or false if it is not supported. </dd></dl>

</div>
</div>
<a id="acb9e59ab20d92979f2995646c8191e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb9e59ab20d92979f2995646c8191e9a">&#9670;&nbsp;</a></span>spdk_nvme_transport_get_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_transport_get_opts </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__opts.html">spdk_nvme_transport_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>opts_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current NVMe transport options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">opts</td><td>Will be filled with the current options for <a class="el" href="nvme_8h.html#a327cc2f4818d3111bdc8485a9b844d4f" title="Set the NVMe transport options.">spdk_nvme_transport_set_opts()</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">opts_size</td><td>Must be set to sizeof(struct spdk_nvme_transport_opts). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb95c5452e84e2c5c1984341fc816ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb95c5452e84e2c5c1984341fc816ea7">&#9670;&nbsp;</a></span>spdk_nvme_transport_id_adrfam_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvme_transport_id_adrfam_str </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="nvmf__spec_8h.html#a08f0090d242e2607ab11f148dcd797c6">spdk_nvmf_adrfam</a>&#160;</td>
          <td class="paramname"><em>adrfam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the string representation of a transport ID address family. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adrfam</td><td>Address family to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>static string constant describing adrfam, or NULL if adrfam not found. </dd></dl>

</div>
</div>
<a id="a9878deb91f677a9a9583342f07dcef41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9878deb91f677a9a9583342f07dcef41">&#9670;&nbsp;</a></span>spdk_nvme_transport_id_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_transport_id_compare </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two transport IDs. </p>
<p>The result of this function may be used to sort transport IDs in a consistent order; however, the comparison result is not guaranteed to be consistent across library versions.</p>
<p>This function uses a case-insensitive comparison for string fields, but it does not otherwise normalize the transport ID. It is the caller's responsibility to provide the transport IDs in a consistent format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid1</td><td>First transport ID to compare. </td></tr>
    <tr><td class="paramname">trid2</td><td>Second transport ID to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if trid1 == trid2, less than 0 if trid1 &lt; trid2, greater than 0 if trid1 &gt; trid2. </dd></dl>

</div>
</div>
<a id="ac37484cc5d14777e4ae1fde031d0edf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37484cc5d14777e4ae1fde031d0edf2">&#9670;&nbsp;</a></span>spdk_nvme_transport_id_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_transport_id_parse </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the string representation of a transport ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid</td><td>Output transport ID structure (must be allocated and initialized by caller). </td></tr>
    <tr><td class="paramname">str</td><td>Input string representation of a transport ID to parse.</td></tr>
  </table>
  </dd>
</dl>
<p>str must be a zero-terminated C string containing one or more key:value pairs separated by whitespace.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Key   </th><th class="markdownTableHeadNone">Value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">trtype   </td><td class="markdownTableBodyNone">Transport type (e.g. PCIe, RDMA)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">adrfam   </td><td class="markdownTableBodyNone">Address family (e.g. IPv4, IPv6)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traddr   </td><td class="markdownTableBodyNone">Transport address (e.g. 0000:04:00.0 for PCIe, 192.168.100.8 for RDMA, or WWN for FC)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">trsvcid   </td><td class="markdownTableBodyNone">Transport service identifier (e.g. 4420)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">subnqn   </td><td class="markdownTableBodyNone">Subsystem NQN   </td></tr>
</table>
<p>Unspecified fields of trid are left unmodified, so the caller must initialize trid (for example, memset() to 0) before calling this function.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if parsing was successful and trid is filled out, or negated errno values on failure. </dd></dl>

</div>
</div>
<a id="af7868a6f646a6d1bd70d5c1b8ce5757f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7868a6f646a6d1bd70d5c1b8ce5757f">&#9670;&nbsp;</a></span>spdk_nvme_transport_id_parse_adrfam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_transport_id_parse_adrfam </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="nvmf__spec_8h.html#a08f0090d242e2607ab11f148dcd797c6">spdk_nvmf_adrfam</a> *&#160;</td>
          <td class="paramname"><em>adrfam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the string representation of a transport ID address family. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adrfam</td><td>Output address family (allocated by caller). </td></tr>
    <tr><td class="paramname">str</td><td>Input string representation of address family (e.g. "IPv4", "IPv6").</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if parsing was successful and adrfam is filled out, or negated errno values on failure. </dd></dl>

</div>
</div>
<a id="ab2afed1cce9d9334dfd127db416ada4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2afed1cce9d9334dfd127db416ada4c">&#9670;&nbsp;</a></span>spdk_nvme_transport_id_parse_trtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_transport_id_parse_trtype </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a> *&#160;</td>
          <td class="paramname"><em>trtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the string representation of a transport ID transport type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trtype</td><td>Output transport type (allocated by caller). </td></tr>
    <tr><td class="paramname">str</td><td>Input string representation of transport type (e.g. "PCIe", "RDMA").</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if parsing was successful and trtype is filled out, or negated errno values on failure. </dd></dl>

</div>
</div>
<a id="a5d0eb5d0f2e974c4d85fa251796486a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0eb5d0f2e974c4d85fa251796486a3">&#9670;&nbsp;</a></span>spdk_nvme_transport_id_populate_trstring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_transport_id_populate_trstring </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>trstring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the string representation of a transport ID transport type into the trid struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid</td><td>The trid to write to </td></tr>
    <tr><td class="paramname">trstring</td><td>Input string representation of transport type (e.g. "PCIe", "RDMA").</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if parsing was successful and trtype is filled out, or negated errno values if the provided string was an invalid transport string. </dd></dl>

</div>
</div>
<a id="aa3a982eb5b757eae63fbc9305627090b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a982eb5b757eae63fbc9305627090b">&#9670;&nbsp;</a></span>spdk_nvme_transport_id_trtype_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvme_transport_id_trtype_str </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a>&#160;</td>
          <td class="paramname"><em>trtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the string representation of a transport ID transport type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trtype</td><td>Transport type to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>static string constant describing trtype, or NULL if trtype not found. </dd></dl>

</div>
</div>
<a id="a6e4165e918b05158286f5984a136acbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4165e918b05158286f5984a136acbf">&#9670;&nbsp;</a></span>spdk_nvme_transport_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_transport_register </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__ops.html">spdk_nvme_transport_ops</a> *&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the operations for a given transport type. </p>
<p>This function should be invoked by referencing the macro SPDK_NVME_TRANSPORT_REGISTER macro in the transport's .c file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>The operations associated with an NVMe-oF transport. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a327cc2f4818d3111bdc8485a9b844d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327cc2f4818d3111bdc8485a9b844d4f">&#9670;&nbsp;</a></span>spdk_nvme_transport_set_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_transport_set_opts </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__opts.html">spdk_nvme_transport_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>opts_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the NVMe transport options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Pointer to the allocated <a class="el" href="structspdk__nvme__transport__opts.html" title="NVMe transport options.">spdk_nvme_transport_opts</a> structure with new values. </td></tr>
    <tr><td class="paramname">opts_size</td><td>Must be set to sizeof(struct spdk_nvme_transport_opts).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno on failure. </dd></dl>

</div>
</div>
<a id="ab5ab0982e7e0191fd16f041a268966b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ab0982e7e0191fd16f041a268966b5">&#9670;&nbsp;</a></span>spdk_nvme_trid_populate_transport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_trid_populate_transport </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a>&#160;</td>
          <td class="paramname"><em>trtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill in the trtype and trstring fields of this trid based on a known transport type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid</td><td>The trid to fill out. </td></tr>
    <tr><td class="paramname">trtype</td><td>The transport type to use for filling the trid fields. Only valid for transport types referenced in the NVMe-oF spec. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.1 </li>
</ul>
</div>
</div>
</body>
</html>
