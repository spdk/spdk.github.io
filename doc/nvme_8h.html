<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.13">
  <title>SPDK: nvme.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row">
      <div class="col-lg-12">
        <section id="banner-header" class="banner-header">
          <div class="banner-message">
            <h1>Storage Performance Development Kit</h1>
            <hr class="banner-divider">
          </div>
        </section>
        <section id="nav">
          <div class="navbar navbar-default banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://lists.01.org/mailman/listinfo/spdk">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">mailing list</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_67fbcc0b4317645100def1406b508c33.html">spdk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">nvme.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>NVMe driver public API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe controller initialization options.  <a href="structspdk__nvme__ctrlr__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe transport identifier.  <a href="structspdk__nvme__transport__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1915e114063119af0a9af50b75b7acaa"><td class="memItemLeft" align="right" valign="top"><a id="a1915e114063119af0a9af50b75b7acaa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVME_DEFAULT_RETRY_COUNT</b>&#160;&#160;&#160;(4)</td></tr>
<tr class="separator:a1915e114063119af0a9af50b75b7acaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a95f40d5179f8424b466a30ba0610ab4c"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a95f40d5179f8424b466a30ba0610ab4c">spdk_nvme_probe_cb</a>) (void *cb_ctx, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts)</td></tr>
<tr class="memdesc:a95f40d5179f8424b466a30ba0610ab4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> enumeration.  <a href="#a95f40d5179f8424b466a30ba0610ab4c">More...</a><br /></td></tr>
<tr class="separator:a95f40d5179f8424b466a30ba0610ab4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eaa795f075495337b270667661ce5d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a>) (void *cb_ctx, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct spdk_nvme_ctrlr *ctrlr, const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts)</td></tr>
<tr class="memdesc:ac1eaa795f075495337b270667661ce5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> to report a device that has been attached to the userspace NVMe driver.  <a href="#ac1eaa795f075495337b270667661ce5d">More...</a><br /></td></tr>
<tr class="separator:ac1eaa795f075495337b270667661ce5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f1aa545be57a03bb2dd0c6180172b6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a>) (void *cb_ctx, struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a05f1aa545be57a03bb2dd0c6180172b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> to report that a device attached to the userspace NVMe driver has been removed from the system.  <a href="#a05f1aa545be57a03bb2dd0c6180172b6">More...</a><br /></td></tr>
<tr class="separator:a05f1aa545be57a03bb2dd0c6180172b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9779e9957d7089dde8e492cc60856d8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>) (void *, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *)</td></tr>
<tr class="memdesc:ac9779e9957d7089dde8e492cc60856d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for callback function invoked when a command is completed.  <a href="#ac9779e9957d7089dde8e492cc60856d8">More...</a><br /></td></tr>
<tr class="separator:ac9779e9957d7089dde8e492cc60856d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae564dc7dced1dd7b474c1a6923734a6d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae564dc7dced1dd7b474c1a6923734a6d">spdk_nvme_aer_cb</a>) (void *aer_cb_arg, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *)</td></tr>
<tr class="memdesc:ae564dc7dced1dd7b474c1a6923734a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for callback function invoked when an asynchronous error request command is completed.  <a href="#ae564dc7dced1dd7b474c1a6923734a6d">More...</a><br /></td></tr>
<tr class="separator:ae564dc7dced1dd7b474c1a6923734a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cdd2049888a1ebb020cb14976a62b9"><td class="memItemLeft" align="right" valign="top"><a id="ac4cdd2049888a1ebb020cb14976a62b9"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac4cdd2049888a1ebb020cb14976a62b9">spdk_nvme_timeout_cb</a>) (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, void *cb_arg)</td></tr>
<tr class="memdesc:ac4cdd2049888a1ebb020cb14976a62b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for the callback function invoked when a timeout is detected on a request. <br /></td></tr>
<tr class="separator:ac4cdd2049888a1ebb020cb14976a62b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1fcb43970ea531567ee00d4ee0675b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>) (void *cb_arg, uint32_t offset)</td></tr>
<tr class="memdesc:a0e1fcb43970ea531567ee00d4ee0675b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart the SGL walk to the specified offset when the command has scattered payloads.  <a href="#a0e1fcb43970ea531567ee00d4ee0675b">More...</a><br /></td></tr>
<tr class="separator:a0e1fcb43970ea531567ee00d4ee0675b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab95bea86f498c08510f6f0bcd2eb09"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>) (void *cb_arg, void **address, uint32_t *length)</td></tr>
<tr class="memdesc:a4ab95bea86f498c08510f6f0bcd2eb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill out *address and *length with the current SGL entry and advance to the next entry for the next time the callback is invoked.  <a href="#a4ab95bea86f498c08510f6f0bcd2eb09">More...</a><br /></td></tr>
<tr class="separator:a4ab95bea86f498c08510f6f0bcd2eb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae87a03c28984a2c0499d50ef5e9d0ece"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a> { <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ecea162afc05d1ae756b8a7969be140035ea">SPDK_NVME_TRANSPORT_PCIE</a> = 256, 
<a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ecea140f1cb4edf258bddffeb1c7277d93d8">SPDK_NVME_TRANSPORT_RDMA</a> = SPDK_NVMF_TRTYPE_RDMA
 }<tr class="memdesc:ae87a03c28984a2c0499d50ef5e9d0ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe library transports.  <a href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae87a03c28984a2c0499d50ef5e9d0ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018f3b986b4345ee0c6931be9718c163"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163">spdk_nvme_ns_flags</a> { <br />
&#160;&#160;<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163a80dcd48a57fa9e14efba4757300ad729">SPDK_NVME_NS_DEALLOCATE_SUPPORTED</a> = 0x1, 
<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163ad403aafc70c00560a1db768029933400">SPDK_NVME_NS_FLUSH_SUPPORTED</a> = 0x2, 
<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163a60edfdee88fbe811250e2f8ff63597d0">SPDK_NVME_NS_RESERVATION_SUPPORTED</a> = 0x4, 
<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163a4e691401f3709b7cd66bd32c28ae109b">SPDK_NVME_NS_WRITE_ZEROES_SUPPORTED</a> = 0x8, 
<br />
&#160;&#160;<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163afe158b050528f0f3341e5af3129c61a7">SPDK_NVME_NS_DPS_PI_SUPPORTED</a> = 0x10, 
<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163a91203896ead47bbe22e9f7db8a63c14f">SPDK_NVME_NS_EXTENDED_LBA_SUPPORTED</a> = 0x20
<br />
 }<tr class="memdesc:a018f3b986b4345ee0c6931be9718c163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace command support flags.  <a href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a018f3b986b4345ee0c6931be9718c163"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac37484cc5d14777e4ae1fde031d0edf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac37484cc5d14777e4ae1fde031d0edf2">spdk_nvme_transport_id_parse</a> (struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, const char *str)</td></tr>
<tr class="memdesc:ac37484cc5d14777e4ae1fde031d0edf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the string representation of a transport ID.  <a href="#ac37484cc5d14777e4ae1fde031d0edf2">More...</a><br /></td></tr>
<tr class="separator:ac37484cc5d14777e4ae1fde031d0edf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5735e7600f79c45871b3dc3adb292f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab5735e7600f79c45871b3dc3adb292f2">spdk_nvme_transport_available</a> (enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a> trtype)</td></tr>
<tr class="memdesc:ab5735e7600f79c45871b3dc3adb292f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the NVMe library can handle a specific NVMe over Fabrics transport type.  <a href="#ab5735e7600f79c45871b3dc3adb292f2">More...</a><br /></td></tr>
<tr class="separator:ab5735e7600f79c45871b3dc3adb292f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225bbc386ec518ae21bd5536f21db45d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d">spdk_nvme_probe</a> (const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, void *cb_ctx, <a class="el" href="nvme_8h.html#a95f40d5179f8424b466a30ba0610ab4c">spdk_nvme_probe_cb</a> probe_cb, <a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a> attach_cb, <a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a> remove_cb)</td></tr>
<tr class="memdesc:a225bbc386ec518ae21bd5536f21db45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device found if desired.  <a href="#a225bbc386ec518ae21bd5536f21db45d">More...</a><br /></td></tr>
<tr class="separator:a225bbc386ec518ae21bd5536f21db45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b63c225c3cce6da60fdbfb6f54b11e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2">spdk_nvme_detach</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a4b63c225c3cce6da60fdbfb6f54b11e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches specified device returned by <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d">spdk_nvme_probe()</a>'s attach_cb from the NVMe driver.  <a href="#a4b63c225c3cce6da60fdbfb6f54b11e2">More...</a><br /></td></tr>
<tr class="separator:a4b63c225c3cce6da60fdbfb6f54b11e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13ccd2ea831842a5008eb95a32545c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae13ccd2ea831842a5008eb95a32545c3">spdk_nvme_ctrlr_reset</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:ae13ccd2ea831842a5008eb95a32545c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a full hardware reset of the NVMe controller.  <a href="#ae13ccd2ea831842a5008eb95a32545c3">More...</a><br /></td></tr>
<tr class="separator:ae13ccd2ea831842a5008eb95a32545c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9daf15b5008ac36c12e7b8db7bdec9"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__nvme__ctrlr__data.html">spdk_nvme_ctrlr_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a5a9daf15b5008ac36c12e7b8db7bdec9">spdk_nvme_ctrlr_get_data</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a5a9daf15b5008ac36c12e7b8db7bdec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the identify controller data as defined by the NVMe specification.  <a href="#a5a9daf15b5008ac36c12e7b8db7bdec9">More...</a><br /></td></tr>
<tr class="separator:a5a9daf15b5008ac36c12e7b8db7bdec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46348531c83fd61acad1a55236d7d576"><td class="memItemLeft" align="right" valign="top"><a id="a46348531c83fd61acad1a55236d7d576"></a>
union <a class="el" href="unionspdk__nvme__csts__register.html">spdk_nvme_csts_register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a46348531c83fd61acad1a55236d7d576">spdk_nvme_ctrlr_get_regs_csts</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a46348531c83fd61acad1a55236d7d576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller CSTS (Status) register. <br /></td></tr>
<tr class="separator:a46348531c83fd61acad1a55236d7d576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6943191f9c88c3cec504f87672b9acf8"><td class="memItemLeft" align="right" valign="top"><a id="a6943191f9c88c3cec504f87672b9acf8"></a>
union <a class="el" href="unionspdk__nvme__cap__register.html">spdk_nvme_cap_register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6943191f9c88c3cec504f87672b9acf8">spdk_nvme_ctrlr_get_regs_cap</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a6943191f9c88c3cec504f87672b9acf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller CAP (Capabilities) register. <br /></td></tr>
<tr class="separator:a6943191f9c88c3cec504f87672b9acf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf238fdce21d10c923a384e18b013dd"><td class="memItemLeft" align="right" valign="top"><a id="aacf238fdce21d10c923a384e18b013dd"></a>
union <a class="el" href="unionspdk__nvme__vs__register.html">spdk_nvme_vs_register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aacf238fdce21d10c923a384e18b013dd">spdk_nvme_ctrlr_get_regs_vs</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:aacf238fdce21d10c923a384e18b013dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller VS (Version) register. <br /></td></tr>
<tr class="separator:aacf238fdce21d10c923a384e18b013dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b18deae44682a51177e8a4193af602"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a02b18deae44682a51177e8a4193af602">spdk_nvme_ctrlr_get_num_ns</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a02b18deae44682a51177e8a4193af602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of namespaces for the given NVMe controller.  <a href="#a02b18deae44682a51177e8a4193af602">More...</a><br /></td></tr>
<tr class="separator:a02b18deae44682a51177e8a4193af602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc6bb842e168a68972ec46cc35591ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7dc6bb842e168a68972ec46cc35591ae">spdk_nvme_ctrlr_is_log_page_supported</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t log_page)</td></tr>
<tr class="memdesc:a7dc6bb842e168a68972ec46cc35591ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a particular log page is supported by the given NVMe controller.  <a href="#a7dc6bb842e168a68972ec46cc35591ae">More...</a><br /></td></tr>
<tr class="separator:a7dc6bb842e168a68972ec46cc35591ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909b61e141b56eaa5895482aa1f18a3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a909b61e141b56eaa5895482aa1f18a3b">spdk_nvme_ctrlr_is_feature_supported</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t feature_code)</td></tr>
<tr class="memdesc:a909b61e141b56eaa5895482aa1f18a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a particular feature is supported by the given NVMe controller.  <a href="#a909b61e141b56eaa5895482aa1f18a3b">More...</a><br /></td></tr>
<tr class="separator:a909b61e141b56eaa5895482aa1f18a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1505fc1ef6e8ccb00134c1fa15e0368b"><td class="memItemLeft" align="right" valign="top"><a id="a1505fc1ef6e8ccb00134c1fa15e0368b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_ctrlr_register_aer_callback</b> (struct spdk_nvme_ctrlr *ctrlr, <a class="el" href="nvme_8h.html#ae564dc7dced1dd7b474c1a6923734a6d">spdk_nvme_aer_cb</a> aer_cb_fn, void *aer_cb_arg)</td></tr>
<tr class="separator:a1505fc1ef6e8ccb00134c1fa15e0368b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e12d6d7cf10399d0a06c99085be99bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a8e12d6d7cf10399d0a06c99085be99bf">spdk_nvme_ctrlr_register_timeout_callback</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t timeout_sec, <a class="el" href="nvme_8h.html#ac4cdd2049888a1ebb020cb14976a62b9">spdk_nvme_timeout_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a8e12d6d7cf10399d0a06c99085be99bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register for timeout callback on a controller.  <a href="#a8e12d6d7cf10399d0a06c99085be99bf">More...</a><br /></td></tr>
<tr class="separator:a8e12d6d7cf10399d0a06c99085be99bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1feac35f9a3d7dc50b1870e820ab65"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_qpair *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65">spdk_nvme_ctrlr_alloc_io_qpair</a> (struct spdk_nvme_ctrlr *ctrlr, enum <a class="el" href="nvme__spec_8h.html#ae83a61e254cf9d1fd59376ceedd1b4e6">spdk_nvme_qprio</a> qprio)</td></tr>
<tr class="memdesc:a6a1feac35f9a3d7dc50b1870e820ab65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an I/O queue pair (submission and completion queue).  <a href="#a6a1feac35f9a3d7dc50b1870e820ab65">More...</a><br /></td></tr>
<tr class="separator:a6a1feac35f9a3d7dc50b1870e820ab65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ec189f50d0f78d73a54413370401f5"><td class="memItemLeft" align="right" valign="top"><a id="a85ec189f50d0f78d73a54413370401f5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a85ec189f50d0f78d73a54413370401f5">spdk_nvme_ctrlr_free_io_qpair</a> (struct spdk_nvme_qpair *qpair)</td></tr>
<tr class="memdesc:a85ec189f50d0f78d73a54413370401f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an I/O queue pair that was allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. <br /></td></tr>
<tr class="separator:a85ec189f50d0f78d73a54413370401f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3def668122e76abbfb74305f118291"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a1e3def668122e76abbfb74305f118291">spdk_nvme_ctrlr_cmd_io_raw</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, uint32_t len, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a1e3def668122e76abbfb74305f118291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the given NVM I/O command to the NVMe controller.  <a href="#a1e3def668122e76abbfb74305f118291">More...</a><br /></td></tr>
<tr class="separator:a1e3def668122e76abbfb74305f118291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa331d140870e977722bfbb6826524782"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa331d140870e977722bfbb6826524782">spdk_nvme_qpair_process_completions</a> (struct spdk_nvme_qpair *qpair, uint32_t max_completions)</td></tr>
<tr class="memdesc:aa331d140870e977722bfbb6826524782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process any outstanding completions for I/O submitted on a queue pair.  <a href="#aa331d140870e977722bfbb6826524782">More...</a><br /></td></tr>
<tr class="separator:aa331d140870e977722bfbb6826524782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2a9d3b715649b4d0a0e89196a13e6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#afe2a9d3b715649b4d0a0e89196a13e6d">spdk_nvme_ctrlr_cmd_admin_raw</a> (struct spdk_nvme_ctrlr *ctrlr, struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, uint32_t len, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:afe2a9d3b715649b4d0a0e89196a13e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the given admin command to the NVMe controller.  <a href="#afe2a9d3b715649b4d0a0e89196a13e6d">More...</a><br /></td></tr>
<tr class="separator:afe2a9d3b715649b4d0a0e89196a13e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10282695461985f58f54de022911745e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a10282695461985f58f54de022911745e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process any outstanding completions for admin commands.  <a href="#a10282695461985f58f54de022911745e">More...</a><br /></td></tr>
<tr class="separator:a10282695461985f58f54de022911745e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f01fb8a5f404e41e6fa224a7942be08"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_ns *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6f01fb8a5f404e41e6fa224a7942be08">spdk_nvme_ctrlr_get_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t ns_id)</td></tr>
<tr class="memdesc:a6f01fb8a5f404e41e6fa224a7942be08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to a namespace for the given controller.  <a href="#a6f01fb8a5f404e41e6fa224a7942be08">More...</a><br /></td></tr>
<tr class="separator:a6f01fb8a5f404e41e6fa224a7942be08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c881cccf7873bbe4605320ffb0a81c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a88c881cccf7873bbe4605320ffb0a81c">spdk_nvme_ctrlr_cmd_get_log_page</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t log_page, uint32_t nsid, void *payload, uint32_t payload_size, uint64_t offset, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a88c881cccf7873bbe4605320ffb0a81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific log page from the NVMe controller.  <a href="#a88c881cccf7873bbe4605320ffb0a81c">More...</a><br /></td></tr>
<tr class="separator:a88c881cccf7873bbe4605320ffb0a81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9507cb98ee30e5df98474bc82190476"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa9507cb98ee30e5df98474bc82190476">spdk_nvme_ctrlr_cmd_set_feature</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t feature, uint32_t cdw11, uint32_t cdw12, void *payload, uint32_t payload_size, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aa9507cb98ee30e5df98474bc82190476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set specific feature for the given NVMe controller.  <a href="#aa9507cb98ee30e5df98474bc82190476">More...</a><br /></td></tr>
<tr class="separator:aa9507cb98ee30e5df98474bc82190476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4ebba22f1585b98e4ca20932d75434"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6b4ebba22f1585b98e4ca20932d75434">spdk_nvme_ctrlr_cmd_get_feature</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t feature, uint32_t cdw11, void *payload, uint32_t payload_size, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a6b4ebba22f1585b98e4ca20932d75434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get specific feature from given NVMe controller.  <a href="#a6b4ebba22f1585b98e4ca20932d75434">More...</a><br /></td></tr>
<tr class="separator:a6b4ebba22f1585b98e4ca20932d75434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae935583b7f95b13fbd2dd41255490da0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae935583b7f95b13fbd2dd41255490da0">spdk_nvme_ctrlr_attach_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, struct <a class="el" href="structspdk__nvme__ctrlr__list.html">spdk_nvme_ctrlr_list</a> *payload)</td></tr>
<tr class="memdesc:ae935583b7f95b13fbd2dd41255490da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach the specified namespace to controllers.  <a href="#ae935583b7f95b13fbd2dd41255490da0">More...</a><br /></td></tr>
<tr class="separator:ae935583b7f95b13fbd2dd41255490da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab562f58b5903071929d6a559fe984d0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab562f58b5903071929d6a559fe984d0a">spdk_nvme_ctrlr_detach_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, struct <a class="el" href="structspdk__nvme__ctrlr__list.html">spdk_nvme_ctrlr_list</a> *payload)</td></tr>
<tr class="memdesc:ab562f58b5903071929d6a559fe984d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach the specified namespace from controllers.  <a href="#ab562f58b5903071929d6a559fe984d0a">More...</a><br /></td></tr>
<tr class="separator:ab562f58b5903071929d6a559fe984d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace23485fea91d126a13fe706ce6d8843"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ace23485fea91d126a13fe706ce6d8843">spdk_nvme_ctrlr_create_ns</a> (struct spdk_nvme_ctrlr *ctrlr, struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a> *payload)</td></tr>
<tr class="memdesc:ace23485fea91d126a13fe706ce6d8843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a namespace.  <a href="#ace23485fea91d126a13fe706ce6d8843">More...</a><br /></td></tr>
<tr class="separator:ace23485fea91d126a13fe706ce6d8843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c62e2d4555a5ebc3a3b6f9632c51e1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7c62e2d4555a5ebc3a3b6f9632c51e1a">spdk_nvme_ctrlr_delete_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid)</td></tr>
<tr class="memdesc:a7c62e2d4555a5ebc3a3b6f9632c51e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a namespace.  <a href="#a7c62e2d4555a5ebc3a3b6f9632c51e1a">More...</a><br /></td></tr>
<tr class="separator:a7c62e2d4555a5ebc3a3b6f9632c51e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb6973133e1fd5e7a1522ab104ac92b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a9bb6973133e1fd5e7a1522ab104ac92b">spdk_nvme_ctrlr_format</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, struct <a class="el" href="structspdk__nvme__format.html">spdk_nvme_format</a> *format)</td></tr>
<tr class="memdesc:a9bb6973133e1fd5e7a1522ab104ac92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format NVM.  <a href="#a9bb6973133e1fd5e7a1522ab104ac92b">More...</a><br /></td></tr>
<tr class="separator:a9bb6973133e1fd5e7a1522ab104ac92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bf2047c92b9bb1a20cf9493fa9ebf6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa5bf2047c92b9bb1a20cf9493fa9ebf6">spdk_nvme_ctrlr_update_firmware</a> (struct spdk_nvme_ctrlr *ctrlr, void *payload, uint32_t size, int slot)</td></tr>
<tr class="memdesc:aa5bf2047c92b9bb1a20cf9493fa9ebf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download a new firmware image.  <a href="#aa5bf2047c92b9bb1a20cf9493fa9ebf6">More...</a><br /></td></tr>
<tr class="separator:aa5bf2047c92b9bb1a20cf9493fa9ebf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1863b5dccf2bcc49fe92275bc1e5a2a"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab1863b5dccf2bcc49fe92275bc1e5a2a">spdk_nvme_ns_get_data</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:ab1863b5dccf2bcc49fe92275bc1e5a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the identify namespace data as defined by the NVMe specification.  <a href="#ab1863b5dccf2bcc49fe92275bc1e5a2a">More...</a><br /></td></tr>
<tr class="separator:ab1863b5dccf2bcc49fe92275bc1e5a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54052303ef2870d6d1856f79ef6ff88a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a54052303ef2870d6d1856f79ef6ff88a">spdk_nvme_ns_get_id</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a54052303ef2870d6d1856f79ef6ff88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the namespace id (index number) from the given namespace handle.  <a href="#a54052303ef2870d6d1856f79ef6ff88a">More...</a><br /></td></tr>
<tr class="separator:a54052303ef2870d6d1856f79ef6ff88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af755eb3e5a5f767a5bdc544d85667898"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#af755eb3e5a5f767a5bdc544d85667898">spdk_nvme_ns_is_active</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:af755eb3e5a5f767a5bdc544d85667898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a namespace is active.  <a href="#af755eb3e5a5f767a5bdc544d85667898">More...</a><br /></td></tr>
<tr class="separator:af755eb3e5a5f767a5bdc544d85667898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aac85501f13bff557d3a224d8ec156"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac2aac85501f13bff557d3a224d8ec156">spdk_nvme_ns_get_max_io_xfer_size</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:ac2aac85501f13bff557d3a224d8ec156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum transfer size, in bytes, for an I/O sent to the given namespace.  <a href="#ac2aac85501f13bff557d3a224d8ec156">More...</a><br /></td></tr>
<tr class="separator:ac2aac85501f13bff557d3a224d8ec156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d24c0b2b0b2a22b0c0af2ca2e157e04"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a0d24c0b2b0b2a22b0c0af2ca2e157e04">spdk_nvme_ns_get_sector_size</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a0d24c0b2b0b2a22b0c0af2ca2e157e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sector size, in bytes, of the given namespace.  <a href="#a0d24c0b2b0b2a22b0c0af2ca2e157e04">More...</a><br /></td></tr>
<tr class="separator:a0d24c0b2b0b2a22b0c0af2ca2e157e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c522609f730db26f66e7f5b6b3501e0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7c522609f730db26f66e7f5b6b3501e0">spdk_nvme_ns_get_num_sectors</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a7c522609f730db26f66e7f5b6b3501e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of sectors for the given namespace.  <a href="#a7c522609f730db26f66e7f5b6b3501e0">More...</a><br /></td></tr>
<tr class="separator:a7c522609f730db26f66e7f5b6b3501e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8fb1bbe066260faf305581e16dde86"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a9e8fb1bbe066260faf305581e16dde86">spdk_nvme_ns_get_size</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a9e8fb1bbe066260faf305581e16dde86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size, in bytes, of the given namespace.  <a href="#a9e8fb1bbe066260faf305581e16dde86">More...</a><br /></td></tr>
<tr class="separator:a9e8fb1bbe066260faf305581e16dde86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85806a7605a104a705e7f9d3d087e4cb"><td class="memItemLeft" align="right" valign="top">enum spdk_nvme_pi_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a85806a7605a104a705e7f9d3d087e4cb">spdk_nvme_ns_get_pi_type</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a85806a7605a104a705e7f9d3d087e4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end-to-end data protection information type of the given namespace.  <a href="#a85806a7605a104a705e7f9d3d087e4cb">More...</a><br /></td></tr>
<tr class="separator:a85806a7605a104a705e7f9d3d087e4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48657f8cb6561b35e1c1b0bc18376d2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2">spdk_nvme_ns_get_md_size</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:ab48657f8cb6561b35e1c1b0bc18376d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the metadata size, in bytes, of the given namespace.  <a href="#ab48657f8cb6561b35e1c1b0bc18376d2">More...</a><br /></td></tr>
<tr class="separator:ab48657f8cb6561b35e1c1b0bc18376d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad367fec5a8963f5d930dfae485de6b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aad367fec5a8963f5d930dfae485de6b3">spdk_nvme_ns_supports_extended_lba</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:aad367fec5a8963f5d930dfae485de6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if the namespace can support extended LBA when end-to-end data protection enabled.  <a href="#aad367fec5a8963f5d930dfae485de6b3">More...</a><br /></td></tr>
<tr class="separator:aad367fec5a8963f5d930dfae485de6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eff1c1b6fbfb348a1f158b3cf70626f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a5eff1c1b6fbfb348a1f158b3cf70626f">spdk_nvme_ns_get_flags</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a5eff1c1b6fbfb348a1f158b3cf70626f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flags for the given namespace.  <a href="#a5eff1c1b6fbfb348a1f158b3cf70626f">More...</a><br /></td></tr>
<tr class="separator:a5eff1c1b6fbfb348a1f158b3cf70626f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3065f669d8b605efdcadffbf94a50538"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a3065f669d8b605efdcadffbf94a50538">spdk_nvme_ns_cmd_write</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags)</td></tr>
<tr class="memdesc:a3065f669d8b605efdcadffbf94a50538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a write I/O to the specified NVMe namespace.  <a href="#a3065f669d8b605efdcadffbf94a50538">More...</a><br /></td></tr>
<tr class="separator:a3065f669d8b605efdcadffbf94a50538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcbb5d31f0b572847cc8ae8b07dfcfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#adfcbb5d31f0b572847cc8ae8b07dfcfb">spdk_nvme_ns_cmd_writev</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn)</td></tr>
<tr class="memdesc:adfcbb5d31f0b572847cc8ae8b07dfcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a write I/O to the specified NVMe namespace.  <a href="#adfcbb5d31f0b572847cc8ae8b07dfcfb">More...</a><br /></td></tr>
<tr class="separator:adfcbb5d31f0b572847cc8ae8b07dfcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2aa2be0d657be0c63d5abc02b274ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#adc2aa2be0d657be0c63d5abc02b274ec">spdk_nvme_ns_cmd_write_with_md</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, void *metadata, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, uint16_t apptag_mask, uint16_t apptag)</td></tr>
<tr class="memdesc:adc2aa2be0d657be0c63d5abc02b274ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a write I/O to the specified NVMe namespace.  <a href="#adc2aa2be0d657be0c63d5abc02b274ec">More...</a><br /></td></tr>
<tr class="separator:adc2aa2be0d657be0c63d5abc02b274ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02e8c701c5496f163a69917ad5397dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#af02e8c701c5496f163a69917ad5397dd">spdk_nvme_ns_cmd_write_zeroes</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags)</td></tr>
<tr class="memdesc:af02e8c701c5496f163a69917ad5397dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a write zeroes I/O to the specified NVMe namespace.  <a href="#af02e8c701c5496f163a69917ad5397dd">More...</a><br /></td></tr>
<tr class="separator:af02e8c701c5496f163a69917ad5397dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084c6ecb53bd810fbb5051100b79bec5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a084c6ecb53bd810fbb5051100b79bec5">spdk_nvme_ns_cmd_read</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags)</td></tr>
<tr class="memdesc:a084c6ecb53bd810fbb5051100b79bec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a read I/O to the specified NVMe namespace.  <a href="#a084c6ecb53bd810fbb5051100b79bec5">More...</a><br /></td></tr>
<tr class="separator:a084c6ecb53bd810fbb5051100b79bec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb47ce7de6b6e963ec9fb8de261466ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#acb47ce7de6b6e963ec9fb8de261466ae">spdk_nvme_ns_cmd_readv</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn)</td></tr>
<tr class="memdesc:acb47ce7de6b6e963ec9fb8de261466ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a read I/O to the specified NVMe namespace.  <a href="#acb47ce7de6b6e963ec9fb8de261466ae">More...</a><br /></td></tr>
<tr class="separator:acb47ce7de6b6e963ec9fb8de261466ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2913b93326e636eca6dfe7b42e349fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa2913b93326e636eca6dfe7b42e349fe">spdk_nvme_ns_cmd_read_with_md</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, void *metadata, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, uint16_t apptag_mask, uint16_t apptag)</td></tr>
<tr class="memdesc:aa2913b93326e636eca6dfe7b42e349fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a read I/O to the specified NVMe namespace.  <a href="#aa2913b93326e636eca6dfe7b42e349fe">More...</a><br /></td></tr>
<tr class="separator:aa2913b93326e636eca6dfe7b42e349fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c646dd18675c54ffcf834ce699658d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac0c646dd18675c54ffcf834ce699658d">spdk_nvme_ns_cmd_dataset_management</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint32_t type, const struct <a class="el" href="structspdk__nvme__dsm__range.html">spdk_nvme_dsm_range</a> *ranges, uint16_t num_ranges, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ac0c646dd18675c54ffcf834ce699658d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a data set management request to the specified NVMe namespace.  <a href="#ac0c646dd18675c54ffcf834ce699658d">More...</a><br /></td></tr>
<tr class="separator:ac0c646dd18675c54ffcf834ce699658d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0b134e140121bb9bd8664d4a43a5c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aed0b134e140121bb9bd8664d4a43a5c6">spdk_nvme_ns_cmd_flush</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aed0b134e140121bb9bd8664d4a43a5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a flush request to the specified NVMe namespace.  <a href="#aed0b134e140121bb9bd8664d4a43a5c6">More...</a><br /></td></tr>
<tr class="separator:aed0b134e140121bb9bd8664d4a43a5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c140c47970bafbfec36bf6e4c37704"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad5c140c47970bafbfec36bf6e4c37704">spdk_nvme_ns_cmd_reservation_register</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__reservation__register__data.html">spdk_nvme_reservation_register_data</a> *payload, bool ignore_key, enum <a class="el" href="nvme__spec_8h.html#a178a7468a0a9c3e814ca2ba80e3406e5">spdk_nvme_reservation_register_action</a> action, enum <a class="el" href="nvme__spec_8h.html#a05b2db4a398c119c029c234a68760c73">spdk_nvme_reservation_register_cptpl</a> cptpl, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ad5c140c47970bafbfec36bf6e4c37704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a reservation register to the specified NVMe namespace.  <a href="#ad5c140c47970bafbfec36bf6e4c37704">More...</a><br /></td></tr>
<tr class="separator:ad5c140c47970bafbfec36bf6e4c37704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b1d9de51027da9a66fe12e2ce28132"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa2b1d9de51027da9a66fe12e2ce28132">spdk_nvme_ns_cmd_reservation_release</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__reservation__key__data.html">spdk_nvme_reservation_key_data</a> *payload, bool ignore_key, enum <a class="el" href="nvme__spec_8h.html#a6fa8ea66c4927d8bb4d81d76867e851a">spdk_nvme_reservation_release_action</a> action, enum <a class="el" href="nvme__spec_8h.html#aa7e108757c0eebbac7e13b598a378210">spdk_nvme_reservation_type</a> type, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aa2b1d9de51027da9a66fe12e2ce28132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a reservation release to the specified NVMe namespace.  <a href="#aa2b1d9de51027da9a66fe12e2ce28132">More...</a><br /></td></tr>
<tr class="separator:aa2b1d9de51027da9a66fe12e2ce28132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8028f294d09711401d098e89d87f38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#abb8028f294d09711401d098e89d87f38">spdk_nvme_ns_cmd_reservation_acquire</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__reservation__acquire__data.html">spdk_nvme_reservation_acquire_data</a> *payload, bool ignore_key, enum <a class="el" href="nvme__spec_8h.html#a95b3685443c2716ee0d125c30182aeac">spdk_nvme_reservation_acquire_action</a> action, enum <a class="el" href="nvme__spec_8h.html#aa7e108757c0eebbac7e13b598a378210">spdk_nvme_reservation_type</a> type, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:abb8028f294d09711401d098e89d87f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a reservation acquire to the specified NVMe namespace.  <a href="#abb8028f294d09711401d098e89d87f38">More...</a><br /></td></tr>
<tr class="separator:abb8028f294d09711401d098e89d87f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7b5944bda3fe9ef1c83fcd2025b39a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a9a7b5944bda3fe9ef1c83fcd2025b39a">spdk_nvme_ns_cmd_reservation_report</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, uint32_t len, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a9a7b5944bda3fe9ef1c83fcd2025b39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a reservation report to the specified NVMe namespace.  <a href="#a9a7b5944bda3fe9ef1c83fcd2025b39a">More...</a><br /></td></tr>
<tr class="separator:a9a7b5944bda3fe9ef1c83fcd2025b39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a004598ea84d2c2c408fe941ea2f3cdf7"><td class="memItemLeft" align="right" valign="top"><a id="a004598ea84d2c2c408fe941ea2f3cdf7"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_retry_count</b></td></tr>
<tr class="separator:a004598ea84d2c2c408fe941ea2f3cdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>NVMe driver public API. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ae564dc7dced1dd7b474c1a6923734a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae564dc7dced1dd7b474c1a6923734a6d">&#9670;&nbsp;</a></span>spdk_nvme_aer_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_aer_cb) (void *aer_cb_arg, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature for callback function invoked when an asynchronous error request command is completed. </p>
<p>The aer_cb_arg parameter is set to the context specified by spdk_nvme_register_aer_callback(). The <a class="el" href="structspdk__nvme__cpl.html" title="Completion queue entry. ">spdk_nvme_cpl</a> parameter contains the completion status of the asynchronous event request that was completed. </p>

</div>
</div>
<a id="ac1eaa795f075495337b270667661ce5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1eaa795f075495337b270667661ce5d">&#9670;&nbsp;</a></span>spdk_nvme_attach_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_attach_cb) (void *cb_ctx, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct spdk_nvme_ctrlr *ctrlr, const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> to report a device that has been attached to the userspace NVMe driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>NVMe controller initialization options that were actually used. Options may differ from the requested options from the probe call depending on what the controller supports. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9779e9957d7089dde8e492cc60856d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9779e9957d7089dde8e492cc60856d8">&#9670;&nbsp;</a></span>spdk_nvme_cmd_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_cmd_cb) (void *, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature for callback function invoked when a command is completed. </p>
<p>The <a class="el" href="structspdk__nvme__cpl.html" title="Completion queue entry. ">spdk_nvme_cpl</a> parameter contains the completion status. </p>

</div>
</div>
<a id="a95f40d5179f8424b466a30ba0610ab4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f40d5179f8424b466a30ba0610ab4c">&#9670;&nbsp;</a></span>spdk_nvme_probe_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* spdk_nvme_probe_cb) (void *cb_ctx, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> enumeration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>NVMe controller initialization options. This structure will be populated with the default values on entry, and the user callback may update any options to request a different value. The controller may not support all requested parameters, so the final values will be provided during the attach callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true to attach to this device. </dd></dl>

</div>
</div>
<a id="a05f1aa545be57a03bb2dd0c6180172b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f1aa545be57a03bb2dd0c6180172b6">&#9670;&nbsp;</a></span>spdk_nvme_remove_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_remove_cb) (void *cb_ctx, struct spdk_nvme_ctrlr *ctrlr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> to report that a device attached to the userspace NVMe driver has been removed from the system. </p>
<p>The controller will remain in a failed state (any new I/O submitted will fail).</p>
<p>The controller must be detached from the userspace driver by calling <a class="el" href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2" title="Detaches specified device returned by spdk_nvme_probe()&#39;s attach_cb from the NVMe driver...">spdk_nvme_detach()</a> once the controller is no longer in use. It is up to the library user to ensure that no other threads are using the controller before calling <a class="el" href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2" title="Detaches specified device returned by spdk_nvme_probe()&#39;s attach_cb from the NVMe driver...">spdk_nvme_detach()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller instance that was removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ab95bea86f498c08510f6f0bcd2eb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab95bea86f498c08510f6f0bcd2eb09">&#9670;&nbsp;</a></span>spdk_nvme_req_next_sge_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_nvme_req_next_sge_cb) (void *cb_arg, void **address, uint32_t *length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill out *address and *length with the current SGL entry and advance to the next entry for the next time the callback is invoked. </p>
<p>The cb_arg parameter is the value passed to readv/writev. The address parameter contains the virtual address of this segment. The length parameter contains the length of this physical segment. </p>

</div>
</div>
<a id="a0e1fcb43970ea531567ee00d4ee0675b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1fcb43970ea531567ee00d4ee0675b">&#9670;&nbsp;</a></span>spdk_nvme_req_reset_sgl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_req_reset_sgl_cb) (void *cb_arg, uint32_t offset)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restart the SGL walk to the specified offset when the command has scattered payloads. </p>
<p>The cb_arg parameter is the value passed to readv/writev. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a018f3b986b4345ee0c6931be9718c163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018f3b986b4345ee0c6931be9718c163">&#9670;&nbsp;</a></span>spdk_nvme_ns_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163">spdk_nvme_ns_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Namespace command support flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163a80dcd48a57fa9e14efba4757300ad729"></a>SPDK_NVME_NS_DEALLOCATE_SUPPORTED&#160;</td><td class="fielddoc"><p>The deallocate command is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163ad403aafc70c00560a1db768029933400"></a>SPDK_NVME_NS_FLUSH_SUPPORTED&#160;</td><td class="fielddoc"><p>The flush command is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163a60edfdee88fbe811250e2f8ff63597d0"></a>SPDK_NVME_NS_RESERVATION_SUPPORTED&#160;</td><td class="fielddoc"><p>The reservation command is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163a4e691401f3709b7cd66bd32c28ae109b"></a>SPDK_NVME_NS_WRITE_ZEROES_SUPPORTED&#160;</td><td class="fielddoc"><p>The write zeroes command is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163afe158b050528f0f3341e5af3129c61a7"></a>SPDK_NVME_NS_DPS_PI_SUPPORTED&#160;</td><td class="fielddoc"><p>The end-to-end data protection is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163a91203896ead47bbe22e9f7db8a63c14f"></a>SPDK_NVME_NS_EXTENDED_LBA_SUPPORTED&#160;</td><td class="fielddoc"><p>The extended lba format is supported, metadata is transferred as a contiguous part of the logical block that it is associated with. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae87a03c28984a2c0499d50ef5e9d0ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87a03c28984a2c0499d50ef5e9d0ece">&#9670;&nbsp;</a></span>spdk_nvme_transport_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NVMe library transports. </p>
<p>NOTE: These are mapped directly to the NVMe over Fabrics TRTYPE values, except for PCIe, which is a special case since NVMe over Fabrics does not define a TRTYPE for local PCIe.</p>
<p>Currently, this uses 256 for PCIe which is intentionally outside of the 8-bit range of TRTYPE. If the NVMe-oF specification ever defines a PCIe TRTYPE, this should be updated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae87a03c28984a2c0499d50ef5e9d0ecea162afc05d1ae756b8a7969be140035ea"></a>SPDK_NVME_TRANSPORT_PCIE&#160;</td><td class="fielddoc"><p>PCIe Transport (locally attached devices) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae87a03c28984a2c0499d50ef5e9d0ecea140f1cb4edf258bddffeb1c7277d93d8"></a>SPDK_NVME_TRANSPORT_RDMA&#160;</td><td class="fielddoc"><p>RDMA Transport (RoCE, iWARP, etc.) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6a1feac35f9a3d7dc50b1870e820ab65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1feac35f9a3d7dc50b1870e820ab65">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_alloc_io_qpair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_qpair* spdk_nvme_ctrlr_alloc_io_qpair </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#ae83a61e254cf9d1fd59376ceedd1b4e6">spdk_nvme_qprio</a>&#160;</td>
          <td class="paramname"><em>qprio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an I/O queue pair (submission and completion queue). </p>
<p>Each queue pair should only be used from a single thread at a time (mutual exclusion must be enforced by the user).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller for which to allocate the I/O queue pair. </td></tr>
    <tr><td class="paramname">qprio</td><td>Queue priority for weighted round robin arbitration. If a different arbitration method is in use, pass 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae935583b7f95b13fbd2dd41255490da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae935583b7f95b13fbd2dd41255490da0">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_attach_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_attach_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__ctrlr__list.html">spdk_nvme_ctrlr_list</a> *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach the specified namespace to controllers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to use for command submission. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace identifier for namespace to attach. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the controller list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if resources could not be allocated for this request</dd></dl>
<p>This function is thread safe and can be called at any point after spdk_nvme_attach().</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function. </p>

</div>
</div>
<a id="afe2a9d3b715649b4d0a0e89196a13e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2a9d3b715649b4d0a0e89196a13e6d">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_admin_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_admin_raw </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the given admin command to the NVMe controller. </p>
<p>This is a low level interface for submitting admin commands directly. Prefer the spdk_nvme_ctrlr_cmd_* functions instead. The validity of the command will not be checked!</p>
<p>When constructing the nvme_command it is not necessary to fill out the PRP list/SGL or the CID. The driver will handle both of those for you.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function. </p>

</div>
</div>
<a id="a6b4ebba22f1585b98e4ca20932d75434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4ebba22f1585b98e4ca20932d75434">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_get_feature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_get_feature </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get specific feature from given NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to query. </td></tr>
    <tr><td class="paramname">feature</td><td>The feature identifier. </td></tr>
    <tr><td class="paramname">cdw11</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the feature has been retrieved. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if resources could not be allocated for this request</dd></dl>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#aa9507cb98ee30e5df98474bc82190476" title="Set specific feature for the given NVMe controller. ">spdk_nvme_ctrlr_cmd_set_feature()</a> </dd></dl>

</div>
</div>
<a id="a88c881cccf7873bbe4605320ffb0a81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c881cccf7873bbe4605320ffb0a81c">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_get_log_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_get_log_page </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>log_page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific log page from the NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to query. </td></tr>
    <tr><td class="paramname">log_page</td><td>The log page identifier. </td></tr>
    <tr><td class="paramname">nsid</td><td>Depending on the log page, this may be 0, a namespace identifier, or SPDK_NVME_GLOBAL_NS_TAG. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes within the log page to start retrieving log page data. May only be non-zero if the controller supports extended data for Get Log Page as reported in the controller data log page attributes. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the log page has been retrieved. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if resources could not be allocated for this request</dd></dl>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a7dc6bb842e168a68972ec46cc35591ae" title="Determine if a particular log page is supported by the given NVMe controller. ">spdk_nvme_ctrlr_is_log_page_supported()</a> </dd></dl>

</div>
</div>
<a id="a1e3def668122e76abbfb74305f118291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3def668122e76abbfb74305f118291">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_io_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_io_raw </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the given NVM I/O command to the NVMe controller. </p>
<p>This is a low level interface for submitting I/O commands directly. Prefer the spdk_nvme_ns_cmd_* functions instead. The validity of the command will not be checked!</p>
<p>When constructing the nvme_command it is not necessary to fill out the PRP list/SGL or the CID. The driver will handle both of those for you.</p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time. </p>

</div>
</div>
<a id="aa9507cb98ee30e5df98474bc82190476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9507cb98ee30e5df98474bc82190476">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_set_feature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_set_feature </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set specific feature for the given NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to manipulate. </td></tr>
    <tr><td class="paramname">feature</td><td>The feature identifier. </td></tr>
    <tr><td class="paramname">cdw11</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">cdw12</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the feature has been set. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if resources could not be allocated for this request</dd></dl>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a6b4ebba22f1585b98e4ca20932d75434" title="Get specific feature from given NVMe controller. ">spdk_nvme_ctrlr_cmd_get_feature()</a> </dd></dl>

</div>
</div>
<a id="ace23485fea91d126a13fe706ce6d8843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace23485fea91d126a13fe706ce6d8843">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_create_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ctrlr_create_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a> *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to create namespace on. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the NVMe namespace data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Namespace ID (&gt;= 1) if successfully created, or 0 if the request failed.</dd></dl>
<p>This function is thread safe and can be called at any point after spdk_nvme_attach(). </p>

</div>
</div>
<a id="a7c62e2d4555a5ebc3a3b6f9632c51e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c62e2d4555a5ebc3a3b6f9632c51e1a">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_delete_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_delete_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to delete namespace from. </td></tr>
    <tr><td class="paramname">nsid</td><td>The namespace identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if resources could not be allocated for this request</dd></dl>
<p>This function is thread safe and can be called at any point after spdk_nvme_attach().</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function. </p>

</div>
</div>
<a id="ab562f58b5903071929d6a559fe984d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab562f58b5903071929d6a559fe984d0a">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_detach_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_detach_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__ctrlr__list.html">spdk_nvme_ctrlr_list</a> *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach the specified namespace from controllers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to use for command submission. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace ID to detach. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the controller list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if resources could not be allocated for this request</dd></dl>
<p>This function is thread safe and can be called at any point after spdk_nvme_attach().</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function. </p>

</div>
</div>
<a id="a9bb6973133e1fd5e7a1522ab104ac92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb6973133e1fd5e7a1522ab104ac92b">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_format </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__format.html">spdk_nvme_format</a> *&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format NVM. </p>
<p>This function requests a low-level format of the media.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to format. </td></tr>
    <tr><td class="paramname">nsid</td><td>The namespace identifier. May be SPDK_NVME_GLOBAL_NS_TAG to format all namespaces. </td></tr>
    <tr><td class="paramname">format</td><td>The format information for the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if resources could not be allocated for this request</dd></dl>
<p>This function is thread safe and can be called at any point after spdk_nvme_attach(). </p>

</div>
</div>
<a id="a5a9daf15b5008ac36c12e7b8db7bdec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9daf15b5008ac36c12e7b8db7bdec9">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__nvme__ctrlr__data.html">spdk_nvme_ctrlr_data</a>* spdk_nvme_ctrlr_get_data </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the identify controller data as defined by the NVMe specification. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver. </p>

</div>
</div>
<a id="a6f01fb8a5f404e41e6fa224a7942be08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f01fb8a5f404e41e6fa224a7942be08">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_ns* spdk_nvme_ctrlr_get_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ns_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to a namespace for the given controller. </p>
<p>Namespaces are numbered from 1 to the total number of namespaces. There will never be any gaps in the numbering. The number of namespaces is obtained by calling <a class="el" href="nvme_8h.html#a02b18deae44682a51177e8a4193af602" title="Get the number of namespaces for the given NVMe controller. ">spdk_nvme_ctrlr_get_num_ns()</a>.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver. </p>

</div>
</div>
<a id="a02b18deae44682a51177e8a4193af602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b18deae44682a51177e8a4193af602">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_num_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ctrlr_get_num_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of namespaces for the given NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>This is equivalent to calling <a class="el" href="nvme_8h.html#a5a9daf15b5008ac36c12e7b8db7bdec9" title="Get the identify controller data as defined by the NVMe specification. ">spdk_nvme_ctrlr_get_data()</a> to get the <a class="el" href="structspdk__nvme__ctrlr__data.html">spdk_nvme_ctrlr_data</a> and then reading the nn field. </p>

</div>
</div>
<a id="a909b61e141b56eaa5895482aa1f18a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909b61e141b56eaa5895482aa1f18a3b">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_is_feature_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ctrlr_is_feature_supported </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>feature_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a particular feature is supported by the given NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a6b4ebba22f1585b98e4ca20932d75434" title="Get specific feature from given NVMe controller. ">spdk_nvme_ctrlr_cmd_get_feature()</a> </dd></dl>

</div>
</div>
<a id="a7dc6bb842e168a68972ec46cc35591ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc6bb842e168a68972ec46cc35591ae">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_is_log_page_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ctrlr_is_log_page_supported </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>log_page</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a particular log page is supported by the given NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a88c881cccf7873bbe4605320ffb0a81c" title="Get a specific log page from the NVMe controller. ">spdk_nvme_ctrlr_cmd_get_log_page()</a> </dd></dl>

</div>
</div>
<a id="a10282695461985f58f54de022911745e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10282695461985f58f54de022911745e">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_process_admin_completions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t spdk_nvme_ctrlr_process_admin_completions </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process any outstanding completions for admin commands. </p>
<p>This will process completions for admin commands submitted on any thread.</p>
<p>This call is non-blocking, i.e. it only processes completions that are ready at the time of this function call. It does not wait for outstanding commands to finish.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of completions processed (may be 0) or negative on error.</dd></dl>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver. </p>

</div>
</div>
<a id="a8e12d6d7cf10399d0a06c99085be99bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e12d6d7cf10399d0a06c99085be99bf">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_register_timeout_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_register_timeout_callback </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac4cdd2049888a1ebb020cb14976a62b9">spdk_nvme_timeout_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register for timeout callback on a controller. </p>
<p>The application can choose to register for timeout callback or not register for timeout callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller on which to monitor for timeout. </td></tr>
    <tr><td class="paramname">timeout_sec</td><td>Timeout value in seconds. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A function pointer that points to the callback function </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae13ccd2ea831842a5008eb95a32545c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13ccd2ea831842a5008eb95a32545c3">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_reset </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a full hardware reset of the NVMe controller. </p>
<p>This function should be called from a single thread while no other threads are actively using the NVMe device.</p>
<p>Any pointers returned from <a class="el" href="nvme_8h.html#a6f01fb8a5f404e41e6fa224a7942be08" title="Get a handle to a namespace for the given controller. ">spdk_nvme_ctrlr_get_ns()</a> and <a class="el" href="nvme_8h.html#ab1863b5dccf2bcc49fe92275bc1e5a2a" title="Get the identify namespace data as defined by the NVMe specification. ">spdk_nvme_ns_get_data()</a> may be invalidated by calling this function. The number of namespaces as returned by <a class="el" href="nvme_8h.html#a02b18deae44682a51177e8a4193af602" title="Get the number of namespaces for the given NVMe controller. ">spdk_nvme_ctrlr_get_num_ns()</a> may also change. </p>

</div>
</div>
<a id="aa5bf2047c92b9bb1a20cf9493fa9ebf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5bf2047c92b9bb1a20cf9493fa9ebf6">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_update_firmware()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_update_firmware </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Download a new firmware image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>The data buffer for the firmware image. </td></tr>
    <tr><td class="paramname">size</td><td>The data size will be downloaded. </td></tr>
    <tr><td class="paramname">slot</td><td>The slot that the firmware image will be committed to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if resources could not be allocated for this request, -1 if the size is not multiple of 4.</dd></dl>
<p>This function is thread safe and can be called at any point after spdk_nvme_attach(). </p>

</div>
</div>
<a id="a4b63c225c3cce6da60fdbfb6f54b11e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b63c225c3cce6da60fdbfb6f54b11e2">&#9670;&nbsp;</a></span>spdk_nvme_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_detach </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches specified device returned by <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d">spdk_nvme_probe()</a>'s attach_cb from the NVMe driver. </p>
<p>On success, the spdk_nvme_ctrlr handle is no longer valid.</p>
<p>This function should be called from a single thread while no other threads are actively using the NVMe device. </p>

</div>
</div>
<a id="ac0c646dd18675c54ffcf834ce699658d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c646dd18675c54ffcf834ce699658d">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_dataset_management()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_dataset_management </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__dsm__range.html">spdk_nvme_dsm_range</a> *&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a data set management request to the specified NVMe namespace. </p>
<p>Data set management operations are designed to optimize interaction with the block translation layer inside the device. The most common type of operation is deallocate, which is often referred to as TRIM or UNMAP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the DSM request </td></tr>
    <tr><td class="paramname">type</td><td>A bit field constructed from enum spdk_nvme_dsm_attribute. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">ranges</td><td>An array of <a class="el" href="structspdk__nvme__dsm__range.html">spdk_nvme_dsm_range</a> elements describing the LBAs to operate on. </td></tr>
    <tr><td class="paramname">num_ranges</td><td>The number of elements in the ranges array. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated POSIX errno values otherwise.</dd></dl>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<p>This is a convenience wrapper that will automatically allocate and construct the correct data buffers. Therefore, ranges does not need to be allocated from pinned memory and can be placed on the stack. If a higher performance, zero-copy version of DSM is required, simply build and submit a raw command using <a class="el" href="nvme_8h.html#a1e3def668122e76abbfb74305f118291" title="Send the given NVM I/O command to the NVMe controller. ">spdk_nvme_ctrlr_cmd_io_raw()</a>. </p>

</div>
</div>
<a id="aed0b134e140121bb9bd8664d4a43a5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0b134e140121bb9bd8664d4a43a5c6">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_flush </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a flush request to the specified NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the flush request </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if an nvme_request structure cannot be allocated for the I/O request</dd></dl>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time. </p>

</div>
</div>
<a id="a084c6ecb53bd810fbb5051100b79bec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084c6ecb53bd810fbb5051100b79bec5">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_read </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a read I/O to the specified NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the read I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">payload</td><td>virtual address pointer to the data payload </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA to read the data </td></tr>
    <tr><td class="paramname">lba_count</td><td>length (in sectors) for the read operation </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function </td></tr>
    <tr><td class="paramname">io_flags</td><td>set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">nvme_spec.h</a>, for this I/O</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if an nvme_request structure cannot be allocated for the I/O request</dd></dl>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time. </p>

</div>
</div>
<a id="aa2913b93326e636eca6dfe7b42e349fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2913b93326e636eca6dfe7b42e349fe">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_read_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_read_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a read I/O to the specified NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the read I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">payload</td><td>virtual address pointer to the data payload </td></tr>
    <tr><td class="paramname">metadata</td><td>virtual address pointer to the metadata payload, the length of metadata is specified by <a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2" title="Get the metadata size, in bytes, of the given namespace. ">spdk_nvme_ns_get_md_size()</a> </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA to read the data </td></tr>
    <tr><td class="paramname">lba_count</td><td>length (in sectors) for the read operation </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function </td></tr>
    <tr><td class="paramname">io_flags</td><td>set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">nvme_spec.h</a>, for this I/O </td></tr>
    <tr><td class="paramname">apptag_mask</td><td>application tag mask. </td></tr>
    <tr><td class="paramname">apptag</td><td>application tag to use end-to-end protection information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if an nvme_request structure cannot be allocated for the I/O request</dd></dl>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time. </p>

</div>
</div>
<a id="acb47ce7de6b6e963ec9fb8de261466ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb47ce7de6b6e963ec9fb8de261466ae">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_readv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_readv </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a read I/O to the specified NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the read I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA to read the data </td></tr>
    <tr><td class="paramname">lba_count</td><td>length (in sectors) for the read operation </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function </td></tr>
    <tr><td class="paramname">io_flags</td><td>set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">nvme_spec.h</a>, for this I/O </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>callback function to reset scattered payload </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>callback function to iterate each scattered payload memory segment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if an nvme_request structure cannot be allocated for the I/O request</dd></dl>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time. </p>

</div>
</div>
<a id="abb8028f294d09711401d098e89d87f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8028f294d09711401d098e89d87f38">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_reservation_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_reservation_acquire </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__reservation__acquire__data.html">spdk_nvme_reservation_acquire_data</a> *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#a95b3685443c2716ee0d125c30182aeac">spdk_nvme_reservation_acquire_action</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#aa7e108757c0eebbac7e13b598a378210">spdk_nvme_reservation_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a reservation acquire to the specified NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the reservation acquire request </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">payload</td><td>virtual address pointer to reservation acquire data </td></tr>
    <tr><td class="paramname">ignore_key</td><td>'1' the current reservation key check is disabled </td></tr>
    <tr><td class="paramname">action</td><td>specifies the reservation acquire action </td></tr>
    <tr><td class="paramname">type</td><td>reservation type for the namespace </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if an nvme_request structure cannot be allocated for the I/O request</dd></dl>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time. </p>

</div>
</div>
<a id="ad5c140c47970bafbfec36bf6e4c37704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c140c47970bafbfec36bf6e4c37704">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_reservation_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_reservation_register </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__reservation__register__data.html">spdk_nvme_reservation_register_data</a> *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#a178a7468a0a9c3e814ca2ba80e3406e5">spdk_nvme_reservation_register_action</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#a05b2db4a398c119c029c234a68760c73">spdk_nvme_reservation_register_cptpl</a>&#160;</td>
          <td class="paramname"><em>cptpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a reservation register to the specified NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the reservation register request </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">payload</td><td>virtual address pointer to the reservation register data </td></tr>
    <tr><td class="paramname">ignore_key</td><td>'1' the current reservation key check is disabled </td></tr>
    <tr><td class="paramname">action</td><td>specifies the registration action </td></tr>
    <tr><td class="paramname">cptpl</td><td>change the Persist Through Power Loss state </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if an nvme_request structure cannot be allocated for the I/O request</dd></dl>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time. </p>

</div>
</div>
<a id="aa2b1d9de51027da9a66fe12e2ce28132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b1d9de51027da9a66fe12e2ce28132">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_reservation_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_reservation_release </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__reservation__key__data.html">spdk_nvme_reservation_key_data</a> *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#a6fa8ea66c4927d8bb4d81d76867e851a">spdk_nvme_reservation_release_action</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#aa7e108757c0eebbac7e13b598a378210">spdk_nvme_reservation_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a reservation release to the specified NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the reservation release request </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">payload</td><td>virtual address pointer to current reservation key </td></tr>
    <tr><td class="paramname">ignore_key</td><td>'1' the current reservation key check is disabled </td></tr>
    <tr><td class="paramname">action</td><td>specifies the reservation release action </td></tr>
    <tr><td class="paramname">type</td><td>reservation type for the namespace </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if an nvme_request structure cannot be allocated for the I/O request</dd></dl>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time. </p>

</div>
</div>
<a id="a9a7b5944bda3fe9ef1c83fcd2025b39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7b5944bda3fe9ef1c83fcd2025b39a">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_reservation_report()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_reservation_report </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a reservation report to the specified NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the reservation report request </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">payload</td><td>virtual address pointer for reservation status data </td></tr>
    <tr><td class="paramname">len</td><td>length bytes for reservation status data structure </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if an nvme_request structure cannot be allocated for the I/O request</dd></dl>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time. </p>

</div>
</div>
<a id="a3065f669d8b605efdcadffbf94a50538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3065f669d8b605efdcadffbf94a50538">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_write </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a write I/O to the specified NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">payload</td><td>virtual address pointer to the data payload </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA to write the data </td></tr>
    <tr><td class="paramname">lba_count</td><td>length (in sectors) for the write operation </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function </td></tr>
    <tr><td class="paramname">io_flags</td><td>set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">spdk/nvme_spec.h</a>, for this I/O.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if an nvme_request structure cannot be allocated for the I/O request</dd></dl>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time. </p>

</div>
</div>
<a id="adc2aa2be0d657be0c63d5abc02b274ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2aa2be0d657be0c63d5abc02b274ec">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_write_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_write_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a write I/O to the specified NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">payload</td><td>virtual address pointer to the data payload </td></tr>
    <tr><td class="paramname">metadata</td><td>virtual address pointer to the metadata payload, the length of metadata is specified by <a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2" title="Get the metadata size, in bytes, of the given namespace. ">spdk_nvme_ns_get_md_size()</a> </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA to write the data </td></tr>
    <tr><td class="paramname">lba_count</td><td>length (in sectors) for the write operation </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function </td></tr>
    <tr><td class="paramname">io_flags</td><td>set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">spdk/nvme_spec.h</a>, for this I/O. </td></tr>
    <tr><td class="paramname">apptag_mask</td><td>application tag mask. </td></tr>
    <tr><td class="paramname">apptag</td><td>application tag to use end-to-end protection information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if an nvme_request structure cannot be allocated for the I/O request</dd></dl>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time. </p>

</div>
</div>
<a id="af02e8c701c5496f163a69917ad5397dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02e8c701c5496f163a69917ad5397dd">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_write_zeroes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_write_zeroes </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a write zeroes I/O to the specified NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write zeroes I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA for this command </td></tr>
    <tr><td class="paramname">lba_count</td><td>length (in sectors) for the write zero operation </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function </td></tr>
    <tr><td class="paramname">io_flags</td><td>set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">spdk/nvme_spec.h</a>, for this I/O.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if an nvme_request structure cannot be allocated for the I/O request</dd></dl>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time. </p>

</div>
</div>
<a id="adfcbb5d31f0b572847cc8ae8b07dfcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcbb5d31f0b572847cc8ae8b07dfcfb">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_writev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_writev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a write I/O to the specified NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA to write the data </td></tr>
    <tr><td class="paramname">lba_count</td><td>length (in sectors) for the write operation </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function </td></tr>
    <tr><td class="paramname">io_flags</td><td>set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">nvme_spec.h</a>, for this I/O </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>callback function to reset scattered payload </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>callback function to iterate each scattered payload memory segment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if an nvme_request structure cannot be allocated for the I/O request</dd></dl>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a6a1feac35f9a3d7dc50b1870e820ab65" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time. </p>

</div>
</div>
<a id="ab1863b5dccf2bcc49fe92275bc1e5a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1863b5dccf2bcc49fe92275bc1e5a2a">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a>* spdk_nvme_ns_get_data </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the identify namespace data as defined by the NVMe specification. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver. </p>

</div>
</div>
<a id="a5eff1c1b6fbfb348a1f158b3cf70626f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eff1c1b6fbfb348a1f158b3cf70626f">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_flags </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the flags for the given namespace. </p>
<p>See spdk_nvme_ns_flags for the possible flags returned.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver. </p>

</div>
</div>
<a id="a54052303ef2870d6d1856f79ef6ff88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54052303ef2870d6d1856f79ef6ff88a">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the namespace id (index number) from the given namespace handle. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver. </p>

</div>
</div>
<a id="ac2aac85501f13bff557d3a224d8ec156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2aac85501f13bff557d3a224d8ec156">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_max_io_xfer_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_max_io_xfer_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum transfer size, in bytes, for an I/O sent to the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver. </p>

</div>
</div>
<a id="ab48657f8cb6561b35e1c1b0bc18376d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48657f8cb6561b35e1c1b0bc18376d2">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_md_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_md_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the metadata size, in bytes, of the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver. </p>

</div>
</div>
<a id="a7c522609f730db26f66e7f5b6b3501e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c522609f730db26f66e7f5b6b3501e0">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_num_sectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_nvme_ns_get_num_sectors </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of sectors for the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver. </p>

</div>
</div>
<a id="a85806a7605a104a705e7f9d3d087e4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85806a7605a104a705e7f9d3d087e4cb">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_pi_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum spdk_nvme_pi_type spdk_nvme_ns_get_pi_type </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the end-to-end data protection information type of the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver. </p>

</div>
</div>
<a id="a0d24c0b2b0b2a22b0c0af2ca2e157e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d24c0b2b0b2a22b0c0af2ca2e157e04">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_sector_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_sector_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sector size, in bytes, of the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver. </p>

</div>
</div>
<a id="a9e8fb1bbe066260faf305581e16dde86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8fb1bbe066260faf305581e16dde86">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_nvme_ns_get_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size, in bytes, of the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver. </p>

</div>
</div>
<a id="af755eb3e5a5f767a5bdc544d85667898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af755eb3e5a5f767a5bdc544d85667898">&#9670;&nbsp;</a></span>spdk_nvme_ns_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ns_is_active </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a namespace is active. </p>
<p>Inactive namespaces cannot be the target of I/O commands. </p>

</div>
</div>
<a id="aad367fec5a8963f5d930dfae485de6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad367fec5a8963f5d930dfae485de6b3">&#9670;&nbsp;</a></span>spdk_nvme_ns_supports_extended_lba()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ns_supports_extended_lba </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if the namespace can support extended LBA when end-to-end data protection enabled. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver. </p>

</div>
</div>
<a id="a225bbc386ec518ae21bd5536f21db45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225bbc386ec518ae21bd5536f21db45d">&#9670;&nbsp;</a></span>spdk_nvme_probe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_probe </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a95f40d5179f8424b466a30ba0610ab4c">spdk_nvme_probe_cb</a>&#160;</td>
          <td class="paramname"><em>probe_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a>&#160;</td>
          <td class="paramname"><em>attach_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a>&#160;</td>
          <td class="paramname"><em>remove_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device found if desired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid</td><td>The transport ID indicating which bus to enumerate. If the trtype is PCIe or trid is NULL, this will scan the local PCIe bus. If the trtype is RDMA, the traddr and trsvcid must point at the location of an NVMe-oF discovery service. </td></tr>
    <tr><td class="paramname">cb_ctx</td><td>Opaque value which will be passed back in cb_ctx parameter of the callbacks. </td></tr>
    <tr><td class="paramname">probe_cb</td><td>will be called once per NVMe device found in the system. </td></tr>
    <tr><td class="paramname">attach_cb</td><td>will be called for devices for which probe_cb returned true once that NVMe controller has been attached to the userspace driver. </td></tr>
    <tr><td class="paramname">remove_cb</td><td>will be called for devices that were attached in a previous <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> call but are no longer attached to the system. Optional; specify NULL if removal notices are not desired.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is not thread safe and should only be called from one thread at a time while no other threads are actively using any NVMe devices.</p>
<p>If called from a secondary process, only devices that have been attached to the userspace driver in the primary process will be probed.</p>
<p>If called more than once, only devices that are not already attached to the SPDK NVMe driver will be reported.</p>
<p>To stop using the the controller and release its associated resources, call <a class="el" href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2">spdk_nvme_detach</a> with the spdk_nvme_ctrlr instance returned by this function. </p>

</div>
</div>
<a id="aa331d140870e977722bfbb6826524782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa331d140870e977722bfbb6826524782">&#9670;&nbsp;</a></span>spdk_nvme_qpair_process_completions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t spdk_nvme_qpair_process_completions </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_completions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process any outstanding completions for I/O submitted on a queue pair. </p>
<p>This call is non-blocking, i.e. it only processes completions that are ready at the time of this function call. It does not wait for outstanding commands to finish.</p>
<p>For each completed command, the request's callback function will be called if specified as non-NULL when the request was submitted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>Queue pair to check for completions. </td></tr>
    <tr><td class="paramname">max_completions</td><td>Limit the number of completions to be processed in one call, or 0 for unlimited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of completions processed (may be 0) or negative on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8" title="Signature for callback function invoked when a command is completed. ">spdk_nvme_cmd_cb</a></dd></dl>
<p>This function may be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>The caller must ensure that each queue pair is only used from one thread at a time. </p>

</div>
</div>
<a id="ab5735e7600f79c45871b3dc3adb292f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5735e7600f79c45871b3dc3adb292f2">&#9670;&nbsp;</a></span>spdk_nvme_transport_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_transport_available </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a>&#160;</td>
          <td class="paramname"><em>trtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the NVMe library can handle a specific NVMe over Fabrics transport type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trtype</td><td>NVMe over Fabrics transport type to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if trtype is supported or false if it is not supported. </dd></dl>

</div>
</div>
<a id="ac37484cc5d14777e4ae1fde031d0edf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37484cc5d14777e4ae1fde031d0edf2">&#9670;&nbsp;</a></span>spdk_nvme_transport_id_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_transport_id_parse </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the string representation of a transport ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid</td><td>Output transport ID structure (must be allocated and initialized by caller). </td></tr>
    <tr><td class="paramname">str</td><td>Input string representation of a transport ID to parse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if parsing was successful and trid is filled out, or negated errno values on failure.</dd></dl>
<p>str must be a zero-terminated C string containing one or more key:value pairs separated by whitespace.</p>
<table class="doxtable">
<tr>
<th>Key </th><th>Value  </th></tr>
<tr>
<td>trtype </td><td>Transport type (e.g. PCIe, RDMA) </td></tr>
<tr>
<td>adrfam </td><td>Address family (e.g. IPv4, IPv6) </td></tr>
<tr>
<td>traddr </td><td>Transport address (e.g. 0000:04:00.0 for PCIe or 192.168.100.8 for RDMA) </td></tr>
<tr>
<td>trsvcid </td><td>Transport service identifier (e.g. 4420) </td></tr>
<tr>
<td>subnqn </td><td>Subsystem NQN </td></tr>
</table>
<p>Unspecified fields of trid are left unmodified, so the caller must initialize trid (for example, memset() to 0) before calling this function. </p>

</div>
</div>
</div><!-- contents -->
<section id="community">
  <div class="community">
    <div class="container">
      <div class="col-lg-6">
        <h2>Join Our Community:</h2>
      </div>
      <div class="col-lg-6">
        <div class="btn-group-vertical" role="group">
          <a href="http://www.spdk.io/" class="btn btn-default btn-lg">
            <i class="glyphicon glyphicon-home"></i>
            <span class="box-name">home</span>
          </a>
          <a href="https://github.com/spdk/spdk/releases/" class="btn btn-default btn-lg">
            <i class="glyphicon glyphicon-download-alt"></i>
            <span class="box-name">download</span>
          </a>
          <a href="http://www.spdk.io/doc/" class="btn btn-default btn-lg">
            <i class="glyphicon glyphicon-book"></i>
            <span class="box-name">documentation</span>
          </a>
          <a href="https://github.com/spdk/spdk/" class="btn btn-default btn-lg">
            <i class="glyphicon glyphicon-wrench"></i>
            <span class="box-name">development</span>
          </a>
          <a href="https://lists.01.org/mailman/listinfo/spdk" class="btn btn-default btn-lg">
            <i class="glyphicon glyphicon-envelope"></i>
            <span class="box-name">mailing list</span>
          </a>
          <a href="http://www.spdk.io/blog/" class="btn btn-default btn-lg">
            <i class="glyphicon glyphicon-comment"></i>
            <span class="box-name">Blog</span>
          </a>
        </div>
      </div>
    </div>
  </div>
</section>
<footer>
  <div class="container text-center">
    <p class="copyright text-muted small">Copyright  Intel Corporation. All Rights Reserved.</p>
  </div>
</footer>
