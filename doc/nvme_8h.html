<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.14">
  <title>SPDK: nvme.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="two.min.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-xs-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://spdk.io/ci/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://trello.com/b/MN8auadQ/spdk-roadmap">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('nvme_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nvme.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>NVMe driver public API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe controller initialization options.  <a href="structspdk__nvme__ctrlr__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe transport identifier.  <a href="structspdk__nvme__transport__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__host__id.html">spdk_nvme_host_id</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe host identifier.  <a href="structspdk__nvme__host__id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__io__qpair__opts.html">spdk_nvme_io_qpair_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe I/O queue pair initialization options.  <a href="structspdk__nvme__io__qpair__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvme__rdma__hooks.html">spdk_nvme_rdma_hooks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RDMA Transport Hooks.  <a href="structspdk__nvme__rdma__hooks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aae15274f006778f31211e555a5cab825"><td class="memItemLeft" align="right" valign="top"><a id="aae15274f006778f31211e555a5cab825"></a>
typedef enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_transport_type_t</b></td></tr>
<tr class="separator:aae15274f006778f31211e555a5cab825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f40d5179f8424b466a30ba0610ab4c"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a95f40d5179f8424b466a30ba0610ab4c">spdk_nvme_probe_cb</a>) (void *cb_ctx, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts)</td></tr>
<tr class="memdesc:a95f40d5179f8424b466a30ba0610ab4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> enumeration.  <a href="#a95f40d5179f8424b466a30ba0610ab4c">More...</a><br /></td></tr>
<tr class="separator:a95f40d5179f8424b466a30ba0610ab4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eaa795f075495337b270667661ce5d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a>) (void *cb_ctx, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct spdk_nvme_ctrlr *ctrlr, const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts)</td></tr>
<tr class="memdesc:ac1eaa795f075495337b270667661ce5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for spdk_nvme_attach() to report a device that has been attached to the userspace NVMe driver.  <a href="#ac1eaa795f075495337b270667661ce5d">More...</a><br /></td></tr>
<tr class="separator:ac1eaa795f075495337b270667661ce5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f1aa545be57a03bb2dd0c6180172b6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a>) (void *cb_ctx, struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a05f1aa545be57a03bb2dd0c6180172b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for spdk_nvme_remove() to report that a device attached to the userspace NVMe driver has been removed from the system.  <a href="#a05f1aa545be57a03bb2dd0c6180172b6">More...</a><br /></td></tr>
<tr class="separator:a05f1aa545be57a03bb2dd0c6180172b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9779e9957d7089dde8e492cc60856d8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>) (void *, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *)</td></tr>
<tr class="memdesc:ac9779e9957d7089dde8e492cc60856d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for callback function invoked when a command is completed.  <a href="#ac9779e9957d7089dde8e492cc60856d8">More...</a><br /></td></tr>
<tr class="separator:ac9779e9957d7089dde8e492cc60856d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae564dc7dced1dd7b474c1a6923734a6d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae564dc7dced1dd7b474c1a6923734a6d">spdk_nvme_aer_cb</a>) (void *aer_cb_arg, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *)</td></tr>
<tr class="memdesc:ae564dc7dced1dd7b474c1a6923734a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for callback function invoked when an asynchronous error request command is completed.  <a href="#ae564dc7dced1dd7b474c1a6923734a6d">More...</a><br /></td></tr>
<tr class="separator:ae564dc7dced1dd7b474c1a6923734a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fe1c01a447be8fcd29821a668227a0"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a53fe1c01a447be8fcd29821a668227a0">spdk_nvme_timeout_cb</a>) (void *cb_arg, struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, uint16_t cid)</td></tr>
<tr class="memdesc:a53fe1c01a447be8fcd29821a668227a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signature for the callback function invoked when a timeout is detected on a request.  <a href="#a53fe1c01a447be8fcd29821a668227a0">More...</a><br /></td></tr>
<tr class="separator:a53fe1c01a447be8fcd29821a668227a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1fcb43970ea531567ee00d4ee0675b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>) (void *cb_arg, uint32_t offset)</td></tr>
<tr class="memdesc:a0e1fcb43970ea531567ee00d4ee0675b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart the SGL walk to the specified offset when the command has scattered payloads.  <a href="#a0e1fcb43970ea531567ee00d4ee0675b">More...</a><br /></td></tr>
<tr class="separator:a0e1fcb43970ea531567ee00d4ee0675b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab95bea86f498c08510f6f0bcd2eb09"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>) (void *cb_arg, void **address, uint32_t *length)</td></tr>
<tr class="memdesc:a4ab95bea86f498c08510f6f0bcd2eb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill out *address and *length with the current SGL entry and advance to the next entry for the next time the callback is invoked.  <a href="#a4ab95bea86f498c08510f6f0bcd2eb09">More...</a><br /></td></tr>
<tr class="separator:a4ab95bea86f498c08510f6f0bcd2eb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae87a03c28984a2c0499d50ef5e9d0ece"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a> { <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ecea162afc05d1ae756b8a7969be140035ea">SPDK_NVME_TRANSPORT_PCIE</a> = 256, 
<a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ecea140f1cb4edf258bddffeb1c7277d93d8">SPDK_NVME_TRANSPORT_RDMA</a> = SPDK_NVMF_TRTYPE_RDMA, 
<a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0eceabbda195aa6d0a4ad7b437ed5e9a0d01f">SPDK_NVME_TRANSPORT_FC</a> = SPDK_NVMF_TRTYPE_FC, 
<a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ecea1b74e6a5b484b71142aa6ac9821a6de3">SPDK_NVME_TRANSPORT_TCP</a> = SPDK_NVMF_TRTYPE_TCP
 }</td></tr>
<tr class="memdesc:ae87a03c28984a2c0499d50ef5e9d0ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe library transports.  <a href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">More...</a><br /></td></tr>
<tr class="separator:ae87a03c28984a2c0499d50ef5e9d0ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add21ceb016f09949ac6cef50e0566818"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#add21ceb016f09949ac6cef50e0566818">spdk_nvme_ctrlr_flags</a> { <a class="el" href="nvme_8h.html#add21ceb016f09949ac6cef50e0566818a06c93626e819195260a55c69dba063c6">SPDK_NVME_CTRLR_SGL_SUPPORTED</a> = 0x1, 
<a class="el" href="nvme_8h.html#add21ceb016f09949ac6cef50e0566818a7bddfe71a101581b0daa4812fbd93268">SPDK_NVME_CTRLR_SECURITY_SEND_RECV_SUPPORTED</a> = 0x2, 
<a class="el" href="nvme_8h.html#add21ceb016f09949ac6cef50e0566818ab7e2345d658ff0069c99427a5e0177d3">SPDK_NVME_CTRLR_WRR_SUPPORTED</a> = 0x4
 }</td></tr>
<tr class="separator:add21ceb016f09949ac6cef50e0566818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018f3b986b4345ee0c6931be9718c163"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163">spdk_nvme_ns_flags</a> { <br />
&#160;&#160;<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163a80dcd48a57fa9e14efba4757300ad729">SPDK_NVME_NS_DEALLOCATE_SUPPORTED</a> = 0x1, 
<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163ad403aafc70c00560a1db768029933400">SPDK_NVME_NS_FLUSH_SUPPORTED</a> = 0x2, 
<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163a60edfdee88fbe811250e2f8ff63597d0">SPDK_NVME_NS_RESERVATION_SUPPORTED</a> = 0x4, 
<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163a4e691401f3709b7cd66bd32c28ae109b">SPDK_NVME_NS_WRITE_ZEROES_SUPPORTED</a> = 0x8, 
<br />
&#160;&#160;<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163afe158b050528f0f3341e5af3129c61a7">SPDK_NVME_NS_DPS_PI_SUPPORTED</a> = 0x10, 
<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163a91203896ead47bbe22e9f7db8a63c14f">SPDK_NVME_NS_EXTENDED_LBA_SUPPORTED</a> = 0x20, 
<a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163afe42f7e0cdcb93109b55b77cf89efd27">SPDK_NVME_NS_WRITE_UNCORRECTABLE_SUPPORTED</a> = 0x40
<br />
 }</td></tr>
<tr class="memdesc:a018f3b986b4345ee0c6931be9718c163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace command support flags.  <a href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163">More...</a><br /></td></tr>
<tr class="separator:a018f3b986b4345ee0c6931be9718c163"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a39c91e2e6ae899f37b5a89c28a2207cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a39c91e2e6ae899f37b5a89c28a2207cf">spdk_nvme_ctrlr_is_discovery</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a39c91e2e6ae899f37b5a89c28a2207cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate whether a ctrlr handle is associated with a Discovery controller.  <a href="#a39c91e2e6ae899f37b5a89c28a2207cf">More...</a><br /></td></tr>
<tr class="separator:a39c91e2e6ae899f37b5a89c28a2207cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31bc692c6b3a84e2355eb63a8b01ccf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac31bc692c6b3a84e2355eb63a8b01ccf">spdk_nvme_ctrlr_get_default_ctrlr_opts</a> (struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:ac31bc692c6b3a84e2355eb63a8b01ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default options for the creation of a specific NVMe controller.  <a href="#ac31bc692c6b3a84e2355eb63a8b01ccf">More...</a><br /></td></tr>
<tr class="separator:ac31bc692c6b3a84e2355eb63a8b01ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37484cc5d14777e4ae1fde031d0edf2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac37484cc5d14777e4ae1fde031d0edf2">spdk_nvme_transport_id_parse</a> (struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, const char *str)</td></tr>
<tr class="memdesc:ac37484cc5d14777e4ae1fde031d0edf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the string representation of a transport ID.  <a href="#ac37484cc5d14777e4ae1fde031d0edf2">More...</a><br /></td></tr>
<tr class="separator:ac37484cc5d14777e4ae1fde031d0edf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad068dd50f11160450098712422116785"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad068dd50f11160450098712422116785">spdk_nvme_host_id_parse</a> (struct <a class="el" href="structspdk__nvme__host__id.html">spdk_nvme_host_id</a> *hostid, const char *str)</td></tr>
<tr class="memdesc:ad068dd50f11160450098712422116785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the string representation of a host ID.  <a href="#ad068dd50f11160450098712422116785">More...</a><br /></td></tr>
<tr class="separator:ad068dd50f11160450098712422116785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2afed1cce9d9334dfd127db416ada4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab2afed1cce9d9334dfd127db416ada4c">spdk_nvme_transport_id_parse_trtype</a> (enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a> *trtype, const char *str)</td></tr>
<tr class="memdesc:ab2afed1cce9d9334dfd127db416ada4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the string representation of a transport ID tranport type.  <a href="#ab2afed1cce9d9334dfd127db416ada4c">More...</a><br /></td></tr>
<tr class="separator:ab2afed1cce9d9334dfd127db416ada4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a982eb5b757eae63fbc9305627090b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa3a982eb5b757eae63fbc9305627090b">spdk_nvme_transport_id_trtype_str</a> (enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a> trtype)</td></tr>
<tr class="memdesc:aa3a982eb5b757eae63fbc9305627090b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the string representation of a transport ID transport type.  <a href="#aa3a982eb5b757eae63fbc9305627090b">More...</a><br /></td></tr>
<tr class="separator:aa3a982eb5b757eae63fbc9305627090b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb95c5452e84e2c5c1984341fc816ea7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#afb95c5452e84e2c5c1984341fc816ea7">spdk_nvme_transport_id_adrfam_str</a> (enum <a class="el" href="nvmf__spec_8h.html#a08f0090d242e2607ab11f148dcd797c6">spdk_nvmf_adrfam</a> adrfam)</td></tr>
<tr class="memdesc:afb95c5452e84e2c5c1984341fc816ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the string representation of a transport ID address family.  <a href="#afb95c5452e84e2c5c1984341fc816ea7">More...</a><br /></td></tr>
<tr class="separator:afb95c5452e84e2c5c1984341fc816ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7868a6f646a6d1bd70d5c1b8ce5757f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#af7868a6f646a6d1bd70d5c1b8ce5757f">spdk_nvme_transport_id_parse_adrfam</a> (enum <a class="el" href="nvmf__spec_8h.html#a08f0090d242e2607ab11f148dcd797c6">spdk_nvmf_adrfam</a> *adrfam, const char *str)</td></tr>
<tr class="memdesc:af7868a6f646a6d1bd70d5c1b8ce5757f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the string representation of a tranport ID address family.  <a href="#af7868a6f646a6d1bd70d5c1b8ce5757f">More...</a><br /></td></tr>
<tr class="separator:af7868a6f646a6d1bd70d5c1b8ce5757f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9878deb91f677a9a9583342f07dcef41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a9878deb91f677a9a9583342f07dcef41">spdk_nvme_transport_id_compare</a> (const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid1, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid2)</td></tr>
<tr class="memdesc:a9878deb91f677a9a9583342f07dcef41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two transport IDs.  <a href="#a9878deb91f677a9a9583342f07dcef41">More...</a><br /></td></tr>
<tr class="separator:a9878deb91f677a9a9583342f07dcef41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f14ec05ce3af11f089a79d47739bd74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a0f14ec05ce3af11f089a79d47739bd74">spdk_nvme_prchk_flags_parse</a> (uint32_t *prchk_flags, const char *str)</td></tr>
<tr class="memdesc:a0f14ec05ce3af11f089a79d47739bd74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the string representation of PI check settings (prchk:guard|reftag)  <a href="#a0f14ec05ce3af11f089a79d47739bd74">More...</a><br /></td></tr>
<tr class="separator:a0f14ec05ce3af11f089a79d47739bd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae125f35c7ab6fd2f5e63bfac804f25e6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae125f35c7ab6fd2f5e63bfac804f25e6">spdk_nvme_prchk_flags_str</a> (uint32_t prchk_flags)</td></tr>
<tr class="memdesc:ae125f35c7ab6fd2f5e63bfac804f25e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the string representation of PI check settings (prchk:guard|reftag)  <a href="#ae125f35c7ab6fd2f5e63bfac804f25e6">More...</a><br /></td></tr>
<tr class="separator:ae125f35c7ab6fd2f5e63bfac804f25e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5735e7600f79c45871b3dc3adb292f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab5735e7600f79c45871b3dc3adb292f2">spdk_nvme_transport_available</a> (enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a> trtype)</td></tr>
<tr class="memdesc:ab5735e7600f79c45871b3dc3adb292f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the NVMe library can handle a specific NVMe over Fabrics transport type.  <a href="#ab5735e7600f79c45871b3dc3adb292f2">More...</a><br /></td></tr>
<tr class="separator:ab5735e7600f79c45871b3dc3adb292f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225bbc386ec518ae21bd5536f21db45d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d">spdk_nvme_probe</a> (const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, void *cb_ctx, <a class="el" href="nvme_8h.html#a95f40d5179f8424b466a30ba0610ab4c">spdk_nvme_probe_cb</a> probe_cb, <a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a> attach_cb, <a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a> remove_cb)</td></tr>
<tr class="memdesc:a225bbc386ec518ae21bd5536f21db45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device found if desired.  <a href="#a225bbc386ec518ae21bd5536f21db45d">More...</a><br /></td></tr>
<tr class="separator:a225bbc386ec518ae21bd5536f21db45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26375a74c2c935ec32f0c41a7ed93df"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_ctrlr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae26375a74c2c935ec32f0c41a7ed93df">spdk_nvme_connect</a> (const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:ae26375a74c2c935ec32f0c41a7ed93df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the NVMe driver to the device located at the given transport ID.  <a href="#ae26375a74c2c935ec32f0c41a7ed93df">More...</a><br /></td></tr>
<tr class="separator:ae26375a74c2c935ec32f0c41a7ed93df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a8762934973d124cbad92fce47a351"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_probe_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae8a8762934973d124cbad92fce47a351">spdk_nvme_connect_async</a> (const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts, <a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a> attach_cb)</td></tr>
<tr class="memdesc:ae8a8762934973d124cbad92fce47a351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the NVMe driver to the device located at the given transport ID.  <a href="#ae8a8762934973d124cbad92fce47a351">More...</a><br /></td></tr>
<tr class="separator:ae8a8762934973d124cbad92fce47a351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02411bf7ae4827a350711e688316997e"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_probe_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a02411bf7ae4827a350711e688316997e">spdk_nvme_probe_async</a> (const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, void *cb_ctx, <a class="el" href="nvme_8h.html#a95f40d5179f8424b466a30ba0610ab4c">spdk_nvme_probe_cb</a> probe_cb, <a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a> attach_cb, <a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a> remove_cb)</td></tr>
<tr class="memdesc:a02411bf7ae4827a350711e688316997e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probe and add controllers to the probe context list.  <a href="#a02411bf7ae4827a350711e688316997e">More...</a><br /></td></tr>
<tr class="separator:a02411bf7ae4827a350711e688316997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedea919a47bdd811b604656e29e3fcef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aedea919a47bdd811b604656e29e3fcef">spdk_nvme_probe_poll_async</a> (struct spdk_nvme_probe_ctx *probe_ctx)</td></tr>
<tr class="memdesc:aedea919a47bdd811b604656e29e3fcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start controllers in the context list.  <a href="#aedea919a47bdd811b604656e29e3fcef">More...</a><br /></td></tr>
<tr class="separator:aedea919a47bdd811b604656e29e3fcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b63c225c3cce6da60fdbfb6f54b11e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2">spdk_nvme_detach</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a4b63c225c3cce6da60fdbfb6f54b11e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach specified device returned by <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>'s attach_cb from the NVMe driver.  <a href="#a4b63c225c3cce6da60fdbfb6f54b11e2">More...</a><br /></td></tr>
<tr class="separator:a4b63c225c3cce6da60fdbfb6f54b11e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eacd62ee8fbab40e1066bc0a53485f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6eacd62ee8fbab40e1066bc0a53485f3">spdk_nvme_ctrlr_set_trid</a> (struct spdk_nvme_ctrlr *ctrlr, struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:a6eacd62ee8fbab40e1066bc0a53485f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the transport ID for a given controller.  <a href="#a6eacd62ee8fbab40e1066bc0a53485f3">More...</a><br /></td></tr>
<tr class="separator:a6eacd62ee8fbab40e1066bc0a53485f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13ccd2ea831842a5008eb95a32545c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae13ccd2ea831842a5008eb95a32545c3">spdk_nvme_ctrlr_reset</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:ae13ccd2ea831842a5008eb95a32545c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a full hardware reset of the NVMe controller.  <a href="#ae13ccd2ea831842a5008eb95a32545c3">More...</a><br /></td></tr>
<tr class="separator:ae13ccd2ea831842a5008eb95a32545c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7578aeee6b6a092a4a4013a2f32ce5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a4b7578aeee6b6a092a4a4013a2f32ce5">spdk_nvme_ctrlr_fail</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a4b7578aeee6b6a092a4a4013a2f32ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fail the given NVMe controller.  <a href="#a4b7578aeee6b6a092a4a4013a2f32ce5">More...</a><br /></td></tr>
<tr class="separator:a4b7578aeee6b6a092a4a4013a2f32ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdd28db5de54dfee308ea0a3c4f1442"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a1cdd28db5de54dfee308ea0a3c4f1442">spdk_nvme_ctrlr_is_failed</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a1cdd28db5de54dfee308ea0a3c4f1442"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the failed status of a given controller.  <a href="#a1cdd28db5de54dfee308ea0a3c4f1442">More...</a><br /></td></tr>
<tr class="separator:a1cdd28db5de54dfee308ea0a3c4f1442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9daf15b5008ac36c12e7b8db7bdec9"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__nvme__ctrlr__data.html">spdk_nvme_ctrlr_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a5a9daf15b5008ac36c12e7b8db7bdec9">spdk_nvme_ctrlr_get_data</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a5a9daf15b5008ac36c12e7b8db7bdec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the identify controller data as defined by the NVMe specification.  <a href="#a5a9daf15b5008ac36c12e7b8db7bdec9">More...</a><br /></td></tr>
<tr class="separator:a5a9daf15b5008ac36c12e7b8db7bdec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46348531c83fd61acad1a55236d7d576"><td class="memItemLeft" align="right" valign="top">union <a class="el" href="unionspdk__nvme__csts__register.html">spdk_nvme_csts_register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a46348531c83fd61acad1a55236d7d576">spdk_nvme_ctrlr_get_regs_csts</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a46348531c83fd61acad1a55236d7d576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller CSTS (Status) register.  <a href="#a46348531c83fd61acad1a55236d7d576">More...</a><br /></td></tr>
<tr class="separator:a46348531c83fd61acad1a55236d7d576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6943191f9c88c3cec504f87672b9acf8"><td class="memItemLeft" align="right" valign="top">union <a class="el" href="unionspdk__nvme__cap__register.html">spdk_nvme_cap_register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6943191f9c88c3cec504f87672b9acf8">spdk_nvme_ctrlr_get_regs_cap</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a6943191f9c88c3cec504f87672b9acf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller CAP (Capabilities) register.  <a href="#a6943191f9c88c3cec504f87672b9acf8">More...</a><br /></td></tr>
<tr class="separator:a6943191f9c88c3cec504f87672b9acf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf238fdce21d10c923a384e18b013dd"><td class="memItemLeft" align="right" valign="top">union <a class="el" href="unionspdk__nvme__vs__register.html">spdk_nvme_vs_register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aacf238fdce21d10c923a384e18b013dd">spdk_nvme_ctrlr_get_regs_vs</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:aacf238fdce21d10c923a384e18b013dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller VS (Version) register.  <a href="#aacf238fdce21d10c923a384e18b013dd">More...</a><br /></td></tr>
<tr class="separator:aacf238fdce21d10c923a384e18b013dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260b335960b9d81ac1a2601b003b99cd"><td class="memItemLeft" align="right" valign="top">union <a class="el" href="unionspdk__nvme__cmbsz__register.html">spdk_nvme_cmbsz_register</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a260b335960b9d81ac1a2601b003b99cd">spdk_nvme_ctrlr_get_regs_cmbsz</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a260b335960b9d81ac1a2601b003b99cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NVMe controller CMBSZ (Controller Memory Buffer Size) register.  <a href="#a260b335960b9d81ac1a2601b003b99cd">More...</a><br /></td></tr>
<tr class="separator:a260b335960b9d81ac1a2601b003b99cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b18deae44682a51177e8a4193af602"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a02b18deae44682a51177e8a4193af602">spdk_nvme_ctrlr_get_num_ns</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a02b18deae44682a51177e8a4193af602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of namespaces for the given NVMe controller.  <a href="#a02b18deae44682a51177e8a4193af602">More...</a><br /></td></tr>
<tr class="separator:a02b18deae44682a51177e8a4193af602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d8173db83accb35f0c5fe1ec8261bf"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a60d8173db83accb35f0c5fe1ec8261bf">spdk_nvme_ctrlr_get_pci_device</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a60d8173db83accb35f0c5fe1ec8261bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the PCI device of a given NVMe controller.  <a href="#a60d8173db83accb35f0c5fe1ec8261bf">More...</a><br /></td></tr>
<tr class="separator:a60d8173db83accb35f0c5fe1ec8261bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac750410c9b53a0435d0111ae1e98913e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac750410c9b53a0435d0111ae1e98913e">spdk_nvme_ctrlr_get_max_xfer_size</a> (const struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:ac750410c9b53a0435d0111ae1e98913e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum data transfer size of a given NVMe controller.  <a href="#ac750410c9b53a0435d0111ae1e98913e">More...</a><br /></td></tr>
<tr class="separator:ac750410c9b53a0435d0111ae1e98913e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcdb6e7c22b0ef87ed927bf97952c19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#abbcdb6e7c22b0ef87ed927bf97952c19">spdk_nvme_ctrlr_is_active_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid)</td></tr>
<tr class="memdesc:abbcdb6e7c22b0ef87ed927bf97952c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the nsid is an active nv for the given NVMe controller.  <a href="#abbcdb6e7c22b0ef87ed927bf97952c19">More...</a><br /></td></tr>
<tr class="separator:abbcdb6e7c22b0ef87ed927bf97952c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e69f39c7cb8a9e1c3e00af7804c8bd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a59e69f39c7cb8a9e1c3e00af7804c8bd">spdk_nvme_ctrlr_get_first_active_ns</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a59e69f39c7cb8a9e1c3e00af7804c8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nsid of the first active namespace.  <a href="#a59e69f39c7cb8a9e1c3e00af7804c8bd">More...</a><br /></td></tr>
<tr class="separator:a59e69f39c7cb8a9e1c3e00af7804c8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd528b0df0a564c218dc2745c3af159"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#abcd528b0df0a564c218dc2745c3af159">spdk_nvme_ctrlr_get_next_active_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t prev_nsid)</td></tr>
<tr class="memdesc:abcd528b0df0a564c218dc2745c3af159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next active namespace given the previous nsid.  <a href="#abcd528b0df0a564c218dc2745c3af159">More...</a><br /></td></tr>
<tr class="separator:abcd528b0df0a564c218dc2745c3af159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc6bb842e168a68972ec46cc35591ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7dc6bb842e168a68972ec46cc35591ae">spdk_nvme_ctrlr_is_log_page_supported</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t log_page)</td></tr>
<tr class="memdesc:a7dc6bb842e168a68972ec46cc35591ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a particular log page is supported by the given NVMe controller.  <a href="#a7dc6bb842e168a68972ec46cc35591ae">More...</a><br /></td></tr>
<tr class="separator:a7dc6bb842e168a68972ec46cc35591ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909b61e141b56eaa5895482aa1f18a3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a909b61e141b56eaa5895482aa1f18a3b">spdk_nvme_ctrlr_is_feature_supported</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t feature_code)</td></tr>
<tr class="memdesc:a909b61e141b56eaa5895482aa1f18a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a particular feature is supported by the given NVMe controller.  <a href="#a909b61e141b56eaa5895482aa1f18a3b">More...</a><br /></td></tr>
<tr class="separator:a909b61e141b56eaa5895482aa1f18a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1505fc1ef6e8ccb00134c1fa15e0368b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a1505fc1ef6e8ccb00134c1fa15e0368b">spdk_nvme_ctrlr_register_aer_callback</a> (struct spdk_nvme_ctrlr *ctrlr, <a class="el" href="nvme_8h.html#ae564dc7dced1dd7b474c1a6923734a6d">spdk_nvme_aer_cb</a> aer_cb_fn, void *aer_cb_arg)</td></tr>
<tr class="memdesc:a1505fc1ef6e8ccb00134c1fa15e0368b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register callback function invoked when an AER command is completed for the given NVMe controller.  <a href="#a1505fc1ef6e8ccb00134c1fa15e0368b">More...</a><br /></td></tr>
<tr class="separator:a1505fc1ef6e8ccb00134c1fa15e0368b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecec86e033e0d13e6fc67ead61a7028d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aecec86e033e0d13e6fc67ead61a7028d">spdk_nvme_ctrlr_register_timeout_callback</a> (struct spdk_nvme_ctrlr *ctrlr, uint64_t timeout_us, <a class="el" href="nvme_8h.html#a53fe1c01a447be8fcd29821a668227a0">spdk_nvme_timeout_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aecec86e033e0d13e6fc67ead61a7028d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register for timeout callback on a controller.  <a href="#aecec86e033e0d13e6fc67ead61a7028d">More...</a><br /></td></tr>
<tr class="separator:aecec86e033e0d13e6fc67ead61a7028d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6964d09dc51882fae6f2a7cf94afc741"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6964d09dc51882fae6f2a7cf94afc741">spdk_nvme_ctrlr_get_default_io_qpair_opts</a> (struct spdk_nvme_ctrlr *ctrlr, struct <a class="el" href="structspdk__nvme__io__qpair__opts.html">spdk_nvme_io_qpair_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:a6964d09dc51882fae6f2a7cf94afc741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the default options for I/O qpair creation for a specific NVMe controller.  <a href="#a6964d09dc51882fae6f2a7cf94afc741">More...</a><br /></td></tr>
<tr class="separator:a6964d09dc51882fae6f2a7cf94afc741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f745d239dab9b8f934fae2ad4984a2"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_qpair *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2">spdk_nvme_ctrlr_alloc_io_qpair</a> (struct spdk_nvme_ctrlr *ctrlr, const struct <a class="el" href="structspdk__nvme__io__qpair__opts.html">spdk_nvme_io_qpair_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:a13f745d239dab9b8f934fae2ad4984a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an I/O queue pair (submission and completion queue).  <a href="#a13f745d239dab9b8f934fae2ad4984a2">More...</a><br /></td></tr>
<tr class="separator:a13f745d239dab9b8f934fae2ad4984a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e04d50b1f27f6cd163a4ea2024a6fbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a1e04d50b1f27f6cd163a4ea2024a6fbb">spdk_nvme_ctrlr_reconnect_io_qpair</a> (struct spdk_nvme_qpair *qpair)</td></tr>
<tr class="memdesc:a1e04d50b1f27f6cd163a4ea2024a6fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to reconnect the given qpair.  <a href="#a1e04d50b1f27f6cd163a4ea2024a6fbb">More...</a><br /></td></tr>
<tr class="separator:a1e04d50b1f27f6cd163a4ea2024a6fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ec189f50d0f78d73a54413370401f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a85ec189f50d0f78d73a54413370401f5">spdk_nvme_ctrlr_free_io_qpair</a> (struct spdk_nvme_qpair *qpair)</td></tr>
<tr class="memdesc:a85ec189f50d0f78d73a54413370401f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an I/O queue pair that was allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>.  <a href="#a85ec189f50d0f78d73a54413370401f5">More...</a><br /></td></tr>
<tr class="separator:a85ec189f50d0f78d73a54413370401f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c00b191b38472b57b06f3f394353ad3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a8c00b191b38472b57b06f3f394353ad3">spdk_nvme_ctrlr_io_cmd_raw_no_payload_build</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a8c00b191b38472b57b06f3f394353ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the given NVM I/O command, I/O buffers, lists and all to the NVMe controller.  <a href="#a8c00b191b38472b57b06f3f394353ad3">More...</a><br /></td></tr>
<tr class="separator:a8c00b191b38472b57b06f3f394353ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3def668122e76abbfb74305f118291"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a1e3def668122e76abbfb74305f118291">spdk_nvme_ctrlr_cmd_io_raw</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, uint32_t len, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a1e3def668122e76abbfb74305f118291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the given NVM I/O command to the NVMe controller.  <a href="#a1e3def668122e76abbfb74305f118291">More...</a><br /></td></tr>
<tr class="separator:a1e3def668122e76abbfb74305f118291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2d8453bb2478c7b1a70c0a09c7ef4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#afd2d8453bb2478c7b1a70c0a09c7ef4b">spdk_nvme_ctrlr_cmd_io_raw_with_md</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, uint32_t len, void *md_buf, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:afd2d8453bb2478c7b1a70c0a09c7ef4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the given NVM I/O command with metadata to the NVMe controller.  <a href="#afd2d8453bb2478c7b1a70c0a09c7ef4b">More...</a><br /></td></tr>
<tr class="separator:afd2d8453bb2478c7b1a70c0a09c7ef4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa331d140870e977722bfbb6826524782"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa331d140870e977722bfbb6826524782">spdk_nvme_qpair_process_completions</a> (struct spdk_nvme_qpair *qpair, uint32_t max_completions)</td></tr>
<tr class="memdesc:aa331d140870e977722bfbb6826524782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process any outstanding completions for I/O submitted on a queue pair.  <a href="#aa331d140870e977722bfbb6826524782">More...</a><br /></td></tr>
<tr class="separator:aa331d140870e977722bfbb6826524782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8ade16f6272f03af420ca0de2ad615"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#acd8ade16f6272f03af420ca0de2ad615">spdk_nvme_io_msg_process</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:acd8ade16f6272f03af420ca0de2ad615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process IO message sent to controller from external module.  <a href="#acd8ade16f6272f03af420ca0de2ad615">More...</a><br /></td></tr>
<tr class="separator:acd8ade16f6272f03af420ca0de2ad615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2a9d3b715649b4d0a0e89196a13e6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#afe2a9d3b715649b4d0a0e89196a13e6d">spdk_nvme_ctrlr_cmd_admin_raw</a> (struct spdk_nvme_ctrlr *ctrlr, struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, uint32_t len, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:afe2a9d3b715649b4d0a0e89196a13e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the given admin command to the NVMe controller.  <a href="#afe2a9d3b715649b4d0a0e89196a13e6d">More...</a><br /></td></tr>
<tr class="separator:afe2a9d3b715649b4d0a0e89196a13e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10282695461985f58f54de022911745e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a10282695461985f58f54de022911745e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process any outstanding completions for admin commands.  <a href="#a10282695461985f58f54de022911745e">More...</a><br /></td></tr>
<tr class="separator:a10282695461985f58f54de022911745e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f01fb8a5f404e41e6fa224a7942be08"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_ns *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6f01fb8a5f404e41e6fa224a7942be08">spdk_nvme_ctrlr_get_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t ns_id)</td></tr>
<tr class="memdesc:a6f01fb8a5f404e41e6fa224a7942be08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to a namespace for the given controller.  <a href="#a6f01fb8a5f404e41e6fa224a7942be08">More...</a><br /></td></tr>
<tr class="separator:a6f01fb8a5f404e41e6fa224a7942be08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c881cccf7873bbe4605320ffb0a81c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a88c881cccf7873bbe4605320ffb0a81c">spdk_nvme_ctrlr_cmd_get_log_page</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t log_page, uint32_t nsid, void *payload, uint32_t payload_size, uint64_t offset, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a88c881cccf7873bbe4605320ffb0a81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific log page from the NVMe controller.  <a href="#a88c881cccf7873bbe4605320ffb0a81c">More...</a><br /></td></tr>
<tr class="separator:a88c881cccf7873bbe4605320ffb0a81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724ed20a1a5adaf30c48db8c28d29677"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a724ed20a1a5adaf30c48db8c28d29677">spdk_nvme_ctrlr_cmd_abort</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, uint16_t cid, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a724ed20a1a5adaf30c48db8c28d29677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort a specific previously-submitted NVMe command.  <a href="#a724ed20a1a5adaf30c48db8c28d29677">More...</a><br /></td></tr>
<tr class="separator:a724ed20a1a5adaf30c48db8c28d29677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9507cb98ee30e5df98474bc82190476"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa9507cb98ee30e5df98474bc82190476">spdk_nvme_ctrlr_cmd_set_feature</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t feature, uint32_t cdw11, uint32_t cdw12, void *payload, uint32_t payload_size, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aa9507cb98ee30e5df98474bc82190476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set specific feature for the given NVMe controller.  <a href="#aa9507cb98ee30e5df98474bc82190476">More...</a><br /></td></tr>
<tr class="separator:aa9507cb98ee30e5df98474bc82190476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4ebba22f1585b98e4ca20932d75434"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6b4ebba22f1585b98e4ca20932d75434">spdk_nvme_ctrlr_cmd_get_feature</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t feature, uint32_t cdw11, void *payload, uint32_t payload_size, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a6b4ebba22f1585b98e4ca20932d75434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get specific feature from given NVMe controller.  <a href="#a6b4ebba22f1585b98e4ca20932d75434">More...</a><br /></td></tr>
<tr class="separator:a6b4ebba22f1585b98e4ca20932d75434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0f038c06c49df0e75148faf6cc4b51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#abc0f038c06c49df0e75148faf6cc4b51">spdk_nvme_ctrlr_cmd_get_feature_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t feature, uint32_t cdw11, void *payload, uint32_t payload_size, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t ns_id)</td></tr>
<tr class="memdesc:abc0f038c06c49df0e75148faf6cc4b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get specific feature from given NVMe controller.  <a href="#abc0f038c06c49df0e75148faf6cc4b51">More...</a><br /></td></tr>
<tr class="separator:abc0f038c06c49df0e75148faf6cc4b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fda1acce45c71590ed0db99220d26b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a63fda1acce45c71590ed0db99220d26b">spdk_nvme_ctrlr_cmd_set_feature_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t feature, uint32_t cdw11, uint32_t cdw12, void *payload, uint32_t payload_size, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t ns_id)</td></tr>
<tr class="memdesc:a63fda1acce45c71590ed0db99220d26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set specific feature for the given NVMe controller and namespace ID.  <a href="#a63fda1acce45c71590ed0db99220d26b">More...</a><br /></td></tr>
<tr class="separator:a63fda1acce45c71590ed0db99220d26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5175d6805225d84d6e4aa4e0f1546c69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a5175d6805225d84d6e4aa4e0f1546c69">spdk_nvme_ctrlr_security_receive</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t secp, uint16_t spsp, uint8_t nssf, void *payload, size_t size)</td></tr>
<tr class="memdesc:a5175d6805225d84d6e4aa4e0f1546c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive security protocol data from controller.  <a href="#a5175d6805225d84d6e4aa4e0f1546c69">More...</a><br /></td></tr>
<tr class="separator:a5175d6805225d84d6e4aa4e0f1546c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4ab089f73f3f43e9c5b8e6415e6f50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ada4ab089f73f3f43e9c5b8e6415e6f50">spdk_nvme_ctrlr_security_send</a> (struct spdk_nvme_ctrlr *ctrlr, uint8_t secp, uint16_t spsp, uint8_t nssf, void *payload, size_t size)</td></tr>
<tr class="memdesc:ada4ab089f73f3f43e9c5b8e6415e6f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send security protocol data to controller.  <a href="#ada4ab089f73f3f43e9c5b8e6415e6f50">More...</a><br /></td></tr>
<tr class="separator:ada4ab089f73f3f43e9c5b8e6415e6f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af654a7a016511f265b29294fd06ce26e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#af654a7a016511f265b29294fd06ce26e">spdk_nvme_ctrlr_get_flags</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:af654a7a016511f265b29294fd06ce26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get supported flags of the controller.  <a href="#af654a7a016511f265b29294fd06ce26e">More...</a><br /></td></tr>
<tr class="separator:af654a7a016511f265b29294fd06ce26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae935583b7f95b13fbd2dd41255490da0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ae935583b7f95b13fbd2dd41255490da0">spdk_nvme_ctrlr_attach_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, struct <a class="el" href="structspdk__nvme__ctrlr__list.html">spdk_nvme_ctrlr_list</a> *payload)</td></tr>
<tr class="memdesc:ae935583b7f95b13fbd2dd41255490da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach the specified namespace to controllers.  <a href="#ae935583b7f95b13fbd2dd41255490da0">More...</a><br /></td></tr>
<tr class="separator:ae935583b7f95b13fbd2dd41255490da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab562f58b5903071929d6a559fe984d0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab562f58b5903071929d6a559fe984d0a">spdk_nvme_ctrlr_detach_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, struct <a class="el" href="structspdk__nvme__ctrlr__list.html">spdk_nvme_ctrlr_list</a> *payload)</td></tr>
<tr class="memdesc:ab562f58b5903071929d6a559fe984d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detach the specified namespace from controllers.  <a href="#ab562f58b5903071929d6a559fe984d0a">More...</a><br /></td></tr>
<tr class="separator:ab562f58b5903071929d6a559fe984d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace23485fea91d126a13fe706ce6d8843"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ace23485fea91d126a13fe706ce6d8843">spdk_nvme_ctrlr_create_ns</a> (struct spdk_nvme_ctrlr *ctrlr, struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a> *payload)</td></tr>
<tr class="memdesc:ace23485fea91d126a13fe706ce6d8843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a namespace.  <a href="#ace23485fea91d126a13fe706ce6d8843">More...</a><br /></td></tr>
<tr class="separator:ace23485fea91d126a13fe706ce6d8843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c62e2d4555a5ebc3a3b6f9632c51e1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7c62e2d4555a5ebc3a3b6f9632c51e1a">spdk_nvme_ctrlr_delete_ns</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid)</td></tr>
<tr class="memdesc:a7c62e2d4555a5ebc3a3b6f9632c51e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a namespace.  <a href="#a7c62e2d4555a5ebc3a3b6f9632c51e1a">More...</a><br /></td></tr>
<tr class="separator:a7c62e2d4555a5ebc3a3b6f9632c51e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb6973133e1fd5e7a1522ab104ac92b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a9bb6973133e1fd5e7a1522ab104ac92b">spdk_nvme_ctrlr_format</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid, struct <a class="el" href="structspdk__nvme__format.html">spdk_nvme_format</a> *format)</td></tr>
<tr class="memdesc:a9bb6973133e1fd5e7a1522ab104ac92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format NVM.  <a href="#a9bb6973133e1fd5e7a1522ab104ac92b">More...</a><br /></td></tr>
<tr class="separator:a9bb6973133e1fd5e7a1522ab104ac92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7938b258a7614073065be4f6a35bd0e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7938b258a7614073065be4f6a35bd0e2">spdk_nvme_ctrlr_update_firmware</a> (struct spdk_nvme_ctrlr *ctrlr, void *payload, uint32_t size, int slot, enum <a class="el" href="nvme__spec_8h.html#ae4da1c1bec22eb22d1af72bbf37af36e">spdk_nvme_fw_commit_action</a> commit_action, struct <a class="el" href="structspdk__nvme__status.html">spdk_nvme_status</a> *completion_status)</td></tr>
<tr class="memdesc:a7938b258a7614073065be4f6a35bd0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download a new firmware image.  <a href="#a7938b258a7614073065be4f6a35bd0e2">More...</a><br /></td></tr>
<tr class="separator:a7938b258a7614073065be4f6a35bd0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887db5ce5c84eba37a4d82f5d180d020"><td class="memItemLeft" align="right" valign="top">volatile struct <a class="el" href="structspdk__nvme__registers.html">spdk_nvme_registers</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a887db5ce5c84eba37a4d82f5d180d020">spdk_nvme_ctrlr_get_registers</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:a887db5ce5c84eba37a4d82f5d180d020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return virtual address of PCIe NVM I/O registers.  <a href="#a887db5ce5c84eba37a4d82f5d180d020">More...</a><br /></td></tr>
<tr class="separator:a887db5ce5c84eba37a4d82f5d180d020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63b25defbb0f1ccd52538e3b9a748df"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad63b25defbb0f1ccd52538e3b9a748df">spdk_nvme_ctrlr_alloc_cmb_io_buffer</a> (struct spdk_nvme_ctrlr *ctrlr, size_t size)</td></tr>
<tr class="memdesc:ad63b25defbb0f1ccd52538e3b9a748df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an I/O buffer from the controller memory buffer (Experimental).  <a href="#ad63b25defbb0f1ccd52538e3b9a748df">More...</a><br /></td></tr>
<tr class="separator:ad63b25defbb0f1ccd52538e3b9a748df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb11b2a40d2cd45072f83624956b8b01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#abb11b2a40d2cd45072f83624956b8b01">spdk_nvme_ctrlr_free_cmb_io_buffer</a> (struct spdk_nvme_ctrlr *ctrlr, void *buf, size_t size)</td></tr>
<tr class="memdesc:abb11b2a40d2cd45072f83624956b8b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a controller memory I/O buffer (Experimental).  <a href="#abb11b2a40d2cd45072f83624956b8b01">More...</a><br /></td></tr>
<tr class="separator:abb11b2a40d2cd45072f83624956b8b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7ae9abf97b7c6b57777d06eaa1258a"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#abb7ae9abf97b7c6b57777d06eaa1258a">spdk_nvme_ctrlr_get_transport_id</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:abb7ae9abf97b7c6b57777d06eaa1258a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transport ID for a given NVMe controller.  <a href="#abb7ae9abf97b7c6b57777d06eaa1258a">More...</a><br /></td></tr>
<tr class="separator:abb7ae9abf97b7c6b57777d06eaa1258a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1863b5dccf2bcc49fe92275bc1e5a2a"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab1863b5dccf2bcc49fe92275bc1e5a2a">spdk_nvme_ns_get_data</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:ab1863b5dccf2bcc49fe92275bc1e5a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the identify namespace data as defined by the NVMe specification.  <a href="#ab1863b5dccf2bcc49fe92275bc1e5a2a">More...</a><br /></td></tr>
<tr class="separator:ab1863b5dccf2bcc49fe92275bc1e5a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54052303ef2870d6d1856f79ef6ff88a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a54052303ef2870d6d1856f79ef6ff88a">spdk_nvme_ns_get_id</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a54052303ef2870d6d1856f79ef6ff88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the namespace id (index number) from the given namespace handle.  <a href="#a54052303ef2870d6d1856f79ef6ff88a">More...</a><br /></td></tr>
<tr class="separator:a54052303ef2870d6d1856f79ef6ff88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2640aeebb82108e9b507dcccb1e564c2"><td class="memItemLeft" align="right" valign="top">struct spdk_nvme_ctrlr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a2640aeebb82108e9b507dcccb1e564c2">spdk_nvme_ns_get_ctrlr</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a2640aeebb82108e9b507dcccb1e564c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the controller with which this namespace is associated.  <a href="#a2640aeebb82108e9b507dcccb1e564c2">More...</a><br /></td></tr>
<tr class="separator:a2640aeebb82108e9b507dcccb1e564c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af755eb3e5a5f767a5bdc544d85667898"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#af755eb3e5a5f767a5bdc544d85667898">spdk_nvme_ns_is_active</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:af755eb3e5a5f767a5bdc544d85667898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a namespace is active.  <a href="#af755eb3e5a5f767a5bdc544d85667898">More...</a><br /></td></tr>
<tr class="separator:af755eb3e5a5f767a5bdc544d85667898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aac85501f13bff557d3a224d8ec156"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac2aac85501f13bff557d3a224d8ec156">spdk_nvme_ns_get_max_io_xfer_size</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:ac2aac85501f13bff557d3a224d8ec156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum transfer size, in bytes, for an I/O sent to the given namespace.  <a href="#ac2aac85501f13bff557d3a224d8ec156">More...</a><br /></td></tr>
<tr class="separator:ac2aac85501f13bff557d3a224d8ec156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d24c0b2b0b2a22b0c0af2ca2e157e04"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a0d24c0b2b0b2a22b0c0af2ca2e157e04">spdk_nvme_ns_get_sector_size</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a0d24c0b2b0b2a22b0c0af2ca2e157e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sector size, in bytes, of the given namespace.  <a href="#a0d24c0b2b0b2a22b0c0af2ca2e157e04">More...</a><br /></td></tr>
<tr class="separator:a0d24c0b2b0b2a22b0c0af2ca2e157e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3f5c5a738dc7ad7e3b2913bff4324c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a8f3f5c5a738dc7ad7e3b2913bff4324c">spdk_nvme_ns_get_extended_sector_size</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a8f3f5c5a738dc7ad7e3b2913bff4324c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the extended sector size, in bytes, of the given namespace.  <a href="#a8f3f5c5a738dc7ad7e3b2913bff4324c">More...</a><br /></td></tr>
<tr class="separator:a8f3f5c5a738dc7ad7e3b2913bff4324c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c522609f730db26f66e7f5b6b3501e0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a7c522609f730db26f66e7f5b6b3501e0">spdk_nvme_ns_get_num_sectors</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a7c522609f730db26f66e7f5b6b3501e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of sectors for the given namespace.  <a href="#a7c522609f730db26f66e7f5b6b3501e0">More...</a><br /></td></tr>
<tr class="separator:a7c522609f730db26f66e7f5b6b3501e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8fb1bbe066260faf305581e16dde86"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a9e8fb1bbe066260faf305581e16dde86">spdk_nvme_ns_get_size</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a9e8fb1bbe066260faf305581e16dde86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size, in bytes, of the given namespace.  <a href="#a9e8fb1bbe066260faf305581e16dde86">More...</a><br /></td></tr>
<tr class="separator:a9e8fb1bbe066260faf305581e16dde86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85806a7605a104a705e7f9d3d087e4cb"><td class="memItemLeft" align="right" valign="top">enum spdk_nvme_pi_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a85806a7605a104a705e7f9d3d087e4cb">spdk_nvme_ns_get_pi_type</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a85806a7605a104a705e7f9d3d087e4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the end-to-end data protection information type of the given namespace.  <a href="#a85806a7605a104a705e7f9d3d087e4cb">More...</a><br /></td></tr>
<tr class="separator:a85806a7605a104a705e7f9d3d087e4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48657f8cb6561b35e1c1b0bc18376d2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2">spdk_nvme_ns_get_md_size</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:ab48657f8cb6561b35e1c1b0bc18376d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the metadata size, in bytes, of the given namespace.  <a href="#ab48657f8cb6561b35e1c1b0bc18376d2">More...</a><br /></td></tr>
<tr class="separator:ab48657f8cb6561b35e1c1b0bc18376d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad367fec5a8963f5d930dfae485de6b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aad367fec5a8963f5d930dfae485de6b3">spdk_nvme_ns_supports_extended_lba</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:aad367fec5a8963f5d930dfae485de6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether if the namespace can support extended LBA when end-to-end data protection enabled.  <a href="#aad367fec5a8963f5d930dfae485de6b3">More...</a><br /></td></tr>
<tr class="separator:aad367fec5a8963f5d930dfae485de6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42040dca95489218417539d2c08d815e"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="nvme__spec_8h.html#a1c06fbd66f7572c43c51e6f106215b8d">spdk_nvme_dealloc_logical_block_read_value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a42040dca95489218417539d2c08d815e">spdk_nvme_ns_get_dealloc_logical_block_read_value</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a42040dca95489218417539d2c08d815e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the value returned when reading deallocated blocks.  <a href="#a42040dca95489218417539d2c08d815e">More...</a><br /></td></tr>
<tr class="separator:a42040dca95489218417539d2c08d815e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58edc3021f8adcbecce5d3ebc5b6789"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#af58edc3021f8adcbecce5d3ebc5b6789">spdk_nvme_ns_get_optimal_io_boundary</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:af58edc3021f8adcbecce5d3ebc5b6789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the optimal I/O boundary, in blocks, for the given namespace.  <a href="#af58edc3021f8adcbecce5d3ebc5b6789">More...</a><br /></td></tr>
<tr class="separator:af58edc3021f8adcbecce5d3ebc5b6789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c559063408299a4612fd2e62f97bc63"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__uuid.html">spdk_uuid</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a6c559063408299a4612fd2e62f97bc63">spdk_nvme_ns_get_uuid</a> (const struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a6c559063408299a4612fd2e62f97bc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the UUID for the given namespace.  <a href="#a6c559063408299a4612fd2e62f97bc63">More...</a><br /></td></tr>
<tr class="separator:a6c559063408299a4612fd2e62f97bc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eff1c1b6fbfb348a1f158b3cf70626f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a5eff1c1b6fbfb348a1f158b3cf70626f">spdk_nvme_ns_get_flags</a> (struct spdk_nvme_ns *ns)</td></tr>
<tr class="memdesc:a5eff1c1b6fbfb348a1f158b3cf70626f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flags for the given namespace.  <a href="#a5eff1c1b6fbfb348a1f158b3cf70626f">More...</a><br /></td></tr>
<tr class="separator:a5eff1c1b6fbfb348a1f158b3cf70626f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3065f669d8b605efdcadffbf94a50538"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a3065f669d8b605efdcadffbf94a50538">spdk_nvme_ns_cmd_write</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags)</td></tr>
<tr class="memdesc:a3065f669d8b605efdcadffbf94a50538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write I/O to the specified NVMe namespace.  <a href="#a3065f669d8b605efdcadffbf94a50538">More...</a><br /></td></tr>
<tr class="separator:a3065f669d8b605efdcadffbf94a50538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcbb5d31f0b572847cc8ae8b07dfcfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#adfcbb5d31f0b572847cc8ae8b07dfcfb">spdk_nvme_ns_cmd_writev</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn)</td></tr>
<tr class="memdesc:adfcbb5d31f0b572847cc8ae8b07dfcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write I/O to the specified NVMe namespace.  <a href="#adfcbb5d31f0b572847cc8ae8b07dfcfb">More...</a><br /></td></tr>
<tr class="separator:adfcbb5d31f0b572847cc8ae8b07dfcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d42660e3de76f75f4b5d79ed9b1d01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab4d42660e3de76f75f4b5d79ed9b1d01">spdk_nvme_ns_cmd_writev_with_md</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn, void *metadata, uint16_t apptag_mask, uint16_t apptag)</td></tr>
<tr class="memdesc:ab4d42660e3de76f75f4b5d79ed9b1d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write I/O to the specified NVMe namespace.  <a href="#ab4d42660e3de76f75f4b5d79ed9b1d01">More...</a><br /></td></tr>
<tr class="separator:ab4d42660e3de76f75f4b5d79ed9b1d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2aa2be0d657be0c63d5abc02b274ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#adc2aa2be0d657be0c63d5abc02b274ec">spdk_nvme_ns_cmd_write_with_md</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, void *metadata, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, uint16_t apptag_mask, uint16_t apptag)</td></tr>
<tr class="memdesc:adc2aa2be0d657be0c63d5abc02b274ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write I/O to the specified NVMe namespace.  <a href="#adc2aa2be0d657be0c63d5abc02b274ec">More...</a><br /></td></tr>
<tr class="separator:adc2aa2be0d657be0c63d5abc02b274ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02e8c701c5496f163a69917ad5397dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#af02e8c701c5496f163a69917ad5397dd">spdk_nvme_ns_cmd_write_zeroes</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags)</td></tr>
<tr class="memdesc:af02e8c701c5496f163a69917ad5397dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write zeroes I/O to the specified NVMe namespace.  <a href="#af02e8c701c5496f163a69917ad5397dd">More...</a><br /></td></tr>
<tr class="separator:af02e8c701c5496f163a69917ad5397dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f23130b6ebdb7b3e4086545e422e59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ab2f23130b6ebdb7b3e4086545e422e59">spdk_nvme_ns_cmd_write_uncorrectable</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ab2f23130b6ebdb7b3e4086545e422e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write uncorrectable I/O to the specified NVMe namespace.  <a href="#ab2f23130b6ebdb7b3e4086545e422e59">More...</a><br /></td></tr>
<tr class="separator:ab2f23130b6ebdb7b3e4086545e422e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084c6ecb53bd810fbb5051100b79bec5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a084c6ecb53bd810fbb5051100b79bec5">spdk_nvme_ns_cmd_read</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags)</td></tr>
<tr class="memdesc:a084c6ecb53bd810fbb5051100b79bec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a read I/O to the specified NVMe namespace.  <a href="#a084c6ecb53bd810fbb5051100b79bec5">More...</a><br /></td></tr>
<tr class="separator:a084c6ecb53bd810fbb5051100b79bec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb47ce7de6b6e963ec9fb8de261466ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#acb47ce7de6b6e963ec9fb8de261466ae">spdk_nvme_ns_cmd_readv</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn)</td></tr>
<tr class="memdesc:acb47ce7de6b6e963ec9fb8de261466ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read I/O to the specified NVMe namespace.  <a href="#acb47ce7de6b6e963ec9fb8de261466ae">More...</a><br /></td></tr>
<tr class="separator:acb47ce7de6b6e963ec9fb8de261466ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08afb91732d92d84a054012cd3d236aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a08afb91732d92d84a054012cd3d236aa">spdk_nvme_ns_cmd_readv_with_md</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn, void *metadata, uint16_t apptag_mask, uint16_t apptag)</td></tr>
<tr class="memdesc:a08afb91732d92d84a054012cd3d236aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read I/O to the specified NVMe namespace.  <a href="#a08afb91732d92d84a054012cd3d236aa">More...</a><br /></td></tr>
<tr class="separator:a08afb91732d92d84a054012cd3d236aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2913b93326e636eca6dfe7b42e349fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa2913b93326e636eca6dfe7b42e349fe">spdk_nvme_ns_cmd_read_with_md</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, void *metadata, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, uint16_t apptag_mask, uint16_t apptag)</td></tr>
<tr class="memdesc:aa2913b93326e636eca6dfe7b42e349fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a read I/O to the specified NVMe namespace.  <a href="#aa2913b93326e636eca6dfe7b42e349fe">More...</a><br /></td></tr>
<tr class="separator:aa2913b93326e636eca6dfe7b42e349fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c646dd18675c54ffcf834ce699658d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac0c646dd18675c54ffcf834ce699658d">spdk_nvme_ns_cmd_dataset_management</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint32_t type, const struct <a class="el" href="structspdk__nvme__dsm__range.html">spdk_nvme_dsm_range</a> *ranges, uint16_t num_ranges, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ac0c646dd18675c54ffcf834ce699658d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a data set management request to the specified NVMe namespace.  <a href="#ac0c646dd18675c54ffcf834ce699658d">More...</a><br /></td></tr>
<tr class="separator:ac0c646dd18675c54ffcf834ce699658d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0b134e140121bb9bd8664d4a43a5c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aed0b134e140121bb9bd8664d4a43a5c6">spdk_nvme_ns_cmd_flush</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aed0b134e140121bb9bd8664d4a43a5c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a flush request to the specified NVMe namespace.  <a href="#aed0b134e140121bb9bd8664d4a43a5c6">More...</a><br /></td></tr>
<tr class="separator:aed0b134e140121bb9bd8664d4a43a5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c140c47970bafbfec36bf6e4c37704"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad5c140c47970bafbfec36bf6e4c37704">spdk_nvme_ns_cmd_reservation_register</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__reservation__register__data.html">spdk_nvme_reservation_register_data</a> *payload, bool ignore_key, enum <a class="el" href="nvme__spec_8h.html#a178a7468a0a9c3e814ca2ba80e3406e5">spdk_nvme_reservation_register_action</a> action, enum <a class="el" href="nvme__spec_8h.html#a05b2db4a398c119c029c234a68760c73">spdk_nvme_reservation_register_cptpl</a> cptpl, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ad5c140c47970bafbfec36bf6e4c37704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a reservation register to the specified NVMe namespace.  <a href="#ad5c140c47970bafbfec36bf6e4c37704">More...</a><br /></td></tr>
<tr class="separator:ad5c140c47970bafbfec36bf6e4c37704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b1d9de51027da9a66fe12e2ce28132"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#aa2b1d9de51027da9a66fe12e2ce28132">spdk_nvme_ns_cmd_reservation_release</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__reservation__key__data.html">spdk_nvme_reservation_key_data</a> *payload, bool ignore_key, enum <a class="el" href="nvme__spec_8h.html#a6fa8ea66c4927d8bb4d81d76867e851a">spdk_nvme_reservation_release_action</a> action, enum <a class="el" href="nvme__spec_8h.html#aa7e108757c0eebbac7e13b598a378210">spdk_nvme_reservation_type</a> type, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aa2b1d9de51027da9a66fe12e2ce28132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a reservation release to the specified NVMe namespace.  <a href="#aa2b1d9de51027da9a66fe12e2ce28132">More...</a><br /></td></tr>
<tr class="separator:aa2b1d9de51027da9a66fe12e2ce28132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8028f294d09711401d098e89d87f38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#abb8028f294d09711401d098e89d87f38">spdk_nvme_ns_cmd_reservation_acquire</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__reservation__acquire__data.html">spdk_nvme_reservation_acquire_data</a> *payload, bool ignore_key, enum <a class="el" href="nvme__spec_8h.html#a95b3685443c2716ee0d125c30182aeac">spdk_nvme_reservation_acquire_action</a> action, enum <a class="el" href="nvme__spec_8h.html#aa7e108757c0eebbac7e13b598a378210">spdk_nvme_reservation_type</a> type, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:abb8028f294d09711401d098e89d87f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a reservation acquire to the specified NVMe namespace.  <a href="#abb8028f294d09711401d098e89d87f38">More...</a><br /></td></tr>
<tr class="separator:abb8028f294d09711401d098e89d87f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7b5944bda3fe9ef1c83fcd2025b39a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a9a7b5944bda3fe9ef1c83fcd2025b39a">spdk_nvme_ns_cmd_reservation_report</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, uint32_t len, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a9a7b5944bda3fe9ef1c83fcd2025b39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a reservation report to the specified NVMe namespace.  <a href="#a9a7b5944bda3fe9ef1c83fcd2025b39a">More...</a><br /></td></tr>
<tr class="separator:a9a7b5944bda3fe9ef1c83fcd2025b39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8aa3c9ff510fe73945549077df18436"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad8aa3c9ff510fe73945549077df18436">spdk_nvme_ns_cmd_compare</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags)</td></tr>
<tr class="memdesc:ad8aa3c9ff510fe73945549077df18436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a compare I/O to the specified NVMe namespace.  <a href="#ad8aa3c9ff510fe73945549077df18436">More...</a><br /></td></tr>
<tr class="separator:ad8aa3c9ff510fe73945549077df18436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d6b722c8837593dec16f30376d182"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a108d6b722c8837593dec16f30376d182">spdk_nvme_ns_cmd_comparev</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, <a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a> reset_sgl_fn, <a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a> next_sge_fn)</td></tr>
<tr class="memdesc:a108d6b722c8837593dec16f30376d182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a compare I/O to the specified NVMe namespace.  <a href="#a108d6b722c8837593dec16f30376d182">More...</a><br /></td></tr>
<tr class="separator:a108d6b722c8837593dec16f30376d182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf7a40872bfe623a5dfa31922263532"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a4bf7a40872bfe623a5dfa31922263532">spdk_nvme_ns_cmd_compare_with_md</a> (struct spdk_nvme_ns *ns, struct spdk_nvme_qpair *qpair, void *payload, void *metadata, uint64_t lba, uint32_t lba_count, <a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a> cb_fn, void *cb_arg, uint32_t io_flags, uint16_t apptag_mask, uint16_t apptag)</td></tr>
<tr class="memdesc:a4bf7a40872bfe623a5dfa31922263532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a compare I/O to the specified NVMe namespace.  <a href="#a4bf7a40872bfe623a5dfa31922263532">More...</a><br /></td></tr>
<tr class="separator:a4bf7a40872bfe623a5dfa31922263532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6188764b8c71b2f64a74077d6bfabf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#acf6188764b8c71b2f64a74077d6bfabf">spdk_nvme_qpair_add_cmd_error_injection</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, uint8_t opc, bool do_not_submit, uint64_t timeout_in_us, uint32_t err_count, uint8_t sct, uint8_t sc)</td></tr>
<tr class="memdesc:acf6188764b8c71b2f64a74077d6bfabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject an error for the next request with a given opcode.  <a href="#acf6188764b8c71b2f64a74077d6bfabf">More...</a><br /></td></tr>
<tr class="separator:acf6188764b8c71b2f64a74077d6bfabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad720b23786450b5a2b2d7d65c6dd6b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad720b23786450b5a2b2d7d65c6dd6b7c">spdk_nvme_qpair_remove_cmd_error_injection</a> (struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, uint8_t opc)</td></tr>
<tr class="memdesc:ad720b23786450b5a2b2d7d65c6dd6b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the specified NVMe command with error status.  <a href="#ad720b23786450b5a2b2d7d65c6dd6b7c">More...</a><br /></td></tr>
<tr class="separator:ad720b23786450b5a2b2d7d65c6dd6b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f179ad680512c168148e13aa74b3f4b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a5f179ad680512c168148e13aa74b3f4b">spdk_nvme_cpl_get_status_string</a> (const struct <a class="el" href="structspdk__nvme__status.html">spdk_nvme_status</a> *status)</td></tr>
<tr class="memdesc:a5f179ad680512c168148e13aa74b3f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given NVMe status, return ASCII string for that error.  <a href="#a5f179ad680512c168148e13aa74b3f4b">More...</a><br /></td></tr>
<tr class="separator:a5f179ad680512c168148e13aa74b3f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06275147a2cbb800440686b8ba9a73b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ac06275147a2cbb800440686b8ba9a73b">spdk_nvme_qpair_print_command</a> (struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd)</td></tr>
<tr class="memdesc:ac06275147a2cbb800440686b8ba9a73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints (SPDK_NOTICELOG) the contents of an NVMe submission queue entry (command).  <a href="#ac06275147a2cbb800440686b8ba9a73b">More...</a><br /></td></tr>
<tr class="separator:ac06275147a2cbb800440686b8ba9a73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b2335194f9c4c24a5e2c15a9432f4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad4b2335194f9c4c24a5e2c15a9432f4a">spdk_nvme_qpair_print_completion</a> (struct spdk_nvme_qpair *qpair, struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *cpl)</td></tr>
<tr class="memdesc:ad4b2335194f9c4c24a5e2c15a9432f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints (SPDK_NOTICELOG) the contents of an NVMe completion queue entry.  <a href="#ad4b2335194f9c4c24a5e2c15a9432f4a">More...</a><br /></td></tr>
<tr class="separator:ad4b2335194f9c4c24a5e2c15a9432f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cdb425c9fad7b94ad0b8f5c27bb8b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#a82cdb425c9fad7b94ad0b8f5c27bb8b2">spdk_nvme_rdma_init_hooks</a> (struct <a class="el" href="structspdk__nvme__rdma__hooks.html">spdk_nvme_rdma_hooks</a> *hooks)</td></tr>
<tr class="memdesc:a82cdb425c9fad7b94ad0b8f5c27bb8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global hooks for the RDMA transport, if necessary.  <a href="#a82cdb425c9fad7b94ad0b8f5c27bb8b2">More...</a><br /></td></tr>
<tr class="separator:a82cdb425c9fad7b94ad0b8f5c27bb8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8c70873181a2561240944d3c63aae1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#afc8c70873181a2561240944d3c63aae1">spdk_nvme_cuse_get_ctrlr_name</a> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="memdesc:afc8c70873181a2561240944d3c63aae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of cuse device associated with NVMe controller.  <a href="#afc8c70873181a2561240944d3c63aae1">More...</a><br /></td></tr>
<tr class="separator:afc8c70873181a2561240944d3c63aae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4cd4052825486e483bff14f328040cf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvme_8h.html#ad4cd4052825486e483bff14f328040cf">spdk_nvme_cuse_get_ns_name</a> (struct spdk_nvme_ctrlr *ctrlr, uint32_t nsid)</td></tr>
<tr class="memdesc:ad4cd4052825486e483bff14f328040cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of cuse device associated with NVMe namespace.  <a href="#ad4cd4052825486e483bff14f328040cf">More...</a><br /></td></tr>
<tr class="separator:ad4cd4052825486e483bff14f328040cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406b7ee1f53f568334e505365a281569"><td class="memItemLeft" align="right" valign="top"><a id="a406b7ee1f53f568334e505365a281569"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_cuse_register</b> (struct spdk_nvme_ctrlr *ctrlr, const char *dev_path)</td></tr>
<tr class="separator:a406b7ee1f53f568334e505365a281569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af071b3e57e51005c4e2b877eeda58b4b"><td class="memItemLeft" align="right" valign="top"><a id="af071b3e57e51005c4e2b877eeda58b4b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvme_cuse_unregister</b> (struct spdk_nvme_ctrlr *ctrlr)</td></tr>
<tr class="separator:af071b3e57e51005c4e2b877eeda58b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>NVMe driver public API. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ae564dc7dced1dd7b474c1a6923734a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae564dc7dced1dd7b474c1a6923734a6d">&#9670;&nbsp;</a></span>spdk_nvme_aer_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_aer_cb) (void *aer_cb_arg, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature for callback function invoked when an asynchronous error request command is completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">aer_cb_arg</td><td>Context specified by spdk_nvme_register_aer_callback(). </td></tr>
    <tr><td class="paramname"><a class="el" href="structspdk__nvme__cpl.html" title="Completion queue entry. ">spdk_nvme_cpl</a></td><td>Completion queue entry that contains the completion status of the asynchronous event request that was completed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1eaa795f075495337b270667661ce5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1eaa795f075495337b270667661ce5d">&#9670;&nbsp;</a></span>spdk_nvme_attach_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_attach_cb) (void *cb_ctx, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct spdk_nvme_ctrlr *ctrlr, const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for spdk_nvme_attach() to report a device that has been attached to the userspace NVMe driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_ctx</td><td>Opaque value passed to <a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d" title="Callback for spdk_nvme_attach() to report a device that has been attached to the userspace NVMe drive...">spdk_nvme_attach_cb()</a>. </td></tr>
    <tr><td class="paramname">trid</td><td>NVMe transport identifier. </td></tr>
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">opts</td><td>NVMe controller initialization options that were actually used. Options may differ from the requested options from the attach call depending on what the controller supports. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9779e9957d7089dde8e492cc60856d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9779e9957d7089dde8e492cc60856d8">&#9670;&nbsp;</a></span>spdk_nvme_cmd_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_cmd_cb) (void *, const struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature for callback function invoked when a command is completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structspdk__nvme__cpl.html" title="Completion queue entry. ">spdk_nvme_cpl</a></td><td>Completion queue entry that coontains the completion status. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95f40d5179f8424b466a30ba0610ab4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f40d5179f8424b466a30ba0610ab4c">&#9670;&nbsp;</a></span>spdk_nvme_probe_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* spdk_nvme_probe_cb) (void *cb_ctx, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *opts)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> enumeration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_ctx</td><td>Opaque value passed to <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>. </td></tr>
    <tr><td class="paramname">trid</td><td>NVMe transport identifier. </td></tr>
    <tr><td class="paramname">opts</td><td>NVMe controller initialization options. This structure will be populated with the default values on entry, and the user callback may update any options to request a different value. The controller may not support all requested parameters, so the final values will be provided during the attach callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true to attach to this device. </dd></dl>

</div>
</div>
<a id="a05f1aa545be57a03bb2dd0c6180172b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f1aa545be57a03bb2dd0c6180172b6">&#9670;&nbsp;</a></span>spdk_nvme_remove_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_remove_cb) (void *cb_ctx, struct spdk_nvme_ctrlr *ctrlr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback for spdk_nvme_remove() to report that a device attached to the userspace NVMe driver has been removed from the system. </p>
<p>The controller will remain in a failed state (any new I/O submitted will fail).</p>
<p>The controller must be detached from the userspace driver by calling <a class="el" href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2" title="Detach specified device returned by spdk_nvme_probe()&#39;s attach_cb from the NVMe driver. ">spdk_nvme_detach()</a> once the controller is no longer in use. It is up to the library user to ensure that no other threads are using the controller before calling <a class="el" href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2" title="Detach specified device returned by spdk_nvme_probe()&#39;s attach_cb from the NVMe driver. ">spdk_nvme_detach()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_ctx</td><td>Opaque value passed to <a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6" title="Callback for spdk_nvme_remove() to report that a device attached to the userspace NVMe driver has bee...">spdk_nvme_remove_cb()</a>. </td></tr>
    <tr><td class="paramname">ctrlr</td><td>NVMe controller instance that was removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ab95bea86f498c08510f6f0bcd2eb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab95bea86f498c08510f6f0bcd2eb09">&#9670;&nbsp;</a></span>spdk_nvme_req_next_sge_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_nvme_req_next_sge_cb) (void *cb_arg, void **address, uint32_t *length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill out *address and *length with the current SGL entry and advance to the next entry for the next time the callback is invoked. </p>
<p>The described segment must be physically contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Argument passed to readv/writev. </td></tr>
    <tr><td class="paramname">address</td><td>Virtual address of this segment. </td></tr>
    <tr><td class="paramname">length</td><td>Length of this physical segment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e1fcb43970ea531567ee00d4ee0675b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1fcb43970ea531567ee00d4ee0675b">&#9670;&nbsp;</a></span>spdk_nvme_req_reset_sgl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_req_reset_sgl_cb) (void *cb_arg, uint32_t offset)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restart the SGL walk to the specified offset when the command has scattered payloads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Argument passed to readv/writev. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset for SGL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53fe1c01a447be8fcd29821a668227a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fe1c01a447be8fcd29821a668227a0">&#9670;&nbsp;</a></span>spdk_nvme_timeout_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvme_timeout_cb) (void *cb_arg, struct spdk_nvme_ctrlr *ctrlr, struct spdk_nvme_qpair *qpair, uint16_t cid)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signature for the callback function invoked when a timeout is detected on a request. </p>
<p>For timeouts detected on the admin queue pair, the qpair returned here will be NULL. If the controller has a serious error condition and is unable to communicate with driver via completion queue, the controller can set Controller Fatal Status field to 1, then reset is required to recover from such error. Users may detect Controller Fatal Status when timeout happens.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Argument passed to callback funciton. </td></tr>
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">qpair</td><td>Opaque handle to a queue pair. </td></tr>
    <tr><td class="paramname">cid</td><td>Command ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="add21ceb016f09949ac6cef50e0566818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add21ceb016f09949ac6cef50e0566818">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme_8h.html#add21ceb016f09949ac6cef50e0566818">spdk_nvme_ctrlr_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="add21ceb016f09949ac6cef50e0566818a06c93626e819195260a55c69dba063c6"></a>SPDK_NVME_CTRLR_SGL_SUPPORTED&#160;</td><td class="fielddoc"><p>The SGL is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="add21ceb016f09949ac6cef50e0566818a7bddfe71a101581b0daa4812fbd93268"></a>SPDK_NVME_CTRLR_SECURITY_SEND_RECV_SUPPORTED&#160;</td><td class="fielddoc"><p>security send/receive is supported </p>
</td></tr>
<tr><td class="fieldname"><a id="add21ceb016f09949ac6cef50e0566818ab7e2345d658ff0069c99427a5e0177d3"></a>SPDK_NVME_CTRLR_WRR_SUPPORTED&#160;</td><td class="fielddoc"><p>Weighted Round Robin is supported. </p>
</td></tr>
</table>

</div>
</div>
<a id="a018f3b986b4345ee0c6931be9718c163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018f3b986b4345ee0c6931be9718c163">&#9670;&nbsp;</a></span>spdk_nvme_ns_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme_8h.html#a018f3b986b4345ee0c6931be9718c163">spdk_nvme_ns_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Namespace command support flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163a80dcd48a57fa9e14efba4757300ad729"></a>SPDK_NVME_NS_DEALLOCATE_SUPPORTED&#160;</td><td class="fielddoc"><p>The deallocate command is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163ad403aafc70c00560a1db768029933400"></a>SPDK_NVME_NS_FLUSH_SUPPORTED&#160;</td><td class="fielddoc"><p>The flush command is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163a60edfdee88fbe811250e2f8ff63597d0"></a>SPDK_NVME_NS_RESERVATION_SUPPORTED&#160;</td><td class="fielddoc"><p>The reservation command is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163a4e691401f3709b7cd66bd32c28ae109b"></a>SPDK_NVME_NS_WRITE_ZEROES_SUPPORTED&#160;</td><td class="fielddoc"><p>The write zeroes command is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163afe158b050528f0f3341e5af3129c61a7"></a>SPDK_NVME_NS_DPS_PI_SUPPORTED&#160;</td><td class="fielddoc"><p>The end-to-end data protection is supported. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163a91203896ead47bbe22e9f7db8a63c14f"></a>SPDK_NVME_NS_EXTENDED_LBA_SUPPORTED&#160;</td><td class="fielddoc"><p>The extended lba format is supported, metadata is transferred as a contiguous part of the logical block that it is associated with. </p>
</td></tr>
<tr><td class="fieldname"><a id="a018f3b986b4345ee0c6931be9718c163afe42f7e0cdcb93109b55b77cf89efd27"></a>SPDK_NVME_NS_WRITE_UNCORRECTABLE_SUPPORTED&#160;</td><td class="fielddoc"><p>The write uncorrectable command is supported. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae87a03c28984a2c0499d50ef5e9d0ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87a03c28984a2c0499d50ef5e9d0ece">&#9670;&nbsp;</a></span>spdk_nvme_transport_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NVMe library transports. </p>
<p>NOTE: These are mapped directly to the NVMe over Fabrics TRTYPE values, except for PCIe, which is a special case since NVMe over Fabrics does not define a TRTYPE for local PCIe.</p>
<p>Currently, this uses 256 for PCIe which is intentionally outside of the 8-bit range of TRTYPE. If the NVMe-oF specification ever defines a PCIe TRTYPE, this should be updated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae87a03c28984a2c0499d50ef5e9d0ecea162afc05d1ae756b8a7969be140035ea"></a>SPDK_NVME_TRANSPORT_PCIE&#160;</td><td class="fielddoc"><p>PCIe Transport (locally attached devices) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae87a03c28984a2c0499d50ef5e9d0ecea140f1cb4edf258bddffeb1c7277d93d8"></a>SPDK_NVME_TRANSPORT_RDMA&#160;</td><td class="fielddoc"><p>RDMA Transport (RoCE, iWARP, etc.) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae87a03c28984a2c0499d50ef5e9d0eceabbda195aa6d0a4ad7b437ed5e9a0d01f"></a>SPDK_NVME_TRANSPORT_FC&#160;</td><td class="fielddoc"><p>Fibre Channel (FC) Transport. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae87a03c28984a2c0499d50ef5e9d0ecea1b74e6a5b484b71142aa6ac9821a6de3"></a>SPDK_NVME_TRANSPORT_TCP&#160;</td><td class="fielddoc"><p>TCP Transport. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae26375a74c2c935ec32f0c41a7ed93df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26375a74c2c935ec32f0c41a7ed93df">&#9670;&nbsp;</a></span>spdk_nvme_connect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_ctrlr* spdk_nvme_connect </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>opts_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect the NVMe driver to the device located at the given transport ID. </p>
<p>This function is not thread safe and should only be called from one thread at a time while no other threads are actively using this NVMe device.</p>
<p>If called from a secondary process, only the device that has been attached to the userspace driver in the primary process will be connected.</p>
<p>If connecting to multiple controllers, it is suggested to use <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> and filter the requested controllers with the probe callback. For PCIe controllers, <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> will be more efficient since the controller resets will happen in parallel.</p>
<p>To stop using the the controller and release its associated resources, call <a class="el" href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2" title="Detach specified device returned by spdk_nvme_probe()&#39;s attach_cb from the NVMe driver. ">spdk_nvme_detach()</a> with the spdk_nvme_ctrlr instance returned by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid</td><td>The transport ID indicating which device to connect. If the trtype is PCIe, this will connect the local PCIe bus. If the trtype is RDMA, the traddr and trsvcid must point at the location of an NVMe-oF service. </td></tr>
    <tr><td class="paramname">opts</td><td>NVMe controller initialization options. Default values will be used if the user does not specify the options. The controller may not support all requested parameters. </td></tr>
    <tr><td class="paramname">opts_size</td><td>Must be set to sizeof(struct spdk_nvme_ctrlr_opts), or 0 if opts is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the connected NVMe controller or NULL if there is any failure. </dd></dl>

</div>
</div>
<a id="ae8a8762934973d124cbad92fce47a351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a8762934973d124cbad92fce47a351">&#9670;&nbsp;</a></span>spdk_nvme_connect_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_probe_ctx* spdk_nvme_connect_async </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a>&#160;</td>
          <td class="paramname"><em>attach_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect the NVMe driver to the device located at the given transport ID. </p>
<p>The function will return a probe context on success, controller associates with the context is not ready for use, user must call <a class="el" href="nvme_8h.html#aedea919a47bdd811b604656e29e3fcef" title="Start controllers in the context list. ">spdk_nvme_probe_poll_async()</a> until <a class="el" href="nvme_8h.html#aedea919a47bdd811b604656e29e3fcef" title="Start controllers in the context list. ">spdk_nvme_probe_poll_async()</a> returns 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid</td><td>The transport ID indicating which device to connect. If the trtype is PCIe, this will connect the local PCIe bus. If the trtype is RDMA, the traddr and trsvcid must point at the location of an NVMe-oF service. </td></tr>
    <tr><td class="paramname">opts</td><td>NVMe controller initialization options. Default values will be used if the user does not specify the options. The controller may not support all requested parameters. </td></tr>
    <tr><td class="paramname">attach_cb</td><td>will be called once the NVMe controller has been attached to the userspace driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>probe context on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="a5f179ad680512c168148e13aa74b3f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f179ad680512c168148e13aa74b3f4b">&#9670;&nbsp;</a></span>spdk_nvme_cpl_get_status_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvme_cpl_get_status_string </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__status.html">spdk_nvme_status</a> *&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given NVMe status, return ASCII string for that error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Status from NVMe completion queue element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns status as an ASCII string. </dd></dl>

</div>
</div>
<a id="ad63b25defbb0f1ccd52538e3b9a748df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63b25defbb0f1ccd52538e3b9a748df">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_alloc_cmb_io_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_nvme_ctrlr_alloc_cmb_io_buffer </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an I/O buffer from the controller memory buffer (Experimental). </p>
<p>This function allocates registered memory which belongs to the Controller Memory Buffer (CMB) of the specified NVMe controller. Note that the CMB has to support the WDS and RDS capabilities for the allocation to be successful. Also, due to vtophys contraints the CMB must be at least 4MiB in size. Free memory allocated with this function using <a class="el" href="nvme_8h.html#abb11b2a40d2cd45072f83624956b8b01" title="Free a controller memory I/O buffer (Experimental). ">spdk_nvme_ctrlr_free_cmb_io_buffer()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Controller from which to allocate memory buffer. </td></tr>
    <tr><td class="paramname">size</td><td>Size of buffer to allocate in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to controller memory buffer allocation, or NULL if allocation was not possible. </dd></dl>

</div>
</div>
<a id="a13f745d239dab9b8f934fae2ad4984a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f745d239dab9b8f934fae2ad4984a2">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_alloc_io_qpair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_qpair* spdk_nvme_ctrlr_alloc_io_qpair </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__io__qpair__opts.html">spdk_nvme_io_qpair_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>opts_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an I/O queue pair (submission and completion queue). </p>
<p>Each queue pair should only be used from a single thread at a time (mutual exclusion must be enforced by the user).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller for which to allocate the I/O queue pair. </td></tr>
    <tr><td class="paramname">opts</td><td>I/O qpair creation options, or NULL to use the defaults as returned by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. </td></tr>
    <tr><td class="paramname">opts_size</td><td>Must be set to sizeof(struct spdk_nvme_io_qpair_opts), or 0 if opts is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated I/O queue pair. </dd></dl>

</div>
</div>
<a id="ae935583b7f95b13fbd2dd41255490da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae935583b7f95b13fbd2dd41255490da0">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_attach_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_attach_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__ctrlr__list.html">spdk_nvme_ctrlr_list</a> *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach the specified namespace to controllers. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands. ">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to use for command submission. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace identifier for namespace to attach. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the controller list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if resources could not be allocated for this request. </dd></dl>

</div>
</div>
<a id="a724ed20a1a5adaf30c48db8c28d29677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724ed20a1a5adaf30c48db8c28d29677">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_abort </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>cid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort a specific previously-submitted NVMe command. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#aecec86e033e0d13e6fc67ead61a7028d" title="Register for timeout callback on a controller. ">spdk_nvme_ctrlr_register_timeout_callback()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to which the command was submitted. </td></tr>
    <tr><td class="paramname">qpair</td><td>NVMe queue pair to which the command was submitted. For admin commands, pass NULL for the qpair. </td></tr>
    <tr><td class="paramname">cid</td><td>Command ID of the command to abort. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the abort has completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="afe2a9d3b715649b4d0a0e89196a13e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2a9d3b715649b4d0a0e89196a13e6d">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_admin_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_admin_raw </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the given admin command to the NVMe controller. </p>
<p>This is a low level interface for submitting admin commands directly. Prefer the spdk_nvme_ctrlr_cmd_* functions instead. The validity of the command will not be checked!</p>
<p>When constructing the nvme_command it is not necessary to fill out the PRP list/SGL or the CID. The driver will handle both of those for you.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands. ">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">cmd</td><td>NVM admin command to submit. </td></tr>
    <tr><td class="paramname">buf</td><td>Virtual memory address of a single physically contiguous buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Size of buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function invoked when the admin command completes. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="a6b4ebba22f1585b98e4ca20932d75434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4ebba22f1585b98e4ca20932d75434">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_get_feature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_get_feature </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get specific feature from given NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands. ">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#aa9507cb98ee30e5df98474bc82190476" title="Set specific feature for the given NVMe controller. ">spdk_nvme_ctrlr_cmd_set_feature()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to query. </td></tr>
    <tr><td class="paramname">feature</td><td>The feature identifier. </td></tr>
    <tr><td class="paramname">cdw11</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the feature has been retrieved. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, -ENOMEM if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="abc0f038c06c49df0e75148faf6cc4b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0f038c06c49df0e75148faf6cc4b51">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_get_feature_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_get_feature_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ns_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get specific feature from given NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to query. </td></tr>
    <tr><td class="paramname">feature</td><td>The feature identifier. </td></tr>
    <tr><td class="paramname">cdw11</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the feature has been retrieved. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">ns_id</td><td>The namespace identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, -ENOMEM if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer.</dd></dl>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a63fda1acce45c71590ed0db99220d26b" title="Set specific feature for the given NVMe controller and namespace ID. ">spdk_nvme_ctrlr_cmd_set_feature_ns()</a> </dd></dl>

</div>
</div>
<a id="a88c881cccf7873bbe4605320ffb0a81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c881cccf7873bbe4605320ffb0a81c">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_get_log_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_get_log_page </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>log_page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a specific log page from the NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands. ">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a7dc6bb842e168a68972ec46cc35591ae" title="Determine if a particular log page is supported by the given NVMe controller. ">spdk_nvme_ctrlr_is_log_page_supported()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">log_page</td><td>The log page identifier. </td></tr>
    <tr><td class="paramname">nsid</td><td>Depending on the log page, this may be 0, a namespace identifier, or SPDK_NVME_GLOBAL_NS_TAG. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in bytes within the log page to start retrieving log page data. May only be non-zero if the controller supports extended data for Get Log Page as reported in the controller data log page attributes. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the log page has been retrieved. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="a1e3def668122e76abbfb74305f118291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3def668122e76abbfb74305f118291">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_io_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_io_raw </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the given NVM I/O command to the NVMe controller. </p>
<p>This is a low level interface for submitting I/O commands directly. Prefer the spdk_nvme_ns_cmd_* functions instead. The validity of the command will not be checked!</p>
<p>When constructing the nvme_command it is not necessary to fill out the PRP list/SGL or the CID. The driver will handle both of those for you.</p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O qpair to submit command. </td></tr>
    <tr><td class="paramname">cmd</td><td>NVM I/O command to submit. </td></tr>
    <tr><td class="paramname">buf</td><td>Virtual memory address of a single physically contiguous buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Size of buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function invoked when the I/O command completes. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="afd2d8453bb2478c7b1a70c0a09c7ef4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2d8453bb2478c7b1a70c0a09c7ef4b">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_io_raw_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_io_raw_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>md_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the given NVM I/O command with metadata to the NVMe controller. </p>
<p>This is a low level interface for submitting I/O commands directly. Prefer the spdk_nvme_ns_cmd_* functions instead. The validity of the command will not be checked!</p>
<p>When constructing the nvme_command it is not necessary to fill out the PRP list/SGL or the CID. The driver will handle both of those for you.</p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O qpair to submit command. </td></tr>
    <tr><td class="paramname">cmd</td><td>NVM I/O command to submit. </td></tr>
    <tr><td class="paramname">buf</td><td>Virtual memory address of a single physically contiguous buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Size of buffer. </td></tr>
    <tr><td class="paramname">md_buf</td><td>Virtual memory address of a single physically contiguous metadata buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function invoked when the I/O command completes. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="aa9507cb98ee30e5df98474bc82190476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9507cb98ee30e5df98474bc82190476">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_set_feature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_set_feature </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set specific feature for the given NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands. ">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a6b4ebba22f1585b98e4ca20932d75434" title="Get specific feature from given NVMe controller. ">spdk_nvme_ctrlr_cmd_get_feature()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to manipulate. </td></tr>
    <tr><td class="paramname">feature</td><td>The feature identifier. </td></tr>
    <tr><td class="paramname">cdw11</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">cdw12</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the feature has been set. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="a63fda1acce45c71590ed0db99220d26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fda1acce45c71590ed0db99220d26b">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_cmd_set_feature_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_cmd_set_feature_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cdw12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ns_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set specific feature for the given NVMe controller and namespace ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to manipulate. </td></tr>
    <tr><td class="paramname">feature</td><td>The feature identifier. </td></tr>
    <tr><td class="paramname">cdw11</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">cdw12</td><td>as defined by the specification for this command. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of payload buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the feature has been set. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">ns_id</td><td>The namespace identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, -ENOMEM if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer.</dd></dl>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#abc0f038c06c49df0e75148faf6cc4b51" title="Get specific feature from given NVMe controller. ">spdk_nvme_ctrlr_cmd_get_feature_ns()</a> </dd></dl>

</div>
</div>
<a id="ace23485fea91d126a13fe706ce6d8843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace23485fea91d126a13fe706ce6d8843">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_create_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ctrlr_create_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a> *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a namespace. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to create namespace on. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the NVMe namespace data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Namespace ID (&gt;= 1) if successfully created, or 0 if the request failed. </dd></dl>

</div>
</div>
<a id="a7c62e2d4555a5ebc3a3b6f9632c51e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c62e2d4555a5ebc3a3b6f9632c51e1a">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_delete_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_delete_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a namespace. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands. ">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to delete namespace from. </td></tr>
    <tr><td class="paramname">nsid</td><td>The namespace identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request </dd></dl>

</div>
</div>
<a id="ab562f58b5903071929d6a559fe984d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab562f58b5903071929d6a559fe984d0a">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_detach_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_detach_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__ctrlr__list.html">spdk_nvme_ctrlr_list</a> *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach the specified namespace from controllers. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands. ">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to use for command submission. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace ID to detach. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the controller list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if resources could not be allocated for this request </dd></dl>

</div>
</div>
<a id="a4b7578aeee6b6a092a4a4013a2f32ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7578aeee6b6a092a4a4013a2f32ce5">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_fail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_fail </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fail the given NVMe controller. </p>
<p>This function gives the application the opportunity to fail a controller at will. When a controller is failed, any calls to process completions or submit I/O on qpairs associated with that controller will fail with an error code of -ENXIO. The controller can only be taken from the failed state by calling spdk_nvme_ctrlr_reset. After the controller has been successfully reset, any I/O pending when the controller was moved to failed will be aborted back to the application and can be resubmitted. I/O can then resume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to an NVMe controller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bb6973133e1fd5e7a1522ab104ac92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb6973133e1fd5e7a1522ab104ac92b">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_format </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__format.html">spdk_nvme_format</a> *&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format NVM. </p>
<p>This function requests a low-level format of the media.</p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to format. </td></tr>
    <tr><td class="paramname">nsid</td><td>The namespace identifier. May be SPDK_NVME_GLOBAL_NS_TAG to format all namespaces. </td></tr>
    <tr><td class="paramname">format</td><td>The format information for the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request </dd></dl>

</div>
</div>
<a id="abb11b2a40d2cd45072f83624956b8b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb11b2a40d2cd45072f83624956b8b01">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_free_cmb_io_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_free_cmb_io_buffer </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a controller memory I/O buffer (Experimental). </p>
<p>Note this function is currently a NOP which is one reason why this and <a class="el" href="nvme_8h.html#ad63b25defbb0f1ccd52538e3b9a748df" title="Allocate an I/O buffer from the controller memory buffer (Experimental). ">spdk_nvme_ctrlr_alloc_cmb_io_buffer()</a> are currently marked as experimental.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Controller from which the buffer was allocated. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer previously allocated by <a class="el" href="nvme_8h.html#ad63b25defbb0f1ccd52538e3b9a748df" title="Allocate an I/O buffer from the controller memory buffer (Experimental). ">spdk_nvme_ctrlr_alloc_cmb_io_buffer()</a>. </td></tr>
    <tr><td class="paramname">size</td><td>Size of buf in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85ec189f50d0f78d73a54413370401f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ec189f50d0f78d73a54413370401f5">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_free_io_qpair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_free_io_qpair </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an I/O queue pair that was allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>I/O queue pair to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a5a9daf15b5008ac36c12e7b8db7bdec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9daf15b5008ac36c12e7b8db7bdec9">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__nvme__ctrlr__data.html">spdk_nvme_ctrlr_data</a>* spdk_nvme_ctrlr_get_data </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the identify controller data as defined by the NVMe specification. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the identify controller data. </dd></dl>

</div>
</div>
<a id="ac31bc692c6b3a84e2355eb63a8b01ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31bc692c6b3a84e2355eb63a8b01ccf">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_default_ctrlr_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_get_default_ctrlr_opts </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__ctrlr__opts.html">spdk_nvme_ctrlr_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>opts_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default options for the creation of a specific NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">opts</td><td>Will be filled with the default option. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">opts_size</td><td>Must be set to sizeof(struct spdk_nvme_ctrlr_opts). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6964d09dc51882fae6f2a7cf94afc741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6964d09dc51882fae6f2a7cf94afc741">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_default_io_qpair_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_get_default_io_qpair_opts </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__io__qpair__opts.html">spdk_nvme_io_qpair_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>opts_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the default options for I/O qpair creation for a specific NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ctrlr</td><td>NVMe controller to retrieve the defaults from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">opts</td><td>Will be filled with the default options for <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">opts_size</td><td>Must be set to sizeof(struct spdk_nvme_io_qpair_opts). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59e69f39c7cb8a9e1c3e00af7804c8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e69f39c7cb8a9e1c3e00af7804c8bd">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_first_active_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ctrlr_get_first_active_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nsid of the first active namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nsid of the first active namespace, 0 if there are no active namespaces. </dd></dl>

</div>
</div>
<a id="af654a7a016511f265b29294fd06ce26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af654a7a016511f265b29294fd06ce26e">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_nvme_ctrlr_get_flags </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get supported flags of the controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to get flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>supported flags of this controller. </dd></dl>

</div>
</div>
<a id="ac750410c9b53a0435d0111ae1e98913e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac750410c9b53a0435d0111ae1e98913e">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_max_xfer_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ctrlr_get_max_xfer_size </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum data transfer size of a given NVMe controller. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum data transfer size of the NVMe controller in bytes.</dd></dl>
<p>The I/O command helper functions, such as <a class="el" href="nvme_8h.html#a084c6ecb53bd810fbb5051100b79bec5" title="Submits a read I/O to the specified NVMe namespace. ">spdk_nvme_ns_cmd_read()</a>, will split large I/Os automatically; however, it is up to the user to obey this limit for commands submitted with the raw command functions, such as <a class="el" href="nvme_8h.html#a1e3def668122e76abbfb74305f118291" title="Send the given NVM I/O command to the NVMe controller. ">spdk_nvme_ctrlr_cmd_io_raw()</a>. </p>

</div>
</div>
<a id="abcd528b0df0a564c218dc2745c3af159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd528b0df0a564c218dc2745c3af159">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_next_active_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ctrlr_get_next_active_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>prev_nsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get next active namespace given the previous nsid. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">prev_nsid</td><td>Namespace id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a next active namespace given the previous nsid, 0 when there are no more active namespaces. </dd></dl>

</div>
</div>
<a id="a6f01fb8a5f404e41e6fa224a7942be08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f01fb8a5f404e41e6fa224a7942be08">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_ns* spdk_nvme_ctrlr_get_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ns_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to a namespace for the given controller. </p>
<p>Namespaces are numbered from 1 to the total number of namespaces. There will never be any gaps in the numbering. The number of namespaces is obtained by calling <a class="el" href="nvme_8h.html#a02b18deae44682a51177e8a4193af602" title="Get the number of namespaces for the given NVMe controller. ">spdk_nvme_ctrlr_get_num_ns()</a>.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">ns_id</td><td>Namespace id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the namespace. </dd></dl>

</div>
</div>
<a id="a02b18deae44682a51177e8a4193af602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02b18deae44682a51177e8a4193af602">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_num_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ctrlr_get_num_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of namespaces for the given NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<p>This is equivalent to calling <a class="el" href="nvme_8h.html#a5a9daf15b5008ac36c12e7b8db7bdec9" title="Get the identify controller data as defined by the NVMe specification. ">spdk_nvme_ctrlr_get_data()</a> to get the <a class="el" href="structspdk__nvme__ctrlr__data.html">spdk_nvme_ctrlr_data</a> and then reading the nn field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of namespaces. </dd></dl>

</div>
</div>
<a id="a60d8173db83accb35f0c5fe1ec8261bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d8173db83accb35f0c5fe1ec8261bf">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_pci_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__pci__device.html">spdk_pci_device</a>* spdk_nvme_ctrlr_get_pci_device </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the PCI device of a given NVMe controller. </p>
<p>This only works for local (PCIe-attached) NVMe controllers; other transports will return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>PCI device of the NVMe controller, or NULL if not available. </dd></dl>

</div>
</div>
<a id="a887db5ce5c84eba37a4d82f5d180d020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887db5ce5c84eba37a4d82f5d180d020">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile struct <a class="el" href="structspdk__nvme__registers.html">spdk_nvme_registers</a>* spdk_nvme_ctrlr_get_registers </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return virtual address of PCIe NVM I/O registers. </p>
<p>This function returns a pointer to the PCIe I/O registers for a controller or NULL if unsupported for this transport.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Controller whose registers are to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to virtual address of register bank, or NULL. </dd></dl>

</div>
</div>
<a id="a6943191f9c88c3cec504f87672b9acf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6943191f9c88c3cec504f87672b9acf8">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_regs_cap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="unionspdk__nvme__cap__register.html">spdk_nvme_cap_register</a> spdk_nvme_ctrlr_get_regs_cap </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NVMe controller CAP (Capabilities) register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the NVMe controller CAP (Capabilities) register. </dd></dl>

</div>
</div>
<a id="a260b335960b9d81ac1a2601b003b99cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260b335960b9d81ac1a2601b003b99cd">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_regs_cmbsz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="unionspdk__nvme__cmbsz__register.html">spdk_nvme_cmbsz_register</a> spdk_nvme_ctrlr_get_regs_cmbsz </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NVMe controller CMBSZ (Controller Memory Buffer Size) register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the NVMe controller CMBSZ (Controller Memory Buffer Size) register. </dd></dl>

</div>
</div>
<a id="a46348531c83fd61acad1a55236d7d576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46348531c83fd61acad1a55236d7d576">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_regs_csts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="unionspdk__nvme__csts__register.html">spdk_nvme_csts_register</a> spdk_nvme_ctrlr_get_regs_csts </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NVMe controller CSTS (Status) register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the NVMe controller CSTS (Status) register. </dd></dl>

</div>
</div>
<a id="aacf238fdce21d10c923a384e18b013dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf238fdce21d10c923a384e18b013dd">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_regs_vs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="unionspdk__nvme__vs__register.html">spdk_nvme_vs_register</a> spdk_nvme_ctrlr_get_regs_vs </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NVMe controller VS (Version) register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the NVMe controller VS (Version) register. </dd></dl>

</div>
</div>
<a id="abb7ae9abf97b7c6b57777d06eaa1258a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7ae9abf97b7c6b57777d06eaa1258a">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_get_transport_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a>* spdk_nvme_ctrlr_get_transport_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transport ID for a given NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Controller to get the transport ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the controller's transport ID. </dd></dl>

</div>
</div>
<a id="a8c00b191b38472b57b06f3f394353ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c00b191b38472b57b06f3f394353ad3">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_io_cmd_raw_no_payload_build()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_io_cmd_raw_no_payload_build </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send the given NVM I/O command, I/O buffers, lists and all to the NVMe controller. </p>
<p>This is a low level interface for submitting I/O commands directly.</p>
<p>This function allows a caller to submit an I/O request that is COMPLETELY pre-defined, right down to the "physical" memory buffers. It is intended for testing hardware, specifying exact buffer location, alignment, and offset. It also allows for specific choice of PRP and SGLs.</p>
<p>The driver sets the CID. EVERYTHING else is assumed set by the caller. Needless to say, this is potentially extremely dangerous for both the host (accidental/malicionus storage usage/corruption), and the device. Thus its intent is for very specific hardware testing and environment reproduction.</p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<p>This function can only be used on PCIe controllers and qpairs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O qpair to submit command. </td></tr>
    <tr><td class="paramname">cmd</td><td>NVM I/O command to submit. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function invoked when the I/O command completes. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, -ENOMEN if resources could not be allocated for this request, -ENXIO if the admin qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="abbcdb6e7c22b0ef87ed927bf97952c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcdb6e7c22b0ef87ed927bf97952c19">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_is_active_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ctrlr_is_active_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the nsid is an active nv for the given NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if nsid is an active ns, or false otherwise. </dd></dl>

</div>
</div>
<a id="a39c91e2e6ae899f37b5a89c28a2207cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c91e2e6ae899f37b5a89c28a2207cf">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_is_discovery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ctrlr_is_discovery </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate whether a ctrlr handle is associated with a Discovery controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a discovery controller, else false. </dd></dl>

</div>
</div>
<a id="a1cdd28db5de54dfee308ea0a3c4f1442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdd28db5de54dfee308ea0a3c4f1442">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_is_failed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ctrlr_is_failed </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the failed status of a given controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to an NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the controller is failed, false otherwise. </dd></dl>

</div>
</div>
<a id="a909b61e141b56eaa5895482aa1f18a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909b61e141b56eaa5895482aa1f18a3b">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_is_feature_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ctrlr_is_feature_supported </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>feature_code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a particular feature is supported by the given NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a6b4ebba22f1585b98e4ca20932d75434" title="Get specific feature from given NVMe controller. ">spdk_nvme_ctrlr_cmd_get_feature()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">feature_code</td><td>Feature to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if supported, or false otherwise. </dd></dl>

</div>
</div>
<a id="a7dc6bb842e168a68972ec46cc35591ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc6bb842e168a68972ec46cc35591ae">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_is_log_page_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ctrlr_is_log_page_supported </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>log_page</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a particular log page is supported by the given NVMe controller. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#a88c881cccf7873bbe4605320ffb0a81c" title="Get a specific log page from the NVMe controller. ">spdk_nvme_ctrlr_cmd_get_log_page()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">log_page</td><td>Log page to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if supported, or false otherwise. </dd></dl>

</div>
</div>
<a id="a10282695461985f58f54de022911745e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10282695461985f58f54de022911745e">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_process_admin_completions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t spdk_nvme_ctrlr_process_admin_completions </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process any outstanding completions for admin commands. </p>
<p>This will process completions for admin commands submitted on any thread.</p>
<p>This call is non-blocking, i.e. it only processes completions that are ready at the time of this function call. It does not wait for outstanding commands to finish.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of completions processed (may be 0) or negated on error. -ENXIO in the special case that the qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="a1e04d50b1f27f6cd163a4ea2024a6fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e04d50b1f27f6cd163a4ea2024a6fbb">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_reconnect_io_qpair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_reconnect_io_qpair </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to reconnect the given qpair. </p>
<p>This function is intended to be called on qpairs that have already been connected, but have since entered a failed state as indicated by a return value of -ENXIO from either spdk_nvme_qpair_process_completions or one of the spdk_nvme_ns_cmd_* functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The qpair to reconnect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or if the qpair was already connected. -EAGAIN if the driver was unable to reconnect during this call, but the controller is still connected and is either resetting or enabled. -ENODEV if the controller is removed. In this case, the controller cannot be recovered and the application will have to destroy it and the associated qpairs. -ENXIO if the controller is in a failed state but is not yet resetting. In this case, the application should call spdk_nvme_ctrlr_reset to reset the entire controller. </dd></dl>

</div>
</div>
<a id="a1505fc1ef6e8ccb00134c1fa15e0368b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1505fc1ef6e8ccb00134c1fa15e0368b">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_register_aer_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_register_aer_callback </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ae564dc7dced1dd7b474c1a6923734a6d">spdk_nvme_aer_cb</a>&#160;</td>
          <td class="paramname"><em>aer_cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>aer_cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register callback function invoked when an AER command is completed for the given NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">aer_cb_fn</td><td>Callback function invoked when an asynchronous error request command is completed. </td></tr>
    <tr><td class="paramname">aer_cb_arg</td><td>Argument passed to callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecec86e033e0d13e6fc67ead61a7028d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecec86e033e0d13e6fc67ead61a7028d">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_register_timeout_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_ctrlr_register_timeout_callback </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a53fe1c01a447be8fcd29821a668227a0">spdk_nvme_timeout_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register for timeout callback on a controller. </p>
<p>The application can choose to register for timeout callback or not register for timeout callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller on which to monitor for timeout. </td></tr>
    <tr><td class="paramname">timeout_us</td><td>Timeout value in microseconds. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A function pointer that points to the callback function. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae13ccd2ea831842a5008eb95a32545c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13ccd2ea831842a5008eb95a32545c3">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_reset </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a full hardware reset of the NVMe controller. </p>
<p>This function should be called from a single thread while no other threads are actively using the NVMe device.</p>
<p>Any pointers returned from <a class="el" href="nvme_8h.html#a6f01fb8a5f404e41e6fa224a7942be08" title="Get a handle to a namespace for the given controller. ">spdk_nvme_ctrlr_get_ns()</a> and <a class="el" href="nvme_8h.html#ab1863b5dccf2bcc49fe92275bc1e5a2a" title="Get the identify namespace data as defined by the NVMe specification. ">spdk_nvme_ns_get_data()</a> may be invalidated by calling this function. The number of namespaces as returned by <a class="el" href="nvme_8h.html#a02b18deae44682a51177e8a4193af602" title="Get the number of namespaces for the given NVMe controller. ">spdk_nvme_ctrlr_get_num_ns()</a> may also change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a5175d6805225d84d6e4aa4e0f1546c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5175d6805225d84d6e4aa4e0f1546c69">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_security_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_security_receive </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>secp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>spsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nssf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive security protocol data from controller. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands. ">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to use for security receive command submission. </td></tr>
    <tr><td class="paramname">secp</td><td>Security Protocol that is used. </td></tr>
    <tr><td class="paramname">spsp</td><td>Security Protocol Specific field. </td></tr>
    <tr><td class="paramname">nssf</td><td>NVMe Security Specific field. Indicate RPMB target when using Security Protocol EAh. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of payload buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request. </dd></dl>

</div>
</div>
<a id="ada4ab089f73f3f43e9c5b8e6415e6f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4ab089f73f3f43e9c5b8e6415e6f50">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_security_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_security_send </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>secp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>spsp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nssf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send security protocol data to controller. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<p>Call <a class="el" href="nvme_8h.html#a10282695461985f58f54de022911745e" title="Process any outstanding completions for admin commands. ">spdk_nvme_ctrlr_process_admin_completions()</a> to poll for completion of commands submitted through this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to use for security send command submission. </td></tr>
    <tr><td class="paramname">secp</td><td>Security Protocol that is used. </td></tr>
    <tr><td class="paramname">spsp</td><td>Security Protocol Specific field. </td></tr>
    <tr><td class="paramname">nssf</td><td>NVMe Security Specific field. Indicate RPMB target when using Security Protocol EAh. </td></tr>
    <tr><td class="paramname">payload</td><td>The pointer to the payload buffer. </td></tr>
    <tr><td class="paramname">size</td><td>The size of payload buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if resources could not be allocated for this request. </dd></dl>

</div>
</div>
<a id="a6eacd62ee8fbab40e1066bc0a53485f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eacd62ee8fbab40e1066bc0a53485f3">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_set_trid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_set_trid </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the transport ID for a given controller. </p>
<p>This function allows the user to set a new trid for a controller only if the controller is failed. The controller's failed state can be obtained from <a class="el" href="nvme_8h.html#a1cdd28db5de54dfee308ea0a3c4f1442" title="This function returns the failed status of a given controller. ">spdk_nvme_ctrlr_is_failed()</a>. The controller can also be forced to the failed state using <a class="el" href="nvme_8h.html#a4b7578aeee6b6a092a4a4013a2f32ce5" title="Fail the given NVMe controller. ">spdk_nvme_ctrlr_fail()</a>.</p>
<p>This function also requires that the transport type and subnqn of the new trid be the same as the old trid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to an NVMe controller. </td></tr>
    <tr><td class="paramname">trid</td><td>The new transport ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -EINVAL if the trid is invalid, -EPERM if the ctrlr is not failed. </dd></dl>

</div>
</div>
<a id="a7938b258a7614073065be4f6a35bd0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7938b258a7614073065be4f6a35bd0e2">&#9670;&nbsp;</a></span>spdk_nvme_ctrlr_update_firmware()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ctrlr_update_firmware </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#ae4da1c1bec22eb22d1af72bbf37af36e">spdk_nvme_fw_commit_action</a>&#160;</td>
          <td class="paramname"><em>commit_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__status.html">spdk_nvme_status</a> *&#160;</td>
          <td class="paramname"><em>completion_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Download a new firmware image. </p>
<p>This function is thread safe and can be called at any point after <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller to perform firmware operation on. </td></tr>
    <tr><td class="paramname">payload</td><td>The data buffer for the firmware image. </td></tr>
    <tr><td class="paramname">size</td><td>The data size will be downloaded. </td></tr>
    <tr><td class="paramname">slot</td><td>The slot that the firmware image will be committed to. </td></tr>
    <tr><td class="paramname">commit_action</td><td>The action to perform when firmware is committed. </td></tr>
    <tr><td class="paramname">completion_status</td><td>output parameter. Contains the completion status of the firmware commit operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, ENOMEM if resources could not be allocated for this request, -1 if the size is not multiple of 4. </dd></dl>

</div>
</div>
<a id="afc8c70873181a2561240944d3c63aae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8c70873181a2561240944d3c63aae1">&#9670;&nbsp;</a></span>spdk_nvme_cuse_get_ctrlr_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* spdk_nvme_cuse_get_ctrlr_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get name of cuse device associated with NVMe controller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the name of device. </dd></dl>

</div>
</div>
<a id="ad4cd4052825486e483bff14f328040cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4cd4052825486e483bff14f328040cf">&#9670;&nbsp;</a></span>spdk_nvme_cuse_get_ns_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* spdk_nvme_cuse_get_ns_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get name of cuse device associated with NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the name of device. </dd></dl>

</div>
</div>
<a id="a4b63c225c3cce6da60fdbfb6f54b11e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b63c225c3cce6da60fdbfb6f54b11e2">&#9670;&nbsp;</a></span>spdk_nvme_detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_detach </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detach specified device returned by <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a>'s attach_cb from the NVMe driver. </p>
<p>On success, the spdk_nvme_ctrlr handle is no longer valid.</p>
<p>This function should be called from a single thread while no other threads are actively using the NVMe device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ad068dd50f11160450098712422116785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad068dd50f11160450098712422116785">&#9670;&nbsp;</a></span>spdk_nvme_host_id_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_host_id_parse </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__host__id.html">spdk_nvme_host_id</a> *&#160;</td>
          <td class="paramname"><em>hostid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the string representation of a host ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostid</td><td>Output host ID structure (must be allocated and initialized by caller). </td></tr>
    <tr><td class="paramname">str</td><td>Input string representation of a transport ID to parse (hostid is a sub-configuration).</td></tr>
  </table>
  </dd>
</dl>
<p>str must be a zero-terminated C string containing one or more key:value pairs separated by whitespace.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Key  </th><th class="markdownTableHeadNone">Value   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">hostaddr  </td><td class="markdownTableBodyNone">Transport address (e.g. 192.168.100.8 for RDMA)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">hostsvcid  </td><td class="markdownTableBodyNone">Transport service identifier (e.g. 4420)   </td></tr>
</table>
<p>Unspecified fields of trid are left unmodified, so the caller must initialize hostid (for example, memset() to 0) before calling this function.</p>
<p>This function should not be used with Fiber Channel or PCIe as these transports do not require host information for connections.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if parsing was successful and hostid is filled out, or negated errno values on failure. </dd></dl>

</div>
</div>
<a id="acd8ade16f6272f03af420ca0de2ad615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8ade16f6272f03af420ca0de2ad615">&#9670;&nbsp;</a></span>spdk_nvme_io_msg_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_io_msg_process </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process IO message sent to controller from external module. </p>
<p>This call process requests from the ring, send IO to an allocated qpair or admin commands in its context. This call is non-blocking and intended to be polled by SPDK thread to provide safe environment for NVMe request completition sent by external module to controller.</p>
<p>The caller must ensure that each controller is polled by only one thread at a time.</p>
<p>This function may be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>Opaque handle to NVMe controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of processed external IO messages. </dd></dl>

</div>
</div>
<a id="ad8aa3c9ff510fe73945549077df18436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8aa3c9ff510fe73945549077df18436">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_compare </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a compare I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the compare I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to the data payload. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to compare the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the compare operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">nvme_spec.h</a>, for this I/O.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a4bf7a40872bfe623a5dfa31922263532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf7a40872bfe623a5dfa31922263532">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_compare_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_compare_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a compare I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the compare I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to the data payload. </td></tr>
    <tr><td class="paramname">metadata</td><td>Virtual address pointer to the metadata payload, the length of metadata is specified by <a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2" title="Get the metadata size, in bytes, of the given namespace. ">spdk_nvme_ns_get_md_size()</a>. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to compare the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the compare operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">nvme_spec.h</a>, for this I/O. </td></tr>
    <tr><td class="paramname">apptag_mask</td><td>Application tag mask. </td></tr>
    <tr><td class="paramname">apptag</td><td>Application tag to use end-to-end protection information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a108d6b722c8837593dec16f30376d182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108d6b722c8837593dec16f30376d182">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_comparev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_comparev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a compare I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the compare I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to compare the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the compare operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">nvme_spec.h</a>, for this I/O. </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>Callback function to reset scattered payload. </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>Callback function to iterate each scattered payload memory segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="ac0c646dd18675c54ffcf834ce699658d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c646dd18675c54ffcf834ce699658d">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_dataset_management()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_dataset_management </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__dsm__range.html">spdk_nvme_dsm_range</a> *&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a data set management request to the specified NVMe namespace. </p>
<p>Data set management operations are designed to optimize interaction with the block translation layer inside the device. The most common type of operation is deallocate, which is often referred to as TRIM or UNMAP.</p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<p>This is a convenience wrapper that will automatically allocate and construct the correct data buffers. Therefore, ranges does not need to be allocated from pinned memory and can be placed on the stack. If a higher performance, zero-copy version of DSM is required, simply build and submit a raw command using <a class="el" href="nvme_8h.html#a1e3def668122e76abbfb74305f118291" title="Send the given NVM I/O command to the NVMe controller. ">spdk_nvme_ctrlr_cmd_io_raw()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the DSM request </td></tr>
    <tr><td class="paramname">type</td><td>A bit field constructed from <a class="el" href="nvme__spec_8h.html#a553aa11d679deea767299b75e8ff5fca">spdk_nvme_dsm_attribute</a>. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">ranges</td><td>An array of <a class="el" href="structspdk__nvme__dsm__range.html">spdk_nvme_dsm_range</a> elements describing the LBAs to operate on. </td></tr>
    <tr><td class="paramname">num_ranges</td><td>The number of elements in the ranges array. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated POSIX errno values otherwise. </dd></dl>

</div>
</div>
<a id="aed0b134e140121bb9bd8664d4a43a5c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0b134e140121bb9bd8664d4a43a5c6">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_flush </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a flush request to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the flush request. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if an nvme_request structure cannot be allocated for the I/O request, -ENXIO if the qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a084c6ecb53bd810fbb5051100b79bec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084c6ecb53bd810fbb5051100b79bec5">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_read </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a read I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the read I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to the data payload. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to read the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the read operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">nvme_spec.h</a>, for this I/O.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="aa2913b93326e636eca6dfe7b42e349fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2913b93326e636eca6dfe7b42e349fe">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_read_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_read_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a read I/O to the specified NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the read I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">payload</td><td>virtual address pointer to the data payload </td></tr>
    <tr><td class="paramname">metadata</td><td>virtual address pointer to the metadata payload, the length of metadata is specified by <a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2" title="Get the metadata size, in bytes, of the given namespace. ">spdk_nvme_ns_get_md_size()</a>. </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA to read the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the read operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">nvme_spec.h</a>, for this I/O. </td></tr>
    <tr><td class="paramname">apptag_mask</td><td>Application tag mask. </td></tr>
    <tr><td class="paramname">apptag</td><td>Application tag to use end-to-end protection information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="acb47ce7de6b6e963ec9fb8de261466ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb47ce7de6b6e963ec9fb8de261466ae">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_readv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_readv </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the read I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to read the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the read operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">nvme_spec.h</a>, for this I/O. </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>Callback function to reset scattered payload. </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>Callback function to iterate each scattered payload memory segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a08afb91732d92d84a054012cd3d236aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08afb91732d92d84a054012cd3d236aa">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_readv_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_readv_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read I/O to the specified NVMe namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the read I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA to read the data </td></tr>
    <tr><td class="paramname">lba_count</td><td>length (in sectors) for the read operation </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function </td></tr>
    <tr><td class="paramname">io_flags</td><td>set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">nvme_spec.h</a>, for this I/O </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>callback function to reset scattered payload </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>callback function to iterate each scattered payload memory segment </td></tr>
    <tr><td class="paramname">metadata</td><td>virtual address pointer to the metadata payload, the length of metadata is specified by <a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2" title="Get the metadata size, in bytes, of the given namespace. ">spdk_nvme_ns_get_md_size()</a> </td></tr>
    <tr><td class="paramname">apptag_mask</td><td>application tag mask. </td></tr>
    <tr><td class="paramname">apptag</td><td>application tag to use end-to-end protection information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level.</dd></dl>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time. </p>

</div>
</div>
<a id="abb8028f294d09711401d098e89d87f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8028f294d09711401d098e89d87f38">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_reservation_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_reservation_acquire </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__reservation__acquire__data.html">spdk_nvme_reservation_acquire_data</a> *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#a95b3685443c2716ee0d125c30182aeac">spdk_nvme_reservation_acquire_action</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#aa7e108757c0eebbac7e13b598a378210">spdk_nvme_reservation_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a reservation acquire to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the reservation acquire request. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to reservation acquire data. </td></tr>
    <tr><td class="paramname">ignore_key</td><td>'1' the current reservation key check is disabled. </td></tr>
    <tr><td class="paramname">action</td><td>Specifies the reservation acquire action. </td></tr>
    <tr><td class="paramname">type</td><td>Reservation type for the namespace. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if an nvme_request structure cannot be allocated for the I/O request, -ENXIO if the qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="ad5c140c47970bafbfec36bf6e4c37704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c140c47970bafbfec36bf6e4c37704">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_reservation_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_reservation_register </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__reservation__register__data.html">spdk_nvme_reservation_register_data</a> *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#a178a7468a0a9c3e814ca2ba80e3406e5">spdk_nvme_reservation_register_action</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#a05b2db4a398c119c029c234a68760c73">spdk_nvme_reservation_register_cptpl</a>&#160;</td>
          <td class="paramname"><em>cptpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a reservation register to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the reservation register request. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to the reservation register data. </td></tr>
    <tr><td class="paramname">ignore_key</td><td>'1' the current reservation key check is disabled. </td></tr>
    <tr><td class="paramname">action</td><td>Specifies the registration action. </td></tr>
    <tr><td class="paramname">cptpl</td><td>Change the Persist Through Power Loss state. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if an nvme_request structure cannot be allocated for the I/O request, -ENXIO if the qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="aa2b1d9de51027da9a66fe12e2ce28132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b1d9de51027da9a66fe12e2ce28132">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_reservation_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_reservation_release </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__reservation__key__data.html">spdk_nvme_reservation_key_data</a> *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#a6fa8ea66c4927d8bb4d81d76867e851a">spdk_nvme_reservation_release_action</a>&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvme__spec_8h.html#aa7e108757c0eebbac7e13b598a378210">spdk_nvme_reservation_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a reservation release to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the reservation release request. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to current reservation key. </td></tr>
    <tr><td class="paramname">ignore_key</td><td>'1' the current reservation key check is disabled. </td></tr>
    <tr><td class="paramname">action</td><td>Specifies the reservation release action. </td></tr>
    <tr><td class="paramname">type</td><td>Reservation type for the namespace. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if an nvme_request structure cannot be allocated for the I/O request, -ENXIO if the qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a9a7b5944bda3fe9ef1c83fcd2025b39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7b5944bda3fe9ef1c83fcd2025b39a">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_reservation_report()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_reservation_report </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a reservation report to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the reservation report request. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer for reservation status data. </td></tr>
    <tr><td class="paramname">len</td><td>Length bytes for reservation status data structure. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errno if an nvme_request structure cannot be allocated for the I/O request, -ENXIO if the qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a3065f669d8b605efdcadffbf94a50538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3065f669d8b605efdcadffbf94a50538">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_write </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to the data payload. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to write the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the write operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">spdk/nvme_spec.h</a>, for this I/O.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="ab2f23130b6ebdb7b3e4086545e422e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f23130b6ebdb7b3e4086545e422e59">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_write_uncorrectable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_write_uncorrectable </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write uncorrectable I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write uncorrectable I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA for this command. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the write uncorrectable operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="adc2aa2be0d657be0c63d5abc02b274ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2aa2be0d657be0c63d5abc02b274ec">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_write_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_write_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">payload</td><td>Virtual address pointer to the data payload. </td></tr>
    <tr><td class="paramname">metadata</td><td>Virtual address pointer to the metadata payload, the length of metadata is specified by <a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2" title="Get the metadata size, in bytes, of the given namespace. ">spdk_nvme_ns_get_md_size()</a>. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to write the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the write operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">spdk/nvme_spec.h</a>, for this I/O. </td></tr>
    <tr><td class="paramname">apptag_mask</td><td>Application tag mask. </td></tr>
    <tr><td class="paramname">apptag</td><td>Application tag to use end-to-end protection information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="af02e8c701c5496f163a69917ad5397dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02e8c701c5496f163a69917ad5397dd">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_write_zeroes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_write_zeroes </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write zeroes I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write zeroes I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA for this command. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the write zero operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined by the SPDK_NVME_IO_FLAGS_* entries in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">spdk/nvme_spec.h</a>, for this I/O.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="adfcbb5d31f0b572847cc8ae8b07dfcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcbb5d31f0b572847cc8ae8b07dfcfb">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_writev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_writev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write I/O. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request. </td></tr>
    <tr><td class="paramname">lba</td><td>Starting LBA to write the data. </td></tr>
    <tr><td class="paramname">lba_count</td><td>Length (in sectors) for the write operation. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to invoke when the I/O is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to the callback function. </td></tr>
    <tr><td class="paramname">io_flags</td><td>Set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">nvme_spec.h</a>, for this I/O. </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>Callback function to reset scattered payload. </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>Callback function to iterate each scattered payload memory segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="ab4d42660e3de76f75f4b5d79ed9b1d01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d42660e3de76f75f4b5d79ed9b1d01">&#9670;&nbsp;</a></span>spdk_nvme_ns_cmd_writev_with_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_ns_cmd_writev_with_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>lba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lba_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8">spdk_nvme_cmd_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>io_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a0e1fcb43970ea531567ee00d4ee0675b">spdk_nvme_req_reset_sgl_cb</a>&#160;</td>
          <td class="paramname"><em>reset_sgl_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a4ab95bea86f498c08510f6f0bcd2eb09">spdk_nvme_req_next_sge_cb</a>&#160;</td>
          <td class="paramname"><em>next_sge_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>apptag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write I/O to the specified NVMe namespace. </p>
<p>The command is submitted to a qpair allocated by <a class="el" href="nvme_8h.html#a13f745d239dab9b8f934fae2ad4984a2" title="Allocate an I/O queue pair (submission and completion queue). ">spdk_nvme_ctrlr_alloc_io_qpair()</a>. The user must ensure that only one thread submits I/O on a given qpair at any given time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>NVMe namespace to submit the write I/O </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to submit the request </td></tr>
    <tr><td class="paramname">lba</td><td>starting LBA to write the data </td></tr>
    <tr><td class="paramname">lba_count</td><td>length (in sectors) for the write operation </td></tr>
    <tr><td class="paramname">cb_fn</td><td>callback function to invoke when the I/O is completed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>argument to pass to the callback function </td></tr>
    <tr><td class="paramname">io_flags</td><td>set flags, defined in <a class="el" href="nvme__spec_8h.html" title="NVMe specification definitions. ">nvme_spec.h</a>, for this I/O </td></tr>
    <tr><td class="paramname">reset_sgl_fn</td><td>callback function to reset scattered payload </td></tr>
    <tr><td class="paramname">next_sge_fn</td><td>callback function to iterate each scattered payload memory segment </td></tr>
    <tr><td class="paramname">metadata</td><td>virtual address pointer to the metadata payload, the length of metadata is specified by <a class="el" href="nvme_8h.html#ab48657f8cb6561b35e1c1b0bc18376d2" title="Get the metadata size, in bytes, of the given namespace. ">spdk_nvme_ns_get_md_size()</a> </td></tr>
    <tr><td class="paramname">apptag_mask</td><td>application tag mask. </td></tr>
    <tr><td class="paramname">apptag</td><td>application tag to use end-to-end protection information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully submitted, negated errnos on the following error conditions: -EINVAL: The request is malformed. -ENOMEM: The request cannot be allocated. -ENXIO: The qpair is failed at the transport level. </dd></dl>

</div>
</div>
<a id="a2640aeebb82108e9b507dcccb1e564c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2640aeebb82108e9b507dcccb1e564c2">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_ctrlr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_ctrlr* spdk_nvme_ns_get_ctrlr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the controller with which this namespace is associated. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the controller. </dd></dl>

</div>
</div>
<a id="ab1863b5dccf2bcc49fe92275bc1e5a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1863b5dccf2bcc49fe92275bc1e5a2a">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__nvme__ns__data.html">spdk_nvme_ns_data</a>* spdk_nvme_ns_get_data </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the identify namespace data as defined by the NVMe specification. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the namespace data. </dd></dl>

</div>
</div>
<a id="a42040dca95489218417539d2c08d815e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42040dca95489218417539d2c08d815e">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_dealloc_logical_block_read_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvme__spec_8h.html#a1c06fbd66f7572c43c51e6f106215b8d">spdk_nvme_dealloc_logical_block_read_value</a> spdk_nvme_ns_get_dealloc_logical_block_read_value </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the value returned when reading deallocated blocks. </p>
<p>If deallocated blocks return 0, the deallocate command can be used as a more efficient alternative to the write_zeroes command, especially for large requests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logical block read value. </dd></dl>

</div>
</div>
<a id="a8f3f5c5a738dc7ad7e3b2913bff4324c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3f5c5a738dc7ad7e3b2913bff4324c">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_extended_sector_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_extended_sector_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the extended sector size, in bytes, of the given namespace. </p>
<p>This function returns the size of the data sector plus metadata.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<p>/return the extended sector size in bytes. </p>

</div>
</div>
<a id="a5eff1c1b6fbfb348a1f158b3cf70626f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eff1c1b6fbfb348a1f158b3cf70626f">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_flags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_flags </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the flags for the given namespace. </p>
<p>See spdk_nvme_ns_flags for the possible flags returned.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the flags for the given namespace. </dd></dl>

</div>
</div>
<a id="a54052303ef2870d6d1856f79ef6ff88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54052303ef2870d6d1856f79ef6ff88a">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_id </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the namespace id (index number) from the given namespace handle. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>namespace id. </dd></dl>

</div>
</div>
<a id="ac2aac85501f13bff557d3a224d8ec156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2aac85501f13bff557d3a224d8ec156">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_max_io_xfer_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_max_io_xfer_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum transfer size, in bytes, for an I/O sent to the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum transfer size in bytes. </dd></dl>

</div>
</div>
<a id="ab48657f8cb6561b35e1c1b0bc18376d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48657f8cb6561b35e1c1b0bc18376d2">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_md_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_md_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the metadata size, in bytes, of the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the metadata size of the given namespace in bytes. </dd></dl>

</div>
</div>
<a id="a7c522609f730db26f66e7f5b6b3501e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c522609f730db26f66e7f5b6b3501e0">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_num_sectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_nvme_ns_get_num_sectors </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of sectors for the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of sectors. </dd></dl>

</div>
</div>
<a id="af58edc3021f8adcbecce5d3ebc5b6789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58edc3021f8adcbecce5d3ebc5b6789">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_optimal_io_boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_optimal_io_boundary </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the optimal I/O boundary, in blocks, for the given namespace. </p>
<p>Read and write commands should not cross the optimal I/O boundary for best performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optimal granularity of I/O commands, in blocks, or 0 if no optimal granularity is reported. </dd></dl>

</div>
</div>
<a id="a85806a7605a104a705e7f9d3d087e4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85806a7605a104a705e7f9d3d087e4cb">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_pi_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum spdk_nvme_pi_type spdk_nvme_ns_get_pi_type </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the end-to-end data protection information type of the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end-to-end data protection information type. </dd></dl>

</div>
</div>
<a id="a0d24c0b2b0b2a22b0c0af2ca2e157e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d24c0b2b0b2a22b0c0af2ca2e157e04">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_sector_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvme_ns_get_sector_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sector size, in bytes, of the given namespace. </p>
<p>This function returns the size of the data sector only. It does not include metadata size.</p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<p>/return the sector size in bytes. </p>

</div>
</div>
<a id="a9e8fb1bbe066260faf305581e16dde86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8fb1bbe066260faf305581e16dde86">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_nvme_ns_get_size </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size, in bytes, of the given namespace. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the given namespace in bytes. </dd></dl>

</div>
</div>
<a id="a6c559063408299a4612fd2e62f97bc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c559063408299a4612fd2e62f97bc63">&#9670;&nbsp;</a></span>spdk_nvme_ns_get_uuid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__uuid.html">spdk_uuid</a>* spdk_nvme_ns_get_uuid </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the UUID for the given namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to namespace UUID, or NULL if ns does not have a UUID. </dd></dl>

</div>
</div>
<a id="af755eb3e5a5f767a5bdc544d85667898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af755eb3e5a5f767a5bdc544d85667898">&#9670;&nbsp;</a></span>spdk_nvme_ns_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ns_is_active </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a namespace is active. </p>
<p>Inactive namespaces cannot be the target of I/O commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if active, or false if inactive. </dd></dl>

</div>
</div>
<a id="aad367fec5a8963f5d930dfae485de6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad367fec5a8963f5d930dfae485de6b3">&#9670;&nbsp;</a></span>spdk_nvme_ns_supports_extended_lba()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_ns_supports_extended_lba </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether if the namespace can support extended LBA when end-to-end data protection enabled. </p>
<p>This function is thread safe and can be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the namespace can support extended LBA when end-to-end data protection enabled, or false otherwise. </dd></dl>

</div>
</div>
<a id="a0f14ec05ce3af11f089a79d47739bd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f14ec05ce3af11f089a79d47739bd74">&#9670;&nbsp;</a></span>spdk_nvme_prchk_flags_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_prchk_flags_parse </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>prchk_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the string representation of PI check settings (prchk:guard|reftag) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prchk_flags</td><td>Output PI check flags. </td></tr>
    <tr><td class="paramname">str</td><td>Input string representation of PI check settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if parsing was successful and prchk_flags is set, or negated errno values on failure. </dd></dl>

</div>
</div>
<a id="ae125f35c7ab6fd2f5e63bfac804f25e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae125f35c7ab6fd2f5e63bfac804f25e6">&#9670;&nbsp;</a></span>spdk_nvme_prchk_flags_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvme_prchk_flags_str </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>prchk_flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the string representation of PI check settings (prchk:guard|reftag) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prchk_flags</td><td>PI check flags to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>static string constant describing PI check settings. If prchk_flags is 0, NULL is returned. </dd></dl>

</div>
</div>
<a id="a225bbc386ec518ae21bd5536f21db45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225bbc386ec518ae21bd5536f21db45d">&#9670;&nbsp;</a></span>spdk_nvme_probe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_probe </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a95f40d5179f8424b466a30ba0610ab4c">spdk_nvme_probe_cb</a>&#160;</td>
          <td class="paramname"><em>probe_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a>&#160;</td>
          <td class="paramname"><em>attach_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a>&#160;</td>
          <td class="paramname"><em>remove_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device found if desired. </p>
<p>This function is not thread safe and should only be called from one thread at a time while no other threads are actively using any NVMe devices.</p>
<p>If called from a secondary process, only devices that have been attached to the userspace driver in the primary process will be probed.</p>
<p>If called more than once, only devices that are not already attached to the SPDK NVMe driver will be reported.</p>
<p>To stop using the the controller and release its associated resources, call <a class="el" href="nvme_8h.html#a4b63c225c3cce6da60fdbfb6f54b11e2" title="Detach specified device returned by spdk_nvme_probe()&#39;s attach_cb from the NVMe driver. ">spdk_nvme_detach()</a> with the spdk_nvme_ctrlr instance from the attach_cb() function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid</td><td>The transport ID indicating which bus to enumerate. If the trtype is PCIe or trid is NULL, this will scan the local PCIe bus. If the trtype is RDMA, the traddr and trsvcid must point at the location of an NVMe-oF discovery service. </td></tr>
    <tr><td class="paramname">cb_ctx</td><td>Opaque value which will be passed back in cb_ctx parameter of the callbacks. </td></tr>
    <tr><td class="paramname">probe_cb</td><td>will be called once per NVMe device found in the system. </td></tr>
    <tr><td class="paramname">attach_cb</td><td>will be called for devices for which probe_cb returned true once that NVMe controller has been attached to the userspace driver. </td></tr>
    <tr><td class="paramname">remove_cb</td><td>will be called for devices that were attached in a previous <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> call but are no longer attached to the system. Optional; specify NULL if removal notices are not desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a02411bf7ae4827a350711e688316997e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02411bf7ae4827a350711e688316997e">&#9670;&nbsp;</a></span>spdk_nvme_probe_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvme_probe_ctx* spdk_nvme_probe_async </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a95f40d5179f8424b466a30ba0610ab4c">spdk_nvme_probe_cb</a>&#160;</td>
          <td class="paramname"><em>probe_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#ac1eaa795f075495337b270667661ce5d">spdk_nvme_attach_cb</a>&#160;</td>
          <td class="paramname"><em>attach_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvme_8h.html#a05f1aa545be57a03bb2dd0c6180172b6">spdk_nvme_remove_cb</a>&#160;</td>
          <td class="paramname"><em>remove_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Probe and add controllers to the probe context list. </p>
<p>Users must call <a class="el" href="nvme_8h.html#aedea919a47bdd811b604656e29e3fcef" title="Start controllers in the context list. ">spdk_nvme_probe_poll_async()</a> to initialize controllers in the probe context list to the READY state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid</td><td>The transport ID indicating which bus to enumerate. If the trtype is PCIe or trid is NULL, this will scan the local PCIe bus. If the trtype is RDMA, the traddr and trsvcid must point at the location of an NVMe-oF discovery service. </td></tr>
    <tr><td class="paramname">cb_ctx</td><td>Opaque value which will be passed back in cb_ctx parameter of the callbacks. </td></tr>
    <tr><td class="paramname">probe_cb</td><td>will be called once per NVMe device found in the system. </td></tr>
    <tr><td class="paramname">attach_cb</td><td>will be called for devices for which probe_cb returned true once that NVMe controller has been attached to the userspace driver. </td></tr>
    <tr><td class="paramname">remove_cb</td><td>will be called for devices that were attached in a previous <a class="el" href="nvme_8h.html#a225bbc386ec518ae21bd5536f21db45d" title="Enumerate the bus indicated by the transport ID and attach the userspace NVMe driver to each device f...">spdk_nvme_probe()</a> call but are no longer attached to the system. Optional; specify NULL if removal notices are not desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>probe context on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="aedea919a47bdd811b604656e29e3fcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedea919a47bdd811b604656e29e3fcef">&#9670;&nbsp;</a></span>spdk_nvme_probe_poll_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_probe_poll_async </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_probe_ctx *&#160;</td>
          <td class="paramname"><em>probe_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start controllers in the context list. </p>
<p>Users may call the function util it returns True.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">probe_ctx</td><td>Context used to track probe actions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if all probe operations are complete; the probe_ctx is also freed and no longer valid. </dd>
<dd>
-EAGAIN if there are still pending probe operations; user must call spdk_nvme_probe_poll_async again to continue progress. </dd>
<dd>
value other than 0 and -EAGAIN probe error with one controller. </dd></dl>

</div>
</div>
<a id="acf6188764b8c71b2f64a74077d6bfabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6188764b8c71b2f64a74077d6bfabf">&#9670;&nbsp;</a></span>spdk_nvme_qpair_add_cmd_error_injection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_qpair_add_cmd_error_injection </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>opc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_not_submit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>timeout_in_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>err_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject an error for the next request with a given opcode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to add the error command, NULL for Admin queue pair. </td></tr>
    <tr><td class="paramname">opc</td><td>Opcode for Admin or I/O commands. </td></tr>
    <tr><td class="paramname">do_not_submit</td><td>True if matching requests should not be submitted to the controller, but instead completed manually after timeout_in_us has expired. False if matching requests should be submitted to the controller and have their completion status modified after the controller completes the request. </td></tr>
    <tr><td class="paramname">timeout_in_us</td><td>Wait specified microseconds when do_not_submit is true. </td></tr>
    <tr><td class="paramname">err_count</td><td>Number of matching requests to inject errors. </td></tr>
    <tr><td class="paramname">sct</td><td>Status code type. </td></tr>
    <tr><td class="paramname">sc</td><td>Status code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successfully enabled, ENOMEM if an error command structure cannot be allocated.</dd></dl>
<p>The function can be called multiple times to inject errors for different commands. If the opcode matches an existing entry, the existing entry will be updated with the values specified. </p>

</div>
</div>
<a id="ac06275147a2cbb800440686b8ba9a73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06275147a2cbb800440686b8ba9a73b">&#9670;&nbsp;</a></span>spdk_nvme_qpair_print_command()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_qpair_print_command </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints (SPDK_NOTICELOG) the contents of an NVMe submission queue entry (command). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>Pointer to the NVMe queue pair - used to determine admin versus I/O queue. </td></tr>
    <tr><td class="paramname">cmd</td><td>Pointer to the submission queue command to be formatted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4b2335194f9c4c24a5e2c15a9432f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b2335194f9c4c24a5e2c15a9432f4a">&#9670;&nbsp;</a></span>spdk_nvme_qpair_print_completion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_qpair_print_completion </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__cpl.html">spdk_nvme_cpl</a> *&#160;</td>
          <td class="paramname"><em>cpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints (SPDK_NOTICELOG) the contents of an NVMe completion queue entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>Pointer to the NVMe queue pair - presently unused. </td></tr>
    <tr><td class="paramname">cpl</td><td>Pointer to the completion queue element to be formatted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa331d140870e977722bfbb6826524782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa331d140870e977722bfbb6826524782">&#9670;&nbsp;</a></span>spdk_nvme_qpair_process_completions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t spdk_nvme_qpair_process_completions </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_completions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process any outstanding completions for I/O submitted on a queue pair. </p>
<p>This call is non-blocking, i.e. it only processes completions that are ready at the time of this function call. It does not wait for outstanding commands to finish.</p>
<p>For each completed command, the request's callback function will be called if specified as non-NULL when the request was submitted.</p>
<p>The caller must ensure that each queue pair is only used from one thread at a time.</p>
<p>This function may be called at any point while the controller is attached to the SPDK NVMe driver.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="nvme_8h.html#ac9779e9957d7089dde8e492cc60856d8" title="Signature for callback function invoked when a command is completed. ">spdk_nvme_cmd_cb</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>Queue pair to check for completions. </td></tr>
    <tr><td class="paramname">max_completions</td><td>Limit the number of completions to be processed in one call, or 0 for unlimited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of completions processed (may be 0) or negated on error. -ENXIO in the special case that the qpair is failed at the transport layer. </dd></dl>

</div>
</div>
<a id="ad720b23786450b5a2b2d7d65c6dd6b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad720b23786450b5a2b2d7d65c6dd6b7c">&#9670;&nbsp;</a></span>spdk_nvme_qpair_remove_cmd_error_injection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_qpair_remove_cmd_error_injection </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvme_ctrlr *&#160;</td>
          <td class="paramname"><em>ctrlr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvme_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>opc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the specified NVMe command with error status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctrlr</td><td>NVMe controller. </td></tr>
    <tr><td class="paramname">qpair</td><td>I/O queue pair to remove the error command, \ NULL for Admin queue pair. </td></tr>
    <tr><td class="paramname">opc</td><td>Opcode for Admin or I/O commands.</td></tr>
  </table>
  </dd>
</dl>
<p>The function will remove specified command in the error list. </p>

</div>
</div>
<a id="a82cdb425c9fad7b94ad0b8f5c27bb8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cdb425c9fad7b94ad0b8f5c27bb8b2">&#9670;&nbsp;</a></span>spdk_nvme_rdma_init_hooks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvme_rdma_init_hooks </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__rdma__hooks.html">spdk_nvme_rdma_hooks</a> *&#160;</td>
          <td class="paramname"><em>hooks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global hooks for the RDMA transport, if necessary. </p>
<p>This call is optional and must be performed prior to probing for any devices. By default, the RDMA transport will use the ibverbs library to create protection domains and register memory. This is a mechanism to subvert that and use an existing registration.</p>
<p>This function may only be called one time per process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hooks</td><td>for initializing global hooks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5735e7600f79c45871b3dc3adb292f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5735e7600f79c45871b3dc3adb292f2">&#9670;&nbsp;</a></span>spdk_nvme_transport_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvme_transport_available </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a>&#160;</td>
          <td class="paramname"><em>trtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the NVMe library can handle a specific NVMe over Fabrics transport type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trtype</td><td>NVMe over Fabrics transport type to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if trtype is supported or false if it is not supported. </dd></dl>

</div>
</div>
<a id="afb95c5452e84e2c5c1984341fc816ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb95c5452e84e2c5c1984341fc816ea7">&#9670;&nbsp;</a></span>spdk_nvme_transport_id_adrfam_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvme_transport_id_adrfam_str </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="nvmf__spec_8h.html#a08f0090d242e2607ab11f148dcd797c6">spdk_nvmf_adrfam</a>&#160;</td>
          <td class="paramname"><em>adrfam</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the string representation of a transport ID address family. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adrfam</td><td>Address family to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>static string constant describing adrfam, or NULL if adrmfam not found. </dd></dl>

</div>
</div>
<a id="a9878deb91f677a9a9583342f07dcef41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9878deb91f677a9a9583342f07dcef41">&#9670;&nbsp;</a></span>spdk_nvme_transport_id_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_transport_id_compare </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two transport IDs. </p>
<p>The result of this function may be used to sort transport IDs in a consistent order; however, the comparison result is not guaranteed to be consistent across library versions.</p>
<p>This function uses a case-insensitive comparison for string fields, but it does not otherwise normalize the transport ID. It is the caller's responsibility to provide the transport IDs in a consistent format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid1</td><td>First transport ID to compare. </td></tr>
    <tr><td class="paramname">trid2</td><td>Second transport ID to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if trid1 == trid2, less than 0 if trid1 &lt; trid2, greater than 0 if trid1 &gt; trid2. </dd></dl>

</div>
</div>
<a id="ac37484cc5d14777e4ae1fde031d0edf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37484cc5d14777e4ae1fde031d0edf2">&#9670;&nbsp;</a></span>spdk_nvme_transport_id_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_transport_id_parse </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the string representation of a transport ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trid</td><td>Output transport ID structure (must be allocated and initialized by caller). </td></tr>
    <tr><td class="paramname">str</td><td>Input string representation of a transport ID to parse.</td></tr>
  </table>
  </dd>
</dl>
<p>str must be a zero-terminated C string containing one or more key:value pairs separated by whitespace.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Key  </th><th class="markdownTableHeadNone">Value   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">trtype  </td><td class="markdownTableBodyNone">Transport type (e.g. PCIe, RDMA)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">adrfam  </td><td class="markdownTableBodyNone">Address family (e.g. IPv4, IPv6)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">traddr  </td><td class="markdownTableBodyNone">Transport address (e.g. 0000:04:00.0 for PCIe, 192.168.100.8 for RDMA, or WWN for FC)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">trsvcid  </td><td class="markdownTableBodyNone">Transport service identifier (e.g. 4420)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">subnqn  </td><td class="markdownTableBodyNone">Subsystem NQN   </td></tr>
</table>
<p>Unspecified fields of trid are left unmodified, so the caller must initialize trid (for example, memset() to 0) before calling this function.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if parsing was successful and trid is filled out, or negated errno values on failure. </dd></dl>

</div>
</div>
<a id="af7868a6f646a6d1bd70d5c1b8ce5757f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7868a6f646a6d1bd70d5c1b8ce5757f">&#9670;&nbsp;</a></span>spdk_nvme_transport_id_parse_adrfam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_transport_id_parse_adrfam </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="nvmf__spec_8h.html#a08f0090d242e2607ab11f148dcd797c6">spdk_nvmf_adrfam</a> *&#160;</td>
          <td class="paramname"><em>adrfam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the string representation of a tranport ID address family. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adrfam</td><td>Output address family (allocated by caller). </td></tr>
    <tr><td class="paramname">str</td><td>Input string representation of address family (e.g. "IPv4", "IPv6").</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if parsing was successful and adrfam is filled out, or negated errno values on failure. </dd></dl>

</div>
</div>
<a id="ab2afed1cce9d9334dfd127db416ada4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2afed1cce9d9334dfd127db416ada4c">&#9670;&nbsp;</a></span>spdk_nvme_transport_id_parse_trtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvme_transport_id_parse_trtype </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a> *&#160;</td>
          <td class="paramname"><em>trtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the string representation of a transport ID tranport type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trtype</td><td>Output transport type (allocated by caller). </td></tr>
    <tr><td class="paramname">str</td><td>Input string representation of transport type (e.g. "PCIe", "RDMA").</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if parsing was successful and trtype is filled out, or negated errno values on failure. </dd></dl>

</div>
</div>
<a id="aa3a982eb5b757eae63fbc9305627090b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a982eb5b757eae63fbc9305627090b">&#9670;&nbsp;</a></span>spdk_nvme_transport_id_trtype_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvme_transport_id_trtype_str </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="nvme_8h.html#ae87a03c28984a2c0499d50ef5e9d0ece">spdk_nvme_transport_type</a>&#160;</td>
          <td class="paramname"><em>trtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the string representation of a transport ID transport type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trtype</td><td>Transport type to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>static string constant describing trtype, or NULL if trtype not found. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
