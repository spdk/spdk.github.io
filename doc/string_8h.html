<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Doxygen 1.10.0" />
	<title>SPDK: string.h File Reference</title>
	<script src="https://code.jquery.com/jquery-3.7.1.slim.min.js" integrity="sha256-kmHvs0B+OpCW5GVHUNjv9rOmY0IvSIRcf7zGUDTDQM8=" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.11.8/umd/popper.min.js" integrity="sha512-TPh2Oxlg1zp+kz3nFA0C5vVC6leG/6mm1z9+mA81MI5eaUVqasPLO8Cuk4gMF4gUfP5etR73rgU/8PNMsSesoQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js" integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+" crossorigin="anonymous"></script>
	<script type="text/javascript" src="../js/doxyboot.js"></script>
	<script type="text/javascript">
		$( document ).ready(function() {
			$("#cn_lang_btn").remove();
		});
	</script>
	<script type="text/javascript" src="./navtree.js"></script>
	<link rel="stylesheet" href='https://fonts.googleapis.com/css?family=Roboto:400,900' type='text/css'>
	<link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
	<link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
  <body>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <a class="navbar-brand" href="/" aria-label="SPDK">
    <img src="../img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
  </a>
  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <div class="navbar-nav me-auto">
      <a class="nav-link header-link"
      href="../releases/">
        download
      </a>
      <a class="nav-link header-link active text-white"
      href="/doc/">
        documentation
      </a>
      <a class="nav-link header-link"
      href="../development/">
        development
      </a>
      <a class="nav-link header-link"
      href="/ci/">
        CI status
      </a>
      <a class="nav-link header-link"
      href="../community/">
        community
      </a>
      <a class="nav-link header-link"
      href="../blog/">
        Blog
      </a>
      <a class="nav-link header-link"
      href="https://github.com/orgs/spdk/projects/5">
        Roadmap
      </a>
      <a class="nav-link header-link"
      href="../news/">
        News
      </a>
    </div>
    <div class="navbar-nav ms-auto me-3">
      <a class="nav-link header-link" href="https://github.com/spdk/spdk">
        <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
      </a>
      <a id="cn_lang_btn" href="/cn/doc/" class="nav-link header-link">中文</a>
    </div>
  </div>
</nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('string_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">string.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>String utility functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0ce6745ea1aacd2b5052a4d9ba103ef4" id="r_a0ce6745ea1aacd2b5052a4d9ba103ef4"><td class="memItemLeft" align="right" valign="top"><a id="a0ce6745ea1aacd2b5052a4d9ba103ef4" name="a0ce6745ea1aacd2b5052a4d9ba103ef4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_SPDK_STRINGIFY</b>(x)&#160;&#160;&#160;#x</td></tr>
<tr class="separator:a0ce6745ea1aacd2b5052a4d9ba103ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e174093ff2b6d904a0f1fa6c38f58e9" id="r_a9e174093ff2b6d904a0f1fa6c38f58e9"><td class="memItemLeft" align="right" valign="top"><a id="a9e174093ff2b6d904a0f1fa6c38f58e9" name="a9e174093ff2b6d904a0f1fa6c38f58e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STRINGIFY</b>(x)&#160;&#160;&#160;_SPDK_STRINGIFY(x)</td></tr>
<tr class="separator:a9e174093ff2b6d904a0f1fa6c38f58e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7446fbf244d70a29528f29b8bc33e840" id="r_a7446fbf244d70a29528f29b8bc33e840"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7446fbf244d70a29528f29b8bc33e840">spdk_sprintf_alloc</a> (const char *format,...)</td></tr>
<tr class="memdesc:a7446fbf244d70a29528f29b8bc33e840"><td class="mdescLeft">&#160;</td><td class="mdescRight">sprintf with automatic buffer allocation.  <br /></td></tr>
<tr class="separator:a7446fbf244d70a29528f29b8bc33e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de2829c1b25b13e37b05f1f7ef94c6b" id="r_a6de2829c1b25b13e37b05f1f7ef94c6b"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6de2829c1b25b13e37b05f1f7ef94c6b">spdk_vsprintf_alloc</a> (const char *format, va_list args)</td></tr>
<tr class="memdesc:a6de2829c1b25b13e37b05f1f7ef94c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">vsprintf with automatic buffer allocation.  <br /></td></tr>
<tr class="separator:a6de2829c1b25b13e37b05f1f7ef94c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae72f13c37106d4b024fd325419366f" id="r_adae72f13c37106d4b024fd325419366f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adae72f13c37106d4b024fd325419366f">spdk_sprintf_append_realloc</a> (char *buffer, const char *format,...)</td></tr>
<tr class="memdesc:adae72f13c37106d4b024fd325419366f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append string using vsprintf with automatic buffer re-allocation.  <br /></td></tr>
<tr class="separator:adae72f13c37106d4b024fd325419366f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca8e284c424ab309e3b182fc5b3cc5e" id="r_a7ca8e284c424ab309e3b182fc5b3cc5e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ca8e284c424ab309e3b182fc5b3cc5e">spdk_vsprintf_append_realloc</a> (char *buffer, const char *format, va_list args)</td></tr>
<tr class="memdesc:a7ca8e284c424ab309e3b182fc5b3cc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append string using vsprintf with automatic buffer re-allocation.  <br /></td></tr>
<tr class="separator:a7ca8e284c424ab309e3b182fc5b3cc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14114d7ce2c1b0c42e90cb80c8409e12" id="r_a14114d7ce2c1b0c42e90cb80c8409e12"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14114d7ce2c1b0c42e90cb80c8409e12">spdk_strlwr</a> (char *s)</td></tr>
<tr class="memdesc:a14114d7ce2c1b0c42e90cb80c8409e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to lowercase in place.  <br /></td></tr>
<tr class="separator:a14114d7ce2c1b0c42e90cb80c8409e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88825738518f071e2406694ae5968e50" id="r_a88825738518f071e2406694ae5968e50"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88825738518f071e2406694ae5968e50">spdk_strsepq</a> (char **stringp, const char *delim)</td></tr>
<tr class="memdesc:a88825738518f071e2406694ae5968e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a delimited string with quote handling.  <br /></td></tr>
<tr class="separator:a88825738518f071e2406694ae5968e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99a3144c835406e0845c601b71ab5bf" id="r_ad99a3144c835406e0845c601b71ab5bf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad99a3144c835406e0845c601b71ab5bf">spdk_str_trim</a> (char *s)</td></tr>
<tr class="memdesc:ad99a3144c835406e0845c601b71ab5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim whitespace from a string in place.  <br /></td></tr>
<tr class="separator:ad99a3144c835406e0845c601b71ab5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306d9e4d639bd6b6424eddc02324f0a2" id="r_a306d9e4d639bd6b6424eddc02324f0a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a306d9e4d639bd6b6424eddc02324f0a2">spdk_strerror_r</a> (int errnum, char *buf, size_t buflen)</td></tr>
<tr class="memdesc:a306d9e4d639bd6b6424eddc02324f0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the string version of an error into the user supplied buffer.  <br /></td></tr>
<tr class="separator:a306d9e4d639bd6b6424eddc02324f0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5ce3fff788d26168203840903d6613" id="r_abb5ce3fff788d26168203840903d6613"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb5ce3fff788d26168203840903d6613">spdk_strerror</a> (int errnum)</td></tr>
<tr class="memdesc:abb5ce3fff788d26168203840903d6613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the string version of an error from a static, thread-local buffer.  <br /></td></tr>
<tr class="separator:abb5ce3fff788d26168203840903d6613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713ec7967f4c2c3cb8c031421edee78a" id="r_a713ec7967f4c2c3cb8c031421edee78a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a713ec7967f4c2c3cb8c031421edee78a">spdk_str_chomp</a> (char *s)</td></tr>
<tr class="memdesc:a713ec7967f4c2c3cb8c031421edee78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove trailing newlines from the end of a string in place.  <br /></td></tr>
<tr class="separator:a713ec7967f4c2c3cb8c031421edee78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa333ebed7fc3529d446f819b647e2d88" id="r_aa333ebed7fc3529d446f819b647e2d88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa333ebed7fc3529d446f819b647e2d88">spdk_strcpy_pad</a> (void *dst, const char *src, size_t size, int pad)</td></tr>
<tr class="memdesc:aa333ebed7fc3529d446f819b647e2d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string into a fixed-size buffer, padding extra bytes with a specific character.  <br /></td></tr>
<tr class="separator:aa333ebed7fc3529d446f819b647e2d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8f770428a60f0d2836d479c4b1b4e7" id="r_a3c8f770428a60f0d2836d479c4b1b4e7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c8f770428a60f0d2836d479c4b1b4e7">spdk_strlen_pad</a> (const void *str, size_t size, int pad)</td></tr>
<tr class="memdesc:a3c8f770428a60f0d2836d479c4b1b4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the length of a string that has been padded with a specific byte.  <br /></td></tr>
<tr class="separator:a3c8f770428a60f0d2836d479c4b1b4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48498f237af5f5c25ca7cbca5300e12" id="r_ad48498f237af5f5c25ca7cbca5300e12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad48498f237af5f5c25ca7cbca5300e12">spdk_parse_ip_addr</a> (char *ip, char **host, char **port)</td></tr>
<tr class="memdesc:ad48498f237af5f5c25ca7cbca5300e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an IP address into its hostname and port components.  <br /></td></tr>
<tr class="separator:ad48498f237af5f5c25ca7cbca5300e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81c3a52c60c7390e54437dc5856996b" id="r_ab81c3a52c60c7390e54437dc5856996b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab81c3a52c60c7390e54437dc5856996b">spdk_parse_capacity</a> (const char *cap_str, uint64_t *cap, bool *has_prefix)</td></tr>
<tr class="memdesc:ab81c3a52c60c7390e54437dc5856996b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string representing a number possibly followed by a binary prefix.  <br /></td></tr>
<tr class="separator:ab81c3a52c60c7390e54437dc5856996b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae013400d8f031493f284ed3b614357e0" id="r_ae013400d8f031493f284ed3b614357e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae013400d8f031493f284ed3b614357e0">spdk_mem_all_zero</a> (const void *data, size_t size)</td></tr>
<tr class="memdesc:ae013400d8f031493f284ed3b614357e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a buffer is all zero (0x00) bytes or not.  <br /></td></tr>
<tr class="separator:ae013400d8f031493f284ed3b614357e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12420e9e2ab3af9d14e518245691c15" id="r_ae12420e9e2ab3af9d14e518245691c15"><td class="memItemLeft" align="right" valign="top">long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae12420e9e2ab3af9d14e518245691c15">spdk_strtol</a> (const char *nptr, int base)</td></tr>
<tr class="memdesc:ae12420e9e2ab3af9d14e518245691c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the string in nptr to a long integer value according to the given base.  <br /></td></tr>
<tr class="separator:ae12420e9e2ab3af9d14e518245691c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317132c2abb23a53dc3d53846689e2b6" id="r_a317132c2abb23a53dc3d53846689e2b6"><td class="memItemLeft" align="right" valign="top">long long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a317132c2abb23a53dc3d53846689e2b6">spdk_strtoll</a> (const char *nptr, int base)</td></tr>
<tr class="memdesc:a317132c2abb23a53dc3d53846689e2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the string in nptr to a long long integer value according to the given base.  <br /></td></tr>
<tr class="separator:a317132c2abb23a53dc3d53846689e2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cddd40e61b0e1c966f5cfef0513800" id="r_aa6cddd40e61b0e1c966f5cfef0513800"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6cddd40e61b0e1c966f5cfef0513800">spdk_strarray_from_string</a> (const char *str, const char *delim)</td></tr>
<tr class="memdesc:aa6cddd40e61b0e1c966f5cfef0513800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a NULL-terminated array of strings from the given string separated by the given chars in delim, as if split by strpbrk().  <br /></td></tr>
<tr class="separator:aa6cddd40e61b0e1c966f5cfef0513800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52f3eab11701a6eaed0635ce0983690" id="r_aa52f3eab11701a6eaed0635ce0983690"><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa52f3eab11701a6eaed0635ce0983690">spdk_strarray_dup</a> (const char **strarray)</td></tr>
<tr class="memdesc:aa52f3eab11701a6eaed0635ce0983690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a NULL-terminated array of strings.  <br /></td></tr>
<tr class="separator:aa52f3eab11701a6eaed0635ce0983690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204f9062adca879642296b993293fd04" id="r_a204f9062adca879642296b993293fd04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a204f9062adca879642296b993293fd04">spdk_strarray_free</a> (char **strarray)</td></tr>
<tr class="memdesc:a204f9062adca879642296b993293fd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a NULL-terminated array of strings.  <br /></td></tr>
<tr class="separator:a204f9062adca879642296b993293fd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2409f826e23aea462d0362d0bf45b7f5" id="r_a2409f826e23aea462d0362d0bf45b7f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2409f826e23aea462d0362d0bf45b7f5">spdk_strcpy_replace</a> (char *dst, size_t size, const char *src, const char *search, const char *replace)</td></tr>
<tr class="memdesc:a2409f826e23aea462d0362d0bf45b7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string into a fixed-size buffer with all occurrences of the search string replaced with the given replace substring.  <br /></td></tr>
<tr class="separator:a2409f826e23aea462d0362d0bf45b7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>String utility functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae013400d8f031493f284ed3b614357e0" name="ae013400d8f031493f284ed3b614357e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae013400d8f031493f284ed3b614357e0">&#9670;&#160;</a></span>spdk_mem_all_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_mem_all_zero </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a buffer is all zero (0x00) bytes or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Buffer to check. </td></tr>
    <tr><td class="paramname">size</td><td>Size of data in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data consists entirely of zeroes, or false if any byte in data is not zero. </dd></dl>

</div>
</div>
<a id="ab81c3a52c60c7390e54437dc5856996b" name="ab81c3a52c60c7390e54437dc5856996b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab81c3a52c60c7390e54437dc5856996b">&#9670;&#160;</a></span>spdk_parse_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_parse_capacity </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>cap_str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>cap</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>has_prefix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a string representing a number possibly followed by a binary prefix. </p>
<p>The string can contain a trailing "B" (KB,MB,GB) but it's not necessary. "128K" = 128 * 1024; "2G" = 2 * 1024 * 1024; "2GB" = 2 * 1024 * 1024; Additionally, lowercase "k", "m", "g" are parsed as well. They are processed the same as their uppercase equivalents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cap_str</td><td>Null terminated string. </td></tr>
    <tr><td class="paramname">cap</td><td>Pointer where the parsed capacity (in bytes) will be put. </td></tr>
    <tr><td class="paramname">has_prefix</td><td>Pointer to a flag that will be set to describe whether given string contains a binary prefix (optional).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negative errno on failure. </dd></dl>

</div>
</div>
<a id="ad48498f237af5f5c25ca7cbca5300e12" name="ad48498f237af5f5c25ca7cbca5300e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48498f237af5f5c25ca7cbca5300e12">&#9670;&#160;</a></span>spdk_parse_ip_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_parse_ip_addr </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>ip</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>host</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>port</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an IP address into its hostname and port components. </p>
<p>This modifies the IP address in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip</td><td>A null terminated IP address, including port. Both IPv4 and IPv6 are supported. </td></tr>
    <tr><td class="paramname">host</td><td>Will point to the start of the hostname within ip. The string will be null terminated. </td></tr>
    <tr><td class="paramname">port</td><td>Will point to the start of the port within ip. The string will be null terminated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. -EINVAL on failure. </dd></dl>

</div>
</div>
<a id="a7446fbf244d70a29528f29b8bc33e840" name="a7446fbf244d70a29528f29b8bc33e840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7446fbf244d70a29528f29b8bc33e840">&#9670;&#160;</a></span>spdk_sprintf_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * spdk_sprintf_alloc </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sprintf with automatic buffer allocation. </p>
<p>The return value is the formatted string, which should be passed to free() when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Format for the string to print.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the formatted string on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="adae72f13c37106d4b024fd325419366f" name="adae72f13c37106d4b024fd325419366f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae72f13c37106d4b024fd325419366f">&#9670;&#160;</a></span>spdk_sprintf_append_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * spdk_sprintf_append_realloc </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append string using vsprintf with automatic buffer re-allocation. </p>
<p>The return value is the formatted string, in which the original string in buffer is unchanged and the specified formatted string is appended.</p>
<p>The returned string should be passed to free() when no longer needed.</p>
<p>If buffer is NULL, the call is equivalent to <a class="el" href="#a7446fbf244d70a29528f29b8bc33e840" title="sprintf with automatic buffer allocation.">spdk_sprintf_alloc()</a>. If the call fails, the original buffer is left untouched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer which has a formatted string. </td></tr>
    <tr><td class="paramname">format</td><td>Format for the string to print.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the formatted string on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a713ec7967f4c2c3cb8c031421edee78a" name="a713ec7967f4c2c3cb8c031421edee78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713ec7967f4c2c3cb8c031421edee78a">&#9670;&#160;</a></span>spdk_str_chomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_str_chomp </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove trailing newlines from the end of a string in place. </p>
<p>Any sequence of trailing \r and \n characters is removed from the end of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to remove newline from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of characters removed. </dd></dl>

</div>
</div>
<a id="ad99a3144c835406e0845c601b71ab5bf" name="ad99a3144c835406e0845c601b71ab5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99a3144c835406e0845c601b71ab5bf">&#9670;&#160;</a></span>spdk_str_trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * spdk_str_trim </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trim whitespace from a string in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to trim.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the trimmed string. </dd></dl>

</div>
</div>
<a id="aa52f3eab11701a6eaed0635ce0983690" name="aa52f3eab11701a6eaed0635ce0983690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa52f3eab11701a6eaed0635ce0983690">&#9670;&#160;</a></span>spdk_strarray_dup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** spdk_strarray_dup </td>
          <td>(</td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>strarray</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a NULL-terminated array of strings. </p>
<p>Returns NULL on failure. The array, and the strings, are allocated with the standard allocator (e.g. calloc()).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strarray</td><td>input array of strings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a204f9062adca879642296b993293fd04" name="a204f9062adca879642296b993293fd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204f9062adca879642296b993293fd04">&#9670;&#160;</a></span>spdk_strarray_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_strarray_free </td>
          <td>(</td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>strarray</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a NULL-terminated array of strings. </p>
<p>The array and its strings must have been allocated with the standard allocator (calloc() etc.).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strarray</td><td>array of strings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6cddd40e61b0e1c966f5cfef0513800" name="aa6cddd40e61b0e1c966f5cfef0513800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6cddd40e61b0e1c966f5cfef0513800">&#9670;&#160;</a></span>spdk_strarray_from_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ** spdk_strarray_from_string </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>delim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a NULL-terminated array of strings from the given string separated by the given chars in delim, as if split by strpbrk(). </p>
<p>Empty items are pointers to an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Input string </td></tr>
    <tr><td class="paramname">delim</td><td>Separating delimiter set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string array, or NULL on failure. </dd></dl>

</div>
</div>
<a id="aa333ebed7fc3529d446f819b647e2d88" name="aa333ebed7fc3529d446f819b647e2d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa333ebed7fc3529d446f819b647e2d88">&#9670;&#160;</a></span>spdk_strcpy_pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_strcpy_pad </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pad</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string into a fixed-size buffer, padding extra bytes with a specific character. </p>
<p>If src is longer than size, only size bytes will be copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Pointer to destination fixed-size buffer to fill. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to source null-terminated string to copy into dst. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to fill in dst. </td></tr>
    <tr><td class="paramname">pad</td><td>Character to pad extra space in dst beyond the size of src. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2409f826e23aea462d0362d0bf45b7f5" name="a2409f826e23aea462d0362d0bf45b7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2409f826e23aea462d0362d0bf45b7f5">&#9670;&#160;</a></span>spdk_strcpy_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_strcpy_replace </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dst</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>search</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>replace</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a string into a fixed-size buffer with all occurrences of the search string replaced with the given replace substring. </p>
<p>The fixed-size buffer must not be less than the string with the replaced values including the terminating null byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Pointer to destination fixed-size buffer to fill. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the destination fixed-size buffer in bytes. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to source null-terminated string to copy into dst. </td></tr>
    <tr><td class="paramname">search</td><td>The string being searched for. </td></tr>
    <tr><td class="paramname">replace</td><td>the replacement substring the replaces the found search substring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno on failure. </dd></dl>

</div>
</div>
<a id="abb5ce3fff788d26168203840903d6613" name="abb5ce3fff788d26168203840903d6613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5ce3fff788d26168203840903d6613">&#9670;&#160;</a></span>spdk_strerror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_strerror </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>errnum</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the string version of an error from a static, thread-local buffer. </p>
<p>This function is thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errnum</td><td>Error code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to buffer upon success. </dd></dl>

</div>
</div>
<a id="a306d9e4d639bd6b6424eddc02324f0a2" name="a306d9e4d639bd6b6424eddc02324f0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306d9e4d639bd6b6424eddc02324f0a2">&#9670;&#160;</a></span>spdk_strerror_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_strerror_r </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>errnum</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>buflen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the string version of an error into the user supplied buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errnum</td><td>Error code. </td></tr>
    <tr><td class="paramname">buf</td><td>Pointer to a buffer in which to place the error message. </td></tr>
    <tr><td class="paramname">buflen</td><td>The size of the buffer in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c8f770428a60f0d2836d479c4b1b4e7" name="a3c8f770428a60f0d2836d479c4b1b4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8f770428a60f0d2836d479c4b1b4e7">&#9670;&#160;</a></span>spdk_strlen_pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_strlen_pad </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pad</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the length of a string that has been padded with a specific byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Right-padded string to find the length of. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the full string pointed to by str, including padding. </td></tr>
    <tr><td class="paramname">pad</td><td>Character that was used to pad str up to size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the non-padded portion of str. </dd></dl>

</div>
</div>
<a id="a14114d7ce2c1b0c42e90cb80c8409e12" name="a14114d7ce2c1b0c42e90cb80c8409e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14114d7ce2c1b0c42e90cb80c8409e12">&#9670;&#160;</a></span>spdk_strlwr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * spdk_strlwr </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to lowercase in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String to convert to lowercase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted string. </dd></dl>

</div>
</div>
<a id="a88825738518f071e2406694ae5968e50" name="a88825738518f071e2406694ae5968e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88825738518f071e2406694ae5968e50">&#9670;&#160;</a></span>spdk_strsepq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * spdk_strsepq </td>
          <td>(</td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>stringp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>delim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a delimited string with quote handling. </p>
<p>Note that the string will be modified in place to add the string terminator to each field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stringp</td><td>Pointer to starting location in string. *stringp will be updated to point to the start of the next field, or NULL if the end of the string has been reached. </td></tr>
    <tr><td class="paramname">delim</td><td>Null-terminated string containing the list of accepted delimiters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to beginning of the current field. </dd></dl>

</div>
</div>
<a id="ae12420e9e2ab3af9d14e518245691c15" name="ae12420e9e2ab3af9d14e518245691c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12420e9e2ab3af9d14e518245691c15">&#9670;&#160;</a></span>spdk_strtol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int spdk_strtol </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>nptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the string in nptr to a long integer value according to the given base. </p>
<p><a class="el" href="#ae12420e9e2ab3af9d14e518245691c15" title="Convert the string in nptr to a long integer value according to the given base.">spdk_strtol()</a> does the additional error checking and allows only strings that contains only numbers and is positive number or zero. The caller only has to check if the return value is not negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>String containing numbers. </td></tr>
    <tr><td class="paramname">base</td><td>Base which must be between 2 and 32 inclusive, or be the special value 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>positive number or zero on success, or negative errno on failure. </dd></dl>

</div>
</div>
<a id="a317132c2abb23a53dc3d53846689e2b6" name="a317132c2abb23a53dc3d53846689e2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317132c2abb23a53dc3d53846689e2b6">&#9670;&#160;</a></span>spdk_strtoll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long int spdk_strtoll </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>nptr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the string in nptr to a long long integer value according to the given base. </p>
<p><a class="el" href="#a317132c2abb23a53dc3d53846689e2b6" title="Convert the string in nptr to a long long integer value according to the given base.">spdk_strtoll()</a> does the additional error checking and allows only strings that contains only numbers and is positive number or zero. The caller only has to check if the return value is not negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>String containing numbers. </td></tr>
    <tr><td class="paramname">base</td><td>Base which must be between 2 and 32 inclusive, or be the special value 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>positive number or zero on success, or negative errno on failure. </dd></dl>

</div>
</div>
<a id="a6de2829c1b25b13e37b05f1f7ef94c6b" name="a6de2829c1b25b13e37b05f1f7ef94c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de2829c1b25b13e37b05f1f7ef94c6b">&#9670;&#160;</a></span>spdk_vsprintf_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * spdk_vsprintf_alloc </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vsprintf with automatic buffer allocation. </p>
<p>The return value is the formatted string, which should be passed to free() when no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Format for the string to print. </td></tr>
    <tr><td class="paramname">args</td><td>A value that identifies a variable arguments list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the formatted string on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a7ca8e284c424ab309e3b182fc5b3cc5e" name="a7ca8e284c424ab309e3b182fc5b3cc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca8e284c424ab309e3b182fc5b3cc5e">&#9670;&#160;</a></span>spdk_vsprintf_append_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * spdk_vsprintf_append_realloc </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append string using vsprintf with automatic buffer re-allocation. </p>
<p>The return value is the formatted string, in which the original string in buffer is unchanged and the specified formatted string is appended.</p>
<p>The returned string should be passed to free() when no longer needed.</p>
<p>If buffer is NULL, the call is equivalent to <a class="el" href="#a7446fbf244d70a29528f29b8bc33e840" title="sprintf with automatic buffer allocation.">spdk_sprintf_alloc()</a>. If the call fails, the original buffer is left untouched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer which has a formatted string. </td></tr>
    <tr><td class="paramname">format</td><td>Format for the string to print. </td></tr>
    <tr><td class="paramname">args</td><td>A value that identifies a variable arguments list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the formatted string on success, or NULL on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.10.0 </li>
</ul>
</div>
</div>
</body>
</html>
