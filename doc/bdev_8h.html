<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.11">
  <title>SPDK: bdev.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-sm-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://ci.spdk.io/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/roadmap/">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('bdev_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bdev.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Block device abstraction layer.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a22219ae3fb084dcb87bcc6d454b415aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22219ae3fb084dcb87bcc6d454b415aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_BDEV_SMALL_BUF_MAX_SIZE</b>&#160;&#160;&#160;8192</td></tr>
<tr class="separator:a22219ae3fb084dcb87bcc6d454b415aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9496c34e0fc135e1f309fd586e8e65d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9496c34e0fc135e1f309fd586e8e65d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_BDEV_LARGE_BUF_MAX_SIZE</b>&#160;&#160;&#160;(64 * 1024)</td></tr>
<tr class="separator:a9496c34e0fc135e1f309fd586e8e65d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a51a55c97586c2d524fffcabc4d7910d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51a55c97586c2d524fffcabc4d7910d6"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_remove_cb_t</b>) (void *remove_ctx)</td></tr>
<tr class="separator:a51a55c97586c2d524fffcabc4d7910d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5602dfd313f90032dd91683b9663e3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>) (struct spdk_bdev_io *bdev_io, bool success, void *cb_arg)</td></tr>
<tr class="memdesc:a0c5602dfd313f90032dd91683b9663e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block device completion callback.  <a href="#a0c5602dfd313f90032dd91683b9663e3">More...</a><br /></td></tr>
<tr class="separator:a0c5602dfd313f90032dd91683b9663e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a8987bb3a1bc368881f6b81d249bd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6a8987bb3a1bc368881f6b81d249bd3"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_init_cb</b>) (void *cb_arg, int rc)</td></tr>
<tr class="separator:aa6a8987bb3a1bc368881f6b81d249bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33efc88148d8984b353e54b7ee0058f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad33efc88148d8984b353e54b7ee0058f"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_fini_cb</b>) (void *cb_arg)</td></tr>
<tr class="separator:ad33efc88148d8984b353e54b7ee0058f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715b633110065696fa53c518bb411602"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a715b633110065696fa53c518bb411602"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_poller_fn</b>) (void *arg)</td></tr>
<tr class="separator:a715b633110065696fa53c518bb411602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8afc62abda848cac82fdc02604dbcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace8afc62abda848cac82fdc02604dbcf"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_poller_start_cb</b>) (struct spdk_bdev_poller **ppoller, spdk_bdev_poller_fn fn, void *arg, uint64_t period_microseconds)</td></tr>
<tr class="separator:ace8afc62abda848cac82fdc02604dbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b86291d0c4d75ad8b0fc69dc6e9d87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24b86291d0c4d75ad8b0fc69dc6e9d87"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_poller_stop_cb</b>) (struct spdk_bdev_poller **ppoller)</td></tr>
<tr class="separator:a24b86291d0c4d75ad8b0fc69dc6e9d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad6c166f5d928c2995df57c96a2977862"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6c166f5d928c2995df57c96a2977862"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ad6c166f5d928c2995df57c96a2977862">spdk_bdev_status</a> { <b>SPDK_BDEV_STATUS_INVALID</b>, 
<b>SPDK_BDEV_STATUS_READY</b>, 
<b>SPDK_BDEV_STATUS_REMOVING</b>
 }<tr class="memdesc:ad6c166f5d928c2995df57c96a2977862"><td class="mdescLeft">&#160;</td><td class="mdescRight">bdev status <br /></td></tr>
</td></tr>
<tr class="separator:ad6c166f5d928c2995df57c96a2977862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633029e24ab5ae4a689bffa2565a519f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a633029e24ab5ae4a689bffa2565a519f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a633029e24ab5ae4a689bffa2565a519f">spdk_bdev_io_type</a> { <br />
&#160;&#160;<b>SPDK_BDEV_IO_TYPE_INVALID</b> = 0, 
<b>SPDK_BDEV_IO_TYPE_READ</b>, 
<b>SPDK_BDEV_IO_TYPE_WRITE</b>, 
<b>SPDK_BDEV_IO_TYPE_UNMAP</b>, 
<br />
&#160;&#160;<b>SPDK_BDEV_IO_TYPE_FLUSH</b>, 
<b>SPDK_BDEV_IO_TYPE_RESET</b>, 
<b>SPDK_BDEV_IO_TYPE_NVME_ADMIN</b>, 
<b>SPDK_BDEV_IO_TYPE_NVME_IO</b>, 
<br />
&#160;&#160;<b>SPDK_BDEV_IO_TYPE_NVME_IO_MD</b>, 
<b>SPDK_BDEV_IO_TYPE_WRITE_ZEROES</b>
<br />
 }<tr class="memdesc:a633029e24ab5ae4a689bffa2565a519f"><td class="mdescLeft">&#160;</td><td class="mdescRight">bdev I/O type <br /></td></tr>
</td></tr>
<tr class="separator:a633029e24ab5ae4a689bffa2565a519f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8922cc097ac6ced68ce492e618df1512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a8922cc097ac6ced68ce492e618df1512">spdk_bdev_initialize</a> (spdk_bdev_init_cb cb_fn, void *cb_arg, spdk_bdev_poller_start_cb start_poller_fn, spdk_bdev_poller_stop_cb stop_poller_fn)</td></tr>
<tr class="memdesc:a8922cc097ac6ced68ce492e618df1512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize block device modules.  <a href="#a8922cc097ac6ced68ce492e618df1512">More...</a><br /></td></tr>
<tr class="separator:a8922cc097ac6ced68ce492e618df1512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7263aeb5393b46fa5af8e04760f62ea4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a7263aeb5393b46fa5af8e04760f62ea4">spdk_bdev_finish</a> (spdk_bdev_fini_cb cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a7263aeb5393b46fa5af8e04760f62ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform cleanup work to remove the registered block device modules.  <a href="#a7263aeb5393b46fa5af8e04760f62ea4">More...</a><br /></td></tr>
<tr class="separator:a7263aeb5393b46fa5af8e04760f62ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273c20b5f07dd8c727ec0d0b80b804fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a273c20b5f07dd8c727ec0d0b80b804fe">spdk_bdev_config_text</a> (FILE *fp)</td></tr>
<tr class="memdesc:a273c20b5f07dd8c727ec0d0b80b804fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configuration options for the registered block device modules.  <a href="#a273c20b5f07dd8c727ec0d0b80b804fe">More...</a><br /></td></tr>
<tr class="separator:a273c20b5f07dd8c727ec0d0b80b804fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c759c53d028e3e408d19156f0e1eb1"><td class="memItemLeft" align="right" valign="top">struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a89c759c53d028e3e408d19156f0e1eb1">spdk_bdev_get_by_name</a> (const char *bdev_name)</td></tr>
<tr class="memdesc:a89c759c53d028e3e408d19156f0e1eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device by the block device name.  <a href="#a89c759c53d028e3e408d19156f0e1eb1">More...</a><br /></td></tr>
<tr class="separator:a89c759c53d028e3e408d19156f0e1eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578b0a9d444ddbb23c8181d9a5ea4f46"><td class="memItemLeft" align="right" valign="top">struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a578b0a9d444ddbb23c8181d9a5ea4f46">spdk_bdev_first</a> (void)</td></tr>
<tr class="memdesc:a578b0a9d444ddbb23c8181d9a5ea4f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first registered block device.  <a href="#a578b0a9d444ddbb23c8181d9a5ea4f46">More...</a><br /></td></tr>
<tr class="separator:a578b0a9d444ddbb23c8181d9a5ea4f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c0b9cb8dde1177df3442206cf87d2d"><td class="memItemLeft" align="right" valign="top">struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aa1c0b9cb8dde1177df3442206cf87d2d">spdk_bdev_next</a> (struct spdk_bdev *prev)</td></tr>
<tr class="memdesc:aa1c0b9cb8dde1177df3442206cf87d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next registered block device.  <a href="#aa1c0b9cb8dde1177df3442206cf87d2d">More...</a><br /></td></tr>
<tr class="separator:aa1c0b9cb8dde1177df3442206cf87d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717d20a033b87c5de88892c78ae55f4c"><td class="memItemLeft" align="right" valign="top">struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a717d20a033b87c5de88892c78ae55f4c">spdk_bdev_first_leaf</a> (void)</td></tr>
<tr class="memdesc:a717d20a033b87c5de88892c78ae55f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first block device without virtual block devices on top.  <a href="#a717d20a033b87c5de88892c78ae55f4c">More...</a><br /></td></tr>
<tr class="separator:a717d20a033b87c5de88892c78ae55f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae4a6dad6562cdefd3476ec23bfcccb"><td class="memItemLeft" align="right" valign="top">struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a6ae4a6dad6562cdefd3476ec23bfcccb">spdk_bdev_next_leaf</a> (struct spdk_bdev *prev)</td></tr>
<tr class="memdesc:a6ae4a6dad6562cdefd3476ec23bfcccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next block device without virtual block devices on top.  <a href="#a6ae4a6dad6562cdefd3476ec23bfcccb">More...</a><br /></td></tr>
<tr class="separator:a6ae4a6dad6562cdefd3476ec23bfcccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacdfd5debd3917d84d18be0277203ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aeacdfd5debd3917d84d18be0277203ff">spdk_bdev_open</a> (struct spdk_bdev *bdev, bool write, spdk_bdev_remove_cb_t remove_cb, void *remove_ctx, struct spdk_bdev_desc **desc)</td></tr>
<tr class="memdesc:aeacdfd5debd3917d84d18be0277203ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a block device for I/O operations.  <a href="#aeacdfd5debd3917d84d18be0277203ff">More...</a><br /></td></tr>
<tr class="separator:aeacdfd5debd3917d84d18be0277203ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5fc830851a2eb0aa34bbb40cf5eac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aaf5fc830851a2eb0aa34bbb40cf5eac6">spdk_bdev_close</a> (struct spdk_bdev_desc *desc)</td></tr>
<tr class="memdesc:aaf5fc830851a2eb0aa34bbb40cf5eac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a previously opened block device.  <a href="#aaf5fc830851a2eb0aa34bbb40cf5eac6">More...</a><br /></td></tr>
<tr class="separator:aaf5fc830851a2eb0aa34bbb40cf5eac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6418cfa0e9076ef7dafa7753c4c2028"><td class="memItemLeft" align="right" valign="top">struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ac6418cfa0e9076ef7dafa7753c4c2028">spdk_bdev_desc_get_bdev</a> (struct spdk_bdev_desc *desc)</td></tr>
<tr class="memdesc:ac6418cfa0e9076ef7dafa7753c4c2028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bdev associated with a bdev descriptor.  <a href="#ac6418cfa0e9076ef7dafa7753c4c2028">More...</a><br /></td></tr>
<tr class="separator:ac6418cfa0e9076ef7dafa7753c4c2028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd5dff692dc162459801d5649fe7655"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a7cd5dff692dc162459801d5649fe7655">spdk_bdev_io_type_supported</a> (struct spdk_bdev *bdev, enum <a class="el" href="bdev_8h.html#a633029e24ab5ae4a689bffa2565a519f">spdk_bdev_io_type</a> io_type)</td></tr>
<tr class="memdesc:a7cd5dff692dc162459801d5649fe7655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the block device supports the I/O type.  <a href="#a7cd5dff692dc162459801d5649fe7655">More...</a><br /></td></tr>
<tr class="separator:a7cd5dff692dc162459801d5649fe7655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d158f886b7ae2f735a794da420ca55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a84d158f886b7ae2f735a794da420ca55">spdk_bdev_dump_config_json</a> (struct spdk_bdev *bdev, struct spdk_json_write_ctx *w)</td></tr>
<tr class="memdesc:a84d158f886b7ae2f735a794da420ca55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output driver-specific configuration to a JSON stream.  <a href="#a84d158f886b7ae2f735a794da420ca55">More...</a><br /></td></tr>
<tr class="separator:a84d158f886b7ae2f735a794da420ca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97a853dcb945bf004817424b7aa28af"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ad97a853dcb945bf004817424b7aa28af">spdk_bdev_get_name</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:ad97a853dcb945bf004817424b7aa28af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device name.  <a href="#ad97a853dcb945bf004817424b7aa28af">More...</a><br /></td></tr>
<tr class="separator:ad97a853dcb945bf004817424b7aa28af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb4d1f8822c30be8c5d9c5dc3e62483"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a1cb4d1f8822c30be8c5d9c5dc3e62483">spdk_bdev_get_product_name</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:a1cb4d1f8822c30be8c5d9c5dc3e62483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device product name.  <a href="#a1cb4d1f8822c30be8c5d9c5dc3e62483">More...</a><br /></td></tr>
<tr class="separator:a1cb4d1f8822c30be8c5d9c5dc3e62483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba8c5672c8226b9b63f44543518c527"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a3ba8c5672c8226b9b63f44543518c527">spdk_bdev_get_block_size</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:a3ba8c5672c8226b9b63f44543518c527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device logical block size.  <a href="#a3ba8c5672c8226b9b63f44543518c527">More...</a><br /></td></tr>
<tr class="separator:a3ba8c5672c8226b9b63f44543518c527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86568eca8f0b4d0dc9bc59c5138fc7a5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a86568eca8f0b4d0dc9bc59c5138fc7a5">spdk_bdev_get_num_blocks</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:a86568eca8f0b4d0dc9bc59c5138fc7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of block device in logical blocks.  <a href="#a86568eca8f0b4d0dc9bc59c5138fc7a5">More...</a><br /></td></tr>
<tr class="separator:a86568eca8f0b4d0dc9bc59c5138fc7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d238484b372a77ba130fbb70f83519"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ab4d238484b372a77ba130fbb70f83519">spdk_bdev_get_buf_align</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:ab4d238484b372a77ba130fbb70f83519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimum I/O buffer address alignment for a bdev.  <a href="#ab4d238484b372a77ba130fbb70f83519">More...</a><br /></td></tr>
<tr class="separator:ab4d238484b372a77ba130fbb70f83519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79625889e23318204d235da36a4fa02"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aa79625889e23318204d235da36a4fa02">spdk_bdev_get_optimal_io_boundary</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:aa79625889e23318204d235da36a4fa02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get optimal I/O boundary for a bdev.  <a href="#aa79625889e23318204d235da36a4fa02">More...</a><br /></td></tr>
<tr class="separator:aa79625889e23318204d235da36a4fa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f6d6ce09da384501f09a49581caa37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a93f6d6ce09da384501f09a49581caa37">spdk_bdev_has_write_cache</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:a93f6d6ce09da384501f09a49581caa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether block device has an enabled write cache.  <a href="#a93f6d6ce09da384501f09a49581caa37">More...</a><br /></td></tr>
<tr class="separator:a93f6d6ce09da384501f09a49581caa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bb9e746b030d7c4c89cbcf60076c7e"><td class="memItemLeft" align="right" valign="top">struct spdk_io_channel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e">spdk_bdev_get_io_channel</a> (struct spdk_bdev_desc *desc)</td></tr>
<tr class="memdesc:ab5bb9e746b030d7c4c89cbcf60076c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an I/O channel for the block device opened by the specified descriptor.  <a href="#ab5bb9e746b030d7c4c89cbcf60076c7e">More...</a><br /></td></tr>
<tr class="separator:ab5bb9e746b030d7c4c89cbcf60076c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b500ce84df1d2551f76e635c9dafbd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a4b500ce84df1d2551f76e635c9dafbd5">spdk_bdev_read</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, uint64_t offset, uint64_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a4b500ce84df1d2551f76e635c9dafbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <a href="#a4b500ce84df1d2551f76e635c9dafbd5">More...</a><br /></td></tr>
<tr class="separator:a4b500ce84df1d2551f76e635c9dafbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec9efd151e2fb34ee3d22a1edbbb53f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aeec9efd151e2fb34ee3d22a1edbbb53f">spdk_bdev_read_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:aeec9efd151e2fb34ee3d22a1edbbb53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <a href="#aeec9efd151e2fb34ee3d22a1edbbb53f">More...</a><br /></td></tr>
<tr class="separator:aeec9efd151e2fb34ee3d22a1edbbb53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac9efa882e87909acfd4bccaddb1778"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a9ac9efa882e87909acfd4bccaddb1778">spdk_bdev_readv</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset, uint64_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a9ac9efa882e87909acfd4bccaddb1778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <a href="#a9ac9efa882e87909acfd4bccaddb1778">More...</a><br /></td></tr>
<tr class="separator:a9ac9efa882e87909acfd4bccaddb1778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55483d5ae010c514b37b976ad803b4b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a55483d5ae010c514b37b976ad803b4b2">spdk_bdev_readv_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a55483d5ae010c514b37b976ad803b4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <a href="#a55483d5ae010c514b37b976ad803b4b2">More...</a><br /></td></tr>
<tr class="separator:a55483d5ae010c514b37b976ad803b4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa740a114ef34d6a2f126d4e3a9dd9e9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aa740a114ef34d6a2f126d4e3a9dd9e9b">spdk_bdev_write</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, uint64_t offset, uint64_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:aa740a114ef34d6a2f126d4e3a9dd9e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <a href="#aa740a114ef34d6a2f126d4e3a9dd9e9b">More...</a><br /></td></tr>
<tr class="separator:aa740a114ef34d6a2f126d4e3a9dd9e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12da8917f525a6e11cbf22b2b7652c89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a12da8917f525a6e11cbf22b2b7652c89">spdk_bdev_write_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a12da8917f525a6e11cbf22b2b7652c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <a href="#a12da8917f525a6e11cbf22b2b7652c89">More...</a><br /></td></tr>
<tr class="separator:a12da8917f525a6e11cbf22b2b7652c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a508a1c301a1321faf0680a8f31f59a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a9a508a1c301a1321faf0680a8f31f59a">spdk_bdev_writev</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset, uint64_t len, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a9a508a1c301a1321faf0680a8f31f59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <a href="#a9a508a1c301a1321faf0680a8f31f59a">More...</a><br /></td></tr>
<tr class="separator:a9a508a1c301a1321faf0680a8f31f59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5849064d12de9f140a41522d1f7c95b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#af5849064d12de9f140a41522d1f7c95b">spdk_bdev_writev_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:af5849064d12de9f140a41522d1f7c95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <a href="#af5849064d12de9f140a41522d1f7c95b">More...</a><br /></td></tr>
<tr class="separator:af5849064d12de9f140a41522d1f7c95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc50b78fec7f69190d9139aff29a9043"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#adc50b78fec7f69190d9139aff29a9043">spdk_bdev_write_zeroes</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset, uint64_t len, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:adc50b78fec7f69190d9139aff29a9043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write zeroes request to the bdev on the given channel.  <a href="#adc50b78fec7f69190d9139aff29a9043">More...</a><br /></td></tr>
<tr class="separator:adc50b78fec7f69190d9139aff29a9043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047f8a9f8d0a3d1d7bfcdf0a9838b261"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a047f8a9f8d0a3d1d7bfcdf0a9838b261">spdk_bdev_write_zeroes_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a047f8a9f8d0a3d1d7bfcdf0a9838b261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write zeroes request to the bdev on the given channel.  <a href="#a047f8a9f8d0a3d1d7bfcdf0a9838b261">More...</a><br /></td></tr>
<tr class="separator:a047f8a9f8d0a3d1d7bfcdf0a9838b261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680c9c302998f7b003e2476e35d9ae4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a680c9c302998f7b003e2476e35d9ae4b">spdk_bdev_unmap</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset, uint64_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a680c9c302998f7b003e2476e35d9ae4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an unmap request to the block device.  <a href="#a680c9c302998f7b003e2476e35d9ae4b">More...</a><br /></td></tr>
<tr class="separator:a680c9c302998f7b003e2476e35d9ae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7555fdd41019e29b40e535b72457d30b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a7555fdd41019e29b40e535b72457d30b">spdk_bdev_unmap_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a7555fdd41019e29b40e535b72457d30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an unmap request to the block device.  <a href="#a7555fdd41019e29b40e535b72457d30b">More...</a><br /></td></tr>
<tr class="separator:a7555fdd41019e29b40e535b72457d30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7105b63cc84037543d9472ab33c8be93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a7105b63cc84037543d9472ab33c8be93">spdk_bdev_flush</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset, uint64_t length, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a7105b63cc84037543d9472ab33c8be93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a flush request to the bdev on the given channel.  <a href="#a7105b63cc84037543d9472ab33c8be93">More...</a><br /></td></tr>
<tr class="separator:a7105b63cc84037543d9472ab33c8be93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d84cd937e760cf32756654dc9720ed4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a9d84cd937e760cf32756654dc9720ed4">spdk_bdev_flush_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a9d84cd937e760cf32756654dc9720ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a flush request to the bdev on the given channel.  <a href="#a9d84cd937e760cf32756654dc9720ed4">More...</a><br /></td></tr>
<tr class="separator:a9d84cd937e760cf32756654dc9720ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca574d3e94be6150343823dd2e7ecf46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aca574d3e94be6150343823dd2e7ecf46">spdk_bdev_reset</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:aca574d3e94be6150343823dd2e7ecf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a reset request to the bdev on the given channel.  <a href="#aca574d3e94be6150343823dd2e7ecf46">More...</a><br /></td></tr>
<tr class="separator:aca574d3e94be6150343823dd2e7ecf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2249ef71e7125338b6cebf935a881ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ae2249ef71e7125338b6cebf935a881ab">spdk_bdev_nvme_admin_passthru</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, size_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ae2249ef71e7125338b6cebf935a881ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an NVMe Admin command to the bdev.  <a href="#ae2249ef71e7125338b6cebf935a881ab">More...</a><br /></td></tr>
<tr class="separator:ae2249ef71e7125338b6cebf935a881ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab172cf6afc9ef154bd823b91b09dee87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ab172cf6afc9ef154bd823b91b09dee87">spdk_bdev_nvme_io_passthru</a> (struct spdk_bdev_desc *bdev_desc, struct spdk_io_channel *ch, const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, size_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ab172cf6afc9ef154bd823b91b09dee87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an NVMe I/O command to the bdev.  <a href="#ab172cf6afc9ef154bd823b91b09dee87">More...</a><br /></td></tr>
<tr class="separator:ab172cf6afc9ef154bd823b91b09dee87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b5933e4c0b2ad68bad591655b4f9e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ac6b5933e4c0b2ad68bad591655b4f9e6">spdk_bdev_nvme_io_passthru_md</a> (struct spdk_bdev_desc *bdev_desc, struct spdk_io_channel *ch, const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, size_t nbytes, void *md_buf, size_t md_len, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ac6b5933e4c0b2ad68bad591655b4f9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an NVMe I/O command to the bdev.  <a href="#ac6b5933e4c0b2ad68bad591655b4f9e6">More...</a><br /></td></tr>
<tr class="separator:ac6b5933e4c0b2ad68bad591655b4f9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536a365e14bc4f3ddf76b9340958ebd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a536a365e14bc4f3ddf76b9340958ebd8">spdk_bdev_free_io</a> (struct spdk_bdev_io *bdev_io)</td></tr>
<tr class="memdesc:a536a365e14bc4f3ddf76b9340958ebd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an I/O request.  <a href="#a536a365e14bc4f3ddf76b9340958ebd8">More...</a><br /></td></tr>
<tr class="separator:a536a365e14bc4f3ddf76b9340958ebd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ba28ba382edd1d792d51a054eb3aa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ab1ba28ba382edd1d792d51a054eb3aa2">spdk_bdev_get_io_stat</a> (struct spdk_bdev *bdev, struct spdk_io_channel *ch, struct <a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a> *stat)</td></tr>
<tr class="memdesc:ab1ba28ba382edd1d792d51a054eb3aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return I/O statistics for this channel.  <a href="#ab1ba28ba382edd1d792d51a054eb3aa2">More...</a><br /></td></tr>
<tr class="separator:ab1ba28ba382edd1d792d51a054eb3aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe43254747db3cd072dfb596be3bbf2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#afe43254747db3cd072dfb596be3bbf2f">spdk_bdev_io_get_nvme_status</a> (const struct spdk_bdev_io *bdev_io, int *sct, int *sc)</td></tr>
<tr class="memdesc:afe43254747db3cd072dfb596be3bbf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of bdev_io as an NVMe status code.  <a href="#afe43254747db3cd072dfb596be3bbf2f">More...</a><br /></td></tr>
<tr class="separator:afe43254747db3cd072dfb596be3bbf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c213b4317d5077197950253af1ac50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ac3c213b4317d5077197950253af1ac50">spdk_bdev_io_get_scsi_status</a> (const struct spdk_bdev_io *bdev_io, int *sc, int *sk, int *asc, int *ascq)</td></tr>
<tr class="memdesc:ac3c213b4317d5077197950253af1ac50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of bdev_io as a SCSI status code.  <a href="#ac3c213b4317d5077197950253af1ac50">More...</a><br /></td></tr>
<tr class="separator:ac3c213b4317d5077197950253af1ac50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05d8c0e82bfbcc209af1eb958230ede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aa05d8c0e82bfbcc209af1eb958230ede">spdk_bdev_io_get_iovec</a> (struct spdk_bdev_io *bdev_io, struct iovec **iovp, int *iovcntp)</td></tr>
<tr class="memdesc:aa05d8c0e82bfbcc209af1eb958230ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the iovec describing the data buffer of a bdev_io.  <a href="#aa05d8c0e82bfbcc209af1eb958230ede">More...</a><br /></td></tr>
<tr class="separator:aa05d8c0e82bfbcc209af1eb958230ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Block device abstraction layer. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a0c5602dfd313f90032dd91683b9663e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bdev_io_completion_cb) (struct spdk_bdev_io *bdev_io, bool success, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block device completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>Block device I/O that has completed. </td></tr>
    <tr><td class="paramname">success</td><td>true if I/O completed successfully or false if it failed; additional error information may be retrieved from bdev_io by calling <a class="el" href="bdev_8h.html#afe43254747db3cd072dfb596be3bbf2f" title="Get the status of bdev_io as an NVMe status code. ">spdk_bdev_io_get_nvme_status()</a> or <a class="el" href="bdev_8h.html#ac3c213b4317d5077197950253af1ac50" title="Get the status of bdev_io as a SCSI status code. ">spdk_bdev_io_get_scsi_status()</a>. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Callback argument specified when bdev_io was submitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aaf5fc830851a2eb0aa34bbb40cf5eac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_close </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a previously opened block device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a273c20b5f07dd8c727ec0d0b80b804fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_config_text </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configuration options for the registered block device modules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>The pointer to a file that will be written to the configuration options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6418cfa0e9076ef7dafa7753c4c2028"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_bdev* spdk_bdev_desc_get_bdev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bdev associated with a bdev descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Open block device desciptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bdev associated with the descriptor </dd></dl>

</div>
</div>
<a class="anchor" id="a84d158f886b7ae2f735a794da420ca55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_dump_config_json </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_json_write_ctx *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output driver-specific configuration to a JSON stream. </p>
<p>The JSON write context will be initialized with an open object, so the bdev driver should write a name(based on the driver name) followed by a JSON value (most likely another nested object).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
    <tr><td class="paramname">w</td><td>JSON write context. It will store the driver-specific configuration context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a7263aeb5393b46fa5af8e04760f62ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_finish </td>
          <td>(</td>
          <td class="paramtype">spdk_bdev_fini_cb&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform cleanup work to remove the registered block device modules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_fn</td><td>Called when the removal is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a578b0a9d444ddbb23c8181d9a5ea4f46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_bdev* spdk_bdev_first </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first registered block device. </p>
<dl class="section return"><dt>Returns</dt><dd>The first registered block device. </dd></dl>

</div>
</div>
<a class="anchor" id="a717d20a033b87c5de88892c78ae55f4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_bdev* spdk_bdev_first_leaf </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first block device without virtual block devices on top. </p>
<p>This function only traverses over block devices which have no virtual block devices on top of them, then get the first one.</p>
<dl class="section return"><dt>Returns</dt><dd>The first block device without virtual block devices on top. </dd></dl>

</div>
</div>
<a class="anchor" id="a7105b63cc84037543d9472ab33c8be93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_flush </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a flush request to the bdev on the given channel. </p>
<p>For devices with volatile caches, data is not guaranteed to be persistent until the completion of a flush request. Call <a class="el" href="bdev_8h.html#a93f6d6ce09da384501f09a49581caa37" title="Query whether block device has an enabled write cache. ">spdk_bdev_has_write_cache()</a> to check if the bdev has a volatile cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d84cd937e760cf32756654dc9720ed4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_flush_blocks </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a flush request to the bdev on the given channel. </p>
<p>For devices with volatile caches, data is not guaranteed to be persistent until the completion of a flush request. Call <a class="el" href="bdev_8h.html#a93f6d6ce09da384501f09a49581caa37" title="Query whether block device has an enabled write cache. ">spdk_bdev_has_write_cache()</a> to check if the bdev has a volatile cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="a536a365e14bc4f3ddf76b9340958ebd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_free_io </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_io *&#160;</td>
          <td class="paramname"><em>bdev_io</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an I/O request. </p>
<p>This should be called after the callback for the I/O has been called and notifies the bdev layer that memory may now be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on failure, 0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ba8c5672c8226b9b63f44543518c527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_bdev_get_block_size </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device logical block size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of logical block for this bdev in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4d238484b372a77ba130fbb70f83519"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_bdev_get_buf_align </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get minimum I/O buffer address alignment for a bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Required alignment of I/O buffers in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a89c759c53d028e3e408d19156f0e1eb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_bdev* spdk_bdev_get_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bdev_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device by the block device name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_name</td><td>The name of the block device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Block device associated with the name or NULL if no block device with bdev_name is currently registered. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5bb9e746b030d7c4c89cbcf60076c7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_io_channel* spdk_bdev_get_io_channel </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain an I/O channel for the block device opened by the specified descriptor. </p>
<p>I/O channels are bound to threads, so the resulting I/O channel may only be used from the thread it was originally obtained from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the I/O channel or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1ba28ba382edd1d792d51a054eb3aa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_get_io_stat </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return I/O statistics for this channel. </p>
<p>After returning stats, zero out the current state of the statistics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">stat</td><td>The per-channel statistics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad97a853dcb945bf004817424b7aa28af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_bdev_get_name </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of bdev as a null-terminated string. </dd></dl>

</div>
</div>
<a class="anchor" id="a86568eca8f0b4d0dc9bc59c5138fc7a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_bdev_get_num_blocks </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of block device in logical blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of bdev in logical blocks.</dd></dl>
<p>Logical blocks are numbered from 0 to spdk_bdev_get_num_blocks(bdev) - 1, inclusive. </p>

</div>
</div>
<a class="anchor" id="aa79625889e23318204d235da36a4fa02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_bdev_get_optimal_io_boundary </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get optimal I/O boundary for a bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optimal I/O boundary in blocks that should not be crossed for best performance, or 0 if no optimal boundary is reported. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cb4d1f8822c30be8c5d9c5dc3e62483"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_bdev_get_product_name </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device product name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product name of bdev as a null-terminated string. </dd></dl>

</div>
</div>
<a class="anchor" id="a93f6d6ce09da384501f09a49581caa37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_bdev_has_write_cache </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether block device has an enabled write cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if block device has a volatile write cache enabled.</dd></dl>
<p>If this function returns true, written data may not be persistent until a flush command is issued. </p>

</div>
</div>
<a class="anchor" id="a8922cc097ac6ced68ce492e618df1512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_initialize </td>
          <td>(</td>
          <td class="paramtype">spdk_bdev_init_cb&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_bdev_poller_start_cb&#160;</td>
          <td class="paramname"><em>start_poller_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_bdev_poller_stop_cb&#160;</td>
          <td class="paramname"><em>stop_poller_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize block device modules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_fn</td><td>Called when the initialization is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
    <tr><td class="paramname">start_poller_fn</td><td>This function is called to request starting a poller. </td></tr>
    <tr><td class="paramname">stop_poller_fn</td><td>This function is called to request stopping a poller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa05d8c0e82bfbcc209af1eb958230ede"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_io_get_iovec </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_io *&#160;</td>
          <td class="paramname"><em>bdev_io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec **&#160;</td>
          <td class="paramname"><em>iovp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iovcntp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the iovec describing the data buffer of a bdev_io. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to describe with iovec. </td></tr>
    <tr><td class="paramname">iovp</td><td>Pointer to be filled with iovec. </td></tr>
    <tr><td class="paramname">iovcntp</td><td>Pointer to be filled with number of iovec entries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe43254747db3cd072dfb596be3bbf2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_io_get_nvme_status </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev_io *&#160;</td>
          <td class="paramname"><em>bdev_io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of bdev_io as an NVMe status code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to get the status from. </td></tr>
    <tr><td class="paramname">sct</td><td>Status Code Type return value, as defined by the NVMe specification. </td></tr>
    <tr><td class="paramname">sc</td><td>Status Code return value, as defined by the NVMe specification. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3c213b4317d5077197950253af1ac50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_io_get_scsi_status </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev_io *&#160;</td>
          <td class="paramname"><em>bdev_io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>asc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ascq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of bdev_io as a SCSI status code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to get the status from. </td></tr>
    <tr><td class="paramname">sc</td><td>SCSI Status Code. </td></tr>
    <tr><td class="paramname">sk</td><td>SCSI Sense Key. </td></tr>
    <tr><td class="paramname">asc</td><td>SCSI Additional Sense Code. </td></tr>
    <tr><td class="paramname">ascq</td><td>SCSI Additional Sense Code Qualifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cd5dff692dc162459801d5649fe7655"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_bdev_io_type_supported </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="bdev_8h.html#a633029e24ab5ae4a689bffa2565a519f">spdk_bdev_io_type</a>&#160;</td>
          <td class="paramname"><em>io_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the block device supports the I/O type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to check. </td></tr>
    <tr><td class="paramname">io_type</td><td>The specific I/O type like read, write, flush, unmap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if support, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1c0b9cb8dde1177df3442206cf87d2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_bdev* spdk_bdev_next </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>prev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next registered block device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>The current block device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next registered block device. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ae4a6dad6562cdefd3476ec23bfcccb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_bdev* spdk_bdev_next_leaf </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>prev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next block device without virtual block devices on top. </p>
<p>This function only traverses over block devices which have no virtual block devices on top of them, then get the next one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>The current block device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next block device without virtual block devices on top. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2249ef71e7125338b6cebf935a881ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_nvme_admin_passthru </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an NVMe Admin command to the bdev. </p>
<p>This passes directly through the block layer to the device. Support for NVMe passthru is optional, indicated by calling <a class="el" href="bdev_8h.html#a7cd5dff692dc162459801d5649fe7655" title="Check whether the block device supports the I/O type. ">spdk_bdev_io_type_supported()</a>.</p>
<p>The SGL/PRP will be automated generated based on the given buffer, so that portion of the command may be left empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">cmd</td><td>The raw NVMe command. Must be an admin command. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to written from. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to transfer. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="ab172cf6afc9ef154bd823b91b09dee87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_nvme_io_passthru </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>bdev_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an NVMe I/O command to the bdev. </p>
<p>This passes directly through the block layer to the device. Support for NVMe passthru is optional, indicated by calling <a class="el" href="bdev_8h.html#a7cd5dff692dc162459801d5649fe7655" title="Check whether the block device supports the I/O type. ">spdk_bdev_io_type_supported()</a>.</p>
<p>The SGL/PRP will be automated generated based on the given buffer, so that portion of the command may be left empty. Also, the namespace id (nsid) will be populated automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">cmd</td><td>The raw NVMe command. Must be in the NVM command set. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to written from. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to transfer. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6b5933e4c0b2ad68bad591655b4f9e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_nvme_io_passthru_md </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>bdev_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>md_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>md_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an NVMe I/O command to the bdev. </p>
<p>This passes directly through the block layer to the device. Support for NVMe passthru is optional, indicated by calling <a class="el" href="bdev_8h.html#a7cd5dff692dc162459801d5649fe7655" title="Check whether the block device supports the I/O type. ">spdk_bdev_io_type_supported()</a>.</p>
<p>The SGL/PRP will be automated generated based on the given buffer, so that portion of the command may be left empty. Also, the namespace id (nsid) will be populated automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">cmd</td><td>The raw NVMe command. Must be in the NVM command set. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to written from. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to transfer. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">md_buf</td><td>Meta data buffer to written from. </td></tr>
    <tr><td class="paramname">md_len</td><td>md_buf size to transfer. md_buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="aeacdfd5debd3917d84d18be0277203ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_open </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_bdev_remove_cb_t&#160;</td>
          <td class="paramname"><em>remove_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>remove_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_bdev_desc **&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a block device for I/O operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to open. </td></tr>
    <tr><td class="paramname">write</td><td>true is read/write access requested, false if read-only </td></tr>
    <tr><td class="paramname">remove_cb</td><td>callback function for hot remove the device. </td></tr>
    <tr><td class="paramname">remove_ctx</td><td>param for hot removal callback function. </td></tr>
    <tr><td class="paramname">desc</td><td>output parameter for the descriptor when operation is successful </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if operation is successful, suitable errno value otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a4b500ce84df1d2551f76e635c9dafbd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_read </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read request to the bdev on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to read into. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="aeec9efd151e2fb34ee3d22a1edbbb53f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_read_blocks </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read request to the bdev on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to read into. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks to read. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ac9efa882e87909acfd4bccaddb1778"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_readv </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read request to the bdev on the given channel. </p>
<p>This differs from spdk_bdev_read by allowing the data buffer to be described in a scatter gather list. Some physical devices place memory alignment requirements on data and may not be able to directly transfer into the buffers provided. In this case, the request may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">iov</td><td>A scatter gather list of buffers to be read into. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of elements in iov. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="a55483d5ae010c514b37b976ad803b4b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_readv_blocks </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read request to the bdev on the given channel. </p>
<p>This differs from spdk_bdev_read by allowing the data buffer to be described in a scatter gather list. Some physical devices place memory alignment requirements on data and may not be able to directly transfer into the buffers provided. In this case, the request may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">iov</td><td>A scatter gather list of buffers to be read into. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of elements in iov. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks to read. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="aca574d3e94be6150343823dd2e7ecf46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_reset </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a reset request to the bdev on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="a680c9c302998f7b003e2476e35d9ae4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_unmap </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an unmap request to the block device. </p>
<p>Unmap is sometimes also called trim or deallocate. This notifies the device that the data in the blocks described is no longer valid. Reading blocks that have been unmapped results in indeterminate data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to unmap. Must be a multiple of the block size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="a7555fdd41019e29b40e535b72457d30b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_unmap_blocks </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an unmap request to the block device. </p>
<p>Unmap is sometimes also called trim or deallocate. This notifies the device that the data in the blocks described is no longer valid. Reading blocks that have been unmapped results in indeterminate data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks to unmap. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="aa740a114ef34d6a2f126d4e3a9dd9e9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_write </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write request to the bdev on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to written from. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to write. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="a12da8917f525a6e11cbf22b2b7652c89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_write_blocks </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write request to the bdev on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to written from. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks to write. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="adc50b78fec7f69190d9139aff29a9043"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_write_zeroes </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write zeroes request to the bdev on the given channel. </p>
<p>This command ensures that all bytes in the specified range are set to 00h</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">len</td><td>The size of data to zero. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="a047f8a9f8d0a3d1d7bfcdf0a9838b261"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_write_zeroes_blocks </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write zeroes request to the bdev on the given channel. </p>
<p>This command ensures that all bytes in the specified range are set to 00h</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks to zero. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a508a1c301a1321faf0680a8f31f59a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_writev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write request to the bdev on the given channel. </p>
<p>This differs from spdk_bdev_write by allowing the data buffer to be described in a scatter gather list. Some physical devices place memory alignment requirements on data and may not be able to directly transfer out of the buffers provided. In this case, the request may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">iov</td><td>A scatter gather list of buffers to be written from. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of elements in iov. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">len</td><td>The size of data to write. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a class="anchor" id="af5849064d12de9f140a41522d1f7c95b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_writev_blocks </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write request to the bdev on the given channel. </p>
<p>This differs from spdk_bdev_write by allowing the data buffer to be described in a scatter gather list. Some physical devices place memory alignment requirements on data and may not be able to directly transfer out of the buffers provided. In this case, the request may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">iov</td><td>A scatter gather list of buffers to be written from. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of elements in iov. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks to write. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
