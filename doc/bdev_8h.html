<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="generator" content="Doxygen 1.10.0" />
  <title>SPDK: bdev.h File Reference</title>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  <script type="text/javascript" src="../js/doxyboot.js"></script>
  <script type="text/javascript" src="./navtree.js"></script>
  <link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
<body>
  <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/" aria-label="SPDK">
      <img src="/img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <div class="navbar-nav me-auto">
        <a class="nav-link header-link active" href="../doc/">Documentation</a>
        <a class="nav-link header-link" href="../development/">Development</a>
        <a class="nav-link header-link" href="../community/">Community</a>
        <a class="nav-link header-link" href="../blog/">Blog</a>
      </div>
      <div class="navbar-nav ms-auto me-3">
        <a class="nav-link header-link" href="https://github.com/spdk/spdk">
          <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
      </div>
    </div>
  </nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('bdev_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">bdev.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Block device abstraction layer.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__bdev__media__event.html">spdk_bdev_media_event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Media management event details.  <a href="structspdk__bdev__media__event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__bdev__opts.html">spdk_bdev_opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionspdk__bdev__nvme__ctratt.html">spdk_bdev_nvme_ctratt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union for controller attributes field, to list whether bdev supports fdp etc.  <a href="unionspdk__bdev__nvme__ctratt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionspdk__bdev__nvme__cdw12.html">spdk_bdev_nvme_cdw12</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union for command dword 12, which by convention matches the NVMe command dword 12 definition.  <a href="unionspdk__bdev__nvme__cdw12.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionspdk__bdev__nvme__cdw13.html">spdk_bdev_nvme_cdw13</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union for command dword 13, which by convention matches the NVMe command dword 13 definition.  <a href="unionspdk__bdev__nvme__cdw13.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__bdev__ext__io__opts.html">spdk_bdev_ext_io_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure with optional IO request parameters.  <a href="structspdk__bdev__ext__io__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__bdev__open__async__opts.html">spdk_bdev_open_async_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure with optional asynchronous bdev open parameters.  <a href="structspdk__bdev__open__async__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__bdev__io__wait__entry.html">spdk_bdev_io_wait_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to register a callback when an <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> becomes available.  <a href="structspdk__bdev__io__wait__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a22219ae3fb084dcb87bcc6d454b415aa" id="r_a22219ae3fb084dcb87bcc6d454b415aa"><td class="memItemLeft" align="right" valign="top"><a id="a22219ae3fb084dcb87bcc6d454b415aa" name="a22219ae3fb084dcb87bcc6d454b415aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_BDEV_SMALL_BUF_MAX_SIZE</b>&#160;&#160;&#160;8192</td></tr>
<tr class="separator:a22219ae3fb084dcb87bcc6d454b415aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9496c34e0fc135e1f309fd586e8e65d0" id="r_a9496c34e0fc135e1f309fd586e8e65d0"><td class="memItemLeft" align="right" valign="top"><a id="a9496c34e0fc135e1f309fd586e8e65d0" name="a9496c34e0fc135e1f309fd586e8e65d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_BDEV_LARGE_BUF_MAX_SIZE</b>&#160;&#160;&#160;(64 * 1024)</td></tr>
<tr class="separator:a9496c34e0fc135e1f309fd586e8e65d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a20cbee5def3eb9f9893d60ba70103e" id="r_a9a20cbee5def3eb9f9893d60ba70103e"><td class="memItemLeft" align="right" valign="top"><a id="a9a20cbee5def3eb9f9893d60ba70103e" name="a9a20cbee5def3eb9f9893d60ba70103e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_BDEV_MAX_INTERLEAVED_MD_SIZE</b>&#160;&#160;&#160;(64)</td></tr>
<tr class="separator:a9a20cbee5def3eb9f9893d60ba70103e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c60455b0ae9e1c8139bb24df036d6d" id="r_a60c60455b0ae9e1c8139bb24df036d6d"><td class="memItemLeft" align="right" valign="top"><a id="a60c60455b0ae9e1c8139bb24df036d6d" name="a60c60455b0ae9e1c8139bb24df036d6d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_BDEV_BUF_SIZE_WITH_MD</b>(x)&#160;&#160;&#160;(((x) / 512) * (512 + SPDK_BDEV_MAX_INTERLEAVED_MD_SIZE))</td></tr>
<tr class="separator:a60c60455b0ae9e1c8139bb24df036d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a51a55c97586c2d524fffcabc4d7910d6" id="r_a51a55c97586c2d524fffcabc4d7910d6"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51a55c97586c2d524fffcabc4d7910d6">spdk_bdev_remove_cb_t</a>) (void *remove_ctx)</td></tr>
<tr class="memdesc:a51a55c97586c2d524fffcabc4d7910d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block device remove callback.  <br /></td></tr>
<tr class="separator:a51a55c97586c2d524fffcabc4d7910d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4755b1b0a2a204732c3be266b6e1b08" id="r_ab4755b1b0a2a204732c3be266b6e1b08"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4755b1b0a2a204732c3be266b6e1b08">spdk_bdev_event_cb_t</a>) (enum <a class="el" href="#a13e432c6b290dcf392335a406206fd83">spdk_bdev_event_type</a> type, struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, void *event_ctx)</td></tr>
<tr class="memdesc:ab4755b1b0a2a204732c3be266b6e1b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block device event callback.  <br /></td></tr>
<tr class="separator:ab4755b1b0a2a204732c3be266b6e1b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5602dfd313f90032dd91683b9663e3" id="r_a0c5602dfd313f90032dd91683b9663e3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>) (struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *bdev_io, bool success, void *cb_arg)</td></tr>
<tr class="memdesc:a0c5602dfd313f90032dd91683b9663e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block device completion callback.  <br /></td></tr>
<tr class="separator:a0c5602dfd313f90032dd91683b9663e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ee74dcabcf41f4332c7e75b4afa11a" id="r_af8ee74dcabcf41f4332c7e75b4afa11a"><td class="memItemLeft" align="right" valign="top"><a id="af8ee74dcabcf41f4332c7e75b4afa11a" name="af8ee74dcabcf41f4332c7e75b4afa11a"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_wait_for_examine_cb</b>) (void *arg)</td></tr>
<tr class="separator:af8ee74dcabcf41f4332c7e75b4afa11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a8987bb3a1bc368881f6b81d249bd3" id="r_aa6a8987bb3a1bc368881f6b81d249bd3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6a8987bb3a1bc368881f6b81d249bd3">spdk_bdev_init_cb</a>) (void *cb_arg, int rc)</td></tr>
<tr class="memdesc:aa6a8987bb3a1bc368881f6b81d249bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block device initialization callback.  <br /></td></tr>
<tr class="separator:aa6a8987bb3a1bc368881f6b81d249bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33efc88148d8984b353e54b7ee0058f" id="r_ad33efc88148d8984b353e54b7ee0058f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad33efc88148d8984b353e54b7ee0058f">spdk_bdev_fini_cb</a>) (void *cb_arg)</td></tr>
<tr class="memdesc:ad33efc88148d8984b353e54b7ee0058f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block device finish callback.  <br /></td></tr>
<tr class="separator:ad33efc88148d8984b353e54b7ee0058f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2b47e30b56bc875b618beffced9662" id="r_a1e2b47e30b56bc875b618beffced9662"><td class="memItemLeft" align="right" valign="top"><a id="a1e2b47e30b56bc875b618beffced9662" name="a1e2b47e30b56bc875b618beffced9662"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_get_device_stat_cb</b>) (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, struct <a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a> *stat, void *cb_arg, int rc)</td></tr>
<tr class="separator:a1e2b47e30b56bc875b618beffced9662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83db84993554e784cbddf2d217f6ea4f" id="r_a83db84993554e784cbddf2d217f6ea4f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83db84993554e784cbddf2d217f6ea4f">spdk_bdev_io_timeout_cb</a>) (void *cb_arg, struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *bdev_io)</td></tr>
<tr class="memdesc:a83db84993554e784cbddf2d217f6ea4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block device channel IO timeout callback.  <br /></td></tr>
<tr class="separator:a83db84993554e784cbddf2d217f6ea4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0253fe337c6697d014adffde6f8cd000" id="r_a0253fe337c6697d014adffde6f8cd000"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0253fe337c6697d014adffde6f8cd000">spdk_bdev_open_async_cb_t</a>) (struct spdk_bdev_desc *desc, int rc, void *cb_arg)</td></tr>
<tr class="memdesc:a0253fe337c6697d014adffde6f8cd000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block device asynchronous open callback.  <br /></td></tr>
<tr class="separator:a0253fe337c6697d014adffde6f8cd000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4163854db79e0e3b211dd72ca031fbb0" id="r_a4163854db79e0e3b211dd72ca031fbb0"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4163854db79e0e3b211dd72ca031fbb0">spdk_for_each_bdev_fn</a>) (void *ctx, struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:a4163854db79e0e3b211dd72ca031fbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for <a class="el" href="#ac93dda3868b191be70ac7e1517422c1f" title="Call the provided callback function for every registered block device.">spdk_for_each_bdev()</a> and <a class="el" href="#aeb680eb5205197872738e482204ab441" title="Call the provided callback function for every block device without virtual block devices on top.">spdk_for_each_bdev_leaf()</a>.  <br /></td></tr>
<tr class="separator:a4163854db79e0e3b211dd72ca031fbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7e19e090b8cdb22e8fc6b1984e5278" id="r_a9c7e19e090b8cdb22e8fc6b1984e5278"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c7e19e090b8cdb22e8fc6b1984e5278">spdk_bdev_io_wait_cb</a>) (void *cb_arg)</td></tr>
<tr class="memdesc:a9c7e19e090b8cdb22e8fc6b1984e5278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block device I/O wait callback.  <br /></td></tr>
<tr class="separator:a9c7e19e090b8cdb22e8fc6b1984e5278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34045ef60486be1ea00198807bd66c8" id="r_ab34045ef60486be1ea00198807bd66c8"><td class="memItemLeft" align="right" valign="top"><a id="ab34045ef60486be1ea00198807bd66c8" name="ab34045ef60486be1ea00198807bd66c8"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_histogram_status_cb</b>) (void *cb_arg, int status)</td></tr>
<tr class="separator:ab34045ef60486be1ea00198807bd66c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbca76276132f1e14e9d2e5fda17a12a" id="r_abbca76276132f1e14e9d2e5fda17a12a"><td class="memItemLeft" align="right" valign="top"><a id="abbca76276132f1e14e9d2e5fda17a12a" name="abbca76276132f1e14e9d2e5fda17a12a"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_histogram_data_cb</b>) (void *cb_arg, int status, struct <a class="el" href="structspdk__histogram__data.html">spdk_histogram_data</a> *histogram)</td></tr>
<tr class="separator:abbca76276132f1e14e9d2e5fda17a12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac2a1bd295f6c71dbe706e61f5f6ac4" id="r_a4ac2a1bd295f6c71dbe706e61f5f6ac4"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ac2a1bd295f6c71dbe706e61f5f6ac4">spdk_bdev_for_each_channel_msg</a>) (struct spdk_bdev_channel_iter *i, struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, struct spdk_io_channel *ch, void *ctx)</td></tr>
<tr class="memdesc:a4ac2a1bd295f6c71dbe706e61f5f6ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called on the appropriate thread for each channel associated with the given bdev.  <br /></td></tr>
<tr class="separator:a4ac2a1bd295f6c71dbe706e61f5f6ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f406e9a97a6ac7072867bdcc7c1df1" id="r_a16f406e9a97a6ac7072867bdcc7c1df1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16f406e9a97a6ac7072867bdcc7c1df1">spdk_bdev_for_each_channel_done</a>) (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, void *ctx, int status)</td></tr>
<tr class="memdesc:a16f406e9a97a6ac7072867bdcc7c1df1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#a1b51dde3495e6b37f172e172cca3cfd2" title="Call &#39;fn&#39; on each channel associated with the given bdev.">spdk_bdev_for_each_channel()</a> function's final callback with the given bdev.  <br /></td></tr>
<tr class="separator:a16f406e9a97a6ac7072867bdcc7c1df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a13e432c6b290dcf392335a406206fd83" id="r_a13e432c6b290dcf392335a406206fd83"><td class="memItemLeft" align="right" valign="top"><a id="a13e432c6b290dcf392335a406206fd83" name="a13e432c6b290dcf392335a406206fd83"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13e432c6b290dcf392335a406206fd83">spdk_bdev_event_type</a> { <b>SPDK_BDEV_EVENT_REMOVE</b>
, <b>SPDK_BDEV_EVENT_RESIZE</b>
, <b>SPDK_BDEV_EVENT_MEDIA_MANAGEMENT</b>
 }</td></tr>
<tr class="memdesc:a13e432c6b290dcf392335a406206fd83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous event type. <br /></td></tr>
<tr class="separator:a13e432c6b290dcf392335a406206fd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c166f5d928c2995df57c96a2977862" id="r_ad6c166f5d928c2995df57c96a2977862"><td class="memItemLeft" align="right" valign="top"><a id="ad6c166f5d928c2995df57c96a2977862" name="ad6c166f5d928c2995df57c96a2977862"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6c166f5d928c2995df57c96a2977862">spdk_bdev_status</a> { <b>SPDK_BDEV_STATUS_INVALID</b>
, <b>SPDK_BDEV_STATUS_READY</b>
, <b>SPDK_BDEV_STATUS_UNREGISTERING</b>
, <b>SPDK_BDEV_STATUS_REMOVING</b>
 }</td></tr>
<tr class="memdesc:ad6c166f5d928c2995df57c96a2977862"><td class="mdescLeft">&#160;</td><td class="mdescRight">bdev status <br /></td></tr>
<tr class="separator:ad6c166f5d928c2995df57c96a2977862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633029e24ab5ae4a689bffa2565a519f" id="r_a633029e24ab5ae4a689bffa2565a519f"><td class="memItemLeft" align="right" valign="top"><a id="a633029e24ab5ae4a689bffa2565a519f" name="a633029e24ab5ae4a689bffa2565a519f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a633029e24ab5ae4a689bffa2565a519f">spdk_bdev_io_type</a> { <br />
&#160;&#160;<b>SPDK_BDEV_IO_TYPE_INVALID</b> = 0
, <b>SPDK_BDEV_IO_TYPE_READ</b>
, <b>SPDK_BDEV_IO_TYPE_WRITE</b>
, <b>SPDK_BDEV_IO_TYPE_UNMAP</b>
, <br />
&#160;&#160;<b>SPDK_BDEV_IO_TYPE_FLUSH</b>
, <b>SPDK_BDEV_IO_TYPE_RESET</b>
, <b>SPDK_BDEV_IO_TYPE_NVME_ADMIN</b>
, <b>SPDK_BDEV_IO_TYPE_NVME_IO</b>
, <br />
&#160;&#160;<b>SPDK_BDEV_IO_TYPE_NVME_IO_MD</b>
, <b>SPDK_BDEV_IO_TYPE_WRITE_ZEROES</b>
, <b>SPDK_BDEV_IO_TYPE_ZCOPY</b>
, <b>SPDK_BDEV_IO_TYPE_GET_ZONE_INFO</b>
, <br />
&#160;&#160;<b>SPDK_BDEV_IO_TYPE_ZONE_MANAGEMENT</b>
, <b>SPDK_BDEV_IO_TYPE_ZONE_APPEND</b>
, <b>SPDK_BDEV_IO_TYPE_COMPARE</b>
, <b>SPDK_BDEV_IO_TYPE_COMPARE_AND_WRITE</b>
, <br />
&#160;&#160;<b>SPDK_BDEV_IO_TYPE_ABORT</b>
, <b>SPDK_BDEV_IO_TYPE_SEEK_HOLE</b>
, <b>SPDK_BDEV_IO_TYPE_SEEK_DATA</b>
, <b>SPDK_BDEV_IO_TYPE_COPY</b>
, <br />
&#160;&#160;<b>SPDK_BDEV_IO_TYPE_NVME_IOV_MD</b>
, <b>SPDK_BDEV_NUM_IO_TYPES</b>
<br />
 }</td></tr>
<tr class="memdesc:a633029e24ab5ae4a689bffa2565a519f"><td class="mdescLeft">&#160;</td><td class="mdescRight">bdev I/O type <br /></td></tr>
<tr class="separator:a633029e24ab5ae4a689bffa2565a519f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfbfc44fa2113d7ee219d09a0994d93" id="r_aedfbfc44fa2113d7ee219d09a0994d93"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedfbfc44fa2113d7ee219d09a0994d93">spdk_bdev_qos_rate_limit_type</a> { <br />
&#160;&#160;<a class="el" href="#aedfbfc44fa2113d7ee219d09a0994d93a679f76e345c7295f991eeb84d977e5b0">SPDK_BDEV_QOS_RW_IOPS_RATE_LIMIT</a> = 0
, <a class="el" href="#aedfbfc44fa2113d7ee219d09a0994d93a595aaec5bb61bcbdc9f08e111cfd0943">SPDK_BDEV_QOS_RW_BPS_RATE_LIMIT</a>
, <a class="el" href="#aedfbfc44fa2113d7ee219d09a0994d93af9ae83e85454b81d7210cc97b1507a1d">SPDK_BDEV_QOS_R_BPS_RATE_LIMIT</a>
, <a class="el" href="#aedfbfc44fa2113d7ee219d09a0994d93a1b3f5fed3a3173110561ff7c58f211dc">SPDK_BDEV_QOS_W_BPS_RATE_LIMIT</a>
, <br />
&#160;&#160;<a class="el" href="#aedfbfc44fa2113d7ee219d09a0994d93a25c0a2574ea232ae0fd9fd3969c00b11">SPDK_BDEV_QOS_NUM_RATE_LIMIT_TYPES</a>
<br />
 }</td></tr>
<tr class="memdesc:aedfbfc44fa2113d7ee219d09a0994d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">bdev QoS rate limit type  <a href="#aedfbfc44fa2113d7ee219d09a0994d93">More...</a><br /></td></tr>
<tr class="separator:aedfbfc44fa2113d7ee219d09a0994d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2a07b56033890913587438d1c77942db" id="r_a2a07b56033890913587438d1c77942db"><td class="memItemLeft" align="right" valign="top"><a id="a2a07b56033890913587438d1c77942db" name="a2a07b56033890913587438d1c77942db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__bdev__opts.html">spdk_bdev_opts</a>)==32, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a2a07b56033890913587438d1c77942db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae807eb713485e9a2158896186f44843f" id="r_ae807eb713485e9a2158896186f44843f"><td class="memItemLeft" align="right" valign="top"><a id="ae807eb713485e9a2158896186f44843f" name="ae807eb713485e9a2158896186f44843f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(union <a class="el" href="unionspdk__bdev__nvme__ctratt.html">spdk_bdev_nvme_ctratt</a>)==4, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:ae807eb713485e9a2158896186f44843f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3b7fbd1ddedfb13e7ac01d9bd484cf" id="r_a1d3b7fbd1ddedfb13e7ac01d9bd484cf"><td class="memItemLeft" align="right" valign="top"><a id="a1d3b7fbd1ddedfb13e7ac01d9bd484cf" name="a1d3b7fbd1ddedfb13e7ac01d9bd484cf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(union <a class="el" href="unionspdk__bdev__nvme__cdw12.html">spdk_bdev_nvme_cdw12</a>)==4, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a1d3b7fbd1ddedfb13e7ac01d9bd484cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b682915152042c384a50dea9f4dae3" id="r_a09b682915152042c384a50dea9f4dae3"><td class="memItemLeft" align="right" valign="top"><a id="a09b682915152042c384a50dea9f4dae3" name="a09b682915152042c384a50dea9f4dae3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(union <a class="el" href="unionspdk__bdev__nvme__cdw13.html">spdk_bdev_nvme_cdw13</a>)==4, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a09b682915152042c384a50dea9f4dae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7f3fafa3bbfd4c48a60ccfbd86fdb3" id="r_a6f7f3fafa3bbfd4c48a60ccfbd86fdb3"><td class="memItemLeft" align="right" valign="top"><a id="a6f7f3fafa3bbfd4c48a60ccfbd86fdb3" name="a6f7f3fafa3bbfd4c48a60ccfbd86fdb3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__bdev__ext__io__opts.html">spdk_bdev_ext_io_opts</a>)==52, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a6f7f3fafa3bbfd4c48a60ccfbd86fdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c4412ed5d0e1869620965304d36b7f" id="r_ab0c4412ed5d0e1869620965304d36b7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0c4412ed5d0e1869620965304d36b7f">spdk_bdev_get_opts</a> (struct <a class="el" href="structspdk__bdev__opts.html">spdk_bdev_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:ab0c4412ed5d0e1869620965304d36b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the options for the bdev module.  <br /></td></tr>
<tr class="separator:ab0c4412ed5d0e1869620965304d36b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828be2f36a5c1e343488130c457f5bf5" id="r_a828be2f36a5c1e343488130c457f5bf5"><td class="memItemLeft" align="right" valign="top"><a id="a828be2f36a5c1e343488130c457f5bf5" name="a828be2f36a5c1e343488130c457f5bf5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_set_opts</b> (struct <a class="el" href="structspdk__bdev__opts.html">spdk_bdev_opts</a> *opts)</td></tr>
<tr class="separator:a828be2f36a5c1e343488130c457f5bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e34f9d44b0d59b4e1d88967e77d9675" id="r_a4e34f9d44b0d59b4e1d88967e77d9675"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e34f9d44b0d59b4e1d88967e77d9675">spdk_bdev_wait_for_examine</a> (spdk_bdev_wait_for_examine_cb cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a4e34f9d44b0d59b4e1d88967e77d9675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report when all bdevs finished the examine process.  <br /></td></tr>
<tr class="separator:a4e34f9d44b0d59b4e1d88967e77d9675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae720ef13c98f9ba40e6562d4a8582427" id="r_ae720ef13c98f9ba40e6562d4a8582427"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae720ef13c98f9ba40e6562d4a8582427">spdk_bdev_examine</a> (const char *name)</td></tr>
<tr class="memdesc:ae720ef13c98f9ba40e6562d4a8582427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examine a block device explicitly.  <br /></td></tr>
<tr class="separator:ae720ef13c98f9ba40e6562d4a8582427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854eb960c06597051071023a3d70e887" id="r_a854eb960c06597051071023a3d70e887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a854eb960c06597051071023a3d70e887">spdk_bdev_initialize</a> (<a class="el" href="#aa6a8987bb3a1bc368881f6b81d249bd3">spdk_bdev_init_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a854eb960c06597051071023a3d70e887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize block device modules.  <br /></td></tr>
<tr class="separator:a854eb960c06597051071023a3d70e887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7263aeb5393b46fa5af8e04760f62ea4" id="r_a7263aeb5393b46fa5af8e04760f62ea4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7263aeb5393b46fa5af8e04760f62ea4">spdk_bdev_finish</a> (<a class="el" href="#ad33efc88148d8984b353e54b7ee0058f">spdk_bdev_fini_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a7263aeb5393b46fa5af8e04760f62ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform cleanup work to remove the registered block device modules.  <br /></td></tr>
<tr class="separator:a7263aeb5393b46fa5af8e04760f62ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57814ce5dc208380ebf39dab0e1ce9a8" id="r_a57814ce5dc208380ebf39dab0e1ce9a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57814ce5dc208380ebf39dab0e1ce9a8">spdk_bdev_subsystem_config_json</a> (struct spdk_json_write_ctx *w)</td></tr>
<tr class="memdesc:a57814ce5dc208380ebf39dab0e1ce9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the full configuration options for the registered block device modules and created bdevs.  <br /></td></tr>
<tr class="separator:a57814ce5dc208380ebf39dab0e1ce9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665b7764a3bf00c5a53c59e5f201cafb" id="r_a665b7764a3bf00c5a53c59e5f201cafb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a665b7764a3bf00c5a53c59e5f201cafb">spdk_bdev_get_module_name</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:a665b7764a3bf00c5a53c59e5f201cafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device module name.  <br /></td></tr>
<tr class="separator:a665b7764a3bf00c5a53c59e5f201cafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f3638678ead46e86a28c8afd34d1e8" id="r_a04f3638678ead46e86a28c8afd34d1e8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04f3638678ead46e86a28c8afd34d1e8">spdk_bdev_get_by_name</a> (const char *bdev_name)</td></tr>
<tr class="memdesc:a04f3638678ead46e86a28c8afd34d1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device by the block device name.  <br /></td></tr>
<tr class="separator:a04f3638678ead46e86a28c8afd34d1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c74a45879dfcea19908e48c1131a071" id="r_a0c74a45879dfcea19908e48c1131a071"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c74a45879dfcea19908e48c1131a071">spdk_bdev_first</a> (void)</td></tr>
<tr class="memdesc:a0c74a45879dfcea19908e48c1131a071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first registered block device.  <br /></td></tr>
<tr class="separator:a0c74a45879dfcea19908e48c1131a071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f23e8d3f72213af5a9bb22605c74468" id="r_a7f23e8d3f72213af5a9bb22605c74468"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f23e8d3f72213af5a9bb22605c74468">spdk_bdev_next</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *prev)</td></tr>
<tr class="memdesc:a7f23e8d3f72213af5a9bb22605c74468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next registered block device.  <br /></td></tr>
<tr class="separator:a7f23e8d3f72213af5a9bb22605c74468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab103cc993070d39a73c48d7087dc47a8" id="r_ab103cc993070d39a73c48d7087dc47a8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab103cc993070d39a73c48d7087dc47a8">spdk_bdev_first_leaf</a> (void)</td></tr>
<tr class="memdesc:ab103cc993070d39a73c48d7087dc47a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first block device without virtual block devices on top.  <br /></td></tr>
<tr class="separator:ab103cc993070d39a73c48d7087dc47a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b18a69f9da6a60e5a977d7e73f3b11" id="r_a46b18a69f9da6a60e5a977d7e73f3b11"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46b18a69f9da6a60e5a977d7e73f3b11">spdk_bdev_next_leaf</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *prev)</td></tr>
<tr class="memdesc:a46b18a69f9da6a60e5a977d7e73f3b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next block device without virtual block devices on top.  <br /></td></tr>
<tr class="separator:a46b18a69f9da6a60e5a977d7e73f3b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca93f44b46f0b877df9b6936ef9e0a9e" id="r_aca93f44b46f0b877df9b6936ef9e0a9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca93f44b46f0b877df9b6936ef9e0a9e">spdk_bdev_open_ext</a> (const char *bdev_name, bool write, <a class="el" href="#ab4755b1b0a2a204732c3be266b6e1b08">spdk_bdev_event_cb_t</a> event_cb, void *event_ctx, struct spdk_bdev_desc **desc)</td></tr>
<tr class="memdesc:aca93f44b46f0b877df9b6936ef9e0a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a block device for I/O operations.  <br /></td></tr>
<tr class="separator:aca93f44b46f0b877df9b6936ef9e0a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0f34e14b9849b25c5b24c2b4941ad0" id="r_a1a0f34e14b9849b25c5b24c2b4941ad0"><td class="memItemLeft" align="right" valign="top"><a id="a1a0f34e14b9849b25c5b24c2b4941ad0" name="a1a0f34e14b9849b25c5b24c2b4941ad0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__bdev__open__async__opts.html">spdk_bdev_open_async_opts</a>)==16, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a1a0f34e14b9849b25c5b24c2b4941ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29e58cf7325dbc4f4ca8e0abb2d9506" id="r_af29e58cf7325dbc4f4ca8e0abb2d9506"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af29e58cf7325dbc4f4ca8e0abb2d9506">spdk_bdev_open_async</a> (const char *bdev_name, bool write, <a class="el" href="#ab4755b1b0a2a204732c3be266b6e1b08">spdk_bdev_event_cb_t</a> event_cb, void *event_ctx, struct <a class="el" href="structspdk__bdev__open__async__opts.html">spdk_bdev_open_async_opts</a> *opts, <a class="el" href="#a0253fe337c6697d014adffde6f8cd000">spdk_bdev_open_async_cb_t</a> open_cb, void *open_cb_arg)</td></tr>
<tr class="memdesc:af29e58cf7325dbc4f4ca8e0abb2d9506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a block device for I/O operations asynchronously with options.  <br /></td></tr>
<tr class="separator:af29e58cf7325dbc4f4ca8e0abb2d9506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5fc830851a2eb0aa34bbb40cf5eac6" id="r_aaf5fc830851a2eb0aa34bbb40cf5eac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf5fc830851a2eb0aa34bbb40cf5eac6">spdk_bdev_close</a> (struct spdk_bdev_desc *desc)</td></tr>
<tr class="memdesc:aaf5fc830851a2eb0aa34bbb40cf5eac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a previously opened block device.  <br /></td></tr>
<tr class="separator:aaf5fc830851a2eb0aa34bbb40cf5eac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93dda3868b191be70ac7e1517422c1f" id="r_ac93dda3868b191be70ac7e1517422c1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac93dda3868b191be70ac7e1517422c1f">spdk_for_each_bdev</a> (void *ctx, <a class="el" href="#a4163854db79e0e3b211dd72ca031fbb0">spdk_for_each_bdev_fn</a> fn)</td></tr>
<tr class="memdesc:ac93dda3868b191be70ac7e1517422c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the provided callback function for every registered block device.  <br /></td></tr>
<tr class="separator:ac93dda3868b191be70ac7e1517422c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb680eb5205197872738e482204ab441" id="r_aeb680eb5205197872738e482204ab441"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb680eb5205197872738e482204ab441">spdk_for_each_bdev_leaf</a> (void *ctx, <a class="el" href="#a4163854db79e0e3b211dd72ca031fbb0">spdk_for_each_bdev_fn</a> fn)</td></tr>
<tr class="memdesc:aeb680eb5205197872738e482204ab441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the provided callback function for every block device without virtual block devices on top.  <br /></td></tr>
<tr class="separator:aeb680eb5205197872738e482204ab441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae05ee98ddd0903932505782191805da" id="r_aae05ee98ddd0903932505782191805da"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae05ee98ddd0903932505782191805da">spdk_bdev_desc_get_bdev</a> (struct spdk_bdev_desc *desc)</td></tr>
<tr class="memdesc:aae05ee98ddd0903932505782191805da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bdev associated with a bdev descriptor.  <br /></td></tr>
<tr class="separator:aae05ee98ddd0903932505782191805da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fc679da6beac3cf9677f1bf97c6974" id="r_af0fc679da6beac3cf9677f1bf97c6974"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0fc679da6beac3cf9677f1bf97c6974">spdk_bdev_set_timeout</a> (struct spdk_bdev_desc *desc, uint64_t timeout_in_sec, <a class="el" href="#a83db84993554e784cbddf2d217f6ea4f">spdk_bdev_io_timeout_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:af0fc679da6beac3cf9677f1bf97c6974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a time limit for the timeout IO of the bdev and timeout callback.  <br /></td></tr>
<tr class="separator:af0fc679da6beac3cf9677f1bf97c6974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd5dff692dc162459801d5649fe7655" id="r_a7cd5dff692dc162459801d5649fe7655"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cd5dff692dc162459801d5649fe7655">spdk_bdev_io_type_supported</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, enum <a class="el" href="#a633029e24ab5ae4a689bffa2565a519f">spdk_bdev_io_type</a> io_type)</td></tr>
<tr class="memdesc:a7cd5dff692dc162459801d5649fe7655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the block device supports the I/O type.  <br /></td></tr>
<tr class="separator:a7cd5dff692dc162459801d5649fe7655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5216be2decc3b5f2d91416debb54ee7c" id="r_a5216be2decc3b5f2d91416debb54ee7c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5216be2decc3b5f2d91416debb54ee7c">spdk_bdev_get_io_type_name</a> (enum <a class="el" href="#a633029e24ab5ae4a689bffa2565a519f">spdk_bdev_io_type</a> io_type)</td></tr>
<tr class="memdesc:a5216be2decc3b5f2d91416debb54ee7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the name of an IO type based on the io_type.  <br /></td></tr>
<tr class="separator:a5216be2decc3b5f2d91416debb54ee7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef2e861ccd2d6135bfe13257f047fb9" id="r_a3ef2e861ccd2d6135bfe13257f047fb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ef2e861ccd2d6135bfe13257f047fb9">spdk_bdev_dump_info_json</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, struct spdk_json_write_ctx *w)</td></tr>
<tr class="memdesc:a3ef2e861ccd2d6135bfe13257f047fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output driver-specific information to a JSON stream.  <br /></td></tr>
<tr class="separator:a3ef2e861ccd2d6135bfe13257f047fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0cdb8ad1ebf94503b22f86d480a177" id="r_aac0cdb8ad1ebf94503b22f86d480a177"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac0cdb8ad1ebf94503b22f86d480a177">spdk_bdev_get_name</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:aac0cdb8ad1ebf94503b22f86d480a177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device name.  <br /></td></tr>
<tr class="separator:aac0cdb8ad1ebf94503b22f86d480a177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02ca23e2e84b353e8d827a6d854518f" id="r_ae02ca23e2e84b353e8d827a6d854518f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae02ca23e2e84b353e8d827a6d854518f">spdk_bdev_get_product_name</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:ae02ca23e2e84b353e8d827a6d854518f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device product name.  <br /></td></tr>
<tr class="separator:ae02ca23e2e84b353e8d827a6d854518f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba8c5672c8226b9b63f44543518c527" id="r_a3ba8c5672c8226b9b63f44543518c527"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ba8c5672c8226b9b63f44543518c527">spdk_bdev_get_block_size</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:a3ba8c5672c8226b9b63f44543518c527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device logical block size.  <br /></td></tr>
<tr class="separator:a3ba8c5672c8226b9b63f44543518c527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5775a23cadb2eb1d5381dc105577a37" id="r_ab5775a23cadb2eb1d5381dc105577a37"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5775a23cadb2eb1d5381dc105577a37">spdk_bdev_get_write_unit_size</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:ab5775a23cadb2eb1d5381dc105577a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the write unit size for this bdev.  <br /></td></tr>
<tr class="separator:ab5775a23cadb2eb1d5381dc105577a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86568eca8f0b4d0dc9bc59c5138fc7a5" id="r_a86568eca8f0b4d0dc9bc59c5138fc7a5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86568eca8f0b4d0dc9bc59c5138fc7a5">spdk_bdev_get_num_blocks</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:a86568eca8f0b4d0dc9bc59c5138fc7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of block device in logical blocks.  <br /></td></tr>
<tr class="separator:a86568eca8f0b4d0dc9bc59c5138fc7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc5e01fbba1ecadab98ff7d04a95489" id="r_acdc5e01fbba1ecadab98ff7d04a95489"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdc5e01fbba1ecadab98ff7d04a95489">spdk_bdev_get_qos_rpc_type</a> (enum <a class="el" href="#aedfbfc44fa2113d7ee219d09a0994d93">spdk_bdev_qos_rate_limit_type</a> type)</td></tr>
<tr class="memdesc:acdc5e01fbba1ecadab98ff7d04a95489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string of quality of service rate limit.  <br /></td></tr>
<tr class="separator:acdc5e01fbba1ecadab98ff7d04a95489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c63fbd418d5a77f34ddca9a4268f41" id="r_a08c63fbd418d5a77f34ddca9a4268f41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08c63fbd418d5a77f34ddca9a4268f41">spdk_bdev_get_qos_rate_limits</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, uint64_t *limits)</td></tr>
<tr class="memdesc:a08c63fbd418d5a77f34ddca9a4268f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the quality of service rate limits on a bdev.  <br /></td></tr>
<tr class="separator:a08c63fbd418d5a77f34ddca9a4268f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70520c668368881df8d7410fec9b1a08" id="r_a70520c668368881df8d7410fec9b1a08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70520c668368881df8d7410fec9b1a08">spdk_bdev_set_qos_rate_limits</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, uint64_t *limits, void(*cb_fn)(void *cb_arg, int status), void *cb_arg)</td></tr>
<tr class="memdesc:a70520c668368881df8d7410fec9b1a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the quality of service rate limits on a bdev.  <br /></td></tr>
<tr class="separator:a70520c668368881df8d7410fec9b1a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d238484b372a77ba130fbb70f83519" id="r_ab4d238484b372a77ba130fbb70f83519"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4d238484b372a77ba130fbb70f83519">spdk_bdev_get_buf_align</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:ab4d238484b372a77ba130fbb70f83519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimum I/O buffer address alignment for a bdev.  <br /></td></tr>
<tr class="separator:ab4d238484b372a77ba130fbb70f83519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79625889e23318204d235da36a4fa02" id="r_aa79625889e23318204d235da36a4fa02"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa79625889e23318204d235da36a4fa02">spdk_bdev_get_optimal_io_boundary</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:aa79625889e23318204d235da36a4fa02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get optimal I/O boundary for a bdev.  <br /></td></tr>
<tr class="separator:aa79625889e23318204d235da36a4fa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f6d6ce09da384501f09a49581caa37" id="r_a93f6d6ce09da384501f09a49581caa37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93f6d6ce09da384501f09a49581caa37">spdk_bdev_has_write_cache</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:a93f6d6ce09da384501f09a49581caa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether block device has an enabled write cache.  <br /></td></tr>
<tr class="separator:a93f6d6ce09da384501f09a49581caa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e829afdd5236f5e979b0c3663a8067" id="r_af3e829afdd5236f5e979b0c3663a8067"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__uuid.html">spdk_uuid</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3e829afdd5236f5e979b0c3663a8067">spdk_bdev_get_uuid</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:af3e829afdd5236f5e979b0c3663a8067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a bdev's UUID.  <br /></td></tr>
<tr class="separator:af3e829afdd5236f5e979b0c3663a8067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8414b6c4af71136f0c1cb7af4a8d33fa" id="r_a8414b6c4af71136f0c1cb7af4a8d33fa"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8414b6c4af71136f0c1cb7af4a8d33fa">spdk_bdev_get_acwu</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:a8414b6c4af71136f0c1cb7af4a8d33fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device atomic compare and write unit.  <br /></td></tr>
<tr class="separator:a8414b6c4af71136f0c1cb7af4a8d33fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3537d0315100b24da6acc95929e849" id="r_abc3537d0315100b24da6acc95929e849"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc3537d0315100b24da6acc95929e849">spdk_bdev_get_md_size</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:abc3537d0315100b24da6acc95929e849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device metadata size.  <br /></td></tr>
<tr class="separator:abc3537d0315100b24da6acc95929e849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02f628c6ef7cae08b8b623b4800c74d" id="r_aa02f628c6ef7cae08b8b623b4800c74d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa02f628c6ef7cae08b8b623b4800c74d">spdk_bdev_is_md_interleaved</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:aa02f628c6ef7cae08b8b623b4800c74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether metadata is interleaved with block data or separated with block data.  <br /></td></tr>
<tr class="separator:aa02f628c6ef7cae08b8b623b4800c74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c880555f4d66991c1fd9dbd3abaf4f" id="r_ac8c880555f4d66991c1fd9dbd3abaf4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8c880555f4d66991c1fd9dbd3abaf4f">spdk_bdev_is_md_separate</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:ac8c880555f4d66991c1fd9dbd3abaf4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether metadata is interleaved with block data or separated from block data.  <br /></td></tr>
<tr class="separator:ac8c880555f4d66991c1fd9dbd3abaf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e334778f2dfb469e2f96bcd42c6343b" id="r_a2e334778f2dfb469e2f96bcd42c6343b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e334778f2dfb469e2f96bcd42c6343b">spdk_bdev_is_zoned</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:a2e334778f2dfb469e2f96bcd42c6343b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if bdev supports zoned namespace semantics.  <br /></td></tr>
<tr class="separator:a2e334778f2dfb469e2f96bcd42c6343b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84041f3948f91dc0dd0656895970061a" id="r_a84041f3948f91dc0dd0656895970061a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84041f3948f91dc0dd0656895970061a">spdk_bdev_get_data_block_size</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:a84041f3948f91dc0dd0656895970061a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device data block size.  <br /></td></tr>
<tr class="separator:a84041f3948f91dc0dd0656895970061a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c895e82c51c654a5b3f838f7254d690" id="r_a2c895e82c51c654a5b3f838f7254d690"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c895e82c51c654a5b3f838f7254d690">spdk_bdev_get_physical_block_size</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:a2c895e82c51c654a5b3f838f7254d690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device physical block size.  <br /></td></tr>
<tr class="separator:a2c895e82c51c654a5b3f838f7254d690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94b5900766ec42da5fc3658a5749858" id="r_ac94b5900766ec42da5fc3658a5749858"><td class="memItemLeft" align="right" valign="top">enum spdk_dif_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac94b5900766ec42da5fc3658a5749858">spdk_bdev_get_dif_type</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:ac94b5900766ec42da5fc3658a5749858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get DIF type of the block device.  <br /></td></tr>
<tr class="separator:ac94b5900766ec42da5fc3658a5749858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e43a19692e14e5e46b3315e4cf0bc1d" id="r_a4e43a19692e14e5e46b3315e4cf0bc1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e43a19692e14e5e46b3315e4cf0bc1d">spdk_bdev_is_dif_head_of_md</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:a4e43a19692e14e5e46b3315e4cf0bc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether DIF is set in the first 8/16 bytes or the last 8/16 bytes of metadata.  <br /></td></tr>
<tr class="separator:a4e43a19692e14e5e46b3315e4cf0bc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147389751cd351d30703e28f522e9610" id="r_a147389751cd351d30703e28f522e9610"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a147389751cd351d30703e28f522e9610">spdk_bdev_is_dif_check_enabled</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, enum spdk_dif_check_type check_type)</td></tr>
<tr class="memdesc:a147389751cd351d30703e28f522e9610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the DIF check type is enabled.  <br /></td></tr>
<tr class="separator:a147389751cd351d30703e28f522e9610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b542430078d502325f37b92fc3d15ca" id="r_a8b542430078d502325f37b92fc3d15ca"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b542430078d502325f37b92fc3d15ca">spdk_bdev_get_max_copy</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:a8b542430078d502325f37b92fc3d15ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device max copy size.  <br /></td></tr>
<tr class="separator:a8b542430078d502325f37b92fc3d15ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471f32e8948203f7aaf320396a1ae7c9" id="r_a471f32e8948203f7aaf320396a1ae7c9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a471f32e8948203f7aaf320396a1ae7c9">spdk_bdev_get_qd</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:a471f32e8948203f7aaf320396a1ae7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the most recently measured queue depth from a bdev.  <br /></td></tr>
<tr class="separator:a471f32e8948203f7aaf320396a1ae7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab852ac707702316bf869a3d7dfdc85" id="r_adab852ac707702316bf869a3d7dfdc85"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adab852ac707702316bf869a3d7dfdc85">spdk_bdev_get_qd_sampling_period</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:adab852ac707702316bf869a3d7dfdc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the queue depth polling period.  <br /></td></tr>
<tr class="separator:adab852ac707702316bf869a3d7dfdc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d37ad1d4da0bcb51ada76dbe4f4ce15" id="r_a9d37ad1d4da0bcb51ada76dbe4f4ce15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d37ad1d4da0bcb51ada76dbe4f4ce15">spdk_bdev_set_qd_sampling_period</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, uint64_t period)</td></tr>
<tr class="memdesc:a9d37ad1d4da0bcb51ada76dbe4f4ce15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable queue depth sampling for this bdev.  <br /></td></tr>
<tr class="separator:a9d37ad1d4da0bcb51ada76dbe4f4ce15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a082eb89d57860b2e57ebf7f5b3caa2" id="r_a8a082eb89d57860b2e57ebf7f5b3caa2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a082eb89d57860b2e57ebf7f5b3caa2">spdk_bdev_get_io_time</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:a8a082eb89d57860b2e57ebf7f5b3caa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time spent processing IO for this device.  <br /></td></tr>
<tr class="separator:a8a082eb89d57860b2e57ebf7f5b3caa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526ab43ba037b8637a23e9d42289884e" id="r_a526ab43ba037b8637a23e9d42289884e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a526ab43ba037b8637a23e9d42289884e">spdk_bdev_get_weighted_io_time</a> (const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:a526ab43ba037b8637a23e9d42289884e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the weighted IO processing time for this bdev.  <br /></td></tr>
<tr class="separator:a526ab43ba037b8637a23e9d42289884e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9992f445e8adf2b9f4fd38ac4978762" id="r_ac9992f445e8adf2b9f4fd38ac4978762"><td class="memItemLeft" align="right" valign="top">struct spdk_io_channel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9992f445e8adf2b9f4fd38ac4978762">spdk_bdev_get_io_channel</a> (struct spdk_bdev_desc *desc)</td></tr>
<tr class="memdesc:ac9992f445e8adf2b9f4fd38ac4978762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an I/O channel for the block device opened by the specified descriptor.  <br /></td></tr>
<tr class="separator:ac9992f445e8adf2b9f4fd38ac4978762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b596b58de9767fcd2030e5e07ddad41" id="r_a5b596b58de9767fcd2030e5e07ddad41"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b596b58de9767fcd2030e5e07ddad41">spdk_bdev_get_module_ctx</a> (struct spdk_bdev_desc *desc)</td></tr>
<tr class="memdesc:a5b596b58de9767fcd2030e5e07ddad41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a bdev module context for the block device opened by the specified descriptor.  <br /></td></tr>
<tr class="separator:a5b596b58de9767fcd2030e5e07ddad41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga368a41ccc1395faeaddc853a6f7f81d0" id="r_ga368a41ccc1395faeaddc853a6f7f81d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga368a41ccc1395faeaddc853a6f7f81d0">spdk_bdev_seek_data</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga368a41ccc1395faeaddc853a6f7f81d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a data seek request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga368a41ccc1395faeaddc853a6f7f81d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41233f5dd570c8ae72ea4749786a8172" id="r_ga41233f5dd570c8ae72ea4749786a8172"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga41233f5dd570c8ae72ea4749786a8172">spdk_bdev_seek_hole</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga41233f5dd570c8ae72ea4749786a8172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a hole seek request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga41233f5dd570c8ae72ea4749786a8172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b500ce84df1d2551f76e635c9dafbd5" id="r_ga4b500ce84df1d2551f76e635c9dafbd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga4b500ce84df1d2551f76e635c9dafbd5">spdk_bdev_read</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, uint64_t offset, uint64_t nbytes, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga4b500ce84df1d2551f76e635c9dafbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga4b500ce84df1d2551f76e635c9dafbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec9efd151e2fb34ee3d22a1edbbb53f" id="r_gaeec9efd151e2fb34ee3d22a1edbbb53f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#gaeec9efd151e2fb34ee3d22a1edbbb53f">spdk_bdev_read_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:gaeec9efd151e2fb34ee3d22a1edbbb53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:gaeec9efd151e2fb34ee3d22a1edbbb53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8784109649bebb80df9f9535467b85" id="r_gadc8784109649bebb80df9f9535467b85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#gadc8784109649bebb80df9f9535467b85">spdk_bdev_read_blocks_with_md</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, void *md, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:gadc8784109649bebb80df9f9535467b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:gadc8784109649bebb80df9f9535467b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ac9efa882e87909acfd4bccaddb1778" id="r_ga9ac9efa882e87909acfd4bccaddb1778"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga9ac9efa882e87909acfd4bccaddb1778">spdk_bdev_readv</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset, uint64_t nbytes, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga9ac9efa882e87909acfd4bccaddb1778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga9ac9efa882e87909acfd4bccaddb1778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55483d5ae010c514b37b976ad803b4b2" id="r_ga55483d5ae010c514b37b976ad803b4b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga55483d5ae010c514b37b976ad803b4b2">spdk_bdev_readv_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga55483d5ae010c514b37b976ad803b4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga55483d5ae010c514b37b976ad803b4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80f72a0b5b1e02a667ce15cc17ceefeb" id="r_ga80f72a0b5b1e02a667ce15cc17ceefeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga80f72a0b5b1e02a667ce15cc17ceefeb">spdk_bdev_readv_blocks_with_md</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, void *md, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga80f72a0b5b1e02a667ce15cc17ceefeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga80f72a0b5b1e02a667ce15cc17ceefeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8125396dbfee45c78c73534c6e7f22f3" id="r_ga8125396dbfee45c78c73534c6e7f22f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga8125396dbfee45c78c73534c6e7f22f3">spdk_bdev_readv_blocks_ext</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg, struct <a class="el" href="structspdk__bdev__ext__io__opts.html">spdk_bdev_ext_io_opts</a> *opts)</td></tr>
<tr class="memdesc:ga8125396dbfee45c78c73534c6e7f22f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga8125396dbfee45c78c73534c6e7f22f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa740a114ef34d6a2f126d4e3a9dd9e9b" id="r_gaa740a114ef34d6a2f126d4e3a9dd9e9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#gaa740a114ef34d6a2f126d4e3a9dd9e9b">spdk_bdev_write</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, uint64_t offset, uint64_t nbytes, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:gaa740a114ef34d6a2f126d4e3a9dd9e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:gaa740a114ef34d6a2f126d4e3a9dd9e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12da8917f525a6e11cbf22b2b7652c89" id="r_ga12da8917f525a6e11cbf22b2b7652c89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga12da8917f525a6e11cbf22b2b7652c89">spdk_bdev_write_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga12da8917f525a6e11cbf22b2b7652c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga12da8917f525a6e11cbf22b2b7652c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01380182ca77b43e2a854aa59058fe12" id="r_ga01380182ca77b43e2a854aa59058fe12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga01380182ca77b43e2a854aa59058fe12">spdk_bdev_write_blocks_with_md</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, void *md, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga01380182ca77b43e2a854aa59058fe12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga01380182ca77b43e2a854aa59058fe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a508a1c301a1321faf0680a8f31f59a" id="r_ga9a508a1c301a1321faf0680a8f31f59a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga9a508a1c301a1321faf0680a8f31f59a">spdk_bdev_writev</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset, uint64_t len, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga9a508a1c301a1321faf0680a8f31f59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga9a508a1c301a1321faf0680a8f31f59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5849064d12de9f140a41522d1f7c95b" id="r_gaf5849064d12de9f140a41522d1f7c95b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#gaf5849064d12de9f140a41522d1f7c95b">spdk_bdev_writev_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:gaf5849064d12de9f140a41522d1f7c95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:gaf5849064d12de9f140a41522d1f7c95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga635944e7a651c01ecf5d808f988d138d" id="r_ga635944e7a651c01ecf5d808f988d138d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga635944e7a651c01ecf5d808f988d138d">spdk_bdev_writev_blocks_with_md</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, void *md, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga635944e7a651c01ecf5d808f988d138d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga635944e7a651c01ecf5d808f988d138d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga418f6f4ab853a3152a7f7ba256894a3f" id="r_ga418f6f4ab853a3152a7f7ba256894a3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga418f6f4ab853a3152a7f7ba256894a3f">spdk_bdev_writev_blocks_ext</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg, struct <a class="el" href="structspdk__bdev__ext__io__opts.html">spdk_bdev_ext_io_opts</a> *opts)</td></tr>
<tr class="memdesc:ga418f6f4ab853a3152a7f7ba256894a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga418f6f4ab853a3152a7f7ba256894a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0846ab7b6c938f0f52ac36cd09a75278" id="r_ga0846ab7b6c938f0f52ac36cd09a75278"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga0846ab7b6c938f0f52ac36cd09a75278">spdk_bdev_compare_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga0846ab7b6c938f0f52ac36cd09a75278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a compare request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga0846ab7b6c938f0f52ac36cd09a75278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a69444aaff6f046f7de8524e8c886d8" id="r_ga8a69444aaff6f046f7de8524e8c886d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga8a69444aaff6f046f7de8524e8c886d8">spdk_bdev_compare_blocks_with_md</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, void *md, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga8a69444aaff6f046f7de8524e8c886d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a compare request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga8a69444aaff6f046f7de8524e8c886d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf27fa5b35ac2a8d7d78cb31fa8500c8c" id="r_gaf27fa5b35ac2a8d7d78cb31fa8500c8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#gaf27fa5b35ac2a8d7d78cb31fa8500c8c">spdk_bdev_comparev_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:gaf27fa5b35ac2a8d7d78cb31fa8500c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a compare request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:gaf27fa5b35ac2a8d7d78cb31fa8500c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga323ccdb094b61f56840f29745339ceb3" id="r_ga323ccdb094b61f56840f29745339ceb3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga323ccdb094b61f56840f29745339ceb3">spdk_bdev_comparev_blocks_with_md</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, void *md, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga323ccdb094b61f56840f29745339ceb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a compare request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga323ccdb094b61f56840f29745339ceb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaa766d5c5ca4bc2979e1f5f9015ef11" id="r_gafaa766d5c5ca4bc2979e1f5f9015ef11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#gafaa766d5c5ca4bc2979e1f5f9015ef11">spdk_bdev_comparev_and_writev_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *compare_iov, int compare_iovcnt, struct iovec *write_iov, int write_iovcnt, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:gafaa766d5c5ca4bc2979e1f5f9015ef11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an atomic compare-and-write request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:gafaa766d5c5ca4bc2979e1f5f9015ef11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae02ac58ed10886d4a00ba3d94af4ce" id="r_a0ae02ac58ed10886d4a00ba3d94af4ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ae02ac58ed10886d4a00ba3d94af4ce">spdk_bdev_zcopy_start</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset_blocks, uint64_t num_blocks, bool populate, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a0ae02ac58ed10886d4a00ba3d94af4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a request to acquire a data buffer that represents the given range of blocks.  <br /></td></tr>
<tr class="separator:a0ae02ac58ed10886d4a00ba3d94af4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac432e059187b2dee62418354664e87c2" id="r_ac432e059187b2dee62418354664e87c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac432e059187b2dee62418354664e87c2">spdk_bdev_zcopy_end</a> (struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *bdev_io, bool commit, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ac432e059187b2dee62418354664e87c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a request to release a data buffer representing a range of blocks.  <br /></td></tr>
<tr class="separator:ac432e059187b2dee62418354664e87c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc50b78fec7f69190d9139aff29a9043" id="r_gadc50b78fec7f69190d9139aff29a9043"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#gadc50b78fec7f69190d9139aff29a9043">spdk_bdev_write_zeroes</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset, uint64_t len, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:gadc50b78fec7f69190d9139aff29a9043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write zeroes request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:gadc50b78fec7f69190d9139aff29a9043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga047f8a9f8d0a3d1d7bfcdf0a9838b261" id="r_ga047f8a9f8d0a3d1d7bfcdf0a9838b261"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga047f8a9f8d0a3d1d7bfcdf0a9838b261">spdk_bdev_write_zeroes_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga047f8a9f8d0a3d1d7bfcdf0a9838b261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write zeroes request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga047f8a9f8d0a3d1d7bfcdf0a9838b261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga680c9c302998f7b003e2476e35d9ae4b" id="r_ga680c9c302998f7b003e2476e35d9ae4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga680c9c302998f7b003e2476e35d9ae4b">spdk_bdev_unmap</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset, uint64_t nbytes, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga680c9c302998f7b003e2476e35d9ae4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an unmap request to the block device.  <br /></td></tr>
<tr class="separator:ga680c9c302998f7b003e2476e35d9ae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7555fdd41019e29b40e535b72457d30b" id="r_ga7555fdd41019e29b40e535b72457d30b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga7555fdd41019e29b40e535b72457d30b">spdk_bdev_unmap_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga7555fdd41019e29b40e535b72457d30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an unmap request to the block device.  <br /></td></tr>
<tr class="separator:ga7555fdd41019e29b40e535b72457d30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7105b63cc84037543d9472ab33c8be93" id="r_ga7105b63cc84037543d9472ab33c8be93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga7105b63cc84037543d9472ab33c8be93">spdk_bdev_flush</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset, uint64_t length, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga7105b63cc84037543d9472ab33c8be93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a flush request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga7105b63cc84037543d9472ab33c8be93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d84cd937e760cf32756654dc9720ed4" id="r_ga9d84cd937e760cf32756654dc9720ed4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga9d84cd937e760cf32756654dc9720ed4">spdk_bdev_flush_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga9d84cd937e760cf32756654dc9720ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a flush request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga9d84cd937e760cf32756654dc9720ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca574d3e94be6150343823dd2e7ecf46" id="r_gaca574d3e94be6150343823dd2e7ecf46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#gaca574d3e94be6150343823dd2e7ecf46">spdk_bdev_reset</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:gaca574d3e94be6150343823dd2e7ecf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a reset request to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:gaca574d3e94be6150343823dd2e7ecf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga841dcef50460f33c8b5e321e187dc3dd" id="r_ga841dcef50460f33c8b5e321e187dc3dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga841dcef50460f33c8b5e321e187dc3dd">spdk_bdev_abort</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *bio_cb_arg, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga841dcef50460f33c8b5e321e187dc3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit abort requests to abort all I/Os which has bio_cb_arg as its callback context to the bdev on the given channel.  <br /></td></tr>
<tr class="separator:ga841dcef50460f33c8b5e321e187dc3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2249ef71e7125338b6cebf935a881ab" id="r_gae2249ef71e7125338b6cebf935a881ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#gae2249ef71e7125338b6cebf935a881ab">spdk_bdev_nvme_admin_passthru</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, size_t nbytes, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:gae2249ef71e7125338b6cebf935a881ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an NVMe Admin command to the bdev.  <br /></td></tr>
<tr class="separator:gae2249ef71e7125338b6cebf935a881ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab172cf6afc9ef154bd823b91b09dee87" id="r_gab172cf6afc9ef154bd823b91b09dee87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#gab172cf6afc9ef154bd823b91b09dee87">spdk_bdev_nvme_io_passthru</a> (struct spdk_bdev_desc *bdev_desc, struct spdk_io_channel *ch, const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, size_t nbytes, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:gab172cf6afc9ef154bd823b91b09dee87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an NVMe I/O command to the bdev.  <br /></td></tr>
<tr class="separator:gab172cf6afc9ef154bd823b91b09dee87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b5933e4c0b2ad68bad591655b4f9e6" id="r_gac6b5933e4c0b2ad68bad591655b4f9e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#gac6b5933e4c0b2ad68bad591655b4f9e6">spdk_bdev_nvme_io_passthru_md</a> (struct spdk_bdev_desc *bdev_desc, struct spdk_io_channel *ch, const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, size_t nbytes, void *md_buf, size_t md_len, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:gac6b5933e4c0b2ad68bad591655b4f9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an NVMe I/O command to the bdev.  <br /></td></tr>
<tr class="separator:gac6b5933e4c0b2ad68bad591655b4f9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42545d4c7c98398a8750a30b26167a3d" id="r_ga42545d4c7c98398a8750a30b26167a3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#ga42545d4c7c98398a8750a30b26167a3d">spdk_bdev_nvme_iov_passthru_md</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, struct iovec *iov, int iovcnt, size_t nbytes, void *md_buf, size_t md_len, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ga42545d4c7c98398a8750a30b26167a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an NVMe I/O command to the bdev.  <br /></td></tr>
<tr class="separator:ga42545d4c7c98398a8750a30b26167a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea6141ec0cb4090741c6be7ae6927dae" id="r_gaea6141ec0cb4090741c6be7ae6927dae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bdev__io__submit__functions.html#gaea6141ec0cb4090741c6be7ae6927dae">spdk_bdev_copy_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t dst_offset_blocks, uint64_t src_offset_blocks, uint64_t num_blocks, <a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:gaea6141ec0cb4090741c6be7ae6927dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a copy request to the block device.  <br /></td></tr>
<tr class="separator:gaea6141ec0cb4090741c6be7ae6927dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac23d38eb3b56b58197e0111ef68c6b" id="r_a9ac23d38eb3b56b58197e0111ef68c6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ac23d38eb3b56b58197e0111ef68c6b">spdk_bdev_free_io</a> (struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *bdev_io)</td></tr>
<tr class="memdesc:a9ac23d38eb3b56b58197e0111ef68c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an I/O request.  <br /></td></tr>
<tr class="separator:a9ac23d38eb3b56b58197e0111ef68c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4beee18ded7837fa92bd7c34e7ef2e" id="r_acc4beee18ded7837fa92bd7c34e7ef2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc4beee18ded7837fa92bd7c34e7ef2e">spdk_bdev_queue_io_wait</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, struct spdk_io_channel *ch, struct <a class="el" href="structspdk__bdev__io__wait__entry.html">spdk_bdev_io_wait_entry</a> *entry)</td></tr>
<tr class="memdesc:acc4beee18ded7837fa92bd7c34e7ef2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an entry into the calling thread's queue to be notified when an <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> becomes available.  <br /></td></tr>
<tr class="separator:acc4beee18ded7837fa92bd7c34e7ef2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ba28ba382edd1d792d51a054eb3aa2" id="r_ab1ba28ba382edd1d792d51a054eb3aa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1ba28ba382edd1d792d51a054eb3aa2">spdk_bdev_get_io_stat</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, struct spdk_io_channel *ch, struct <a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a> *stat)</td></tr>
<tr class="memdesc:ab1ba28ba382edd1d792d51a054eb3aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return I/O statistics for this channel.  <br /></td></tr>
<tr class="separator:ab1ba28ba382edd1d792d51a054eb3aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa478b43fc9e6e41c34438f5b2ef742d5" id="r_aa478b43fc9e6e41c34438f5b2ef742d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa478b43fc9e6e41c34438f5b2ef742d5">spdk_bdev_get_device_stat</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, struct <a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a> *stat, spdk_bdev_get_device_stat_cb cb, void *cb_arg)</td></tr>
<tr class="memdesc:aa478b43fc9e6e41c34438f5b2ef742d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return I/O statistics for this bdev.  <br /></td></tr>
<tr class="separator:aa478b43fc9e6e41c34438f5b2ef742d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e1bf90f44f042c2b2ad463b8667735" id="r_ae7e1bf90f44f042c2b2ad463b8667735"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7e1bf90f44f042c2b2ad463b8667735">spdk_bdev_io_get_nvme_status</a> (const struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *bdev_io, uint32_t *cdw0, int *sct, int *sc)</td></tr>
<tr class="memdesc:ae7e1bf90f44f042c2b2ad463b8667735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of bdev_io as an NVMe status code and command specific completion queue value.  <br /></td></tr>
<tr class="separator:ae7e1bf90f44f042c2b2ad463b8667735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c7d2a0cf76be7d06d9dc5e09553ec8" id="r_a44c7d2a0cf76be7d06d9dc5e09553ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44c7d2a0cf76be7d06d9dc5e09553ec8">spdk_bdev_io_get_nvme_fused_status</a> (const struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *bdev_io, uint32_t *cdw0, int *first_sct, int *first_sc, int *second_sct, int *second_sc)</td></tr>
<tr class="memdesc:a44c7d2a0cf76be7d06d9dc5e09553ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of bdev_io as an NVMe status codes and command specific completion queue value for fused operations such as compare-and-write.  <br /></td></tr>
<tr class="separator:a44c7d2a0cf76be7d06d9dc5e09553ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c213b4317d5077197950253af1ac50" id="r_ac3c213b4317d5077197950253af1ac50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3c213b4317d5077197950253af1ac50">spdk_bdev_io_get_scsi_status</a> (const struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *bdev_io, int *sc, int *sk, int *asc, int *ascq)</td></tr>
<tr class="memdesc:ac3c213b4317d5077197950253af1ac50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of bdev_io as a SCSI status code.  <br /></td></tr>
<tr class="separator:ac3c213b4317d5077197950253af1ac50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701290c13896ad545b58f5c5fecfbd93" id="r_a701290c13896ad545b58f5c5fecfbd93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a701290c13896ad545b58f5c5fecfbd93">spdk_bdev_io_get_aio_status</a> (const struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *bdev_io, int *aio_result)</td></tr>
<tr class="memdesc:a701290c13896ad545b58f5c5fecfbd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of bdev_io as aio errno.  <br /></td></tr>
<tr class="separator:a701290c13896ad545b58f5c5fecfbd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05d8c0e82bfbcc209af1eb958230ede" id="r_aa05d8c0e82bfbcc209af1eb958230ede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa05d8c0e82bfbcc209af1eb958230ede">spdk_bdev_io_get_iovec</a> (struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *bdev_io, struct iovec **iovp, int *iovcntp)</td></tr>
<tr class="memdesc:aa05d8c0e82bfbcc209af1eb958230ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the iovec describing the data buffer of a bdev_io.  <br /></td></tr>
<tr class="separator:aa05d8c0e82bfbcc209af1eb958230ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee6dce0e4ed7045a9457af0b0486082" id="r_a3ee6dce0e4ed7045a9457af0b0486082"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ee6dce0e4ed7045a9457af0b0486082">spdk_bdev_io_get_md_buf</a> (struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *bdev_io)</td></tr>
<tr class="memdesc:a3ee6dce0e4ed7045a9457af0b0486082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get metadata buffer.  <br /></td></tr>
<tr class="separator:a3ee6dce0e4ed7045a9457af0b0486082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567ddcb43834b7f29289d7d369e89c4d" id="r_a567ddcb43834b7f29289d7d369e89c4d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a567ddcb43834b7f29289d7d369e89c4d">spdk_bdev_io_get_cb_arg</a> (struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *bdev_io)</td></tr>
<tr class="memdesc:a567ddcb43834b7f29289d7d369e89c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the callback argument of bdev_io to abort it by spdk_bdev_abort.  <br /></td></tr>
<tr class="separator:a567ddcb43834b7f29289d7d369e89c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03943b94f83f3402fb8da4093985a829" id="r_a03943b94f83f3402fb8da4093985a829"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03943b94f83f3402fb8da4093985a829">spdk_bdev_io_get_seek_offset</a> (const struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *bdev_io)</td></tr>
<tr class="memdesc:a03943b94f83f3402fb8da4093985a829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result of a previous seek function.  <br /></td></tr>
<tr class="separator:a03943b94f83f3402fb8da4093985a829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4556cb07c52ae7b5b7e7f10cbdc637" id="r_a0b4556cb07c52ae7b5b7e7f10cbdc637"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b4556cb07c52ae7b5b7e7f10cbdc637">spdk_bdev_histogram_enable</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, spdk_bdev_histogram_status_cb cb_fn, void *cb_arg, bool enable)</td></tr>
<tr class="memdesc:a0b4556cb07c52ae7b5b7e7f10cbdc637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable collecting histogram data on a bdev.  <br /></td></tr>
<tr class="separator:a0b4556cb07c52ae7b5b7e7f10cbdc637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf15571883da5a441297b5090e6aaf5" id="r_aacf15571883da5a441297b5090e6aaf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacf15571883da5a441297b5090e6aaf5">spdk_bdev_histogram_get</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, struct <a class="el" href="structspdk__histogram__data.html">spdk_histogram_data</a> *histogram, spdk_bdev_histogram_data_cb cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aacf15571883da5a441297b5090e6aaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get aggregated histogram data from a bdev.  <br /></td></tr>
<tr class="separator:aacf15571883da5a441297b5090e6aaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83092483a9de9f7d736ef4ceaaf0d26c" id="r_a83092483a9de9f7d736ef4ceaaf0d26c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83092483a9de9f7d736ef4ceaaf0d26c">spdk_bdev_channel_get_histogram</a> (struct spdk_io_channel *ch, spdk_bdev_histogram_data_cb cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a83092483a9de9f7d736ef4ceaaf0d26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get histogram data of the specified channel for a bdev.  <br /></td></tr>
<tr class="separator:a83092483a9de9f7d736ef4ceaaf0d26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af359a282820d73a253ffbbe127a30b96" id="r_af359a282820d73a253ffbbe127a30b96"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af359a282820d73a253ffbbe127a30b96">spdk_bdev_get_media_events</a> (struct spdk_bdev_desc *bdev_desc, struct <a class="el" href="structspdk__bdev__media__event.html">spdk_bdev_media_event</a> *events, size_t max_events)</td></tr>
<tr class="memdesc:af359a282820d73a253ffbbe127a30b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves media events.  <br /></td></tr>
<tr class="separator:af359a282820d73a253ffbbe127a30b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2643db603c5c9762d839036c1658bf1b" id="r_a2643db603c5c9762d839036c1658bf1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2643db603c5c9762d839036c1658bf1b">spdk_bdev_get_memory_domains</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, struct spdk_memory_domain **domains, int array_size)</td></tr>
<tr class="memdesc:a2643db603c5c9762d839036c1658bf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SPDK memory domains used by the given bdev.  <br /></td></tr>
<tr class="separator:a2643db603c5c9762d839036c1658bf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576acbae728d3d4ecc83ea5603cdd3f9" id="r_a576acbae728d3d4ecc83ea5603cdd3f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a576acbae728d3d4ecc83ea5603cdd3f9">spdk_bdev_for_each_channel_continue</a> (struct spdk_bdev_channel_iter *i, int status)</td></tr>
<tr class="memdesc:a576acbae728d3d4ecc83ea5603cdd3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to iterate the next channel for <a class="el" href="#a1b51dde3495e6b37f172e172cca3cfd2" title="Call &#39;fn&#39; on each channel associated with the given bdev.">spdk_bdev_for_each_channel()</a>.  <br /></td></tr>
<tr class="separator:a576acbae728d3d4ecc83ea5603cdd3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b51dde3495e6b37f172e172cca3cfd2" id="r_a1b51dde3495e6b37f172e172cca3cfd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b51dde3495e6b37f172e172cca3cfd2">spdk_bdev_for_each_channel</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, <a class="el" href="#a4ac2a1bd295f6c71dbe706e61f5f6ac4">spdk_bdev_for_each_channel_msg</a> fn, void *ctx, <a class="el" href="#a16f406e9a97a6ac7072867bdcc7c1df1">spdk_bdev_for_each_channel_done</a> cpl)</td></tr>
<tr class="memdesc:a1b51dde3495e6b37f172e172cca3cfd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call 'fn' on each channel associated with the given bdev.  <br /></td></tr>
<tr class="separator:a1b51dde3495e6b37f172e172cca3cfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af833943e22885817e6954426b6a11b5f" id="r_af833943e22885817e6954426b6a11b5f"><td class="memItemLeft" align="right" valign="top">union <a class="el" href="unionspdk__bdev__nvme__ctratt.html">spdk_bdev_nvme_ctratt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af833943e22885817e6954426b6a11b5f">spdk_bdev_get_nvme_ctratt</a> (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td></tr>
<tr class="memdesc:af833943e22885817e6954426b6a11b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get controller attributes for the bdev.  <br /></td></tr>
<tr class="separator:af833943e22885817e6954426b6a11b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Block device abstraction layer. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ab4755b1b0a2a204732c3be266b6e1b08" name="ab4755b1b0a2a204732c3be266b6e1b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4755b1b0a2a204732c3be266b6e1b08">&#9670;&#160;</a></span>spdk_bdev_event_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bdev_event_cb_t) (enum <a class="el" href="#a13e432c6b290dcf392335a406206fd83">spdk_bdev_event_type</a> type, struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, void *event_ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block device event callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Event type. </td></tr>
    <tr><td class="paramname">bdev</td><td>Block device that triggered event. </td></tr>
    <tr><td class="paramname">event_ctx</td><td>Context for the block device event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad33efc88148d8984b353e54b7ee0058f" name="ad33efc88148d8984b353e54b7ee0058f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33efc88148d8984b353e54b7ee0058f">&#9670;&#160;</a></span>spdk_bdev_fini_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bdev_fini_cb) (void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block device finish callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16f406e9a97a6ac7072867bdcc7c1df1" name="a16f406e9a97a6ac7072867bdcc7c1df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f406e9a97a6ac7072867bdcc7c1df1">&#9670;&#160;</a></span>spdk_bdev_for_each_channel_done</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bdev_for_each_channel_done) (struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, void *ctx, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#a1b51dde3495e6b37f172e172cca3cfd2" title="Call &#39;fn&#39; on each channel associated with the given bdev.">spdk_bdev_for_each_channel()</a> function's final callback with the given bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device. </td></tr>
    <tr><td class="paramname">ctx</td><td>context of the bdev channel iterator. </td></tr>
    <tr><td class="paramname">status</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ac2a1bd295f6c71dbe706e61f5f6ac4" name="a4ac2a1bd295f6c71dbe706e61f5f6ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac2a1bd295f6c71dbe706e61f5f6ac4">&#9670;&#160;</a></span>spdk_bdev_for_each_channel_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bdev_for_each_channel_msg) (struct spdk_bdev_channel_iter *i, struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, struct spdk_io_channel *ch, void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called on the appropriate thread for each channel associated with the given bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>bdev channel iterator. </td></tr>
    <tr><td class="paramname">bdev</td><td>Block device. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">ctx</td><td>context of the bdev channel iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6a8987bb3a1bc368881f6b81d249bd3" name="aa6a8987bb3a1bc368881f6b81d249bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a8987bb3a1bc368881f6b81d249bd3">&#9670;&#160;</a></span>spdk_bdev_init_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bdev_init_cb) (void *cb_arg, int rc)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block device initialization callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
    <tr><td class="paramname">rc</td><td>0 if block device initialized successfully or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c5602dfd313f90032dd91683b9663e3" name="a0c5602dfd313f90032dd91683b9663e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5602dfd313f90032dd91683b9663e3">&#9670;&#160;</a></span>spdk_bdev_io_completion_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bdev_io_completion_cb) (struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *bdev_io, bool success, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block device completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>Block device I/O that has completed. </td></tr>
    <tr><td class="paramname">success</td><td>True if I/O completed successfully or false if it failed; additional error information may be retrieved from bdev_io by calling <a class="el" href="#ae7e1bf90f44f042c2b2ad463b8667735" title="Get the status of bdev_io as an NVMe status code and command specific completion queue value.">spdk_bdev_io_get_nvme_status()</a> or <a class="el" href="#ac3c213b4317d5077197950253af1ac50" title="Get the status of bdev_io as a SCSI status code.">spdk_bdev_io_get_scsi_status()</a>. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Callback argument specified when bdev_io was submitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83db84993554e784cbddf2d217f6ea4f" name="a83db84993554e784cbddf2d217f6ea4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83db84993554e784cbddf2d217f6ea4f">&#9670;&#160;</a></span>spdk_bdev_io_timeout_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bdev_io_timeout_cb) (void *cb_arg, struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *bdev_io)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block device channel IO timeout callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument </td></tr>
    <tr><td class="paramname">bdev_io</td><td>The IO cause the timeout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c7e19e090b8cdb22e8fc6b1984e5278" name="a9c7e19e090b8cdb22e8fc6b1984e5278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7e19e090b8cdb22e8fc6b1984e5278">&#9670;&#160;</a></span>spdk_bdev_io_wait_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bdev_io_wait_cb) (void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block device I/O wait callback. </p>
<p>Callback function to notify when an <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> structure is available to satisfy a call to one of the <a class="el" href="group__bdev__io__submit__functions.html">bdev I/O Submit Functions</a>. </p>

</div>
</div>
<a id="a0253fe337c6697d014adffde6f8cd000" name="a0253fe337c6697d014adffde6f8cd000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0253fe337c6697d014adffde6f8cd000">&#9670;&#160;</a></span>spdk_bdev_open_async_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bdev_open_async_cb_t) (struct spdk_bdev_desc *desc, int rc, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block device asynchronous open callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Output parameter for the descriptor when operation is successful. </td></tr>
    <tr><td class="paramname">rc</td><td>0 if block device is opened successfully or negated errno if failed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51a55c97586c2d524fffcabc4d7910d6" name="a51a55c97586c2d524fffcabc4d7910d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a55c97586c2d524fffcabc4d7910d6">&#9670;&#160;</a></span>spdk_bdev_remove_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bdev_remove_cb_t) (void *remove_ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block device remove callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remove_ctx</td><td>Context for the removed block device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4163854db79e0e3b211dd72ca031fbb0" name="a4163854db79e0e3b211dd72ca031fbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4163854db79e0e3b211dd72ca031fbb0">&#9670;&#160;</a></span>spdk_for_each_bdev_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_for_each_bdev_fn) (void *ctx, struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for <a class="el" href="#ac93dda3868b191be70ac7e1517422c1f" title="Call the provided callback function for every registered block device.">spdk_for_each_bdev()</a> and <a class="el" href="#aeb680eb5205197872738e482204ab441" title="Call the provided callback function for every block device without virtual block devices on top.">spdk_for_each_bdev_leaf()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context passed to the callback. </td></tr>
    <tr><td class="paramname">bdev</td><td>Block device the callback handles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aedfbfc44fa2113d7ee219d09a0994d93" name="aedfbfc44fa2113d7ee219d09a0994d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfbfc44fa2113d7ee219d09a0994d93">&#9670;&#160;</a></span>spdk_bdev_qos_rate_limit_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#aedfbfc44fa2113d7ee219d09a0994d93">spdk_bdev_qos_rate_limit_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bdev QoS rate limit type </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aedfbfc44fa2113d7ee219d09a0994d93a679f76e345c7295f991eeb84d977e5b0" name="aedfbfc44fa2113d7ee219d09a0994d93a679f76e345c7295f991eeb84d977e5b0"></a>SPDK_BDEV_QOS_RW_IOPS_RATE_LIMIT&#160;</td><td class="fielddoc"><p>IOPS rate limit for both read and write. </p>
</td></tr>
<tr><td class="fieldname"><a id="aedfbfc44fa2113d7ee219d09a0994d93a595aaec5bb61bcbdc9f08e111cfd0943" name="aedfbfc44fa2113d7ee219d09a0994d93a595aaec5bb61bcbdc9f08e111cfd0943"></a>SPDK_BDEV_QOS_RW_BPS_RATE_LIMIT&#160;</td><td class="fielddoc"><p>Byte per second rate limit for both read and write. </p>
</td></tr>
<tr><td class="fieldname"><a id="aedfbfc44fa2113d7ee219d09a0994d93af9ae83e85454b81d7210cc97b1507a1d" name="aedfbfc44fa2113d7ee219d09a0994d93af9ae83e85454b81d7210cc97b1507a1d"></a>SPDK_BDEV_QOS_R_BPS_RATE_LIMIT&#160;</td><td class="fielddoc"><p>Byte per second rate limit for read only. </p>
</td></tr>
<tr><td class="fieldname"><a id="aedfbfc44fa2113d7ee219d09a0994d93a1b3f5fed3a3173110561ff7c58f211dc" name="aedfbfc44fa2113d7ee219d09a0994d93a1b3f5fed3a3173110561ff7c58f211dc"></a>SPDK_BDEV_QOS_W_BPS_RATE_LIMIT&#160;</td><td class="fielddoc"><p>Byte per second rate limit for write only. </p>
</td></tr>
<tr><td class="fieldname"><a id="aedfbfc44fa2113d7ee219d09a0994d93a25c0a2574ea232ae0fd9fd3969c00b11" name="aedfbfc44fa2113d7ee219d09a0994d93a25c0a2574ea232ae0fd9fd3969c00b11"></a>SPDK_BDEV_QOS_NUM_RATE_LIMIT_TYPES&#160;</td><td class="fielddoc"><p>Keep last. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a83092483a9de9f7d736ef4ceaaf0d26c" name="a83092483a9de9f7d736ef4ceaaf0d26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83092483a9de9f7d736ef4ceaaf0d26c">&#9670;&#160;</a></span>spdk_bdev_channel_get_histogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_channel_get_histogram </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_bdev_histogram_data_cb</td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get histogram data of the specified channel for a bdev. </p>
<p>The histogram passed to cb_fn is only valid during the execution of cb_fn. Referencing the histogram after cb_fn returns is not supported and yields undetermined behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>IO channel of bdev. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to process the histogram of the channel. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf5fc830851a2eb0aa34bbb40cf5eac6" name="aaf5fc830851a2eb0aa34bbb40cf5eac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5fc830851a2eb0aa34bbb40cf5eac6">&#9670;&#160;</a></span>spdk_bdev_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_close </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a previously opened block device. </p>
<p>Must be called on the same thread that the <a class="el" href="#aca93f44b46f0b877df9b6936ef9e0a9e" title="Open a block device for I/O operations.">spdk_bdev_open_ext()</a> was performed on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae05ee98ddd0903932505782191805da" name="aae05ee98ddd0903932505782191805da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae05ee98ddd0903932505782191805da">&#9670;&#160;</a></span>spdk_bdev_desc_get_bdev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> * spdk_bdev_desc_get_bdev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bdev associated with a bdev descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Open block device descriptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bdev associated with the descriptor </dd></dl>

</div>
</div>
<a id="a3ef2e861ccd2d6135bfe13257f047fb9" name="a3ef2e861ccd2d6135bfe13257f047fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef2e861ccd2d6135bfe13257f047fb9">&#9670;&#160;</a></span>spdk_bdev_dump_info_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_dump_info_json </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_json_write_ctx *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output driver-specific information to a JSON stream. </p>
<p>The JSON write context will be initialized with an open object, so the bdev driver should write a name(based on the driver name) followed by a JSON value (most likely another nested object).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
    <tr><td class="paramname">w</td><td>JSON write context. It will store the driver-specific configuration context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure. </dd></dl>

</div>
</div>
<a id="ae720ef13c98f9ba40e6562d4a8582427" name="ae720ef13c98f9ba40e6562d4a8582427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae720ef13c98f9ba40e6562d4a8582427">&#9670;&#160;</a></span>spdk_bdev_examine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_examine </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Examine a block device explicitly. </p>
<p>This function must be called from the SPDK app thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name or alias of the block device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if block device was examined successfully, suitable errno value otherwise </dd></dl>

</div>
</div>
<a id="a7263aeb5393b46fa5af8e04760f62ea4" name="a7263aeb5393b46fa5af8e04760f62ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7263aeb5393b46fa5af8e04760f62ea4">&#9670;&#160;</a></span>spdk_bdev_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad33efc88148d8984b353e54b7ee0058f">spdk_bdev_fini_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform cleanup work to remove the registered block device modules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_fn</td><td>Called when the removal is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c74a45879dfcea19908e48c1131a071" name="a0c74a45879dfcea19908e48c1131a071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c74a45879dfcea19908e48c1131a071">&#9670;&#160;</a></span>spdk_bdev_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> * spdk_bdev_first </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first registered block device. </p>
<dl class="section return"><dt>Returns</dt><dd>The first registered block device. </dd></dl>

</div>
</div>
<a id="ab103cc993070d39a73c48d7087dc47a8" name="ab103cc993070d39a73c48d7087dc47a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab103cc993070d39a73c48d7087dc47a8">&#9670;&#160;</a></span>spdk_bdev_first_leaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> * spdk_bdev_first_leaf </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first block device without virtual block devices on top. </p>
<p>This function only traverses over block devices which have no virtual block devices on top of them, then get the first one.</p>
<dl class="section return"><dt>Returns</dt><dd>The first block device without virtual block devices on top. </dd></dl>

</div>
</div>
<a id="a1b51dde3495e6b37f172e172cca3cfd2" name="a1b51dde3495e6b37f172e172cca3cfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b51dde3495e6b37f172e172cca3cfd2">&#9670;&#160;</a></span>spdk_bdev_for_each_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_for_each_channel </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4ac2a1bd295f6c71dbe706e61f5f6ac4">spdk_bdev_for_each_channel_msg</a></td>          <td class="paramname"><span class="paramname"><em>fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a16f406e9a97a6ac7072867bdcc7c1df1">spdk_bdev_for_each_channel_done</a></td>          <td class="paramname"><span class="paramname"><em>cpl</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call 'fn' on each channel associated with the given bdev. </p>
<p>This happens asynchronously, so fn may be called after spdk_bdev_for_each_channel returns. 'fn' will be called for each channel serially, such that two calls to 'fn' will not overlap in time. After 'fn' has been called, call <a class="el" href="#a576acbae728d3d4ecc83ea5603cdd3f9" title="Helper function to iterate the next channel for spdk_bdev_for_each_channel().">spdk_bdev_for_each_channel_continue()</a> to continue iterating. Note that the <a class="el" href="#a576acbae728d3d4ecc83ea5603cdd3f9" title="Helper function to iterate the next channel for spdk_bdev_for_each_channel().">spdk_bdev_for_each_channel_continue()</a> function can be called asynchronously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>'fn' will be called on each channel associated with this given bdev. </td></tr>
    <tr><td class="paramname">fn</td><td>Called on the appropriate thread for each channel associated with the given bdev. </td></tr>
    <tr><td class="paramname">ctx</td><td>Context for the caller. </td></tr>
    <tr><td class="paramname">cpl</td><td>Called on the thread that spdk_bdev_for_each_channel was initially called from when 'fn' has been called on each channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a576acbae728d3d4ecc83ea5603cdd3f9" name="a576acbae728d3d4ecc83ea5603cdd3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576acbae728d3d4ecc83ea5603cdd3f9">&#9670;&#160;</a></span>spdk_bdev_for_each_channel_continue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_for_each_channel_continue </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_channel_iter *</td>          <td class="paramname"><span class="paramname"><em>i</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>status</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to iterate the next channel for <a class="el" href="#a1b51dde3495e6b37f172e172cca3cfd2" title="Call &#39;fn&#39; on each channel associated with the given bdev.">spdk_bdev_for_each_channel()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>bdev channel iterator. </td></tr>
    <tr><td class="paramname">status</td><td>Status for the bdev channel iterator; for non 0 status remaining iterations are terminated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ac23d38eb3b56b58197e0111ef68c6b" name="a9ac23d38eb3b56b58197e0111ef68c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac23d38eb3b56b58197e0111ef68c6b">&#9670;&#160;</a></span>spdk_bdev_free_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_free_io </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev_io</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an I/O request. </p>
<p>This should only be called after the completion callback for the I/O has been called and notifies the bdev layer that memory may now be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8414b6c4af71136f0c1cb7af4a8d33fa" name="a8414b6c4af71136f0c1cb7af4a8d33fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8414b6c4af71136f0c1cb7af4a8d33fa">&#9670;&#160;</a></span>spdk_bdev_get_acwu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t spdk_bdev_get_acwu </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device atomic compare and write unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Atomic compare and write unit for this bdev in blocks. </dd></dl>

</div>
</div>
<a id="a3ba8c5672c8226b9b63f44543518c527" name="a3ba8c5672c8226b9b63f44543518c527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba8c5672c8226b9b63f44543518c527">&#9670;&#160;</a></span>spdk_bdev_get_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_bdev_get_block_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device logical block size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of logical block for this bdev in bytes. </dd></dl>

</div>
</div>
<a id="ab4d238484b372a77ba130fbb70f83519" name="ab4d238484b372a77ba130fbb70f83519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d238484b372a77ba130fbb70f83519">&#9670;&#160;</a></span>spdk_bdev_get_buf_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_bdev_get_buf_align </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get minimum I/O buffer address alignment for a bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Required alignment of I/O buffers in bytes. </dd></dl>

</div>
</div>
<a id="a04f3638678ead46e86a28c8afd34d1e8" name="a04f3638678ead46e86a28c8afd34d1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f3638678ead46e86a28c8afd34d1e8">&#9670;&#160;</a></span>spdk_bdev_get_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> * spdk_bdev_get_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>bdev_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device by the block device name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_name</td><td>The name of the block device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Block device associated with the name or NULL if no block device with bdev_name is currently registered. </dd></dl>

</div>
</div>
<a id="a84041f3948f91dc0dd0656895970061a" name="a84041f3948f91dc0dd0656895970061a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84041f3948f91dc0dd0656895970061a">&#9670;&#160;</a></span>spdk_bdev_get_data_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_bdev_get_data_block_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device data block size. </p>
<p>Data block size is equal to block size if there is no metadata or metadata is separated with block data, or equal to block size minus metadata size if there is metadata and it is interleaved with block data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of data block for this bdev in bytes. </dd></dl>

</div>
</div>
<a id="aa478b43fc9e6e41c34438f5b2ef742d5" name="aa478b43fc9e6e41c34438f5b2ef742d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa478b43fc9e6e41c34438f5b2ef742d5">&#9670;&#160;</a></span>spdk_bdev_get_device_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_get_device_stat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a> *</td>          <td class="paramname"><span class="paramname"><em>stat</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_bdev_get_device_stat_cb</td>          <td class="paramname"><span class="paramname"><em>cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return I/O statistics for this bdev. </p>
<p>All the required information will be passed via the callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
    <tr><td class="paramname">stat</td><td>Structure for aggregating collected statistics. Passed as argument to cb. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when this operation completes. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac94b5900766ec42da5fc3658a5749858" name="ac94b5900766ec42da5fc3658a5749858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94b5900766ec42da5fc3658a5749858">&#9670;&#160;</a></span>spdk_bdev_get_dif_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum spdk_dif_type spdk_bdev_get_dif_type </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get DIF type of the block device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DIF type of the block device. </dd></dl>

</div>
</div>
<a id="ac9992f445e8adf2b9f4fd38ac4978762" name="ac9992f445e8adf2b9f4fd38ac4978762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9992f445e8adf2b9f4fd38ac4978762">&#9670;&#160;</a></span>spdk_bdev_get_io_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_io_channel * spdk_bdev_get_io_channel </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain an I/O channel for the block device opened by the specified descriptor. </p>
<p>I/O channels are bound to threads, so the resulting I/O channel may only be used from the thread it was originally obtained from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the I/O channel or NULL on failure. </dd></dl>

</div>
</div>
<a id="ab1ba28ba382edd1d792d51a054eb3aa2" name="ab1ba28ba382edd1d792d51a054eb3aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ba28ba382edd1d792d51a054eb3aa2">&#9670;&#160;</a></span>spdk_bdev_get_io_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_get_io_stat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a> *</td>          <td class="paramname"><span class="paramname"><em>stat</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return I/O statistics for this channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="#ac9992f445e8adf2b9f4fd38ac4978762" title="Obtain an I/O channel for the block device opened by the specified descriptor.">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">stat</td><td>The per-channel statistics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a082eb89d57860b2e57ebf7f5b3caa2" name="a8a082eb89d57860b2e57ebf7f5b3caa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a082eb89d57860b2e57ebf7f5b3caa2">&#9670;&#160;</a></span>spdk_bdev_get_io_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_bdev_get_io_time </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the time spent processing IO for this device. </p>
<p>This value is dependent upon the queue depth sampling period and is incremented at sampling time by the sampling period only if the measured queue depth is greater than 0.</p>
<p>The disk utilization can be calculated by the following formula: disk_util = (io_time_2 - io_time_1) / elapsed_time. The user is responsible for tracking the elapsed time between two measurements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The io time for this device in microseconds. </dd></dl>

</div>
</div>
<a id="a5216be2decc3b5f2d91416debb54ee7c" name="a5216be2decc3b5f2d91416debb54ee7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5216be2decc3b5f2d91416debb54ee7c">&#9670;&#160;</a></span>spdk_bdev_get_io_type_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_bdev_get_io_type_name </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="#a633029e24ab5ae4a689bffa2565a519f">spdk_bdev_io_type</a></td>          <td class="paramname"><span class="paramname"><em>io_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the name of an IO type based on the io_type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_type</td><td>The specific I/O type like read, write, flush, unmap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of the IO type as a null-terminated string. </dd></dl>

</div>
</div>
<a id="a8b542430078d502325f37b92fc3d15ca" name="a8b542430078d502325f37b92fc3d15ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b542430078d502325f37b92fc3d15ca">&#9670;&#160;</a></span>spdk_bdev_get_max_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_bdev_get_max_copy </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device max copy size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Max copy size for this bdev in blocks. 0 means unlimited. </dd></dl>

</div>
</div>
<a id="abc3537d0315100b24da6acc95929e849" name="abc3537d0315100b24da6acc95929e849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3537d0315100b24da6acc95929e849">&#9670;&#160;</a></span>spdk_bdev_get_md_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_bdev_get_md_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device metadata size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of metadata for this bdev in bytes. </dd></dl>

</div>
</div>
<a id="af359a282820d73a253ffbbe127a30b96" name="af359a282820d73a253ffbbe127a30b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af359a282820d73a253ffbbe127a30b96">&#9670;&#160;</a></span>spdk_bdev_get_media_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_bdev_get_media_events </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *</td>          <td class="paramname"><span class="paramname"><em>bdev_desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev__media__event.html">spdk_bdev_media_event</a> *</td>          <td class="paramname"><span class="paramname"><em>events</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_events</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves media events. </p>
<p>Can only be called from the context of SPDK_BDEV_EVENT_MEDIA_MANAGEMENT event callback. These events are sent by devices exposing raw access to the physical medium (e.g. Open Channel SSD).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_desc</td><td>Block device descriptor </td></tr>
    <tr><td class="paramname">events</td><td>Array of media management event descriptors </td></tr>
    <tr><td class="paramname">max_events</td><td>Size of the events array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of events retrieved </dd></dl>

</div>
</div>
<a id="a2643db603c5c9762d839036c1658bf1b" name="a2643db603c5c9762d839036c1658bf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2643db603c5c9762d839036c1658bf1b">&#9670;&#160;</a></span>spdk_bdev_get_memory_domains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_get_memory_domains </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_memory_domain **</td>          <td class="paramname"><span class="paramname"><em>domains</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>array_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SPDK memory domains used by the given bdev. </p>
<p>If bdev reports that it uses memory domains that means that it can work with data buffers located in those memory domains.</p>
<p>The user can call this function with <b>domains</b> set to NULL and <b>array_size</b> set to 0 to get the number of memory domains used by bdev</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">domains</td><td>Pointer to an array of memory domains to be filled by this function. The user should allocate big enough array to keep all memory domains used by bdev and all underlying bdevs </td></tr>
    <tr><td class="paramname">array_size</td><td>size of <b>domains</b> array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of entries in <b>domains</b> array or negated errno. If returned value is bigger than <b>array_size</b> passed by the user then the user should increase the size of <b>domains</b> array and call this function again. There is no guarantees that the content of <b>domains</b> array is valid in that case. -EINVAL if input parameters were invalid </dd></dl>

</div>
</div>
<a id="a5b596b58de9767fcd2030e5e07ddad41" name="a5b596b58de9767fcd2030e5e07ddad41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b596b58de9767fcd2030e5e07ddad41">&#9670;&#160;</a></span>spdk_bdev_get_module_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * spdk_bdev_get_module_ctx </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain a bdev module context for the block device opened by the specified descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A bdev module context or NULL on failure. </dd></dl>

</div>
</div>
<a id="a665b7764a3bf00c5a53c59e5f201cafb" name="a665b7764a3bf00c5a53c59e5f201cafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665b7764a3bf00c5a53c59e5f201cafb">&#9670;&#160;</a></span>spdk_bdev_get_module_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_bdev_get_module_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device module name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of bdev module as a null-terminated string. </dd></dl>

</div>
</div>
<a id="aac0cdb8ad1ebf94503b22f86d480a177" name="aac0cdb8ad1ebf94503b22f86d480a177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0cdb8ad1ebf94503b22f86d480a177">&#9670;&#160;</a></span>spdk_bdev_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_bdev_get_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of bdev as a null-terminated string. </dd></dl>

</div>
</div>
<a id="a86568eca8f0b4d0dc9bc59c5138fc7a5" name="a86568eca8f0b4d0dc9bc59c5138fc7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86568eca8f0b4d0dc9bc59c5138fc7a5">&#9670;&#160;</a></span>spdk_bdev_get_num_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_bdev_get_num_blocks </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of block device in logical blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of bdev in logical blocks.</dd></dl>
<p>Logical blocks are numbered from 0 to spdk_bdev_get_num_blocks(bdev) - 1, inclusive. </p>

</div>
</div>
<a id="af833943e22885817e6954426b6a11b5f" name="af833943e22885817e6954426b6a11b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af833943e22885817e6954426b6a11b5f">&#9670;&#160;</a></span>spdk_bdev_get_nvme_ctratt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">union <a class="el" href="unionspdk__bdev__nvme__ctratt.html">spdk_bdev_nvme_ctratt</a> spdk_bdev_get_nvme_ctratt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get controller attributes for the bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>controller attributes for the bdev. </dd></dl>

</div>
</div>
<a id="aa79625889e23318204d235da36a4fa02" name="aa79625889e23318204d235da36a4fa02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79625889e23318204d235da36a4fa02">&#9670;&#160;</a></span>spdk_bdev_get_optimal_io_boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_bdev_get_optimal_io_boundary </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get optimal I/O boundary for a bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optimal I/O boundary in blocks that should not be crossed for best performance, or 0 if no optimal boundary is reported. </dd></dl>

</div>
</div>
<a id="ab0c4412ed5d0e1869620965304d36b7f" name="ab0c4412ed5d0e1869620965304d36b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c4412ed5d0e1869620965304d36b7f">&#9670;&#160;</a></span>spdk_bdev_get_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_get_opts </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev__opts.html">spdk_bdev_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>opts_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the options for the bdev module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Output parameter for options. </td></tr>
    <tr><td class="paramname">opts_size</td><td>sizeof(*opts) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c895e82c51c654a5b3f838f7254d690" name="a2c895e82c51c654a5b3f838f7254d690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c895e82c51c654a5b3f838f7254d690">&#9670;&#160;</a></span>spdk_bdev_get_physical_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_bdev_get_physical_block_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device physical block size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of physical block size for this bdev in bytes. </dd></dl>

</div>
</div>
<a id="ae02ca23e2e84b353e8d827a6d854518f" name="ae02ca23e2e84b353e8d827a6d854518f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02ca23e2e84b353e8d827a6d854518f">&#9670;&#160;</a></span>spdk_bdev_get_product_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_bdev_get_product_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device product name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product name of bdev as a null-terminated string. </dd></dl>

</div>
</div>
<a id="a471f32e8948203f7aaf320396a1ae7c9" name="a471f32e8948203f7aaf320396a1ae7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471f32e8948203f7aaf320396a1ae7c9">&#9670;&#160;</a></span>spdk_bdev_get_qd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_bdev_get_qd </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the most recently measured queue depth from a bdev. </p>
<p>The reported queue depth is the aggregate of outstanding I/O across all open channels associated with this bdev.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The most recent queue depth measurement for the bdev. If tracking is not enabled, the function will return UINT64_MAX It is also possible to receive UINT64_MAX after enabling tracking but before the first period has expired. </dd></dl>

</div>
</div>
<a id="adab852ac707702316bf869a3d7dfdc85" name="adab852ac707702316bf869a3d7dfdc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab852ac707702316bf869a3d7dfdc85">&#9670;&#160;</a></span>spdk_bdev_get_qd_sampling_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_bdev_get_qd_sampling_period </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the queue depth polling period. </p>
<p>The return value of this function is only valid if the bdev's queue depth tracking status is set to true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The period at which this bdev's gueue depth is being refreshed. </dd></dl>

</div>
</div>
<a id="a08c63fbd418d5a77f34ddca9a4268f41" name="a08c63fbd418d5a77f34ddca9a4268f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c63fbd418d5a77f34ddca9a4268f41">&#9670;&#160;</a></span>spdk_bdev_get_qos_rate_limits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_get_qos_rate_limits </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>limits</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the quality of service rate limits on a bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
    <tr><td class="paramname">limits</td><td>Pointer to the QoS rate limits array which holding the limits.</td></tr>
  </table>
  </dd>
</dl>
<p>The limits are ordered based on the <a class="el" href="#aedfbfc44fa2113d7ee219d09a0994d93">spdk_bdev_qos_rate_limit_type</a> enum. </p>

</div>
</div>
<a id="acdc5e01fbba1ecadab98ff7d04a95489" name="acdc5e01fbba1ecadab98ff7d04a95489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc5e01fbba1ecadab98ff7d04a95489">&#9670;&#160;</a></span>spdk_bdev_get_qos_rpc_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_bdev_get_qos_rpc_type </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="#aedfbfc44fa2113d7ee219d09a0994d93">spdk_bdev_qos_rate_limit_type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string of quality of service rate limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Type of rate limit to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String of QoS type. </dd></dl>

</div>
</div>
<a id="af3e829afdd5236f5e979b0c3663a8067" name="af3e829afdd5236f5e979b0c3663a8067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e829afdd5236f5e979b0c3663a8067">&#9670;&#160;</a></span>spdk_bdev_get_uuid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__uuid.html">spdk_uuid</a> * spdk_bdev_get_uuid </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a bdev's UUID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to UUID.</dd></dl>
<p>All bdevs will have a UUID, but not all UUIDs will be persistent across application runs. </p>

</div>
</div>
<a id="a526ab43ba037b8637a23e9d42289884e" name="a526ab43ba037b8637a23e9d42289884e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526ab43ba037b8637a23e9d42289884e">&#9670;&#160;</a></span>spdk_bdev_get_weighted_io_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_bdev_get_weighted_io_time </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the weighted IO processing time for this bdev. </p>
<p>This value is dependent upon the queue depth sampling period and is equal to the time spent reading from or writing to a device times the measured queue depth during each sampling period.</p>
<p>The average queue depth can be calculated by the following formula: queue_depth = (weighted_io_time_2 - weighted_io_time_1) / elapsed_time. The user is responsible for tracking the elapsed time between two measurements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The weighted io time for this device in microseconds. </dd></dl>

</div>
</div>
<a id="ab5775a23cadb2eb1d5381dc105577a37" name="ab5775a23cadb2eb1d5381dc105577a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5775a23cadb2eb1d5381dc105577a37">&#9670;&#160;</a></span>spdk_bdev_get_write_unit_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_bdev_get_write_unit_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the write unit size for this bdev. </p>
<p>Write unit size is required number of logical blocks to perform write operation on block device.</p>
<p>Unit of write unit size is logical block and the minimum of write unit size is one. Write operations must be multiple of write unit size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The write unit size in logical blocks. </dd></dl>

</div>
</div>
<a id="a93f6d6ce09da384501f09a49581caa37" name="a93f6d6ce09da384501f09a49581caa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f6d6ce09da384501f09a49581caa37">&#9670;&#160;</a></span>spdk_bdev_has_write_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_bdev_has_write_cache </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether block device has an enabled write cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if block device has a volatile write cache enabled.</dd></dl>
<p>If this function returns true, written data may not be persistent until a flush command is issued. </p>

</div>
</div>
<a id="a0b4556cb07c52ae7b5b7e7f10cbdc637" name="a0b4556cb07c52ae7b5b7e7f10cbdc637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4556cb07c52ae7b5b7e7f10cbdc637">&#9670;&#160;</a></span>spdk_bdev_histogram_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_histogram_enable </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_bdev_histogram_status_cb</td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enable</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable collecting histogram data on a bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to be called when histograms are enabled. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to cb_fn. </td></tr>
    <tr><td class="paramname">enable</td><td>Enable/disable flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacf15571883da5a441297b5090e6aaf5" name="aacf15571883da5a441297b5090e6aaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf15571883da5a441297b5090e6aaf5">&#9670;&#160;</a></span>spdk_bdev_histogram_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_histogram_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__histogram__data.html">spdk_histogram_data</a> *</td>          <td class="paramname"><span class="paramname"><em>histogram</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_bdev_histogram_data_cb</td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get aggregated histogram data from a bdev. </p>
<p>Callback provides merged histogram for specified bdev.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device. </td></tr>
    <tr><td class="paramname">histogram</td><td>Histogram for aggregated data </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to be called with data collected on bdev. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a854eb960c06597051071023a3d70e887" name="a854eb960c06597051071023a3d70e887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854eb960c06597051071023a3d70e887">&#9670;&#160;</a></span>spdk_bdev_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aa6a8987bb3a1bc368881f6b81d249bd3">spdk_bdev_init_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize block device modules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_fn</td><td>Called when the initialization is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a701290c13896ad545b58f5c5fecfbd93" name="a701290c13896ad545b58f5c5fecfbd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701290c13896ad545b58f5c5fecfbd93">&#9670;&#160;</a></span>spdk_bdev_io_get_aio_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_io_get_aio_status </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev_io</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>aio_result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of bdev_io as aio errno. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to get the status from. </td></tr>
    <tr><td class="paramname">aio_result</td><td>Negative errno returned from AIO. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a567ddcb43834b7f29289d7d369e89c4d" name="a567ddcb43834b7f29289d7d369e89c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567ddcb43834b7f29289d7d369e89c4d">&#9670;&#160;</a></span>spdk_bdev_io_get_cb_arg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * spdk_bdev_io_get_cb_arg </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev_io</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the callback argument of bdev_io to abort it by spdk_bdev_abort. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to get the callback argument from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Callback argument of bdev_io. </dd></dl>

</div>
</div>
<a id="aa05d8c0e82bfbcc209af1eb958230ede" name="aa05d8c0e82bfbcc209af1eb958230ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05d8c0e82bfbcc209af1eb958230ede">&#9670;&#160;</a></span>spdk_bdev_io_get_iovec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_io_get_iovec </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev_io</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec **</td>          <td class="paramname"><span class="paramname"><em>iovp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>iovcntp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the iovec describing the data buffer of a bdev_io. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to describe with iovec. </td></tr>
    <tr><td class="paramname">iovp</td><td>Pointer to be filled with iovec. </td></tr>
    <tr><td class="paramname">iovcntp</td><td>Pointer to be filled with number of iovec entries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ee6dce0e4ed7045a9457af0b0486082" name="a3ee6dce0e4ed7045a9457af0b0486082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee6dce0e4ed7045a9457af0b0486082">&#9670;&#160;</a></span>spdk_bdev_io_get_md_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * spdk_bdev_io_get_md_buf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev_io</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get metadata buffer. </p>
<p>Only makes sense if the IO uses separate buffer for metadata transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to retrieve the buffer from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to metadata buffer, NULL if the IO doesn't use separate buffer for metadata transfer. </dd></dl>

</div>
</div>
<a id="a44c7d2a0cf76be7d06d9dc5e09553ec8" name="a44c7d2a0cf76be7d06d9dc5e09553ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c7d2a0cf76be7d06d9dc5e09553ec8">&#9670;&#160;</a></span>spdk_bdev_io_get_nvme_fused_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_io_get_nvme_fused_status </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev_io</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>cdw0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>first_sct</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>first_sc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>second_sct</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>second_sc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of bdev_io as an NVMe status codes and command specific completion queue value for fused operations such as compare-and-write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to get the status from. </td></tr>
    <tr><td class="paramname">cdw0</td><td>Command specific completion queue value </td></tr>
    <tr><td class="paramname">first_sct</td><td>Status Code Type return value for the first operation, as defined by the NVMe specification. </td></tr>
    <tr><td class="paramname">first_sc</td><td>Status Code return value for the first operation, as defined by the NVMe specification. </td></tr>
    <tr><td class="paramname">second_sct</td><td>Status Code Type return value for the second operation, as defined by the NVMe specification. </td></tr>
    <tr><td class="paramname">second_sc</td><td>Status Code return value for the second operation, as defined by the NVMe specification. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7e1bf90f44f042c2b2ad463b8667735" name="ae7e1bf90f44f042c2b2ad463b8667735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e1bf90f44f042c2b2ad463b8667735">&#9670;&#160;</a></span>spdk_bdev_io_get_nvme_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_io_get_nvme_status </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev_io</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *</td>          <td class="paramname"><span class="paramname"><em>cdw0</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>sct</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>sc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of bdev_io as an NVMe status code and command specific completion queue value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to get the status from. </td></tr>
    <tr><td class="paramname">cdw0</td><td>Command specific completion queue value </td></tr>
    <tr><td class="paramname">sct</td><td>Status Code Type return value, as defined by the NVMe specification. </td></tr>
    <tr><td class="paramname">sc</td><td>Status Code return value, as defined by the NVMe specification. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3c213b4317d5077197950253af1ac50" name="ac3c213b4317d5077197950253af1ac50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c213b4317d5077197950253af1ac50">&#9670;&#160;</a></span>spdk_bdev_io_get_scsi_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_io_get_scsi_status </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev_io</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>sc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>sk</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>asc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>ascq</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of bdev_io as a SCSI status code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to get the status from. </td></tr>
    <tr><td class="paramname">sc</td><td>SCSI Status Code. </td></tr>
    <tr><td class="paramname">sk</td><td>SCSI Sense Key. </td></tr>
    <tr><td class="paramname">asc</td><td>SCSI Additional Sense Code. </td></tr>
    <tr><td class="paramname">ascq</td><td>SCSI Additional Sense Code Qualifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03943b94f83f3402fb8da4093985a829" name="a03943b94f83f3402fb8da4093985a829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03943b94f83f3402fb8da4093985a829">&#9670;&#160;</a></span>spdk_bdev_io_get_seek_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_bdev_io_get_seek_offset </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev_io</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the result of a previous seek function. </p>
<p>After calling spdk_bdev_seek_data or spdk_bdev_seek_hole, call this function to retrieve the offset of next allocated data or next unallocated hole.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to get the status from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>data/hole offset in blocks or UINT64_MAX if not found </dd></dl>

</div>
</div>
<a id="a7cd5dff692dc162459801d5649fe7655" name="a7cd5dff692dc162459801d5649fe7655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd5dff692dc162459801d5649fe7655">&#9670;&#160;</a></span>spdk_bdev_io_type_supported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_bdev_io_type_supported </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#a633029e24ab5ae4a689bffa2565a519f">spdk_bdev_io_type</a></td>          <td class="paramname"><span class="paramname"><em>io_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the block device supports the I/O type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to check. </td></tr>
    <tr><td class="paramname">io_type</td><td>The specific I/O type like read, write, flush, unmap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if support, false otherwise. </dd></dl>

</div>
</div>
<a id="a147389751cd351d30703e28f522e9610" name="a147389751cd351d30703e28f522e9610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147389751cd351d30703e28f522e9610">&#9670;&#160;</a></span>spdk_bdev_is_dif_check_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_bdev_is_dif_check_enabled </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum spdk_dif_check_type</td>          <td class="paramname"><span class="paramname"><em>check_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the DIF check type is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
    <tr><td class="paramname">check_type</td><td>The specific DIF check type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="a4e43a19692e14e5e46b3315e4cf0bc1d" name="a4e43a19692e14e5e46b3315e4cf0bc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e43a19692e14e5e46b3315e4cf0bc1d">&#9670;&#160;</a></span>spdk_bdev_is_dif_head_of_md()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_bdev_is_dif_head_of_md </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether DIF is set in the first 8/16 bytes or the last 8/16 bytes of metadata. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if DIF is set in the first 8/16 bytes of metadata, or false if DIF is set in the last 8/16 bytes of metadata.</dd></dl>
<p>Note that this function is valid only if DIF type is not SPDK_DIF_DISABLE. </p>

</div>
</div>
<a id="aa02f628c6ef7cae08b8b623b4800c74d" name="aa02f628c6ef7cae08b8b623b4800c74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02f628c6ef7cae08b8b623b4800c74d">&#9670;&#160;</a></span>spdk_bdev_is_md_interleaved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_bdev_is_md_interleaved </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether metadata is interleaved with block data or separated with block data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if metadata is interleaved with block data or false if metadata is separated with block data.</dd></dl>
<p>Note this function is valid only if there is metadata. </p>

</div>
</div>
<a id="ac8c880555f4d66991c1fd9dbd3abaf4f" name="ac8c880555f4d66991c1fd9dbd3abaf4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c880555f4d66991c1fd9dbd3abaf4f">&#9670;&#160;</a></span>spdk_bdev_is_md_separate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_bdev_is_md_separate </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether metadata is interleaved with block data or separated from block data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if metadata is separated from block data, false otherwise.</dd></dl>
<p>Note this function is valid only if there is metadata. </p>

</div>
</div>
<a id="a2e334778f2dfb469e2f96bcd42c6343b" name="a2e334778f2dfb469e2f96bcd42c6343b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e334778f2dfb469e2f96bcd42c6343b">&#9670;&#160;</a></span>spdk_bdev_is_zoned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_bdev_is_zoned </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if bdev supports zoned namespace semantics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if device supports zoned namespace semantics. </dd></dl>

</div>
</div>
<a id="a7f23e8d3f72213af5a9bb22605c74468" name="a7f23e8d3f72213af5a9bb22605c74468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f23e8d3f72213af5a9bb22605c74468">&#9670;&#160;</a></span>spdk_bdev_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> * spdk_bdev_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>prev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next registered block device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>The current block device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next registered block device. </dd></dl>

</div>
</div>
<a id="a46b18a69f9da6a60e5a977d7e73f3b11" name="a46b18a69f9da6a60e5a977d7e73f3b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b18a69f9da6a60e5a977d7e73f3b11">&#9670;&#160;</a></span>spdk_bdev_next_leaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> * spdk_bdev_next_leaf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>prev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next block device without virtual block devices on top. </p>
<p>This function only traverses over block devices which have no virtual block devices on top of them, then get the next one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>The current block device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next block device without virtual block devices on top. </dd></dl>

</div>
</div>
<a id="af29e58cf7325dbc4f4ca8e0abb2d9506" name="af29e58cf7325dbc4f4ca8e0abb2d9506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29e58cf7325dbc4f4ca8e0abb2d9506">&#9670;&#160;</a></span>spdk_bdev_open_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_open_async </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>bdev_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>write</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab4755b1b0a2a204732c3be266b6e1b08">spdk_bdev_event_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>event_cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>event_ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev__open__async__opts.html">spdk_bdev_open_async_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0253fe337c6697d014adffde6f8cd000">spdk_bdev_open_async_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>open_cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>open_cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a block device for I/O operations asynchronously with options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_name</td><td>Block device name to open. </td></tr>
    <tr><td class="paramname">write</td><td>true is read/write access requested, false if read-only </td></tr>
    <tr><td class="paramname">event_cb</td><td>Notification callback to be called when the bdev triggers asynchronous event such as bdev removal. This will always be called on the same thread that <a class="el" href="#af29e58cf7325dbc4f4ca8e0abb2d9506" title="Open a block device for I/O operations asynchronously with options.">spdk_bdev_open_async()</a> was called on. In case of removal event the descriptor will have to be manually closed to make the bdev unregister proceed. </td></tr>
    <tr><td class="paramname">event_ctx</td><td>param for event_cb. </td></tr>
    <tr><td class="paramname">opts</td><td>Options for asynchronous block device open. If NULL, default values are used. </td></tr>
    <tr><td class="paramname">open_cb</td><td>Open callback. </td></tr>
    <tr><td class="paramname">open_cb_arg</td><td>Parameter for open_cb. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if operation started successfully, suitable errno value otherwise </dd></dl>

</div>
</div>
<a id="aca93f44b46f0b877df9b6936ef9e0a9e" name="aca93f44b46f0b877df9b6936ef9e0a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca93f44b46f0b877df9b6936ef9e0a9e">&#9670;&#160;</a></span>spdk_bdev_open_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_open_ext </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>bdev_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>write</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab4755b1b0a2a204732c3be266b6e1b08">spdk_bdev_event_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>event_cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>event_ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_bdev_desc **</td>          <td class="paramname"><span class="paramname"><em>desc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a block device for I/O operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_name</td><td>Block device name to open. </td></tr>
    <tr><td class="paramname">write</td><td>true is read/write access requested, false if read-only </td></tr>
    <tr><td class="paramname">event_cb</td><td>notification callback to be called when the bdev triggers asynchronous event such as bdev removal. This will always be called on the same thread that <a class="el" href="#aca93f44b46f0b877df9b6936ef9e0a9e" title="Open a block device for I/O operations.">spdk_bdev_open_ext()</a> was called on. In case of removal event the descriptor will have to be manually closed to make the bdev unregister proceed. </td></tr>
    <tr><td class="paramname">event_ctx</td><td>param for event_cb. </td></tr>
    <tr><td class="paramname">desc</td><td>output parameter for the descriptor when operation is successful </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if operation is successful, suitable errno value otherwise </dd></dl>

</div>
</div>
<a id="acc4beee18ded7837fa92bd7c34e7ef2e" name="acc4beee18ded7837fa92bd7c34e7ef2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4beee18ded7837fa92bd7c34e7ef2e">&#9670;&#160;</a></span>spdk_bdev_queue_io_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_queue_io_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev__io__wait__entry.html">spdk_bdev_io_wait_entry</a> *</td>          <td class="paramname"><span class="paramname"><em>entry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an entry into the calling thread's queue to be notified when an <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> becomes available. </p>
<p>When one of the <a class="el" href="group__bdev__io__submit__functions.html">bdev I/O Submit Functions</a> returns -ENOMEM, it means the <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> buffer pool has no available buffers. This function may be called to register a callback to be notified when a buffer becomes available on the calling thread.</p>
<p>The callback function will always be called on the same thread as this function was called.</p>
<p>This function must only be called immediately after one of the <a class="el" href="group__bdev__io__submit__functions.html">bdev I/O Submit Functions</a> returns -ENOMEM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device. The block device that the caller will submit an I/O to when the callback is invoked. Must match the bdev member in the entry parameter. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="#ac9992f445e8adf2b9f4fd38ac4978762" title="Obtain an I/O channel for the block device opened by the specified descriptor.">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">entry</td><td>Data structure allocated by the caller specifying the callback function and argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. -EINVAL if bdev parameter does not match bdev member in entry -EINVAL if an <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> structure was available on this thread. </dd></dl>

</div>
</div>
<a id="a9d37ad1d4da0bcb51ada76dbe4f4ce15" name="a9d37ad1d4da0bcb51ada76dbe4f4ce15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d37ad1d4da0bcb51ada76dbe4f4ce15">&#9670;&#160;</a></span>spdk_bdev_set_qd_sampling_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_set_qd_sampling_period </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>period</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable queue depth sampling for this bdev. </p>
<p>Enables queue depth sampling when period is greater than 0. Disables it when the period is equal to zero. The resulting queue depth is stored in the <a class="el" href="structspdk__bdev.html">spdk_bdev</a> object as measured_queue_depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device on which to enable queue depth tracking. </td></tr>
    <tr><td class="paramname">period</td><td>The period at which to poll this bdev's queue depth. If this is set to zero, polling will be disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70520c668368881df8d7410fec9b1a08" name="a70520c668368881df8d7410fec9b1a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70520c668368881df8d7410fec9b1a08">&#9670;&#160;</a></span>spdk_bdev_set_qos_rate_limits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_set_qos_rate_limits </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *</td>          <td class="paramname"><span class="paramname"><em>limits</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cb_arg, int status)</td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the quality of service rate limits on a bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device. </td></tr>
    <tr><td class="paramname">limits</td><td>Pointer to the QoS rate limits array which holding the limits. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function to be called when the QoS limit has been updated. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument to pass to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<p>The limits are ordered based on the <a class="el" href="#aedfbfc44fa2113d7ee219d09a0994d93">spdk_bdev_qos_rate_limit_type</a> enum. </p>

</div>
</div>
<a id="af0fc679da6beac3cf9677f1bf97c6974" name="af0fc679da6beac3cf9677f1bf97c6974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fc679da6beac3cf9677f1bf97c6974">&#9670;&#160;</a></span>spdk_bdev_set_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_set_timeout </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>timeout_in_sec</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a83db84993554e784cbddf2d217f6ea4f">spdk_bdev_io_timeout_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a time limit for the timeout IO of the bdev and timeout callback. </p>
<p>We can use this function to enable/disable the timeout handler. If the timeout_in_sec &gt; 0 then it means to enable the timeout IO handling or change the time limit. If the timeout_in_sec == 0 it means to disable the timeout IO handling. If you want to enable or change the timeout IO handle you need to specify the spdk_bdev_io_timeout_cb it means the upper user determines what to do if you meet the timeout IO, for example, you can reset the device or abort the IO. Note: This function must run in the desc's thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor. </td></tr>
    <tr><td class="paramname">timeout_in_sec</td><td>Timeout value </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Bdev IO timeout callback </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Callback argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno on failure. </dd></dl>

</div>
</div>
<a id="a57814ce5dc208380ebf39dab0e1ce9a8" name="a57814ce5dc208380ebf39dab0e1ce9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57814ce5dc208380ebf39dab0e1ce9a8">&#9670;&#160;</a></span>spdk_bdev_subsystem_config_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_subsystem_config_json </td>
          <td>(</td>
          <td class="paramtype">struct spdk_json_write_ctx *</td>          <td class="paramname"><span class="paramname"><em>w</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the full configuration options for the registered block device modules and created bdevs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>pointer to a JSON write context where the configuration will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e34f9d44b0d59b4e1d88967e77d9675" name="a4e34f9d44b0d59b4e1d88967e77d9675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e34f9d44b0d59b4e1d88967e77d9675">&#9670;&#160;</a></span>spdk_bdev_wait_for_examine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_wait_for_examine </td>
          <td>(</td>
          <td class="paramtype">spdk_bdev_wait_for_examine_cb</td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report when all bdevs finished the examine process. </p>
<p>The registered cb_fn will be called just once. This function needs to be called again to receive further reports on examine process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_fn</td><td>Callback function. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if function was registered, suitable errno value otherwise </dd></dl>

</div>
</div>
<a id="ac432e059187b2dee62418354664e87c2" name="ac432e059187b2dee62418354664e87c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac432e059187b2dee62418354664e87c2">&#9670;&#160;</a></span>spdk_bdev_zcopy_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_zcopy_end </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> *</td>          <td class="paramname"><span class="paramname"><em>bdev_io</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>commit</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a request to release a data buffer representing a range of blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O request returned in the completion callback of <a class="el" href="#a0ae02ac58ed10886d4a00ba3d94af4ce" title="Submit a request to acquire a data buffer that represents the given range of blocks.">spdk_bdev_zcopy_start()</a>. </td></tr>
    <tr><td class="paramname">commit</td><td>Whether to commit the data in the buffers to the blocks before releasing. The data does not need to be committed if it was not modified. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a0ae02ac58ed10886d4a00ba3d94af4ce" name="a0ae02ac58ed10886d4a00ba3d94af4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae02ac58ed10886d4a00ba3d94af4ce">&#9670;&#160;</a></span>spdk_bdev_zcopy_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_zcopy_start </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset_blocks</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>num_blocks</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>populate</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a request to acquire a data buffer that represents the given range of blocks. </p>
<p>The data buffer is placed in the <a class="el" href="structspdk__bdev__io.html">spdk_bdev_io</a> structure and can be obtained by calling <a class="el" href="#aa05d8c0e82bfbcc209af1eb958230ede" title="Get the iovec describing the data buffer of a bdev_io.">spdk_bdev_io_get_iovec()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="#ac9992f445e8adf2b9f4fd38ac4978762" title="Obtain an I/O channel for the block device opened by the specified descriptor.">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">iov</td><td>A scatter gather list to be populated with the buffers </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The maximum number of elements in iov. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks. </td></tr>
    <tr><td class="paramname">populate</td><td>Whether the data buffer should be populated with the data at the given blocks. Populating the data buffer can be skipped if the user writes new data to the entire buffer. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="ac93dda3868b191be70ac7e1517422c1f" name="ac93dda3868b191be70ac7e1517422c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93dda3868b191be70ac7e1517422c1f">&#9670;&#160;</a></span>spdk_for_each_bdev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_for_each_bdev </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4163854db79e0e3b211dd72ca031fbb0">spdk_for_each_bdev_fn</a></td>          <td class="paramname"><span class="paramname"><em>fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the provided callback function for every registered block device. </p>
<p>If fn returns negated errno, <a class="el" href="#ac93dda3868b191be70ac7e1517422c1f" title="Call the provided callback function for every registered block device.">spdk_for_each_bdev()</a> terminates iteration.</p>
<p><a class="el" href="#ac93dda3868b191be70ac7e1517422c1f" title="Call the provided callback function for every registered block device.">spdk_for_each_bdev()</a> opens before and closes after executing the provided callback function for each bdev internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context passed to the callback function. </td></tr>
    <tr><td class="paramname">fn</td><td>Callback function for each block device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if operation is successful, or suitable errno value one of the callback returned otherwise. </dd></dl>

</div>
</div>
<a id="aeb680eb5205197872738e482204ab441" name="aeb680eb5205197872738e482204ab441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb680eb5205197872738e482204ab441">&#9670;&#160;</a></span>spdk_for_each_bdev_leaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_for_each_bdev_leaf </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a4163854db79e0e3b211dd72ca031fbb0">spdk_for_each_bdev_fn</a></td>          <td class="paramname"><span class="paramname"><em>fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the provided callback function for every block device without virtual block devices on top. </p>
<p><a class="el" href="#aeb680eb5205197872738e482204ab441" title="Call the provided callback function for every block device without virtual block devices on top.">spdk_for_each_bdev_leaf()</a> opens before and closes after executing the provided callback function for each unclaimed bdev internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context passed to the callback function. </td></tr>
    <tr><td class="paramname">fn</td><td>Callback function for each block device without virtual block devices on top.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if operation is successful, or suitable errno value one of the callback returned otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.10.0 </li>
</ul>
</div>
</div>
</body>
</html>
