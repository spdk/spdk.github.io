<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.13">
  <title>SPDK: bdev.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-sm-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://ci.spdk.io/status/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://github.com/spdk/spdk/wiki/Roadmap">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://github.com/spdk/spdk/wiki/News">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_67fbcc0b4317645100def1406b508c33.html">spdk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bdev.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Block device abstraction layer.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a22219ae3fb084dcb87bcc6d454b415aa"><td class="memItemLeft" align="right" valign="top"><a id="a22219ae3fb084dcb87bcc6d454b415aa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_BDEV_SMALL_BUF_MAX_SIZE</b>&#160;&#160;&#160;8192</td></tr>
<tr class="separator:a22219ae3fb084dcb87bcc6d454b415aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9496c34e0fc135e1f309fd586e8e65d0"><td class="memItemLeft" align="right" valign="top"><a id="a9496c34e0fc135e1f309fd586e8e65d0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_BDEV_LARGE_BUF_MAX_SIZE</b>&#160;&#160;&#160;(64 * 1024)</td></tr>
<tr class="separator:a9496c34e0fc135e1f309fd586e8e65d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a51a55c97586c2d524fffcabc4d7910d6"><td class="memItemLeft" align="right" valign="top"><a id="a51a55c97586c2d524fffcabc4d7910d6"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_remove_cb_t</b>) (void *remove_ctx)</td></tr>
<tr class="separator:a51a55c97586c2d524fffcabc4d7910d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5602dfd313f90032dd91683b9663e3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>) (struct spdk_bdev_io *bdev_io, bool success, void *cb_arg)</td></tr>
<tr class="memdesc:a0c5602dfd313f90032dd91683b9663e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block device completion callback.  <a href="#a0c5602dfd313f90032dd91683b9663e3">More...</a><br /></td></tr>
<tr class="separator:a0c5602dfd313f90032dd91683b9663e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a8987bb3a1bc368881f6b81d249bd3"><td class="memItemLeft" align="right" valign="top"><a id="aa6a8987bb3a1bc368881f6b81d249bd3"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_init_cb</b>) (void *cb_arg, int rc)</td></tr>
<tr class="separator:aa6a8987bb3a1bc368881f6b81d249bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715b633110065696fa53c518bb411602"><td class="memItemLeft" align="right" valign="top"><a id="a715b633110065696fa53c518bb411602"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_poller_fn</b>) (void *arg)</td></tr>
<tr class="separator:a715b633110065696fa53c518bb411602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdcec712b6428e422e25953f116509d"><td class="memItemLeft" align="right" valign="top"><a id="aefdcec712b6428e422e25953f116509d"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_poller_start_cb</b>) (struct spdk_bdev_poller **ppoller, spdk_bdev_poller_fn fn, void *arg, uint32_t lcore, uint64_t period_microseconds)</td></tr>
<tr class="separator:aefdcec712b6428e422e25953f116509d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b86291d0c4d75ad8b0fc69dc6e9d87"><td class="memItemLeft" align="right" valign="top"><a id="a24b86291d0c4d75ad8b0fc69dc6e9d87"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_poller_stop_cb</b>) (struct spdk_bdev_poller **ppoller)</td></tr>
<tr class="separator:a24b86291d0c4d75ad8b0fc69dc6e9d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad6c166f5d928c2995df57c96a2977862"><td class="memItemLeft" align="right" valign="top"><a id="ad6c166f5d928c2995df57c96a2977862"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ad6c166f5d928c2995df57c96a2977862">spdk_bdev_status</a> { <b>SPDK_BDEV_STATUS_INVALID</b>, 
<b>SPDK_BDEV_STATUS_READY</b>, 
<b>SPDK_BDEV_STATUS_REMOVING</b>
 }<tr class="memdesc:ad6c166f5d928c2995df57c96a2977862"><td class="mdescLeft">&#160;</td><td class="mdescRight">bdev status <br /></td></tr>
</td></tr>
<tr class="separator:ad6c166f5d928c2995df57c96a2977862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633029e24ab5ae4a689bffa2565a519f"><td class="memItemLeft" align="right" valign="top"><a id="a633029e24ab5ae4a689bffa2565a519f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a633029e24ab5ae4a689bffa2565a519f">spdk_bdev_io_type</a> { <br />
&#160;&#160;<b>SPDK_BDEV_IO_TYPE_INVALID</b> = 0, 
<b>SPDK_BDEV_IO_TYPE_READ</b>, 
<b>SPDK_BDEV_IO_TYPE_WRITE</b>, 
<b>SPDK_BDEV_IO_TYPE_UNMAP</b>, 
<br />
&#160;&#160;<b>SPDK_BDEV_IO_TYPE_FLUSH</b>, 
<b>SPDK_BDEV_IO_TYPE_RESET</b>, 
<b>SPDK_BDEV_IO_TYPE_NVME_ADMIN</b>, 
<b>SPDK_BDEV_IO_TYPE_NVME_IO</b>, 
<br />
&#160;&#160;<b>SPDK_BDEV_IO_TYPE_WRITE_ZEROES</b>
<br />
 }<tr class="memdesc:a633029e24ab5ae4a689bffa2565a519f"><td class="mdescLeft">&#160;</td><td class="mdescRight">bdev I/O type <br /></td></tr>
</td></tr>
<tr class="separator:a633029e24ab5ae4a689bffa2565a519f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8922cc097ac6ced68ce492e618df1512"><td class="memItemLeft" align="right" valign="top"><a id="a8922cc097ac6ced68ce492e618df1512"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_initialize</b> (spdk_bdev_init_cb cb_fn, void *cb_arg, spdk_bdev_poller_start_cb start_poller_fn, spdk_bdev_poller_stop_cb stop_poller_fn)</td></tr>
<tr class="separator:a8922cc097ac6ced68ce492e618df1512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9475b84efdaeb962f5a8cb4f6f6c3d42"><td class="memItemLeft" align="right" valign="top"><a id="a9475b84efdaeb962f5a8cb4f6f6c3d42"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_finish</b> (void)</td></tr>
<tr class="separator:a9475b84efdaeb962f5a8cb4f6f6c3d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273c20b5f07dd8c727ec0d0b80b804fe"><td class="memItemLeft" align="right" valign="top"><a id="a273c20b5f07dd8c727ec0d0b80b804fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_config_text</b> (FILE *fp)</td></tr>
<tr class="separator:a273c20b5f07dd8c727ec0d0b80b804fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c759c53d028e3e408d19156f0e1eb1"><td class="memItemLeft" align="right" valign="top"><a id="a89c759c53d028e3e408d19156f0e1eb1"></a>
struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_get_by_name</b> (const char *bdev_name)</td></tr>
<tr class="separator:a89c759c53d028e3e408d19156f0e1eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578b0a9d444ddbb23c8181d9a5ea4f46"><td class="memItemLeft" align="right" valign="top"><a id="a578b0a9d444ddbb23c8181d9a5ea4f46"></a>
struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a578b0a9d444ddbb23c8181d9a5ea4f46">spdk_bdev_first</a> (void)</td></tr>
<tr class="memdesc:a578b0a9d444ddbb23c8181d9a5ea4f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">These two functions iterate the full list of bdevs, including bdevs that have virtual bdevs on top of them. <br /></td></tr>
<tr class="separator:a578b0a9d444ddbb23c8181d9a5ea4f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c0b9cb8dde1177df3442206cf87d2d"><td class="memItemLeft" align="right" valign="top"><a id="aa1c0b9cb8dde1177df3442206cf87d2d"></a>
struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_next</b> (struct spdk_bdev *prev)</td></tr>
<tr class="separator:aa1c0b9cb8dde1177df3442206cf87d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717d20a033b87c5de88892c78ae55f4c"><td class="memItemLeft" align="right" valign="top"><a id="a717d20a033b87c5de88892c78ae55f4c"></a>
struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a717d20a033b87c5de88892c78ae55f4c">spdk_bdev_first_leaf</a> (void)</td></tr>
<tr class="memdesc:a717d20a033b87c5de88892c78ae55f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">These two functions only iterate over bdevs which have no virtual bdevs on top of them. <br /></td></tr>
<tr class="separator:a717d20a033b87c5de88892c78ae55f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae4a6dad6562cdefd3476ec23bfcccb"><td class="memItemLeft" align="right" valign="top"><a id="a6ae4a6dad6562cdefd3476ec23bfcccb"></a>
struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_next_leaf</b> (struct spdk_bdev *prev)</td></tr>
<tr class="separator:a6ae4a6dad6562cdefd3476ec23bfcccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacdfd5debd3917d84d18be0277203ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aeacdfd5debd3917d84d18be0277203ff">spdk_bdev_open</a> (struct spdk_bdev *bdev, bool write, spdk_bdev_remove_cb_t remove_cb, void *remove_ctx, struct spdk_bdev_desc **desc)</td></tr>
<tr class="memdesc:aeacdfd5debd3917d84d18be0277203ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a block device for I/O operations.  <a href="#aeacdfd5debd3917d84d18be0277203ff">More...</a><br /></td></tr>
<tr class="separator:aeacdfd5debd3917d84d18be0277203ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5fc830851a2eb0aa34bbb40cf5eac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aaf5fc830851a2eb0aa34bbb40cf5eac6">spdk_bdev_close</a> (struct spdk_bdev_desc *desc)</td></tr>
<tr class="memdesc:aaf5fc830851a2eb0aa34bbb40cf5eac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a previously opened block device.  <a href="#aaf5fc830851a2eb0aa34bbb40cf5eac6">More...</a><br /></td></tr>
<tr class="separator:aaf5fc830851a2eb0aa34bbb40cf5eac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6418cfa0e9076ef7dafa7753c4c2028"><td class="memItemLeft" align="right" valign="top">struct spdk_bdev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ac6418cfa0e9076ef7dafa7753c4c2028">spdk_bdev_desc_get_bdev</a> (struct spdk_bdev_desc *desc)</td></tr>
<tr class="memdesc:ac6418cfa0e9076ef7dafa7753c4c2028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bdev associated with a bdev descriptor.  <a href="#ac6418cfa0e9076ef7dafa7753c4c2028">More...</a><br /></td></tr>
<tr class="separator:ac6418cfa0e9076ef7dafa7753c4c2028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd5dff692dc162459801d5649fe7655"><td class="memItemLeft" align="right" valign="top"><a id="a7cd5dff692dc162459801d5649fe7655"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_io_type_supported</b> (struct spdk_bdev *bdev, enum <a class="el" href="bdev_8h.html#a633029e24ab5ae4a689bffa2565a519f">spdk_bdev_io_type</a> io_type)</td></tr>
<tr class="separator:a7cd5dff692dc162459801d5649fe7655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d158f886b7ae2f735a794da420ca55"><td class="memItemLeft" align="right" valign="top"><a id="a84d158f886b7ae2f735a794da420ca55"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_bdev_dump_config_json</b> (struct spdk_bdev *bdev, struct spdk_json_write_ctx *w)</td></tr>
<tr class="separator:a84d158f886b7ae2f735a794da420ca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97a853dcb945bf004817424b7aa28af"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ad97a853dcb945bf004817424b7aa28af">spdk_bdev_get_name</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:ad97a853dcb945bf004817424b7aa28af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device name.  <a href="#ad97a853dcb945bf004817424b7aa28af">More...</a><br /></td></tr>
<tr class="separator:ad97a853dcb945bf004817424b7aa28af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb4d1f8822c30be8c5d9c5dc3e62483"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a1cb4d1f8822c30be8c5d9c5dc3e62483">spdk_bdev_get_product_name</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:a1cb4d1f8822c30be8c5d9c5dc3e62483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device product name.  <a href="#a1cb4d1f8822c30be8c5d9c5dc3e62483">More...</a><br /></td></tr>
<tr class="separator:a1cb4d1f8822c30be8c5d9c5dc3e62483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba8c5672c8226b9b63f44543518c527"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a3ba8c5672c8226b9b63f44543518c527">spdk_bdev_get_block_size</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:a3ba8c5672c8226b9b63f44543518c527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get block device logical block size.  <a href="#a3ba8c5672c8226b9b63f44543518c527">More...</a><br /></td></tr>
<tr class="separator:a3ba8c5672c8226b9b63f44543518c527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86568eca8f0b4d0dc9bc59c5138fc7a5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a86568eca8f0b4d0dc9bc59c5138fc7a5">spdk_bdev_get_num_blocks</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:a86568eca8f0b4d0dc9bc59c5138fc7a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of block device in logical blocks.  <a href="#a86568eca8f0b4d0dc9bc59c5138fc7a5">More...</a><br /></td></tr>
<tr class="separator:a86568eca8f0b4d0dc9bc59c5138fc7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d238484b372a77ba130fbb70f83519"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ab4d238484b372a77ba130fbb70f83519">spdk_bdev_get_buf_align</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:ab4d238484b372a77ba130fbb70f83519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get minimum I/O buffer address alignment for a bdev.  <a href="#ab4d238484b372a77ba130fbb70f83519">More...</a><br /></td></tr>
<tr class="separator:ab4d238484b372a77ba130fbb70f83519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79625889e23318204d235da36a4fa02"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aa79625889e23318204d235da36a4fa02">spdk_bdev_get_optimal_io_boundary</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:aa79625889e23318204d235da36a4fa02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get optimal I/O boundary for a bdev.  <a href="#aa79625889e23318204d235da36a4fa02">More...</a><br /></td></tr>
<tr class="separator:aa79625889e23318204d235da36a4fa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f6d6ce09da384501f09a49581caa37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a93f6d6ce09da384501f09a49581caa37">spdk_bdev_has_write_cache</a> (const struct spdk_bdev *bdev)</td></tr>
<tr class="memdesc:a93f6d6ce09da384501f09a49581caa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether block device has an enabled write cache.  <a href="#a93f6d6ce09da384501f09a49581caa37">More...</a><br /></td></tr>
<tr class="separator:a93f6d6ce09da384501f09a49581caa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bb9e746b030d7c4c89cbcf60076c7e"><td class="memItemLeft" align="right" valign="top">struct spdk_io_channel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e">spdk_bdev_get_io_channel</a> (struct spdk_bdev_desc *desc)</td></tr>
<tr class="memdesc:ab5bb9e746b030d7c4c89cbcf60076c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an I/O channel for the block device opened by the specified descriptor.  <a href="#ab5bb9e746b030d7c4c89cbcf60076c7e">More...</a><br /></td></tr>
<tr class="separator:ab5bb9e746b030d7c4c89cbcf60076c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b500ce84df1d2551f76e635c9dafbd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a4b500ce84df1d2551f76e635c9dafbd5">spdk_bdev_read</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, uint64_t offset, uint64_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a4b500ce84df1d2551f76e635c9dafbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <a href="#a4b500ce84df1d2551f76e635c9dafbd5">More...</a><br /></td></tr>
<tr class="separator:a4b500ce84df1d2551f76e635c9dafbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec9efd151e2fb34ee3d22a1edbbb53f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aeec9efd151e2fb34ee3d22a1edbbb53f">spdk_bdev_read_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:aeec9efd151e2fb34ee3d22a1edbbb53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <a href="#aeec9efd151e2fb34ee3d22a1edbbb53f">More...</a><br /></td></tr>
<tr class="separator:aeec9efd151e2fb34ee3d22a1edbbb53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac9efa882e87909acfd4bccaddb1778"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a9ac9efa882e87909acfd4bccaddb1778">spdk_bdev_readv</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset, uint64_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a9ac9efa882e87909acfd4bccaddb1778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <a href="#a9ac9efa882e87909acfd4bccaddb1778">More...</a><br /></td></tr>
<tr class="separator:a9ac9efa882e87909acfd4bccaddb1778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55483d5ae010c514b37b976ad803b4b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a55483d5ae010c514b37b976ad803b4b2">spdk_bdev_readv_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a55483d5ae010c514b37b976ad803b4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a read request to the bdev on the given channel.  <a href="#a55483d5ae010c514b37b976ad803b4b2">More...</a><br /></td></tr>
<tr class="separator:a55483d5ae010c514b37b976ad803b4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa740a114ef34d6a2f126d4e3a9dd9e9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aa740a114ef34d6a2f126d4e3a9dd9e9b">spdk_bdev_write</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, uint64_t offset, uint64_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:aa740a114ef34d6a2f126d4e3a9dd9e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <a href="#aa740a114ef34d6a2f126d4e3a9dd9e9b">More...</a><br /></td></tr>
<tr class="separator:aa740a114ef34d6a2f126d4e3a9dd9e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12da8917f525a6e11cbf22b2b7652c89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a12da8917f525a6e11cbf22b2b7652c89">spdk_bdev_write_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, void *buf, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a12da8917f525a6e11cbf22b2b7652c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <a href="#a12da8917f525a6e11cbf22b2b7652c89">More...</a><br /></td></tr>
<tr class="separator:a12da8917f525a6e11cbf22b2b7652c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a508a1c301a1321faf0680a8f31f59a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a9a508a1c301a1321faf0680a8f31f59a">spdk_bdev_writev</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset, uint64_t len, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a9a508a1c301a1321faf0680a8f31f59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <a href="#a9a508a1c301a1321faf0680a8f31f59a">More...</a><br /></td></tr>
<tr class="separator:a9a508a1c301a1321faf0680a8f31f59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5849064d12de9f140a41522d1f7c95b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#af5849064d12de9f140a41522d1f7c95b">spdk_bdev_writev_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, struct iovec *iov, int iovcnt, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:af5849064d12de9f140a41522d1f7c95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write request to the bdev on the given channel.  <a href="#af5849064d12de9f140a41522d1f7c95b">More...</a><br /></td></tr>
<tr class="separator:af5849064d12de9f140a41522d1f7c95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc50b78fec7f69190d9139aff29a9043"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#adc50b78fec7f69190d9139aff29a9043">spdk_bdev_write_zeroes</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset, uint64_t len, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:adc50b78fec7f69190d9139aff29a9043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write zeroes request to the bdev on the given channel.  <a href="#adc50b78fec7f69190d9139aff29a9043">More...</a><br /></td></tr>
<tr class="separator:adc50b78fec7f69190d9139aff29a9043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047f8a9f8d0a3d1d7bfcdf0a9838b261"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a047f8a9f8d0a3d1d7bfcdf0a9838b261">spdk_bdev_write_zeroes_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a047f8a9f8d0a3d1d7bfcdf0a9838b261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a write zeroes request to the bdev on the given channel.  <a href="#a047f8a9f8d0a3d1d7bfcdf0a9838b261">More...</a><br /></td></tr>
<tr class="separator:a047f8a9f8d0a3d1d7bfcdf0a9838b261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680c9c302998f7b003e2476e35d9ae4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a680c9c302998f7b003e2476e35d9ae4b">spdk_bdev_unmap</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset, uint64_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a680c9c302998f7b003e2476e35d9ae4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an unmap request to the block device.  <a href="#a680c9c302998f7b003e2476e35d9ae4b">More...</a><br /></td></tr>
<tr class="separator:a680c9c302998f7b003e2476e35d9ae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7555fdd41019e29b40e535b72457d30b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a7555fdd41019e29b40e535b72457d30b">spdk_bdev_unmap_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a7555fdd41019e29b40e535b72457d30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an unmap request to the block device.  <a href="#a7555fdd41019e29b40e535b72457d30b">More...</a><br /></td></tr>
<tr class="separator:a7555fdd41019e29b40e535b72457d30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7105b63cc84037543d9472ab33c8be93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a7105b63cc84037543d9472ab33c8be93">spdk_bdev_flush</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset, uint64_t length, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a7105b63cc84037543d9472ab33c8be93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a flush request to the bdev on the given channel.  <a href="#a7105b63cc84037543d9472ab33c8be93">More...</a><br /></td></tr>
<tr class="separator:a7105b63cc84037543d9472ab33c8be93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d84cd937e760cf32756654dc9720ed4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a9d84cd937e760cf32756654dc9720ed4">spdk_bdev_flush_blocks</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, uint64_t offset_blocks, uint64_t num_blocks, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:a9d84cd937e760cf32756654dc9720ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a flush request to the bdev on the given channel.  <a href="#a9d84cd937e760cf32756654dc9720ed4">More...</a><br /></td></tr>
<tr class="separator:a9d84cd937e760cf32756654dc9720ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca574d3e94be6150343823dd2e7ecf46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aca574d3e94be6150343823dd2e7ecf46">spdk_bdev_reset</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:aca574d3e94be6150343823dd2e7ecf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit a reset request to the bdev on the given channel.  <a href="#aca574d3e94be6150343823dd2e7ecf46">More...</a><br /></td></tr>
<tr class="separator:aca574d3e94be6150343823dd2e7ecf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2249ef71e7125338b6cebf935a881ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ae2249ef71e7125338b6cebf935a881ab">spdk_bdev_nvme_admin_passthru</a> (struct spdk_bdev_desc *desc, struct spdk_io_channel *ch, const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, size_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ae2249ef71e7125338b6cebf935a881ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an NVMe Admin command to the bdev.  <a href="#ae2249ef71e7125338b6cebf935a881ab">More...</a><br /></td></tr>
<tr class="separator:ae2249ef71e7125338b6cebf935a881ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab172cf6afc9ef154bd823b91b09dee87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ab172cf6afc9ef154bd823b91b09dee87">spdk_bdev_nvme_io_passthru</a> (struct spdk_bdev_desc *bdev_desc, struct spdk_io_channel *ch, const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *cmd, void *buf, size_t nbytes, <a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a> cb, void *cb_arg)</td></tr>
<tr class="memdesc:ab172cf6afc9ef154bd823b91b09dee87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submit an NVMe I/O command to the bdev.  <a href="#ab172cf6afc9ef154bd823b91b09dee87">More...</a><br /></td></tr>
<tr class="separator:ab172cf6afc9ef154bd823b91b09dee87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536a365e14bc4f3ddf76b9340958ebd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#a536a365e14bc4f3ddf76b9340958ebd8">spdk_bdev_free_io</a> (struct spdk_bdev_io *bdev_io)</td></tr>
<tr class="memdesc:a536a365e14bc4f3ddf76b9340958ebd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an I/O request.  <a href="#a536a365e14bc4f3ddf76b9340958ebd8">More...</a><br /></td></tr>
<tr class="separator:a536a365e14bc4f3ddf76b9340958ebd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ba28ba382edd1d792d51a054eb3aa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ab1ba28ba382edd1d792d51a054eb3aa2">spdk_bdev_get_io_stat</a> (struct spdk_bdev *bdev, struct spdk_io_channel *ch, struct <a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a> *stat)</td></tr>
<tr class="memdesc:ab1ba28ba382edd1d792d51a054eb3aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return I/O statistics for this channel.  <a href="#ab1ba28ba382edd1d792d51a054eb3aa2">More...</a><br /></td></tr>
<tr class="separator:ab1ba28ba382edd1d792d51a054eb3aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe43254747db3cd072dfb596be3bbf2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#afe43254747db3cd072dfb596be3bbf2f">spdk_bdev_io_get_nvme_status</a> (const struct spdk_bdev_io *bdev_io, int *sct, int *sc)</td></tr>
<tr class="memdesc:afe43254747db3cd072dfb596be3bbf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of bdev_io as an NVMe status code.  <a href="#afe43254747db3cd072dfb596be3bbf2f">More...</a><br /></td></tr>
<tr class="separator:afe43254747db3cd072dfb596be3bbf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c213b4317d5077197950253af1ac50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#ac3c213b4317d5077197950253af1ac50">spdk_bdev_io_get_scsi_status</a> (const struct spdk_bdev_io *bdev_io, int *sc, int *sk, int *asc, int *ascq)</td></tr>
<tr class="memdesc:ac3c213b4317d5077197950253af1ac50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status of bdev_io as a SCSI status code.  <a href="#ac3c213b4317d5077197950253af1ac50">More...</a><br /></td></tr>
<tr class="separator:ac3c213b4317d5077197950253af1ac50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05d8c0e82bfbcc209af1eb958230ede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bdev_8h.html#aa05d8c0e82bfbcc209af1eb958230ede">spdk_bdev_io_get_iovec</a> (struct spdk_bdev_io *bdev_io, struct iovec **iovp, int *iovcntp)</td></tr>
<tr class="memdesc:aa05d8c0e82bfbcc209af1eb958230ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the iovec describing the data buffer of a bdev_io.  <a href="#aa05d8c0e82bfbcc209af1eb958230ede">More...</a><br /></td></tr>
<tr class="separator:aa05d8c0e82bfbcc209af1eb958230ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Block device abstraction layer. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a0c5602dfd313f90032dd91683b9663e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5602dfd313f90032dd91683b9663e3">&#9670;&nbsp;</a></span>spdk_bdev_io_completion_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_bdev_io_completion_cb) (struct spdk_bdev_io *bdev_io, bool success, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block device completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>Block device I/O that has completed. </td></tr>
    <tr><td class="paramname">success</td><td>true if I/O completed successfully or false if it failed; additional error information may be retrieved from bdev_io by calling <a class="el" href="bdev_8h.html#afe43254747db3cd072dfb596be3bbf2f" title="Get the status of bdev_io as an NVMe status code. ">spdk_bdev_io_get_nvme_status()</a> or <a class="el" href="bdev_8h.html#ac3c213b4317d5077197950253af1ac50" title="Get the status of bdev_io as a SCSI status code. ">spdk_bdev_io_get_scsi_status()</a>. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Callback argument specified when bdev_io was submitted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaf5fc830851a2eb0aa34bbb40cf5eac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5fc830851a2eb0aa34bbb40cf5eac6">&#9670;&nbsp;</a></span>spdk_bdev_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_close </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a previously opened block device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6418cfa0e9076ef7dafa7753c4c2028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6418cfa0e9076ef7dafa7753c4c2028">&#9670;&nbsp;</a></span>spdk_bdev_desc_get_bdev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_bdev* spdk_bdev_desc_get_bdev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bdev associated with a bdev descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Open block device desciptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bdev associated with the descriptor </dd></dl>

</div>
</div>
<a id="a7105b63cc84037543d9472ab33c8be93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7105b63cc84037543d9472ab33c8be93">&#9670;&nbsp;</a></span>spdk_bdev_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_flush </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a flush request to the bdev on the given channel. </p>
<p>For devices with volatile caches, data is not guaranteed to be persistent until the completion of a flush request. Call <a class="el" href="bdev_8h.html#a93f6d6ce09da384501f09a49581caa37" title="Query whether block device has an enabled write cache. ">spdk_bdev_has_write_cache()</a> to check if the bdev has a volatile cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a9d84cd937e760cf32756654dc9720ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d84cd937e760cf32756654dc9720ed4">&#9670;&nbsp;</a></span>spdk_bdev_flush_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_flush_blocks </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a flush request to the bdev on the given channel. </p>
<p>For devices with volatile caches, data is not guaranteed to be persistent until the completion of a flush request. Call <a class="el" href="bdev_8h.html#a93f6d6ce09da384501f09a49581caa37" title="Query whether block device has an enabled write cache. ">spdk_bdev_has_write_cache()</a> to check if the bdev has a volatile cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a536a365e14bc4f3ddf76b9340958ebd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536a365e14bc4f3ddf76b9340958ebd8">&#9670;&nbsp;</a></span>spdk_bdev_free_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_free_io </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_io *&#160;</td>
          <td class="paramname"><em>bdev_io</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free an I/O request. </p>
<p>This should be called after the callback for the I/O has been called and notifies the bdev layer that memory may now be released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O request</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on failure, 0 on success. </dd></dl>

</div>
</div>
<a id="a3ba8c5672c8226b9b63f44543518c527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba8c5672c8226b9b63f44543518c527">&#9670;&nbsp;</a></span>spdk_bdev_get_block_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_bdev_get_block_size </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device logical block size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of logical block for this bdev in bytes. </dd></dl>

</div>
</div>
<a id="ab4d238484b372a77ba130fbb70f83519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d238484b372a77ba130fbb70f83519">&#9670;&nbsp;</a></span>spdk_bdev_get_buf_align()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t spdk_bdev_get_buf_align </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get minimum I/O buffer address alignment for a bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Required alignment of I/O buffers in bytes. </dd></dl>

</div>
</div>
<a id="ab5bb9e746b030d7c4c89cbcf60076c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5bb9e746b030d7c4c89cbcf60076c7e">&#9670;&nbsp;</a></span>spdk_bdev_get_io_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_io_channel* spdk_bdev_get_io_channel </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain an I/O channel for the block device opened by the specified descriptor. </p>
<p>I/O channels are bound to threads, so the resulting I/O channel may only be used from the thread it was originally obtained from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the I/O channel or NULL on failure. </dd></dl>

</div>
</div>
<a id="ab1ba28ba382edd1d792d51a054eb3aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ba28ba382edd1d792d51a054eb3aa2">&#9670;&nbsp;</a></span>spdk_bdev_get_io_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_get_io_stat </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev__io__stat.html">spdk_bdev_io_stat</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return I/O statistics for this channel. </p>
<p>After returning stats, zero out the current state of the statistics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">stat</td><td>The per-channel statistics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad97a853dcb945bf004817424b7aa28af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad97a853dcb945bf004817424b7aa28af">&#9670;&nbsp;</a></span>spdk_bdev_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_bdev_get_name </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of bdev as a null-terminated string. </dd></dl>

</div>
</div>
<a id="a86568eca8f0b4d0dc9bc59c5138fc7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86568eca8f0b4d0dc9bc59c5138fc7a5">&#9670;&nbsp;</a></span>spdk_bdev_get_num_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_bdev_get_num_blocks </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get size of block device in logical blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of bdev in logical blocks.</dd></dl>
<p>Logical blocks are numbered from 0 to spdk_bdev_get_num_blocks(bdev) - 1, inclusive. </p>

</div>
</div>
<a id="aa79625889e23318204d235da36a4fa02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79625889e23318204d235da36a4fa02">&#9670;&nbsp;</a></span>spdk_bdev_get_optimal_io_boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_bdev_get_optimal_io_boundary </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get optimal I/O boundary for a bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optimal I/O boundary in blocks that should not be crossed for best performance, or 0 if no optimal boundary is reported. </dd></dl>

</div>
</div>
<a id="a1cb4d1f8822c30be8c5d9c5dc3e62483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb4d1f8822c30be8c5d9c5dc3e62483">&#9670;&nbsp;</a></span>spdk_bdev_get_product_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_bdev_get_product_name </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get block device product name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product name of bdev as a null-terminated string. </dd></dl>

</div>
</div>
<a id="a93f6d6ce09da384501f09a49581caa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f6d6ce09da384501f09a49581caa37">&#9670;&nbsp;</a></span>spdk_bdev_has_write_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_bdev_has_write_cache </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query whether block device has an enabled write cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if block device has a volatile write cache enabled.</dd></dl>
<p>If this function returns true, written data may not be persistent until a flush command is issued. </p>

</div>
</div>
<a id="aa05d8c0e82bfbcc209af1eb958230ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05d8c0e82bfbcc209af1eb958230ede">&#9670;&nbsp;</a></span>spdk_bdev_io_get_iovec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_io_get_iovec </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_io *&#160;</td>
          <td class="paramname"><em>bdev_io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec **&#160;</td>
          <td class="paramname"><em>iovp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>iovcntp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the iovec describing the data buffer of a bdev_io. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to describe with iovec. </td></tr>
    <tr><td class="paramname">iovp</td><td>Pointer to be filled with iovec. </td></tr>
    <tr><td class="paramname">iovcntp</td><td>Pointer to be filled with number of iovec entries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe43254747db3cd072dfb596be3bbf2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe43254747db3cd072dfb596be3bbf2f">&#9670;&nbsp;</a></span>spdk_bdev_io_get_nvme_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_io_get_nvme_status </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev_io *&#160;</td>
          <td class="paramname"><em>bdev_io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of bdev_io as an NVMe status code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to get the status from. </td></tr>
    <tr><td class="paramname">sct</td><td>Status Code Type return value, as defined by the NVMe specification. </td></tr>
    <tr><td class="paramname">sc</td><td>Status Code return value, as defined by the NVMe specification. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3c213b4317d5077197950253af1ac50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c213b4317d5077197950253af1ac50">&#9670;&nbsp;</a></span>spdk_bdev_io_get_scsi_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_bdev_io_get_scsi_status </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_bdev_io *&#160;</td>
          <td class="paramname"><em>bdev_io</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>asc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ascq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the status of bdev_io as a SCSI status code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev_io</td><td>I/O to get the status from. </td></tr>
    <tr><td class="paramname">sc</td><td>SCSI Status Code. </td></tr>
    <tr><td class="paramname">sk</td><td>SCSI Sense Key. </td></tr>
    <tr><td class="paramname">asc</td><td>SCSI Additional Sense Code. </td></tr>
    <tr><td class="paramname">ascq</td><td>SCSI Additional Sense Code Qualifier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2249ef71e7125338b6cebf935a881ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2249ef71e7125338b6cebf935a881ab">&#9670;&nbsp;</a></span>spdk_bdev_nvme_admin_passthru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_nvme_admin_passthru </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an NVMe Admin command to the bdev. </p>
<p>This passes directly through the block layer to the device. Support for NVMe passthru is optional, indicated by calling spdk_bdev_io_type_supported().</p>
<p>The SGL/PRP will be automated generated based on the given buffer, so that portion of the command may be left empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">cmd</td><td>The raw NVMe command. Must be an admin command. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to written from. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to transfer. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="ab172cf6afc9ef154bd823b91b09dee87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab172cf6afc9ef154bd823b91b09dee87">&#9670;&nbsp;</a></span>spdk_bdev_nvme_io_passthru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_nvme_io_passthru </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>bdev_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__cmd.html">spdk_nvme_cmd</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an NVMe I/O command to the bdev. </p>
<p>This passes directly through the block layer to the device. Support for NVMe passthru is optional, indicated by calling spdk_bdev_io_type_supported().</p>
<p>The SGL/PRP will be automated generated based on the given buffer, so that portion of the command may be left empty. Also, the namespace id (nsid) will be populated automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">cmd</td><td>The raw NVMe command. Must be in the NVM command set. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to written from. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to transfer. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="aeacdfd5debd3917d84d18be0277203ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacdfd5debd3917d84d18be0277203ff">&#9670;&nbsp;</a></span>spdk_bdev_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_open </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_bdev_remove_cb_t&#160;</td>
          <td class="paramname"><em>remove_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>remove_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_bdev_desc **&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a block device for I/O operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device to open. </td></tr>
    <tr><td class="paramname">write</td><td>true is read/write access requested, false if read-only </td></tr>
    <tr><td class="paramname">remove_cb</td><td>callback function for hot remove the device. </td></tr>
    <tr><td class="paramname">remove_ctx</td><td>param for hot removal callback function. </td></tr>
    <tr><td class="paramname">desc</td><td>output parameter for the descriptor when operation is successful </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if operation is successful, suitable errno value otherwise </dd></dl>

</div>
</div>
<a id="a4b500ce84df1d2551f76e635c9dafbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b500ce84df1d2551f76e635c9dafbd5">&#9670;&nbsp;</a></span>spdk_bdev_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_read </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read request to the bdev on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to read into. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="aeec9efd151e2fb34ee3d22a1edbbb53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec9efd151e2fb34ee3d22a1edbbb53f">&#9670;&nbsp;</a></span>spdk_bdev_read_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_read_blocks </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read request to the bdev on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to read into. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks to read. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a9ac9efa882e87909acfd4bccaddb1778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac9efa882e87909acfd4bccaddb1778">&#9670;&nbsp;</a></span>spdk_bdev_readv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_readv </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read request to the bdev on the given channel. </p>
<p>This differs from spdk_bdev_read by allowing the data buffer to be described in a scatter gather list. Some physical devices place memory alignment requirements on data and may not be able to directly transfer into the buffers provided. In this case, the request may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">iov</td><td>A scatter gather list of buffers to be read into. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of elements in iov. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a55483d5ae010c514b37b976ad803b4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55483d5ae010c514b37b976ad803b4b2">&#9670;&nbsp;</a></span>spdk_bdev_readv_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_readv_blocks </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a read request to the bdev on the given channel. </p>
<p>This differs from spdk_bdev_read by allowing the data buffer to be described in a scatter gather list. Some physical devices place memory alignment requirements on data and may not be able to directly transfer into the buffers provided. In this case, the request may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">iov</td><td>A scatter gather list of buffers to be read into. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of elements in iov. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks to read. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="aca574d3e94be6150343823dd2e7ecf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca574d3e94be6150343823dd2e7ecf46">&#9670;&nbsp;</a></span>spdk_bdev_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_reset </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a reset request to the bdev on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a680c9c302998f7b003e2476e35d9ae4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680c9c302998f7b003e2476e35d9ae4b">&#9670;&nbsp;</a></span>spdk_bdev_unmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_unmap </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an unmap request to the block device. </p>
<p>Unmap is sometimes also called trim or deallocate. This notifies the device that the data in the blocks described is no longer valid. Reading blocks that have been unmapped results in indeterminate data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to unmap. Must be a multiple of the block size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a7555fdd41019e29b40e535b72457d30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7555fdd41019e29b40e535b72457d30b">&#9670;&nbsp;</a></span>spdk_bdev_unmap_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_unmap_blocks </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit an unmap request to the block device. </p>
<p>Unmap is sometimes also called trim or deallocate. This notifies the device that the data in the blocks described is no longer valid. Reading blocks that have been unmapped results in indeterminate data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks to unmap. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="aa740a114ef34d6a2f126d4e3a9dd9e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa740a114ef34d6a2f126d4e3a9dd9e9b">&#9670;&nbsp;</a></span>spdk_bdev_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_write </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write request to the bdev on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to written from. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to write. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a12da8917f525a6e11cbf22b2b7652c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12da8917f525a6e11cbf22b2b7652c89">&#9670;&nbsp;</a></span>spdk_bdev_write_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_write_blocks </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write request to the bdev on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">buf</td><td>Data buffer to written from. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks to write. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="adc50b78fec7f69190d9139aff29a9043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc50b78fec7f69190d9139aff29a9043">&#9670;&nbsp;</a></span>spdk_bdev_write_zeroes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_write_zeroes </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write zeroes request to the bdev on the given channel. </p>
<p>This command ensures that all bytes in the specified range are set to 00h</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to zero. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a047f8a9f8d0a3d1d7bfcdf0a9838b261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047f8a9f8d0a3d1d7bfcdf0a9838b261">&#9670;&nbsp;</a></span>spdk_bdev_write_zeroes_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_write_zeroes_blocks </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write zeroes request to the bdev on the given channel. </p>
<p>This command ensures that all bytes in the specified range are set to 00h</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks to zero. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="a9a508a1c301a1321faf0680a8f31f59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a508a1c301a1321faf0680a8f31f59a">&#9670;&nbsp;</a></span>spdk_bdev_writev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_writev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write request to the bdev on the given channel. </p>
<p>This differs from spdk_bdev_write by allowing the data buffer to be described in a scatter gather list. Some physical devices place memory alignment requirements on data and may not be able to directly transfer out of the buffers provided. In this case, the request may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdev</td><td>Block device </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">iov</td><td>A scatter gather list of buffers to be written from. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of elements in iov. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset, in bytes, from the start of the block device. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to read. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
<a id="af5849064d12de9f140a41522d1f7c95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5849064d12de9f140a41522d1f7c95b">&#9670;&nbsp;</a></span>spdk_bdev_writev_blocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_bdev_writev_blocks </td>
          <td>(</td>
          <td class="paramtype">struct spdk_bdev_desc *&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iovcnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bdev_8h.html#a0c5602dfd313f90032dd91683b9663e3">spdk_bdev_io_completion_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submit a write request to the bdev on the given channel. </p>
<p>This differs from spdk_bdev_write by allowing the data buffer to be described in a scatter gather list. Some physical devices place memory alignment requirements on data and may not be able to directly transfer out of the buffers provided. In this case, the request may fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Block device descriptor </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. Obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. </td></tr>
    <tr><td class="paramname">iov</td><td>A scatter gather list of buffers to be written from. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>The number of elements in iov. </td></tr>
    <tr><td class="paramname">offset_blocks</td><td>The offset, in blocks, from the start of the block device. </td></tr>
    <tr><td class="paramname">num_blocks</td><td>The number of blocks to write. buf must be greater than or equal to this size. </td></tr>
    <tr><td class="paramname">cb</td><td>Called when the request is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div>
