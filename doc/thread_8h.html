<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="generator" content="Doxygen 1.9.1" />
  <title>SPDK: thread.h File Reference</title>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  <script type="text/javascript" src="../js/doxyboot.js"></script>
  <script type="text/javascript" src="./navtree.js"></script>
  <link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
<body>
  <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/" aria-label="SPDK">
      <img src="/img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <div class="navbar-nav mr-auto">
        <a class="nav-link header-link active" href="../doc/">Documentation</a>
        <a class="nav-link header-link" href="../development/">Development</a>
        <a class="nav-link header-link" href="../community/">Community</a>
        <a class="nav-link header-link" href="../blog/">Blog</a>
      </div>
      <div class="navbar-nav ml-auto mr-3">
        <a class="nav-link header-link" href="https://github.com/spdk/spdk">
          <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
      </div>
    </div>
  </nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('thread_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">thread.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Thread.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__thread__stats.html">spdk_thread_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__spinlock.html">spdk_spinlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A spinlock augmented with safety checks for use with SPDK.  <a href="structspdk__spinlock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__iobuf__opts.html">spdk_iobuf_opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__iobuf__entry.html">spdk_iobuf_entry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iobuf queue entry  <a href="structspdk__iobuf__entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__iobuf__buffer.html">spdk_iobuf_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__iobuf__pool.html">spdk_iobuf_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__iobuf__channel.html">spdk_iobuf_channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iobuf channel  <a href="structspdk__iobuf__channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a22af34e45fef3fcea2ed3612d9bde2e8"><td class="memItemLeft" align="right" valign="top"><a id="a22af34e45fef3fcea2ed3612d9bde2e8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_IO_CHANNEL_STRUCT_SIZE</b>&#160;&#160;&#160;96</td></tr>
<tr class="separator:a22af34e45fef3fcea2ed3612d9bde2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c73c77029e1c65abe51ed347a762328"><td class="memItemLeft" align="right" valign="top"><a id="a7c73c77029e1c65abe51ed347a762328"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a7c73c77029e1c65abe51ed347a762328">SPDK_MSG_MEMPOOL_CACHE_SIZE</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:a7c73c77029e1c65abe51ed347a762328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message memory pool size definitions. <br /></td></tr>
<tr class="separator:a7c73c77029e1c65abe51ed347a762328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9eaeaa63a29f075a51d38c3a653f744"><td class="memItemLeft" align="right" valign="top"><a id="ab9eaeaa63a29f075a51d38c3a653f744"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_DEFAULT_MSG_MEMPOOL_SIZE</b>&#160;&#160;&#160;(262144 - 1)</td></tr>
<tr class="separator:ab9eaeaa63a29f075a51d38c3a653f744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cf88195e46bb118ac03528f7f5eee0"><td class="memItemLeft" align="right" valign="top"><a id="a17cf88195e46bb118ac03528f7f5eee0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_POLLER_REGISTER</b>(fn,  arg,  period_microseconds)&#160;&#160;&#160;	<a class="el" href="thread_8h.html#a4e1086db1bd40b0a1720bd148967d82d">spdk_poller_register_named</a>(fn, arg, period_microseconds, #fn)</td></tr>
<tr class="separator:a17cf88195e46bb118ac03528f7f5eee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15064b1cd3d036753e04c5c207ad71d"><td class="memItemLeft" align="right" valign="top"><a id="ac15064b1cd3d036753e04c5c207ad71d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_INTERRUPT_REGISTER</b>(efd,  fn,  arg)&#160;&#160;&#160;	<a class="el" href="thread_8h.html#aae58fe1101803d60c523891e7540a23c">spdk_interrupt_register</a>(efd, fn, arg, #fn)</td></tr>
<tr class="separator:ac15064b1cd3d036753e04c5c207ad71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afab3d4339c5bca4dfde209816a9e560f"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#afab3d4339c5bca4dfde209816a9e560f">spdk_new_thread_fn</a>) (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:afab3d4339c5bca4dfde209816a9e560f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that is called each time a new thread is created.  <a href="thread_8h.html#afab3d4339c5bca4dfde209816a9e560f">More...</a><br /></td></tr>
<tr class="separator:afab3d4339c5bca4dfde209816a9e560f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0ad3a2bcbb6d304401b579ab63aeba"><td class="memItemLeft" align="right" valign="top"><a id="a9f0ad3a2bcbb6d304401b579ab63aeba"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9f0ad3a2bcbb6d304401b579ab63aeba">spdk_thread_op_fn</a>) (struct spdk_thread *thread, enum <a class="el" href="thread_8h.html#aa0d064c5b2e0268ad751a682fa8ed6a6">spdk_thread_op</a> op)</td></tr>
<tr class="memdesc:a9f0ad3a2bcbb6d304401b579ab63aeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called for SPDK thread operation. <br /></td></tr>
<tr class="separator:a9f0ad3a2bcbb6d304401b579ab63aeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af791c24e496b96c886fe8bad088eb0cb"><td class="memItemLeft" align="right" valign="top"><a id="af791c24e496b96c886fe8bad088eb0cb"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#af791c24e496b96c886fe8bad088eb0cb">spdk_thread_op_supported_fn</a>) (enum <a class="el" href="thread_8h.html#aa0d064c5b2e0268ad751a682fa8ed6a6">spdk_thread_op</a> op)</td></tr>
<tr class="memdesc:af791c24e496b96c886fe8bad088eb0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to check whether the SPDK thread operation is supported. <br /></td></tr>
<tr class="separator:af791c24e496b96c886fe8bad088eb0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0da6b1b784d4f165dcd48b526d12ad"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>) (void *ctx)</td></tr>
<tr class="memdesc:adc0da6b1b784d4f165dcd48b526d12ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that will be called on the target thread.  <a href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">More...</a><br /></td></tr>
<tr class="separator:adc0da6b1b784d4f165dcd48b526d12ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0e155fc3fa0150aa4a505dd1801e91"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4a0e155fc3fa0150aa4a505dd1801e91">spdk_thread_pass_msg</a>) (<a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn, void *ctx, void *thread_ctx)</td></tr>
<tr class="memdesc:a4a0e155fc3fa0150aa4a505dd1801e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called to pass a message to a thread.  <a href="thread_8h.html#a4a0e155fc3fa0150aa4a505dd1801e91">More...</a><br /></td></tr>
<tr class="separator:a4a0e155fc3fa0150aa4a505dd1801e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c421accdc2a0a61bb7be916106293b"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a>) (void *ctx)</td></tr>
<tr class="memdesc:a35c421accdc2a0a61bb7be916106293b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for a poller.  <a href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">More...</a><br /></td></tr>
<tr class="separator:a35c421accdc2a0a61bb7be916106293b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa00024ffe78012bf1b7ade9aee0ab1a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aaa00024ffe78012bf1b7ade9aee0ab1a">spdk_poller_set_interrupt_mode_cb</a>) (struct spdk_poller *poller, void *cb_arg, bool interrupt_mode)</td></tr>
<tr class="memdesc:aaa00024ffe78012bf1b7ade9aee0ab1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function to set poller into interrupt mode or back to poll mode.  <a href="thread_8h.html#aaa00024ffe78012bf1b7ade9aee0ab1a">More...</a><br /></td></tr>
<tr class="separator:aaa00024ffe78012bf1b7ade9aee0ab1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1d14292cfee8553d4a1ebb519b210a"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aed1d14292cfee8553d4a1ebb519b210a">spdk_io_channel_create_cb</a>) (void *io_device, void *ctx_buf)</td></tr>
<tr class="memdesc:aed1d14292cfee8553d4a1ebb519b210a"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O channel creation callback.  <a href="thread_8h.html#aed1d14292cfee8553d4a1ebb519b210a">More...</a><br /></td></tr>
<tr class="separator:aed1d14292cfee8553d4a1ebb519b210a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aa6a61877f23f79bb75c8fc5e68202"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a75aa6a61877f23f79bb75c8fc5e68202">spdk_io_channel_destroy_cb</a>) (void *io_device, void *ctx_buf)</td></tr>
<tr class="memdesc:a75aa6a61877f23f79bb75c8fc5e68202"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O channel destruction callback.  <a href="thread_8h.html#a75aa6a61877f23f79bb75c8fc5e68202">More...</a><br /></td></tr>
<tr class="separator:a75aa6a61877f23f79bb75c8fc5e68202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae044f4141737c7f2df49cdfb03fd58ca"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae044f4141737c7f2df49cdfb03fd58ca">spdk_io_device_unregister_cb</a>) (void *io_device)</td></tr>
<tr class="memdesc:ae044f4141737c7f2df49cdfb03fd58ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O device unregister callback.  <a href="thread_8h.html#ae044f4141737c7f2df49cdfb03fd58ca">More...</a><br /></td></tr>
<tr class="separator:ae044f4141737c7f2df49cdfb03fd58ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd91f3094f8b4cf60f460e3f88bbf0c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a2dd91f3094f8b4cf60f460e3f88bbf0c">spdk_channel_msg</a>) (struct spdk_io_channel_iter *i)</td></tr>
<tr class="memdesc:a2dd91f3094f8b4cf60f460e3f88bbf0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called on the appropriate thread for each channel associated with io_device.  <a href="thread_8h.html#a2dd91f3094f8b4cf60f460e3f88bbf0c">More...</a><br /></td></tr>
<tr class="separator:a2dd91f3094f8b4cf60f460e3f88bbf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f03fe115196f1de03292ed6d86fd46"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a96f03fe115196f1de03292ed6d86fd46">spdk_channel_for_each_cpl</a>) (struct spdk_io_channel_iter *i, int status)</td></tr>
<tr class="memdesc:a96f03fe115196f1de03292ed6d86fd46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1" title="Call &#39;fn&#39; on each channel associated with io_device.">spdk_for_each_channel()</a> callback.  <a href="thread_8h.html#a96f03fe115196f1de03292ed6d86fd46">More...</a><br /></td></tr>
<tr class="separator:a96f03fe115196f1de03292ed6d86fd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cfdc77d10970d7f3a8631df71e9588"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a61cfdc77d10970d7f3a8631df71e9588">spdk_interrupt_fn</a>) (void *ctx)</td></tr>
<tr class="memdesc:a61cfdc77d10970d7f3a8631df71e9588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function registered for interrupt file descriptor.  <a href="thread_8h.html#a61cfdc77d10970d7f3a8631df71e9588">More...</a><br /></td></tr>
<tr class="separator:a61cfdc77d10970d7f3a8631df71e9588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dd175920b5be7e6d155173c24a5a5c"><td class="memItemLeft" align="right" valign="top"><a id="a67dd175920b5be7e6d155173c24a5a5c"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_iobuf_get_cb</b>) (struct <a class="el" href="structspdk__iobuf__entry.html">spdk_iobuf_entry</a> *entry, void *buf)</td></tr>
<tr class="separator:a67dd175920b5be7e6d155173c24a5a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a8d2ceebef3afb15771cd28e340c27"><td class="memItemLeft" align="right" valign="top"><a id="a91a8d2ceebef3afb15771cd28e340c27"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_iobuf_finish_cb</b>) (void *cb_arg)</td></tr>
<tr class="separator:a91a8d2ceebef3afb15771cd28e340c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9df2d253885de944794d6810ff98fc4e"><td class="memItemLeft" align="right" valign="top"><a id="a9df2d253885de944794d6810ff98fc4e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9df2d253885de944794d6810ff98fc4e">spdk_thread_poller_rc</a> { <b>SPDK_POLLER_IDLE</b>
, <b>SPDK_POLLER_BUSY</b>
 }</td></tr>
<tr class="memdesc:a9df2d253885de944794d6810ff98fc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pollers should always return a value of this type indicating whether they did real work or not. <br /></td></tr>
<tr class="separator:a9df2d253885de944794d6810ff98fc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d064c5b2e0268ad751a682fa8ed6a6"><td class="memItemLeft" align="right" valign="top"><a id="aa0d064c5b2e0268ad751a682fa8ed6a6"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aa0d064c5b2e0268ad751a682fa8ed6a6">spdk_thread_op</a> { <b>SPDK_THREAD_OP_NEW</b>
, <b>SPDK_THREAD_OP_RESCHED</b>
 }</td></tr>
<tr class="memdesc:aa0d064c5b2e0268ad751a682fa8ed6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPDK thread operation type. <br /></td></tr>
<tr class="separator:aa0d064c5b2e0268ad751a682fa8ed6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3b860a0c3ec1fb4f1e6743b1d746b6"><td class="memItemLeft" align="right" valign="top"><a id="a9f3b860a0c3ec1fb4f1e6743b1d746b6"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>spdk_interrupt_event_types</b> { <b>SPDK_INTERRUPT_EVENT_IN</b> = 0x001
, <b>SPDK_INTERRUPT_EVENT_OUT</b> = 0x004
, <b>SPDK_INTERRUPT_EVENT_ET</b> = 1u &lt;&lt; 31
 }</td></tr>
<tr class="separator:a9f3b860a0c3ec1fb4f1e6743b1d746b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af6f06715375ed6a1bff5e037628a8558"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#af6f06715375ed6a1bff5e037628a8558">spdk_poller_register_interrupt</a> (struct spdk_poller *poller, <a class="el" href="thread_8h.html#aaa00024ffe78012bf1b7ade9aee0ab1a">spdk_poller_set_interrupt_mode_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:af6f06715375ed6a1bff5e037628a8558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the poller is capable of entering interrupt mode.  <a href="thread_8h.html#af6f06715375ed6a1bff5e037628a8558">More...</a><br /></td></tr>
<tr class="separator:af6f06715375ed6a1bff5e037628a8558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c6e1cadb3b5a83c5723487e3f02c23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a96c6e1cadb3b5a83c5723487e3f02c23">spdk_thread_lib_init</a> (<a class="el" href="thread_8h.html#afab3d4339c5bca4dfde209816a9e560f">spdk_new_thread_fn</a> new_thread_fn, size_t ctx_sz)</td></tr>
<tr class="memdesc:a96c6e1cadb3b5a83c5723487e3f02c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the threading library.  <a href="thread_8h.html#a96c6e1cadb3b5a83c5723487e3f02c23">More...</a><br /></td></tr>
<tr class="separator:a96c6e1cadb3b5a83c5723487e3f02c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7219c832e5483b4318d2533cb45ff22e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a7219c832e5483b4318d2533cb45ff22e">spdk_thread_lib_init_ext</a> (<a class="el" href="thread_8h.html#a9f0ad3a2bcbb6d304401b579ab63aeba">spdk_thread_op_fn</a> thread_op_fn, <a class="el" href="thread_8h.html#af791c24e496b96c886fe8bad088eb0cb">spdk_thread_op_supported_fn</a> thread_op_supported_fn, size_t ctx_sz, size_t msg_mempool_size)</td></tr>
<tr class="memdesc:a7219c832e5483b4318d2533cb45ff22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the threading library.  <a href="thread_8h.html#a7219c832e5483b4318d2533cb45ff22e">More...</a><br /></td></tr>
<tr class="separator:a7219c832e5483b4318d2533cb45ff22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe409bf16664f461daa516b6a6d1682c"><td class="memItemLeft" align="right" valign="top"><a id="afe409bf16664f461daa516b6a6d1682c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#afe409bf16664f461daa516b6a6d1682c">spdk_thread_lib_fini</a> (void)</td></tr>
<tr class="memdesc:afe409bf16664f461daa516b6a6d1682c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all resources associated with this library. <br /></td></tr>
<tr class="separator:afe409bf16664f461daa516b6a6d1682c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49abb69cad49e5f35363d9b8ee990ae2"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a49abb69cad49e5f35363d9b8ee990ae2">spdk_thread_create</a> (const char *name, const struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *cpumask)</td></tr>
<tr class="memdesc:a49abb69cad49e5f35363d9b8ee990ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new SPDK thread object.  <a href="thread_8h.html#a49abb69cad49e5f35363d9b8ee990ae2">More...</a><br /></td></tr>
<tr class="separator:a49abb69cad49e5f35363d9b8ee990ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4e0f6527f81dc3277989d05b4c7111"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a5e4e0f6527f81dc3277989d05b4c7111">spdk_thread_get_app_thread</a> (void)</td></tr>
<tr class="memdesc:a5e4e0f6527f81dc3277989d05b4c7111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the app thread.  <a href="thread_8h.html#a5e4e0f6527f81dc3277989d05b4c7111">More...</a><br /></td></tr>
<tr class="separator:a5e4e0f6527f81dc3277989d05b4c7111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dac2a0fc19b23be6fecb1e5b6f8a7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a60dac2a0fc19b23be6fecb1e5b6f8a7a">spdk_set_thread</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a60dac2a0fc19b23be6fecb1e5b6f8a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the current system thread to act as if executing the given SPDK thread.  <a href="thread_8h.html#a60dac2a0fc19b23be6fecb1e5b6f8a7a">More...</a><br /></td></tr>
<tr class="separator:a60dac2a0fc19b23be6fecb1e5b6f8a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5132d2abe39a40a0e14e19bb2bd15489"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a5132d2abe39a40a0e14e19bb2bd15489">spdk_thread_exit</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a5132d2abe39a40a0e14e19bb2bd15489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the thread as exited, failing all future <a class="el" href="thread_8h.html#a07b662b152c21dad824ad2738d0733ec" title="Send a message to the given thread.">spdk_thread_send_msg()</a>, <a class="el" href="thread_8h.html#a6b3e883ddce01ae8d93541304d1e9126" title="Register a poller on the current thread.">spdk_poller_register()</a>, and <a class="el" href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8" title="Get an I/O channel for the specified io_device to be used by the calling thread.">spdk_get_io_channel()</a> calls.  <a href="thread_8h.html#a5132d2abe39a40a0e14e19bb2bd15489">More...</a><br /></td></tr>
<tr class="separator:a5132d2abe39a40a0e14e19bb2bd15489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99859eb37714e4ed7c6110ea71ab142"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae99859eb37714e4ed7c6110ea71ab142">spdk_thread_is_exited</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:ae99859eb37714e4ed7c6110ea71ab142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the thread is marked as exited.  <a href="thread_8h.html#ae99859eb37714e4ed7c6110ea71ab142">More...</a><br /></td></tr>
<tr class="separator:ae99859eb37714e4ed7c6110ea71ab142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c3bf0e066520e8eeeaec589d021b6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a67c3bf0e066520e8eeeaec589d021b6c">spdk_thread_is_running</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a67c3bf0e066520e8eeeaec589d021b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the thread is still running.  <a href="thread_8h.html#a67c3bf0e066520e8eeeaec589d021b6c">More...</a><br /></td></tr>
<tr class="separator:a67c3bf0e066520e8eeeaec589d021b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aa5a8ec5228fa87db97f7655f8c0d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a10aa5a8ec5228fa87db97f7655f8c0d6">spdk_thread_destroy</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a10aa5a8ec5228fa87db97f7655f8c0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a thread, releasing all of its resources.  <a href="thread_8h.html#a10aa5a8ec5228fa87db97f7655f8c0d6">More...</a><br /></td></tr>
<tr class="separator:a10aa5a8ec5228fa87db97f7655f8c0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deb97a85a8240119cf46fa8a0b71388"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388">spdk_thread_get_ctx</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a1deb97a85a8240119cf46fa8a0b71388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to this thread's context.  <a href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388">More...</a><br /></td></tr>
<tr class="separator:a1deb97a85a8240119cf46fa8a0b71388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f06d559046d570e025d6b67c7e8d507"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9f06d559046d570e025d6b67c7e8d507">spdk_thread_get_cpumask</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a9f06d559046d570e025d6b67c7e8d507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread's cpumask.  <a href="thread_8h.html#a9f06d559046d570e025d6b67c7e8d507">More...</a><br /></td></tr>
<tr class="separator:a9f06d559046d570e025d6b67c7e8d507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c27f304a333a80bbdb48f1df12721f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a44c27f304a333a80bbdb48f1df12721f">spdk_thread_set_cpumask</a> (struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *cpumask)</td></tr>
<tr class="memdesc:a44c27f304a333a80bbdb48f1df12721f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current thread's cpumask to the specified value.  <a href="thread_8h.html#a44c27f304a333a80bbdb48f1df12721f">More...</a><br /></td></tr>
<tr class="separator:a44c27f304a333a80bbdb48f1df12721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af813fe52c71ec5e254f8671570f57bdc"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#af813fe52c71ec5e254f8671570f57bdc">spdk_thread_get_from_ctx</a> (void *ctx)</td></tr>
<tr class="memdesc:af813fe52c71ec5e254f8671570f57bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread object associated with the context handle previously obtained by calling <a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388" title="Return a pointer to this thread&#39;s context.">spdk_thread_get_ctx()</a>.  <a href="thread_8h.html#af813fe52c71ec5e254f8671570f57bdc">More...</a><br /></td></tr>
<tr class="separator:af813fe52c71ec5e254f8671570f57bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e3693e8e9e6c9063ea36414294ae91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91">spdk_thread_poll</a> (struct spdk_thread *thread, uint32_t max_msgs, uint64_t now)</td></tr>
<tr class="memdesc:ad9e3693e8e9e6c9063ea36414294ae91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one iteration worth of processing on the thread.  <a href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91">More...</a><br /></td></tr>
<tr class="separator:ad9e3693e8e9e6c9063ea36414294ae91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474fcfc5c14928eda42c684ba2b4cba9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a474fcfc5c14928eda42c684ba2b4cba9">spdk_thread_next_poller_expiration</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a474fcfc5c14928eda42c684ba2b4cba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of ticks until the next timed poller would expire.  <a href="thread_8h.html#a474fcfc5c14928eda42c684ba2b4cba9">More...</a><br /></td></tr>
<tr class="separator:a474fcfc5c14928eda42c684ba2b4cba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a143ecbc5ce7edcd57e76cffd74bde5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a5a143ecbc5ce7edcd57e76cffd74bde5">spdk_thread_has_active_pollers</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a5a143ecbc5ce7edcd57e76cffd74bde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there are any active pollers (pollers for which period_microseconds equals 0) registered to be run on the thread.  <a href="thread_8h.html#a5a143ecbc5ce7edcd57e76cffd74bde5">More...</a><br /></td></tr>
<tr class="separator:a5a143ecbc5ce7edcd57e76cffd74bde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f877dd192ccdd30572941aa4e453c48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9f877dd192ccdd30572941aa4e453c48">spdk_thread_has_pollers</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a9f877dd192ccdd30572941aa4e453c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there are any pollers registered to be run on the thread.  <a href="thread_8h.html#a9f877dd192ccdd30572941aa4e453c48">More...</a><br /></td></tr>
<tr class="separator:a9f877dd192ccdd30572941aa4e453c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc45e09bda68d13cfc0ae010738cd658"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#adc45e09bda68d13cfc0ae010738cd658">spdk_thread_is_idle</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:adc45e09bda68d13cfc0ae010738cd658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there are scheduled operations to be run on the thread.  <a href="thread_8h.html#adc45e09bda68d13cfc0ae010738cd658">More...</a><br /></td></tr>
<tr class="separator:adc45e09bda68d13cfc0ae010738cd658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d77f05c2461acb75f333e67e6aeb1ed"><td class="memItemLeft" align="right" valign="top"><a id="a1d77f05c2461acb75f333e67e6aeb1ed"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a1d77f05c2461acb75f333e67e6aeb1ed">spdk_thread_get_count</a> (void)</td></tr>
<tr class="memdesc:a1d77f05c2461acb75f333e67e6aeb1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get count of allocated threads. <br /></td></tr>
<tr class="separator:a1d77f05c2461acb75f333e67e6aeb1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34754a98debd5e095bf06889fbaed6aa"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a34754a98debd5e095bf06889fbaed6aa">spdk_get_thread</a> (void)</td></tr>
<tr class="memdesc:a34754a98debd5e095bf06889fbaed6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the current thread.  <a href="thread_8h.html#a34754a98debd5e095bf06889fbaed6aa">More...</a><br /></td></tr>
<tr class="separator:a34754a98debd5e095bf06889fbaed6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae367048fa89366e845d72015064e6f76"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae367048fa89366e845d72015064e6f76">spdk_thread_get_name</a> (const struct spdk_thread *thread)</td></tr>
<tr class="memdesc:ae367048fa89366e845d72015064e6f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a thread's name.  <a href="thread_8h.html#ae367048fa89366e845d72015064e6f76">More...</a><br /></td></tr>
<tr class="separator:ae367048fa89366e845d72015064e6f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead9239fedaf5af9f24b5614f6c0c8fb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aead9239fedaf5af9f24b5614f6c0c8fb">spdk_thread_get_id</a> (const struct spdk_thread *thread)</td></tr>
<tr class="memdesc:aead9239fedaf5af9f24b5614f6c0c8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a thread's ID.  <a href="thread_8h.html#aead9239fedaf5af9f24b5614f6c0c8fb">More...</a><br /></td></tr>
<tr class="separator:aead9239fedaf5af9f24b5614f6c0c8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c90cd523aad947dad7e651074d9f1d"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a24c90cd523aad947dad7e651074d9f1d">spdk_thread_get_by_id</a> (uint64_t id)</td></tr>
<tr class="memdesc:a24c90cd523aad947dad7e651074d9f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread by the ID.  <a href="thread_8h.html#a24c90cd523aad947dad7e651074d9f1d">More...</a><br /></td></tr>
<tr class="separator:a24c90cd523aad947dad7e651074d9f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f07dd00b0b4140155713aca312d46b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ab6f07dd00b0b4140155713aca312d46b">spdk_thread_get_stats</a> (struct <a class="el" href="structspdk__thread__stats.html">spdk_thread_stats</a> *stats)</td></tr>
<tr class="memdesc:ab6f07dd00b0b4140155713aca312d46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get statistics about the current thread.  <a href="thread_8h.html#ab6f07dd00b0b4140155713aca312d46b">More...</a><br /></td></tr>
<tr class="separator:ab6f07dd00b0b4140155713aca312d46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d7fd3db7cd91ff37c3898e69811f7a"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae8d7fd3db7cd91ff37c3898e69811f7a">spdk_thread_get_last_tsc</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:ae8d7fd3db7cd91ff37c3898e69811f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the TSC value from the end of the last time this thread was polled.  <a href="thread_8h.html#ae8d7fd3db7cd91ff37c3898e69811f7a">More...</a><br /></td></tr>
<tr class="separator:ae8d7fd3db7cd91ff37c3898e69811f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b662b152c21dad824ad2738d0733ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a07b662b152c21dad824ad2738d0733ec">spdk_thread_send_msg</a> (const struct spdk_thread *thread, <a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn, void *ctx)</td></tr>
<tr class="memdesc:a07b662b152c21dad824ad2738d0733ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the given thread.  <a href="thread_8h.html#a07b662b152c21dad824ad2738d0733ec">More...</a><br /></td></tr>
<tr class="separator:a07b662b152c21dad824ad2738d0733ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a7e9d44c2a332dfcea5e23df471c8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a91a7e9d44c2a332dfcea5e23df471c8d">spdk_thread_send_critical_msg</a> (struct spdk_thread *thread, <a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn)</td></tr>
<tr class="memdesc:a91a7e9d44c2a332dfcea5e23df471c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the given thread.  <a href="thread_8h.html#a91a7e9d44c2a332dfcea5e23df471c8d">More...</a><br /></td></tr>
<tr class="separator:a91a7e9d44c2a332dfcea5e23df471c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6695466847e7a751b768ab4b8bcd53d0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6695466847e7a751b768ab4b8bcd53d0">spdk_thread_exec_msg</a> (const struct spdk_thread *thread, <a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn, void *ctx)</td></tr>
<tr class="memdesc:a6695466847e7a751b768ab4b8bcd53d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the msg callback on the given thread.  <a href="thread_8h.html#a6695466847e7a751b768ab4b8bcd53d0">More...</a><br /></td></tr>
<tr class="separator:a6695466847e7a751b768ab4b8bcd53d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bb098e6398d2a63577e805f1423a3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a16bb098e6398d2a63577e805f1423a3e">spdk_for_each_thread</a> (<a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn, void *ctx, <a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> cpl)</td></tr>
<tr class="memdesc:a16bb098e6398d2a63577e805f1423a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to each thread, serially.  <a href="thread_8h.html#a16bb098e6398d2a63577e805f1423a3e">More...</a><br /></td></tr>
<tr class="separator:a16bb098e6398d2a63577e805f1423a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c98f015b55188cabb829aaf83a797c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a5c98f015b55188cabb829aaf83a797c6">spdk_thread_set_interrupt_mode</a> (bool enable_interrupt)</td></tr>
<tr class="memdesc:a5c98f015b55188cabb829aaf83a797c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current spdk_thread into interrupt mode or back to poll mode.  <a href="thread_8h.html#a5c98f015b55188cabb829aaf83a797c6">More...</a><br /></td></tr>
<tr class="separator:a5c98f015b55188cabb829aaf83a797c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3e883ddce01ae8d93541304d1e9126"><td class="memItemLeft" align="right" valign="top">struct spdk_poller *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6b3e883ddce01ae8d93541304d1e9126">spdk_poller_register</a> (<a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a> fn, void *arg, uint64_t period_microseconds)</td></tr>
<tr class="memdesc:a6b3e883ddce01ae8d93541304d1e9126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a poller on the current thread.  <a href="thread_8h.html#a6b3e883ddce01ae8d93541304d1e9126">More...</a><br /></td></tr>
<tr class="separator:a6b3e883ddce01ae8d93541304d1e9126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1086db1bd40b0a1720bd148967d82d"><td class="memItemLeft" align="right" valign="top">struct spdk_poller *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4e1086db1bd40b0a1720bd148967d82d">spdk_poller_register_named</a> (<a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a> fn, void *arg, uint64_t period_microseconds, const char *name)</td></tr>
<tr class="memdesc:a4e1086db1bd40b0a1720bd148967d82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a poller on the current thread with arbitrary name.  <a href="thread_8h.html#a4e1086db1bd40b0a1720bd148967d82d">More...</a><br /></td></tr>
<tr class="separator:a4e1086db1bd40b0a1720bd148967d82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c26cbd781063f5ee627d6aba2c73fe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9c26cbd781063f5ee627d6aba2c73fe3">spdk_poller_unregister</a> (struct spdk_poller **ppoller)</td></tr>
<tr class="memdesc:a9c26cbd781063f5ee627d6aba2c73fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a poller on the current thread.  <a href="thread_8h.html#a9c26cbd781063f5ee627d6aba2c73fe3">More...</a><br /></td></tr>
<tr class="separator:a9c26cbd781063f5ee627d6aba2c73fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0c05dd1c9cb0b31eee89213b89f3c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a0f0c05dd1c9cb0b31eee89213b89f3c3">spdk_poller_pause</a> (struct spdk_poller *poller)</td></tr>
<tr class="memdesc:a0f0c05dd1c9cb0b31eee89213b89f3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause a poller on the current thread.  <a href="thread_8h.html#a0f0c05dd1c9cb0b31eee89213b89f3c3">More...</a><br /></td></tr>
<tr class="separator:a0f0c05dd1c9cb0b31eee89213b89f3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3de0ffe9dfc29361b092d467d37017e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ab3de0ffe9dfc29361b092d467d37017e">spdk_poller_resume</a> (struct spdk_poller *poller)</td></tr>
<tr class="memdesc:ab3de0ffe9dfc29361b092d467d37017e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a poller on the current thread.  <a href="thread_8h.html#ab3de0ffe9dfc29361b092d467d37017e">More...</a><br /></td></tr>
<tr class="separator:ab3de0ffe9dfc29361b092d467d37017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f5c71056d8c39ff05a6610d55edcf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a75f5c71056d8c39ff05a6610d55edcf5">spdk_io_device_register</a> (void *io_device, <a class="el" href="thread_8h.html#aed1d14292cfee8553d4a1ebb519b210a">spdk_io_channel_create_cb</a> create_cb, <a class="el" href="thread_8h.html#a75aa6a61877f23f79bb75c8fc5e68202">spdk_io_channel_destroy_cb</a> destroy_cb, uint32_t ctx_size, const char *name)</td></tr>
<tr class="memdesc:a75f5c71056d8c39ff05a6610d55edcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the opaque io_device context as an I/O device.  <a href="thread_8h.html#a75f5c71056d8c39ff05a6610d55edcf5">More...</a><br /></td></tr>
<tr class="separator:a75f5c71056d8c39ff05a6610d55edcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6c3df3a611c10c176cb87966c622f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4c6c3df3a611c10c176cb87966c622f0">spdk_io_device_unregister</a> (void *io_device, <a class="el" href="thread_8h.html#ae044f4141737c7f2df49cdfb03fd58ca">spdk_io_device_unregister_cb</a> unregister_cb)</td></tr>
<tr class="memdesc:a4c6c3df3a611c10c176cb87966c622f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister the opaque io_device context as an I/O device.  <a href="thread_8h.html#a4c6c3df3a611c10c176cb87966c622f0">More...</a><br /></td></tr>
<tr class="separator:a4c6c3df3a611c10c176cb87966c622f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8537c42a7aa203b50578efed509d9ba8"><td class="memItemLeft" align="right" valign="top">struct spdk_io_channel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8">spdk_get_io_channel</a> (void *io_device)</td></tr>
<tr class="memdesc:a8537c42a7aa203b50578efed509d9ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an I/O channel for the specified io_device to be used by the calling thread.  <a href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8">More...</a><br /></td></tr>
<tr class="separator:a8537c42a7aa203b50578efed509d9ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717571a5011db0cdd730498146f25f9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a717571a5011db0cdd730498146f25f9a">spdk_put_io_channel</a> (struct spdk_io_channel *ch)</td></tr>
<tr class="memdesc:a717571a5011db0cdd730498146f25f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a reference to an I/O channel.  <a href="thread_8h.html#a717571a5011db0cdd730498146f25f9a">More...</a><br /></td></tr>
<tr class="separator:a717571a5011db0cdd730498146f25f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf6e22252bc768003c7bbc165fc3c51"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#adbf6e22252bc768003c7bbc165fc3c51">spdk_io_channel_get_ctx</a> (struct spdk_io_channel *ch)</td></tr>
<tr class="memdesc:adbf6e22252bc768003c7bbc165fc3c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context buffer associated with an I/O channel.  <a href="thread_8h.html#adbf6e22252bc768003c7bbc165fc3c51">More...</a><br /></td></tr>
<tr class="separator:adbf6e22252bc768003c7bbc165fc3c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9608b7b0fd448edec6ea5dd38ad04a57"><td class="memItemLeft" align="right" valign="top">struct spdk_io_channel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9608b7b0fd448edec6ea5dd38ad04a57">spdk_io_channel_from_ctx</a> (void *ctx)</td></tr>
<tr class="memdesc:a9608b7b0fd448edec6ea5dd38ad04a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I/O channel from the context buffer.  <a href="thread_8h.html#a9608b7b0fd448edec6ea5dd38ad04a57">More...</a><br /></td></tr>
<tr class="separator:a9608b7b0fd448edec6ea5dd38ad04a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9537d26ac923a7a93cd55ba315b5b"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a8ff9537d26ac923a7a93cd55ba315b5b">spdk_io_channel_get_thread</a> (struct spdk_io_channel *ch)</td></tr>
<tr class="memdesc:a8ff9537d26ac923a7a93cd55ba315b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread associated with an I/O channel.  <a href="thread_8h.html#a8ff9537d26ac923a7a93cd55ba315b5b">More...</a><br /></td></tr>
<tr class="separator:a8ff9537d26ac923a7a93cd55ba315b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a2ca9bd0497544e852c65fd5263cd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1">spdk_for_each_channel</a> (void *io_device, <a class="el" href="thread_8h.html#a2dd91f3094f8b4cf60f460e3f88bbf0c">spdk_channel_msg</a> fn, void *ctx, <a class="el" href="thread_8h.html#a96f03fe115196f1de03292ed6d86fd46">spdk_channel_for_each_cpl</a> cpl)</td></tr>
<tr class="memdesc:aa7a2ca9bd0497544e852c65fd5263cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call 'fn' on each channel associated with io_device.  <a href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1">More...</a><br /></td></tr>
<tr class="separator:aa7a2ca9bd0497544e852c65fd5263cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939935cee4dac6636f2b7c6db0b2fec1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a939935cee4dac6636f2b7c6db0b2fec1">spdk_io_channel_iter_get_io_device</a> (struct spdk_io_channel_iter *i)</td></tr>
<tr class="memdesc:a939935cee4dac6636f2b7c6db0b2fec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get io_device from the I/O channel iterator.  <a href="thread_8h.html#a939935cee4dac6636f2b7c6db0b2fec1">More...</a><br /></td></tr>
<tr class="separator:a939935cee4dac6636f2b7c6db0b2fec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83adef6c3df9568bdea346b8e7dcbaa5"><td class="memItemLeft" align="right" valign="top">struct spdk_io_channel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a83adef6c3df9568bdea346b8e7dcbaa5">spdk_io_channel_iter_get_channel</a> (struct spdk_io_channel_iter *i)</td></tr>
<tr class="memdesc:a83adef6c3df9568bdea346b8e7dcbaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I/O channel from the I/O channel iterator.  <a href="thread_8h.html#a83adef6c3df9568bdea346b8e7dcbaa5">More...</a><br /></td></tr>
<tr class="separator:a83adef6c3df9568bdea346b8e7dcbaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3ebaac7b55dddb239c720c80d97dea"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#add3ebaac7b55dddb239c720c80d97dea">spdk_io_channel_iter_get_ctx</a> (struct spdk_io_channel_iter *i)</td></tr>
<tr class="memdesc:add3ebaac7b55dddb239c720c80d97dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get context buffer from the I/O channel iterator.  <a href="thread_8h.html#add3ebaac7b55dddb239c720c80d97dea">More...</a><br /></td></tr>
<tr class="separator:add3ebaac7b55dddb239c720c80d97dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49adcba47a8dc22c6d6046bc05c47674"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a49adcba47a8dc22c6d6046bc05c47674">spdk_io_channel_get_io_device</a> (struct spdk_io_channel *ch)</td></tr>
<tr class="memdesc:a49adcba47a8dc22c6d6046bc05c47674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the io_device for the specified I/O channel.  <a href="thread_8h.html#a49adcba47a8dc22c6d6046bc05c47674">More...</a><br /></td></tr>
<tr class="separator:a49adcba47a8dc22c6d6046bc05c47674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e87fc8c0fc870769c068a2752cdc359"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4e87fc8c0fc870769c068a2752cdc359">spdk_for_each_channel_continue</a> (struct spdk_io_channel_iter *i, int status)</td></tr>
<tr class="memdesc:a4e87fc8c0fc870769c068a2752cdc359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to iterate all channels for <a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1" title="Call &#39;fn&#39; on each channel associated with io_device.">spdk_for_each_channel()</a>.  <a href="thread_8h.html#a4e87fc8c0fc870769c068a2752cdc359">More...</a><br /></td></tr>
<tr class="separator:a4e87fc8c0fc870769c068a2752cdc359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae58fe1101803d60c523891e7540a23c"><td class="memItemLeft" align="right" valign="top">struct spdk_interrupt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aae58fe1101803d60c523891e7540a23c">spdk_interrupt_register</a> (int efd, <a class="el" href="thread_8h.html#a61cfdc77d10970d7f3a8631df71e9588">spdk_interrupt_fn</a> fn, void *arg, const char *name)</td></tr>
<tr class="memdesc:aae58fe1101803d60c523891e7540a23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an spdk_interrupt on the current thread.  <a href="thread_8h.html#aae58fe1101803d60c523891e7540a23c">More...</a><br /></td></tr>
<tr class="separator:aae58fe1101803d60c523891e7540a23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f3647a26ba93931beeb1782d39e56e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a45f3647a26ba93931beeb1782d39e56e">spdk_interrupt_unregister</a> (struct spdk_interrupt **pintr)</td></tr>
<tr class="memdesc:a45f3647a26ba93931beeb1782d39e56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister an spdk_interrupt on the current thread.  <a href="thread_8h.html#a45f3647a26ba93931beeb1782d39e56e">More...</a><br /></td></tr>
<tr class="separator:a45f3647a26ba93931beeb1782d39e56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6665332ac6d7781f7944f5f471ce1a21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6665332ac6d7781f7944f5f471ce1a21">spdk_interrupt_set_event_types</a> (struct spdk_interrupt *intr, enum spdk_interrupt_event_types event_types)</td></tr>
<tr class="memdesc:a6665332ac6d7781f7944f5f471ce1a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the event_types associated with the spdk_interrupt on the current thread.  <a href="thread_8h.html#a6665332ac6d7781f7944f5f471ce1a21">More...</a><br /></td></tr>
<tr class="separator:a6665332ac6d7781f7944f5f471ce1a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b33abb26c349950555f71a34cf507c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6b33abb26c349950555f71a34cf507c6">spdk_thread_get_interrupt_fd</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a6b33abb26c349950555f71a34cf507c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a file descriptor that becomes ready whenever any of the registered interrupt file descriptors are ready.  <a href="thread_8h.html#a6b33abb26c349950555f71a34cf507c6">More...</a><br /></td></tr>
<tr class="separator:a6b33abb26c349950555f71a34cf507c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1e717df13e86ea95c36e661bb8568d"><td class="memItemLeft" align="right" valign="top">struct spdk_fd_group *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a0d1e717df13e86ea95c36e661bb8568d">spdk_thread_get_interrupt_fd_group</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a0d1e717df13e86ea95c36e661bb8568d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an fd_group that becomes ready whenever any of the registered interrupt file descriptors are ready.  <a href="thread_8h.html#a0d1e717df13e86ea95c36e661bb8568d">More...</a><br /></td></tr>
<tr class="separator:a0d1e717df13e86ea95c36e661bb8568d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cac0f188b5f46ff8bcdd5d4ffa37e84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a0cac0f188b5f46ff8bcdd5d4ffa37e84">spdk_interrupt_mode_enable</a> (void)</td></tr>
<tr class="memdesc:a0cac0f188b5f46ff8bcdd5d4ffa37e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SPDK run as event driven mode.  <a href="thread_8h.html#a0cac0f188b5f46ff8bcdd5d4ffa37e84">More...</a><br /></td></tr>
<tr class="separator:a0cac0f188b5f46ff8bcdd5d4ffa37e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8be492b86ceface921634b9a627b7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a1f8be492b86ceface921634b9a627b7c">spdk_interrupt_mode_is_enabled</a> (void)</td></tr>
<tr class="memdesc:a1f8be492b86ceface921634b9a627b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether interrupt mode is set.  <a href="thread_8h.html#a1f8be492b86ceface921634b9a627b7c">More...</a><br /></td></tr>
<tr class="separator:a1f8be492b86ceface921634b9a627b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9618326108ac7d4a47fefb33e21879f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ad9618326108ac7d4a47fefb33e21879f">spdk_spin_init</a> (struct <a class="el" href="structspdk__spinlock.html">spdk_spinlock</a> *sspin)</td></tr>
<tr class="memdesc:ad9618326108ac7d4a47fefb33e21879f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an <a class="el" href="structspdk__spinlock.html" title="A spinlock augmented with safety checks for use with SPDK.">spdk_spinlock</a>.  <a href="thread_8h.html#ad9618326108ac7d4a47fefb33e21879f">More...</a><br /></td></tr>
<tr class="separator:ad9618326108ac7d4a47fefb33e21879f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082f55ea269d3f171f00917099debb67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a082f55ea269d3f171f00917099debb67">spdk_spin_destroy</a> (struct <a class="el" href="structspdk__spinlock.html">spdk_spinlock</a> *sspin)</td></tr>
<tr class="memdesc:a082f55ea269d3f171f00917099debb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an <a class="el" href="structspdk__spinlock.html" title="A spinlock augmented with safety checks for use with SPDK.">spdk_spinlock</a>.  <a href="thread_8h.html#a082f55ea269d3f171f00917099debb67">More...</a><br /></td></tr>
<tr class="separator:a082f55ea269d3f171f00917099debb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03bb794fec774061fc77367bc6bdfa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ac03bb794fec774061fc77367bc6bdfa2">spdk_spin_lock</a> (struct <a class="el" href="structspdk__spinlock.html">spdk_spinlock</a> *sspin)</td></tr>
<tr class="memdesc:ac03bb794fec774061fc77367bc6bdfa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock an SPDK spin lock.  <a href="thread_8h.html#ac03bb794fec774061fc77367bc6bdfa2">More...</a><br /></td></tr>
<tr class="separator:ac03bb794fec774061fc77367bc6bdfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcaee781de4118a2f789dd76ef4b3b83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#adcaee781de4118a2f789dd76ef4b3b83">spdk_spin_unlock</a> (struct <a class="el" href="structspdk__spinlock.html">spdk_spinlock</a> *sspin)</td></tr>
<tr class="memdesc:adcaee781de4118a2f789dd76ef4b3b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock an SPDK spinlock.  <a href="thread_8h.html#adcaee781de4118a2f789dd76ef4b3b83">More...</a><br /></td></tr>
<tr class="separator:adcaee781de4118a2f789dd76ef4b3b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cf080d22a52b5ae3025221411096f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a14cf080d22a52b5ae3025221411096f5">spdk_spin_held</a> (struct <a class="el" href="structspdk__spinlock.html">spdk_spinlock</a> *sspin)</td></tr>
<tr class="memdesc:a14cf080d22a52b5ae3025221411096f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the caller holds this SPDK spinlock.  <a href="thread_8h.html#a14cf080d22a52b5ae3025221411096f5">More...</a><br /></td></tr>
<tr class="separator:a14cf080d22a52b5ae3025221411096f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212059a30d7b5c5e87b0f56f740dd328"><td class="memItemLeft" align="right" valign="top"><a id="a212059a30d7b5c5e87b0f56f740dd328"></a>
typedef&#160;</td><td class="memItemRight" valign="bottom"><b>STAILQ_HEAD</b> (, <a class="el" href="structspdk__iobuf__entry.html">spdk_iobuf_entry</a>) spdk_iobuf_entry_stailq_t</td></tr>
<tr class="separator:a212059a30d7b5c5e87b0f56f740dd328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ff04e1f01f258dbbf728d2b353b98f"><td class="memItemLeft" align="right" valign="top"><a id="a99ff04e1f01f258dbbf728d2b353b98f"></a>
typedef&#160;</td><td class="memItemRight" valign="bottom"><b>STAILQ_HEAD</b> (, <a class="el" href="structspdk__iobuf__buffer.html">spdk_iobuf_buffer</a>) spdk_iobuf_buffer_stailq_t</td></tr>
<tr class="separator:a99ff04e1f01f258dbbf728d2b353b98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c37e9172bb09d20cfa353dbd92b0a95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a2c37e9172bb09d20cfa353dbd92b0a95">spdk_iobuf_initialize</a> (void)</td></tr>
<tr class="memdesc:a2c37e9172bb09d20cfa353dbd92b0a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize and allocate iobuf pools.  <a href="thread_8h.html#a2c37e9172bb09d20cfa353dbd92b0a95">More...</a><br /></td></tr>
<tr class="separator:a2c37e9172bb09d20cfa353dbd92b0a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8009c7842c30586bd815eaee9b7a91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#acf8009c7842c30586bd815eaee9b7a91">spdk_iobuf_finish</a> (spdk_iobuf_finish_cb cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:acf8009c7842c30586bd815eaee9b7a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up and free iobuf pools.  <a href="thread_8h.html#acf8009c7842c30586bd815eaee9b7a91">More...</a><br /></td></tr>
<tr class="separator:acf8009c7842c30586bd815eaee9b7a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64427a246442e52b60271127bf363d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ac64427a246442e52b60271127bf363d4">spdk_iobuf_set_opts</a> (const struct <a class="el" href="structspdk__iobuf__opts.html">spdk_iobuf_opts</a> *opts)</td></tr>
<tr class="memdesc:ac64427a246442e52b60271127bf363d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set iobuf options.  <a href="thread_8h.html#ac64427a246442e52b60271127bf363d4">More...</a><br /></td></tr>
<tr class="separator:ac64427a246442e52b60271127bf363d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e97f3caeb779908350fd5176c98ba4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a1e97f3caeb779908350fd5176c98ba4a">spdk_iobuf_get_opts</a> (struct <a class="el" href="structspdk__iobuf__opts.html">spdk_iobuf_opts</a> *opts)</td></tr>
<tr class="memdesc:a1e97f3caeb779908350fd5176c98ba4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iobuf options.  <a href="thread_8h.html#a1e97f3caeb779908350fd5176c98ba4a">More...</a><br /></td></tr>
<tr class="separator:a1e97f3caeb779908350fd5176c98ba4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Name of the module.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp3417a198fca2cd43bb94ea6d9922ff0a"></a>Register a module as an iobuf pool user.</p>
<p>Only registered users can request buffers from the iobuf pool.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno otherwise. </dd></dl>
</td></tr>
<tr class="memitem:ad17c5e2e4eadfe701fd0f8ddb482deb4"><td class="memItemLeft" align="right" valign="top"><a id="ad17c5e2e4eadfe701fd0f8ddb482deb4"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_iobuf_for_each_entry_fn</b>) (struct <a class="el" href="structspdk__iobuf__channel.html">spdk_iobuf_channel</a> *ch, struct <a class="el" href="structspdk__iobuf__entry.html">spdk_iobuf_entry</a> *entry, void *ctx)</td></tr>
<tr class="separator:ad17c5e2e4eadfe701fd0f8ddb482deb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18be1edc45d00e45964e5d34ee7f776b"><td class="memItemLeft" align="right" valign="top"><a id="a18be1edc45d00e45964e5d34ee7f776b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_iobuf_register_module</b> (const char *name)</td></tr>
<tr class="separator:a18be1edc45d00e45964e5d34ee7f776b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e3d5418d2219ba6bd603304c3473de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ad4e3d5418d2219ba6bd603304c3473de">spdk_iobuf_channel_init</a> (struct <a class="el" href="structspdk__iobuf__channel.html">spdk_iobuf_channel</a> *ch, const char *name, uint32_t small_cache_size, uint32_t large_cache_size)</td></tr>
<tr class="memdesc:ad4e3d5418d2219ba6bd603304c3473de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an iobuf channel.  <a href="thread_8h.html#ad4e3d5418d2219ba6bd603304c3473de">More...</a><br /></td></tr>
<tr class="separator:ad4e3d5418d2219ba6bd603304c3473de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a69dd994350e50395605e9b394b02fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a3a69dd994350e50395605e9b394b02fe">spdk_iobuf_channel_fini</a> (struct <a class="el" href="structspdk__iobuf__channel.html">spdk_iobuf_channel</a> *ch)</td></tr>
<tr class="memdesc:a3a69dd994350e50395605e9b394b02fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release resources tied to an iobuf channel.  <a href="thread_8h.html#a3a69dd994350e50395605e9b394b02fe">More...</a><br /></td></tr>
<tr class="separator:a3a69dd994350e50395605e9b394b02fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57f01f992d8ebe9e30c5b6c21edf2a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aa57f01f992d8ebe9e30c5b6c21edf2a5">spdk_iobuf_for_each_entry</a> (struct <a class="el" href="structspdk__iobuf__channel.html">spdk_iobuf_channel</a> *ch, struct <a class="el" href="structspdk__iobuf__pool.html">spdk_iobuf_pool</a> *pool, spdk_iobuf_for_each_entry_fn cb_fn, void *cb_ctx)</td></tr>
<tr class="memdesc:aa57f01f992d8ebe9e30c5b6c21edf2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all entries on a given queue and execute a callback on those that were requested using <code>ch</code>.  <a href="thread_8h.html#aa57f01f992d8ebe9e30c5b6c21edf2a5">More...</a><br /></td></tr>
<tr class="separator:aa57f01f992d8ebe9e30c5b6c21edf2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad192ca271f84d76cca2a2ff6403b534a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ad192ca271f84d76cca2a2ff6403b534a">spdk_iobuf_entry_abort</a> (struct <a class="el" href="structspdk__iobuf__channel.html">spdk_iobuf_channel</a> *ch, struct <a class="el" href="structspdk__iobuf__entry.html">spdk_iobuf_entry</a> *entry, uint64_t len)</td></tr>
<tr class="memdesc:ad192ca271f84d76cca2a2ff6403b534a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort an outstanding request waiting for a buffer.  <a href="thread_8h.html#ad192ca271f84d76cca2a2ff6403b534a">More...</a><br /></td></tr>
<tr class="separator:ad192ca271f84d76cca2a2ff6403b534a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861f8067dad2dad16aa5a7f11e2221fc"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a861f8067dad2dad16aa5a7f11e2221fc">spdk_iobuf_get</a> (struct <a class="el" href="structspdk__iobuf__channel.html">spdk_iobuf_channel</a> *ch, uint64_t len, struct <a class="el" href="structspdk__iobuf__entry.html">spdk_iobuf_entry</a> *entry, spdk_iobuf_get_cb cb_fn)</td></tr>
<tr class="memdesc:a861f8067dad2dad16aa5a7f11e2221fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a buffer from the iobuf pool.  <a href="thread_8h.html#a861f8067dad2dad16aa5a7f11e2221fc">More...</a><br /></td></tr>
<tr class="separator:a861f8067dad2dad16aa5a7f11e2221fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca828f485050a8d77d0a0b4182c632cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aca828f485050a8d77d0a0b4182c632cc">spdk_iobuf_put</a> (struct <a class="el" href="structspdk__iobuf__channel.html">spdk_iobuf_channel</a> *ch, void *buf, uint64_t len)</td></tr>
<tr class="memdesc:aca828f485050a8d77d0a0b4182c632cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a buffer back to the iobuf pool.  <a href="thread_8h.html#aca828f485050a8d77d0a0b4182c632cc">More...</a><br /></td></tr>
<tr class="separator:aca828f485050a8d77d0a0b4182c632cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Thread. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a96f03fe115196f1de03292ed6d86fd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f03fe115196f1de03292ed6d86fd46">&#9670;&nbsp;</a></span>spdk_channel_for_each_cpl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_channel_for_each_cpl) (struct spdk_io_channel_iter *i, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1" title="Call &#39;fn&#39; on each channel associated with io_device.">spdk_for_each_channel()</a> callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator. </td></tr>
    <tr><td class="paramname">status</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2dd91f3094f8b4cf60f460e3f88bbf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd91f3094f8b4cf60f460e3f88bbf0c">&#9670;&nbsp;</a></span>spdk_channel_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_channel_msg) (struct spdk_io_channel_iter *i)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called on the appropriate thread for each channel associated with io_device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61cfdc77d10970d7f3a8631df71e9588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61cfdc77d10970d7f3a8631df71e9588">&#9670;&nbsp;</a></span>spdk_interrupt_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_interrupt_fn) (void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function registered for interrupt file descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context passed as arg to <a class="el" href="thread_8h.html#aae58fe1101803d60c523891e7540a23c" title="Register an spdk_interrupt on the current thread.">spdk_interrupt_register()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 to indicate that interrupt took place but no events were found; positive to indicate that interrupt took place and some events were processed; negative if no event information is provided. </dd></dl>

</div>
</div>
<a id="aed1d14292cfee8553d4a1ebb519b210a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1d14292cfee8553d4a1ebb519b210a">&#9670;&nbsp;</a></span>spdk_io_channel_create_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_io_channel_create_cb) (void *io_device, void *ctx_buf)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O channel creation callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>I/O device associated with this channel. </td></tr>
    <tr><td class="paramname">ctx_buf</td><td>Context for the I/O device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75aa6a61877f23f79bb75c8fc5e68202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75aa6a61877f23f79bb75c8fc5e68202">&#9670;&nbsp;</a></span>spdk_io_channel_destroy_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_io_channel_destroy_cb) (void *io_device, void *ctx_buf)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O channel destruction callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>I/O device associated with this channel. </td></tr>
    <tr><td class="paramname">ctx_buf</td><td>Context for the I/O device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae044f4141737c7f2df49cdfb03fd58ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae044f4141737c7f2df49cdfb03fd58ca">&#9670;&nbsp;</a></span>spdk_io_device_unregister_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_io_device_unregister_cb) (void *io_device)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O device unregister callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>Unregistered I/O device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc0da6b1b784d4f165dcd48b526d12ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0da6b1b784d4f165dcd48b526d12ad">&#9670;&nbsp;</a></span>spdk_msg_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_msg_fn) (void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that will be called on the target thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context passed as arg to <a class="el" href="thread_8h.html#a4a0e155fc3fa0150aa4a505dd1801e91" title="Function to be called to pass a message to a thread.">spdk_thread_pass_msg()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afab3d4339c5bca4dfde209816a9e560f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab3d4339c5bca4dfde209816a9e560f">&#9670;&nbsp;</a></span>spdk_new_thread_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_new_thread_fn) (struct spdk_thread *thread)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that is called each time a new thread is created. </p>
<p>The implementor of this function should frequently call <a class="el" href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91" title="Perform one iteration worth of processing on the thread.">spdk_thread_poll()</a> on the thread provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The new spdk_thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35c421accdc2a0a61bb7be916106293b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c421accdc2a0a61bb7be916106293b">&#9670;&nbsp;</a></span>spdk_poller_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_poller_fn) (void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for a poller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context passed as arg to <a class="el" href="thread_8h.html#a6b3e883ddce01ae8d93541304d1e9126" title="Register a poller on the current thread.">spdk_poller_register()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of type <code>enum spdk_thread_poller_rc</code> (ex: SPDK_POLLER_IDLE if no work was done or SPDK_POLLER_BUSY if work was done.) </dd></dl>

</div>
</div>
<a id="aaa00024ffe78012bf1b7ade9aee0ab1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa00024ffe78012bf1b7ade9aee0ab1a">&#9670;&nbsp;</a></span>spdk_poller_set_interrupt_mode_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_poller_set_interrupt_mode_cb) (struct spdk_poller *poller, void *cb_arg, bool interrupt_mode)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function to set poller into interrupt mode or back to poll mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>Poller to set interrupt or poll mode. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to the callback function. </td></tr>
    <tr><td class="paramname">interrupt_mode</td><td>Set interrupt mode for true, or poll mode for false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a0e155fc3fa0150aa4a505dd1801e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0e155fc3fa0150aa4a505dd1801e91">&#9670;&nbsp;</a></span>spdk_thread_pass_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_thread_pass_msg) (<a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn, void *ctx, void *thread_ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called to pass a message to a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>Callback function for a thread. </td></tr>
    <tr><td class="paramname">ctx</td><td>Context passed to fn. </td></tr>
    <tr><td class="paramname">thread_ctx</td><td>Context for the thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa7a2ca9bd0497544e852c65fd5263cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a2ca9bd0497544e852c65fd5263cd1">&#9670;&nbsp;</a></span>spdk_for_each_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_for_each_channel </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a2dd91f3094f8b4cf60f460e3f88bbf0c">spdk_channel_msg</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a96f03fe115196f1de03292ed6d86fd46">spdk_channel_for_each_cpl</a>&#160;</td>
          <td class="paramname"><em>cpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call 'fn' on each channel associated with io_device. </p>
<p>This happens asynchronously, so fn may be called after spdk_for_each_channel returns. 'fn' will be called for each channel serially, such that two calls to 'fn' will not overlap in time. After 'fn' has been called, call <a class="el" href="thread_8h.html#a4e87fc8c0fc870769c068a2752cdc359" title="Helper function to iterate all channels for spdk_for_each_channel().">spdk_for_each_channel_continue()</a> to continue iterating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>'fn' will be called on each channel associated with this io_device. </td></tr>
    <tr><td class="paramname">fn</td><td>Called on the appropriate thread for each channel associated with io_device. </td></tr>
    <tr><td class="paramname">ctx</td><td>Context buffer registered to spdk_io_channel_iter that can be obtained form the function <a class="el" href="thread_8h.html#add3ebaac7b55dddb239c720c80d97dea" title="Get context buffer from the I/O channel iterator.">spdk_io_channel_iter_get_ctx()</a>. </td></tr>
    <tr><td class="paramname">cpl</td><td>Called on the thread that spdk_for_each_channel was initially called from when 'fn' has been called on each channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e87fc8c0fc870769c068a2752cdc359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e87fc8c0fc870769c068a2752cdc359">&#9670;&nbsp;</a></span>spdk_for_each_channel_continue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_for_each_channel_continue </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel_iter *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to iterate all channels for <a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1" title="Call &#39;fn&#39; on each channel associated with io_device.">spdk_for_each_channel()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator. </td></tr>
    <tr><td class="paramname">status</td><td>Status for the I/O channel iterator; for non 0 status remaining iterations are terminated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16bb098e6398d2a63577e805f1423a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bb098e6398d2a63577e805f1423a3e">&#9670;&nbsp;</a></span>spdk_for_each_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_for_each_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>&#160;</td>
          <td class="paramname"><em>cpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to each thread, serially. </p>
<p>The message is sent asynchronously - i.e. spdk_for_each_thread will return prior to <code>fn</code> being called on each thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>This is the function that will be called on each thread. </td></tr>
    <tr><td class="paramname">ctx</td><td>This context will be passed to fn when called. </td></tr>
    <tr><td class="paramname">cpl</td><td>This will be called on the originating thread after <code>fn</code> has been called on each thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8537c42a7aa203b50578efed509d9ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8537c42a7aa203b50578efed509d9ba8">&#9670;&nbsp;</a></span>spdk_get_io_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_io_channel* spdk_get_io_channel </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an I/O channel for the specified io_device to be used by the calling thread. </p>
<p>The io_device context pointer specified must have previously been registered using <a class="el" href="thread_8h.html#a75f5c71056d8c39ff05a6610d55edcf5" title="Register the opaque io_device context as an I/O device.">spdk_io_device_register()</a>. If an existing I/O channel does not exist yet for the given io_device on the calling thread, it will allocate an I/O channel and invoke the create_cb function pointer specified in <a class="el" href="thread_8h.html#a75f5c71056d8c39ff05a6610d55edcf5" title="Register the opaque io_device context as an I/O device.">spdk_io_device_register()</a>. If an I/O channel already exists for the given io_device on the calling thread, its reference is returned rather than creating a new I/O channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>The pointer to io_device context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the I/O channel for this device on success or NULL on failure. </dd></dl>

</div>
</div>
<a id="a34754a98debd5e095bf06889fbaed6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34754a98debd5e095bf06889fbaed6aa">&#9670;&nbsp;</a></span>spdk_get_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_get_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to the current thread. </p>
<p>This handle may be passed to other threads and used as the target of <a class="el" href="thread_8h.html#a07b662b152c21dad824ad2738d0733ec" title="Send a message to the given thread.">spdk_thread_send_msg()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a8ff9537d26ac923a7a93cd55ba315b5b" title="Get the thread associated with an I/O channel.">spdk_io_channel_get_thread()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the current thread on success or NULL on failure. </dd></dl>

</div>
</div>
<a id="a0cac0f188b5f46ff8bcdd5d4ffa37e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cac0f188b5f46ff8bcdd5d4ffa37e84">&#9670;&nbsp;</a></span>spdk_interrupt_mode_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_interrupt_mode_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SPDK run as event driven mode. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -errno on failure </dd></dl>

</div>
</div>
<a id="a1f8be492b86ceface921634b9a627b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8be492b86ceface921634b9a627b7c">&#9670;&nbsp;</a></span>spdk_interrupt_mode_is_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_interrupt_mode_is_enabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether interrupt mode is set. </p>
<dl class="section return"><dt>Returns</dt><dd>True if interrupt mode is set, false otherwise. </dd></dl>

</div>
</div>
<a id="aae58fe1101803d60c523891e7540a23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae58fe1101803d60c523891e7540a23c">&#9670;&nbsp;</a></span>spdk_interrupt_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_interrupt* spdk_interrupt_register </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>efd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a61cfdc77d10970d7f3a8631df71e9588">spdk_interrupt_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register an spdk_interrupt on the current thread. </p>
<p>The provided function will be called any time the associated file descriptor is written to.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">efd</td><td>File descriptor of the spdk_interrupt. </td></tr>
    <tr><td class="paramname">fn</td><td>Called each time there are events in spdk_interrupt. </td></tr>
    <tr><td class="paramname">arg</td><td>Function argument for fn. </td></tr>
    <tr><td class="paramname">name</td><td>Human readable name for the spdk_interrupt. Pointer of the spdk_interrupt name is set if NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the spdk_interrupt registered on the current thread on success or NULL on failure. </dd></dl>

</div>
</div>
<a id="a6665332ac6d7781f7944f5f471ce1a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6665332ac6d7781f7944f5f471ce1a21">&#9670;&nbsp;</a></span>spdk_interrupt_set_event_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_interrupt_set_event_types </td>
          <td>(</td>
          <td class="paramtype">struct spdk_interrupt *&#160;</td>
          <td class="paramname"><em>intr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum spdk_interrupt_event_types&#160;</td>
          <td class="paramname"><em>event_types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the event_types associated with the spdk_interrupt on the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intr</td><td>The pointer to the spdk_interrupt registered on the current thread. </td></tr>
    <tr><td class="paramname">event_types</td><td>New event_types for the spdk_interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success or -errno if failed. </dd></dl>

</div>
</div>
<a id="a45f3647a26ba93931beeb1782d39e56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f3647a26ba93931beeb1782d39e56e">&#9670;&nbsp;</a></span>spdk_interrupt_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_interrupt_unregister </td>
          <td>(</td>
          <td class="paramtype">struct spdk_interrupt **&#160;</td>
          <td class="paramname"><em>pintr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister an spdk_interrupt on the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pintr</td><td>The spdk_interrupt to unregister. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9608b7b0fd448edec6ea5dd38ad04a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9608b7b0fd448edec6ea5dd38ad04a57">&#9670;&nbsp;</a></span>spdk_io_channel_from_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_io_channel* spdk_io_channel_from_ctx </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I/O channel from the context buffer. </p>
<p>This is the inverse of <a class="el" href="thread_8h.html#adbf6e22252bc768003c7bbc165fc3c51" title="Get the context buffer associated with an I/O channel.">spdk_io_channel_get_ctx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The pointer to the context buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the I/O channel associated with the context buffer. </dd></dl>

</div>
</div>
<a id="adbf6e22252bc768003c7bbc165fc3c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf6e22252bc768003c7bbc165fc3c51">&#9670;&nbsp;</a></span>spdk_io_channel_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* spdk_io_channel_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the context buffer associated with an I/O channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>I/O channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the context buffer. </dd></dl>

</div>
</div>
<a id="a49adcba47a8dc22c6d6046bc05c47674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49adcba47a8dc22c6d6046bc05c47674">&#9670;&nbsp;</a></span>spdk_io_channel_get_io_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_io_channel_get_io_device </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the io_device for the specified I/O channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>I/O channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the io_device for the I/O channel </dd></dl>

</div>
</div>
<a id="a8ff9537d26ac923a7a93cd55ba315b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff9537d26ac923a7a93cd55ba315b5b">&#9670;&nbsp;</a></span>spdk_io_channel_get_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_io_channel_get_thread </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread associated with an I/O channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>I/O channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the thread associated with the I/O channel </dd></dl>

</div>
</div>
<a id="a83adef6c3df9568bdea346b8e7dcbaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83adef6c3df9568bdea346b8e7dcbaa5">&#9670;&nbsp;</a></span>spdk_io_channel_iter_get_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_io_channel* spdk_io_channel_iter_get_channel </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel_iter *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I/O channel from the I/O channel iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the I/O channel. </dd></dl>

</div>
</div>
<a id="add3ebaac7b55dddb239c720c80d97dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3ebaac7b55dddb239c720c80d97dea">&#9670;&nbsp;</a></span>spdk_io_channel_iter_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_io_channel_iter_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel_iter *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get context buffer from the I/O channel iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the context buffer. </dd></dl>

</div>
</div>
<a id="a939935cee4dac6636f2b7c6db0b2fec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939935cee4dac6636f2b7c6db0b2fec1">&#9670;&nbsp;</a></span>spdk_io_channel_iter_get_io_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_io_channel_iter_get_io_device </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel_iter *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get io_device from the I/O channel iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the io_device. </dd></dl>

</div>
</div>
<a id="a75f5c71056d8c39ff05a6610d55edcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f5c71056d8c39ff05a6610d55edcf5">&#9670;&nbsp;</a></span>spdk_io_device_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_io_device_register </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#aed1d14292cfee8553d4a1ebb519b210a">spdk_io_channel_create_cb</a>&#160;</td>
          <td class="paramname"><em>create_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a75aa6a61877f23f79bb75c8fc5e68202">spdk_io_channel_destroy_cb</a>&#160;</td>
          <td class="paramname"><em>destroy_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctx_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the opaque io_device context as an I/O device. </p>
<p>After an I/O device is registered, it can return I/O channels using the <a class="el" href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8" title="Get an I/O channel for the specified io_device to be used by the calling thread.">spdk_get_io_channel()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>The pointer to io_device context. </td></tr>
    <tr><td class="paramname">create_cb</td><td>Callback function invoked to allocate any resources required for a new I/O channel. </td></tr>
    <tr><td class="paramname">destroy_cb</td><td>Callback function invoked to release the resources for an I/O channel. </td></tr>
    <tr><td class="paramname">ctx_size</td><td>The size of the context buffer allocated to store references to allocated I/O channel resources. </td></tr>
    <tr><td class="paramname">name</td><td>A string name for the device used only for debugging. Optional - may be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c6c3df3a611c10c176cb87966c622f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6c3df3a611c10c176cb87966c622f0">&#9670;&nbsp;</a></span>spdk_io_device_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_io_device_unregister </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#ae044f4141737c7f2df49cdfb03fd58ca">spdk_io_device_unregister_cb</a>&#160;</td>
          <td class="paramname"><em>unregister_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister the opaque io_device context as an I/O device. </p>
<p>The actual unregistration might be deferred until all active I/O channels are destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>The pointer to io_device context. </td></tr>
    <tr><td class="paramname">unregister_cb</td><td>An optional callback function invoked to release any references to this I/O device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a69dd994350e50395605e9b394b02fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a69dd994350e50395605e9b394b02fe">&#9670;&nbsp;</a></span>spdk_iobuf_channel_fini()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_iobuf_channel_fini </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__iobuf__channel.html">spdk_iobuf_channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release resources tied to an iobuf channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>iobuf channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4e3d5418d2219ba6bd603304c3473de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e3d5418d2219ba6bd603304c3473de">&#9670;&nbsp;</a></span>spdk_iobuf_channel_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_iobuf_channel_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__iobuf__channel.html">spdk_iobuf_channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>small_cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>large_cache_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an iobuf channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>iobuf channel to initialize. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the module registered via <code>spdk_iobuf_register_module()</code>. </td></tr>
    <tr><td class="paramname">small_cache_size</td><td>Number of small buffers to be cached by this channel. </td></tr>
    <tr><td class="paramname">large_cache_size</td><td>Number of large buffers to be cached by this channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno otherwise. </dd></dl>

</div>
</div>
<a id="ad192ca271f84d76cca2a2ff6403b534a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad192ca271f84d76cca2a2ff6403b534a">&#9670;&nbsp;</a></span>spdk_iobuf_entry_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_iobuf_entry_abort </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__iobuf__channel.html">spdk_iobuf_channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__iobuf__entry.html">spdk_iobuf_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort an outstanding request waiting for a buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>iobuf channel on which the entry is waiting. </td></tr>
    <tr><td class="paramname">entry</td><td>Entry to remove from the wait queue. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the requested buffer (must be the exact same value as specified in <code><a class="el" href="thread_8h.html#a861f8067dad2dad16aa5a7f11e2221fc" title="Get a buffer from the iobuf pool.">spdk_iobuf_get()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf8009c7842c30586bd815eaee9b7a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8009c7842c30586bd815eaee9b7a91">&#9670;&nbsp;</a></span>spdk_iobuf_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_iobuf_finish </td>
          <td>(</td>
          <td class="paramtype">spdk_iobuf_finish_cb&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up and free iobuf pools. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_fn</td><td>Callback to be executed once the clean up is completed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa57f01f992d8ebe9e30c5b6c21edf2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57f01f992d8ebe9e30c5b6c21edf2a5">&#9670;&nbsp;</a></span>spdk_iobuf_for_each_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_iobuf_for_each_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__iobuf__channel.html">spdk_iobuf_channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__iobuf__pool.html">spdk_iobuf_pool</a> *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_iobuf_for_each_entry_fn&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over all entries on a given queue and execute a callback on those that were requested using <code>ch</code>. </p>
<p>The iteration is stopped if the callback returns non-zero status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>iobuf channel to iterate over. </td></tr>
    <tr><td class="paramname">pool</td><td>Pool to iterate over (<code>small</code> or <code>large</code>). </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback to execute on each entry on the queue that was requested using <code>ch</code>. </td></tr>
    <tr><td class="paramname">cb_ctx</td><td>Argument passed to <code>cb_fn</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status of the last callback. </dd></dl>

</div>
</div>
<a id="a861f8067dad2dad16aa5a7f11e2221fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861f8067dad2dad16aa5a7f11e2221fc">&#9670;&nbsp;</a></span>spdk_iobuf_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_iobuf_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__iobuf__channel.html">spdk_iobuf_channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__iobuf__entry.html">spdk_iobuf_entry</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_iobuf_get_cb&#160;</td>
          <td class="paramname"><em>cb_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a buffer from the iobuf pool. </p>
<p>If no buffers are available, the request is queued until a buffer is released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>iobuf channel. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the buffer to retrieve. The user is responsible for making sure the length doesn't exceed large_bufsize. </td></tr>
    <tr><td class="paramname">entry</td><td>Wait queue entry. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback to be executed once a buffer becomes available. If a buffer is available immediately, it is NOT be executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a buffer or NULL if no buffers are currently available. </dd></dl>

</div>
</div>
<a id="a1e97f3caeb779908350fd5176c98ba4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e97f3caeb779908350fd5176c98ba4a">&#9670;&nbsp;</a></span>spdk_iobuf_get_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_iobuf_get_opts </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__iobuf__opts.html">spdk_iobuf_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get iobuf options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Options to fill in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c37e9172bb09d20cfa353dbd92b0a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c37e9172bb09d20cfa353dbd92b0a95">&#9670;&nbsp;</a></span>spdk_iobuf_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_iobuf_initialize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize and allocate iobuf pools. </p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno otherwise. </dd></dl>

</div>
</div>
<a id="aca828f485050a8d77d0a0b4182c632cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca828f485050a8d77d0a0b4182c632cc">&#9670;&nbsp;</a></span>spdk_iobuf_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_iobuf_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__iobuf__channel.html">spdk_iobuf_channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a buffer back to the iobuf pool. </p>
<p>If there are outstanding requests waiting for a buffer, this buffer will be passed to one of them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>iobuf channel. </td></tr>
    <tr><td class="paramname">buf</td><td>Buffer to release </td></tr>
    <tr><td class="paramname">len</td><td>Length of the buffer (must be the exact same value as specified in <code><a class="el" href="thread_8h.html#a861f8067dad2dad16aa5a7f11e2221fc" title="Get a buffer from the iobuf pool.">spdk_iobuf_get()</a></code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac64427a246442e52b60271127bf363d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64427a246442e52b60271127bf363d4">&#9670;&nbsp;</a></span>spdk_iobuf_set_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_iobuf_set_opts </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__iobuf__opts.html">spdk_iobuf_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set iobuf options. </p>
<p>These options will be used during <code><a class="el" href="thread_8h.html#a2c37e9172bb09d20cfa353dbd92b0a95" title="Initialize and allocate iobuf pools.">spdk_iobuf_initialize()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Options describing the size of the pools to reserve.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative errno otherwise. </dd></dl>

</div>
</div>
<a id="a0f0c05dd1c9cb0b31eee89213b89f3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0c05dd1c9cb0b31eee89213b89f3c3">&#9670;&nbsp;</a></span>spdk_poller_pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_poller_pause </td>
          <td>(</td>
          <td class="paramtype">struct spdk_poller *&#160;</td>
          <td class="paramname"><em>poller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause a poller on the current thread. </p>
<p>The poller is not run until it is resumed with <a class="el" href="thread_8h.html#ab3de0ffe9dfc29361b092d467d37017e" title="Resume a poller on the current thread.">spdk_poller_resume()</a>. It is perfectly fine to pause an already paused poller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>The poller to pause. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b3e883ddce01ae8d93541304d1e9126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3e883ddce01ae8d93541304d1e9126">&#9670;&nbsp;</a></span>spdk_poller_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_poller* spdk_poller_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>period_microseconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a poller on the current thread. </p>
<p>The poller can be unregistered by calling <a class="el" href="thread_8h.html#a9c26cbd781063f5ee627d6aba2c73fe3" title="Unregister a poller on the current thread.">spdk_poller_unregister()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>This function will be called every <code>period_microseconds</code>. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to fn. </td></tr>
    <tr><td class="paramname">period_microseconds</td><td>How often to call <code>fn</code>. If 0, call <code>fn</code> as often as possible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the poller registered on the current thread on success or NULL on failure. </dd></dl>

</div>
</div>
<a id="af6f06715375ed6a1bff5e037628a8558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f06715375ed6a1bff5e037628a8558">&#9670;&nbsp;</a></span>spdk_poller_register_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_poller_register_interrupt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_poller *&#160;</td>
          <td class="paramname"><em>poller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#aaa00024ffe78012bf1b7ade9aee0ab1a">spdk_poller_set_interrupt_mode_cb</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark that the poller is capable of entering interrupt mode. </p>
<p>When registering the poller set interrupt callback, the callback will get executed immediately if its spdk_thread is in the interrupt mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>The poller to register callback function. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Callback function called when the poller must transition into or out of interrupt mode </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e1086db1bd40b0a1720bd148967d82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1086db1bd40b0a1720bd148967d82d">&#9670;&nbsp;</a></span>spdk_poller_register_named()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_poller* spdk_poller_register_named </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>period_microseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a poller on the current thread with arbitrary name. </p>
<p>The poller can be unregistered by calling <a class="el" href="thread_8h.html#a9c26cbd781063f5ee627d6aba2c73fe3" title="Unregister a poller on the current thread.">spdk_poller_unregister()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>This function will be called every <code>period_microseconds</code>. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to fn. </td></tr>
    <tr><td class="paramname">period_microseconds</td><td>How often to call <code>fn</code>. If 0, call <code>fn</code> as often as possible. </td></tr>
    <tr><td class="paramname">name</td><td>Human readable name for the poller. Pointer of the poller function name is set if NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the poller registered on the current thread on success or NULL on failure. </dd></dl>

</div>
</div>
<a id="ab3de0ffe9dfc29361b092d467d37017e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3de0ffe9dfc29361b092d467d37017e">&#9670;&nbsp;</a></span>spdk_poller_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_poller_resume </td>
          <td>(</td>
          <td class="paramtype">struct spdk_poller *&#160;</td>
          <td class="paramname"><em>poller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a poller on the current thread. </p>
<p>Resumes a poller paused with <a class="el" href="thread_8h.html#a0f0c05dd1c9cb0b31eee89213b89f3c3" title="Pause a poller on the current thread.">spdk_poller_pause()</a>. It is perfectly fine to resume an unpaused poller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>The poller to resume. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c26cbd781063f5ee627d6aba2c73fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c26cbd781063f5ee627d6aba2c73fe3">&#9670;&nbsp;</a></span>spdk_poller_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_poller_unregister </td>
          <td>(</td>
          <td class="paramtype">struct spdk_poller **&#160;</td>
          <td class="paramname"><em>ppoller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a poller on the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppoller</td><td>The poller to unregister. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a717571a5011db0cdd730498146f25f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717571a5011db0cdd730498146f25f9a">&#9670;&nbsp;</a></span>spdk_put_io_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_put_io_channel </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a reference to an I/O channel. </p>
<p>This happens asynchronously.</p>
<p>This must be called on the same thread that called <a class="el" href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8" title="Get an I/O channel for the specified io_device to be used by the calling thread.">spdk_get_io_channel()</a> for the specified I/O channel. If this releases the last reference to the I/O channel, The destroy_cb function specified in <a class="el" href="thread_8h.html#a75f5c71056d8c39ff05a6610d55edcf5" title="Register the opaque io_device context as an I/O device.">spdk_io_device_register()</a> will be invoked to release any associated resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>I/O channel to release a reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60dac2a0fc19b23be6fecb1e5b6f8a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60dac2a0fc19b23be6fecb1e5b6f8a7a">&#9670;&nbsp;</a></span>spdk_set_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_set_thread </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the current system thread to act as if executing the given SPDK thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a082f55ea269d3f171f00917099debb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082f55ea269d3f171f00917099debb67">&#9670;&nbsp;</a></span>spdk_spin_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_spin_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__spinlock.html">spdk_spinlock</a> *&#160;</td>
          <td class="paramname"><em>sspin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an <a class="el" href="structspdk__spinlock.html" title="A spinlock augmented with safety checks for use with SPDK.">spdk_spinlock</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sspin</td><td>The SPDK spinlock to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14cf080d22a52b5ae3025221411096f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14cf080d22a52b5ae3025221411096f5">&#9670;&nbsp;</a></span>spdk_spin_held()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_spin_held </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__spinlock.html">spdk_spinlock</a> *&#160;</td>
          <td class="paramname"><em>sspin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the caller holds this SPDK spinlock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sspin</td><td>An SPDK spinlock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if spinlock is held by this thread, else false </dd></dl>

</div>
</div>
<a id="ad9618326108ac7d4a47fefb33e21879f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9618326108ac7d4a47fefb33e21879f">&#9670;&nbsp;</a></span>spdk_spin_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_spin_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__spinlock.html">spdk_spinlock</a> *&#160;</td>
          <td class="paramname"><em>sspin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an <a class="el" href="structspdk__spinlock.html" title="A spinlock augmented with safety checks for use with SPDK.">spdk_spinlock</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sspin</td><td>The SPDK spinlock to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac03bb794fec774061fc77367bc6bdfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03bb794fec774061fc77367bc6bdfa2">&#9670;&nbsp;</a></span>spdk_spin_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_spin_lock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__spinlock.html">spdk_spinlock</a> *&#160;</td>
          <td class="paramname"><em>sspin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock an SPDK spin lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sspin</td><td>An SPDK spinlock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcaee781de4118a2f789dd76ef4b3b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcaee781de4118a2f789dd76ef4b3b83">&#9670;&nbsp;</a></span>spdk_spin_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_spin_unlock </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__spinlock.html">spdk_spinlock</a> *&#160;</td>
          <td class="paramname"><em>sspin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock an SPDK spinlock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sspin</td><td>An SPDK spinlock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49abb69cad49e5f35363d9b8ee990ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49abb69cad49e5f35363d9b8ee990ae2">&#9670;&nbsp;</a></span>spdk_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_thread_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *&#160;</td>
          <td class="paramname"><em>cpumask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new SPDK thread object. </p>
<p>Note that the first thread created via <a class="el" href="thread_8h.html#a49abb69cad49e5f35363d9b8ee990ae2" title="Creates a new SPDK thread object.">spdk_thread_create()</a> will be designated as the app thread. Other SPDK libraries may place restrictions on certain APIs to only be called in the context of this app thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Human-readable name for the thread; can be retrieved with <a class="el" href="thread_8h.html#ae367048fa89366e845d72015064e6f76" title="Get a thread&#39;s name.">spdk_thread_get_name()</a>. The string is copied, so the pointed-to data only needs to be valid during the <a class="el" href="thread_8h.html#a49abb69cad49e5f35363d9b8ee990ae2" title="Creates a new SPDK thread object.">spdk_thread_create()</a> call. May be NULL to specify no name. </td></tr>
    <tr><td class="paramname">cpumask</td><td>Optional mask of CPU cores on which to schedule this thread. This is only a suggestion to the scheduler. The value is copied, so cpumask may be released when this function returns. May be NULL if no mask is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated thread on success or NULL on failure.. </dd></dl>

</div>
</div>
<a id="a10aa5a8ec5228fa87db97f7655f8c0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aa5a8ec5228fa87db97f7655f8c0d6">&#9670;&nbsp;</a></span>spdk_thread_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_thread_destroy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a thread, releasing all of its resources. </p>
<p>May only be called on a thread previously marked as exited.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6695466847e7a751b768ab4b8bcd53d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6695466847e7a751b768ab4b8bcd53d0">&#9670;&nbsp;</a></span>spdk_thread_exec_msg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int spdk_thread_exec_msg </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the msg callback on the given thread. </p>
<p>If this happens to be the current thread, the callback is executed immediately; otherwise a message is sent to the thread, and it's run asynchronously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The target thread. </td></tr>
    <tr><td class="paramname">fn</td><td>This function will be called on the given thread. </td></tr>
    <tr><td class="paramname">ctx</td><td>This context will be passed to fn when called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-ENOMEM if the message could not be allocated </dd>
<dd>
-EIO if the message could not be sent to the destination thread </dd></dl>

</div>
</div>
<a id="a5132d2abe39a40a0e14e19bb2bd15489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5132d2abe39a40a0e14e19bb2bd15489">&#9670;&nbsp;</a></span>spdk_thread_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_exit </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the thread as exited, failing all future <a class="el" href="thread_8h.html#a07b662b152c21dad824ad2738d0733ec" title="Send a message to the given thread.">spdk_thread_send_msg()</a>, <a class="el" href="thread_8h.html#a6b3e883ddce01ae8d93541304d1e9126" title="Register a poller on the current thread.">spdk_poller_register()</a>, and <a class="el" href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8" title="Get an I/O channel for the specified io_device to be used by the calling thread.">spdk_get_io_channel()</a> calls. </p>
<p>May only be called within an spdk poller or message.</p>
<p>All I/O channel references associated with the thread must be released using <a class="el" href="thread_8h.html#a717571a5011db0cdd730498146f25f9a" title="Release a reference to an I/O channel.">spdk_put_io_channel()</a>, and all active pollers associated with the thread should be unregistered using <a class="el" href="thread_8h.html#a9c26cbd781063f5ee627d6aba2c73fe3" title="Unregister a poller on the current thread.">spdk_poller_unregister()</a>, prior to calling this function. This function will complete these processing. The completion can be queried by <a class="el" href="thread_8h.html#ae99859eb37714e4ed7c6110ea71ab142" title="Returns whether the thread is marked as exited.">spdk_thread_is_exited()</a>.</p>
<p>Note that this function must not be called on the app thread until after it has been called for all other threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to exit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>always 0. (return value was deprecated but keep it for ABI compatibility.) </dd></dl>

</div>
</div>
<a id="a5e4e0f6527f81dc3277989d05b4c7111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4e0f6527f81dc3277989d05b4c7111">&#9670;&nbsp;</a></span>spdk_thread_get_app_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_thread_get_app_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the app thread. </p>
<p>The app thread is the first thread created using <a class="el" href="thread_8h.html#a49abb69cad49e5f35363d9b8ee990ae2" title="Creates a new SPDK thread object.">spdk_thread_create()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the app thread, or NULL if no thread has been created yet. </dd></dl>

</div>
</div>
<a id="a24c90cd523aad947dad7e651074d9f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c90cd523aad947dad7e651074d9f1d">&#9670;&nbsp;</a></span>spdk_thread_get_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_thread_get_by_id </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread by the ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>ID of the thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Thread whose ID matches or NULL otherwise. </dd></dl>

</div>
</div>
<a id="a9f06d559046d570e025d6b67c7e8d507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f06d559046d570e025d6b67c7e8d507">&#9670;&nbsp;</a></span>spdk_thread_get_cpumask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a>* spdk_thread_get_cpumask </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread's cpumask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to get the cpumask for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cpuset pointer </dd></dl>

</div>
</div>
<a id="a1deb97a85a8240119cf46fa8a0b71388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1deb97a85a8240119cf46fa8a0b71388">&#9670;&nbsp;</a></span>spdk_thread_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_thread_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to this thread's context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread on which to get the context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the per-thread context, or NULL if there is no per-thread context. </dd></dl>

</div>
</div>
<a id="af813fe52c71ec5e254f8671570f57bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af813fe52c71ec5e254f8671570f57bdc">&#9670;&nbsp;</a></span>spdk_thread_get_from_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_thread_get_from_ctx </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the thread object associated with the context handle previously obtained by calling <a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388" title="Return a pointer to this thread&#39;s context.">spdk_thread_get_ctx()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>A context previously obtained by calling <a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388" title="Return a pointer to this thread&#39;s context.">spdk_thread_get_ctx()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated thread. </dd></dl>

</div>
</div>
<a id="aead9239fedaf5af9f24b5614f6c0c8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead9239fedaf5af9f24b5614f6c0c8fb">&#9670;&nbsp;</a></span>spdk_thread_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_thread_get_id </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a thread's ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID of the thread.. </dd></dl>

</div>
</div>
<a id="a6b33abb26c349950555f71a34cf507c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b33abb26c349950555f71a34cf507c6">&#9670;&nbsp;</a></span>spdk_thread_get_interrupt_fd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_get_interrupt_fd </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a file descriptor that becomes ready whenever any of the registered interrupt file descriptors are ready. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The spdk_interrupt fd of thread itself. </dd></dl>

</div>
</div>
<a id="a0d1e717df13e86ea95c36e661bb8568d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1e717df13e86ea95c36e661bb8568d">&#9670;&nbsp;</a></span>spdk_thread_get_interrupt_fd_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_fd_group* spdk_thread_get_interrupt_fd_group </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an fd_group that becomes ready whenever any of the registered interrupt file descriptors are ready. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The spdk_fd_group of the thread itself. </dd></dl>

</div>
</div>
<a id="ae8d7fd3db7cd91ff37c3898e69811f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d7fd3db7cd91ff37c3898e69811f7a">&#9670;&nbsp;</a></span>spdk_thread_get_last_tsc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_thread_get_last_tsc </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the TSC value from the end of the last time this thread was polled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to query. If NULL, use current thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TSC value from the end of the last time this thread was polled. </dd></dl>

</div>
</div>
<a id="ae367048fa89366e845d72015064e6f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae367048fa89366e845d72015064e6f76">&#9670;&nbsp;</a></span>spdk_thread_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_thread_get_name </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a thread's name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the thread. </dd></dl>

</div>
</div>
<a id="ab6f07dd00b0b4140155713aca312d46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f07dd00b0b4140155713aca312d46b">&#9670;&nbsp;</a></span>spdk_thread_get_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_get_stats </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__thread__stats.html">spdk_thread_stats</a> *&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get statistics about the current thread. </p>
<p>Copy cumulative thread stats values to the provided thread stats structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stats</td><td>User's thread_stats structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a143ecbc5ce7edcd57e76cffd74bde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a143ecbc5ce7edcd57e76cffd74bde5">&#9670;&nbsp;</a></span>spdk_thread_has_active_pollers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_has_active_pollers </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether there are any active pollers (pollers for which period_microseconds equals 0) registered to be run on the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if there is at least one active poller, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a9f877dd192ccdd30572941aa4e453c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f877dd192ccdd30572941aa4e453c48">&#9670;&nbsp;</a></span>spdk_thread_has_pollers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_thread_has_pollers </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether there are any pollers registered to be run on the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is any active poller, false otherwise. </dd></dl>

</div>
</div>
<a id="ae99859eb37714e4ed7c6110ea71ab142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99859eb37714e4ed7c6110ea71ab142">&#9670;&nbsp;</a></span>spdk_thread_is_exited()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_thread_is_exited </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the thread is marked as exited. </p>
<p>A thread is exited only after it has <a class="el" href="thread_8h.html#a5132d2abe39a40a0e14e19bb2bd15489" title="Mark the thread as exited, failing all future spdk_thread_send_msg(), spdk_poller_register(),...">spdk_thread_exit()</a> called on it, and it has been polled until any outstanding operations targeting this thread have completed. This may include poller unregistrations, io channel unregistrations, or outstanding spdk_thread_send_msg calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if marked as exited, false otherwise. </dd></dl>

</div>
</div>
<a id="adc45e09bda68d13cfc0ae010738cd658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc45e09bda68d13cfc0ae010738cd658">&#9670;&nbsp;</a></span>spdk_thread_is_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_thread_is_idle </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether there are scheduled operations to be run on the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there are no scheduled operations, false otherwise. </dd></dl>

</div>
</div>
<a id="a67c3bf0e066520e8eeeaec589d021b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c3bf0e066520e8eeeaec589d021b6c">&#9670;&nbsp;</a></span>spdk_thread_is_running()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_thread_is_running </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the thread is still running. </p>
<p>A thread is considered running until it has * <a class="el" href="thread_8h.html#a5132d2abe39a40a0e14e19bb2bd15489" title="Mark the thread as exited, failing all future spdk_thread_send_msg(), spdk_poller_register(),...">spdk_thread_exit()</a> called on it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if still running, false otherwise. </dd></dl>

</div>
</div>
<a id="a96c6e1cadb3b5a83c5723487e3f02c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c6e1cadb3b5a83c5723487e3f02c23">&#9670;&nbsp;</a></span>spdk_thread_lib_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_lib_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#afab3d4339c5bca4dfde209816a9e560f">spdk_new_thread_fn</a>&#160;</td>
          <td class="paramname"><em>new_thread_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ctx_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the threading library. </p>
<p>Must be called once prior to allocating any threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_thread_fn</td><td>Called each time a new SPDK thread is created. The implementor is expected to frequently call <a class="el" href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91" title="Perform one iteration worth of processing on the thread.">spdk_thread_poll()</a> on the provided thread. </td></tr>
    <tr><td class="paramname">ctx_sz</td><td>For each thread allocated, an additional region of memory of size ctx_size will also be allocated, for use by the thread scheduler. A pointer to this region may be obtained by calling <a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388" title="Return a pointer to this thread&#39;s context.">spdk_thread_get_ctx()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Negated errno on failure. </dd></dl>

</div>
</div>
<a id="a7219c832e5483b4318d2533cb45ff22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7219c832e5483b4318d2533cb45ff22e">&#9670;&nbsp;</a></span>spdk_thread_lib_init_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_lib_init_ext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a9f0ad3a2bcbb6d304401b579ab63aeba">spdk_thread_op_fn</a>&#160;</td>
          <td class="paramname"><em>thread_op_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#af791c24e496b96c886fe8bad088eb0cb">spdk_thread_op_supported_fn</a>&#160;</td>
          <td class="paramname"><em>thread_op_supported_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ctx_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>msg_mempool_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the threading library. </p>
<p>Must be called once prior to allocating any threads</p>
<p>Both thread_op_fn and thread_op_type_supported_fn have to be specified or not specified together.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_op_fn</td><td>Called for SPDK thread operation. </td></tr>
    <tr><td class="paramname">thread_op_supported_fn</td><td>Called to check whether the SPDK thread operation is supported. </td></tr>
    <tr><td class="paramname">ctx_sz</td><td>For each thread allocated, for use by the thread scheduler. A pointer to this region may be obtained by calling <a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388" title="Return a pointer to this thread&#39;s context.">spdk_thread_get_ctx()</a>. </td></tr>
    <tr><td class="paramname">msg_mempool_size</td><td>Size of the allocated spdk_msg_mempool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Negated errno on failure. </dd></dl>

</div>
</div>
<a id="a474fcfc5c14928eda42c684ba2b4cba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474fcfc5c14928eda42c684ba2b4cba9">&#9670;&nbsp;</a></span>spdk_thread_next_poller_expiration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_thread_next_poller_expiration </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of ticks until the next timed poller would expire. </p>
<p>Timed pollers are pollers for which period_microseconds is greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to check poller expiration times on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of ticks. If no timed pollers, return 0. </dd></dl>

</div>
</div>
<a id="ad9e3693e8e9e6c9063ea36414294ae91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e3693e8e9e6c9063ea36414294ae91">&#9670;&nbsp;</a></span>spdk_thread_poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_poll </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_msgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform one iteration worth of processing on the thread. </p>
<p>This includes both expired and continuous pollers as well as messages. If the thread has exited, return immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to process </td></tr>
    <tr><td class="paramname">max_msgs</td><td>The maximum number of messages that will be processed. Use 0 to process the default number of messages (8). </td></tr>
    <tr><td class="paramname">now</td><td>The current time, in ticks. Optional. If 0 is passed, this function will call <a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596" title="Get a monotonic timestamp counter.">spdk_get_ticks()</a> to get the current time. The current time is used as start time and this function will call <a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596" title="Get a monotonic timestamp counter.">spdk_get_ticks()</a> at its end to know end time to measure run time of this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if work was done. 0 if no work was done. </dd></dl>

</div>
</div>
<a id="a91a7e9d44c2a332dfcea5e23df471c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a7e9d44c2a332dfcea5e23df471c8d">&#9670;&nbsp;</a></span>spdk_thread_send_critical_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_send_critical_msg </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to the given thread. </p>
<p>Only one critical message can be outstanding at the same time. It's intended to use this function in any cases that might interrupt the execution of the application, such as signal handlers.</p>
<p>The message will be sent asynchronously - i.e. spdk_thread_send_critical_msg will always return prior to <code>fn</code> being called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The target thread. </td></tr>
    <tr><td class="paramname">fn</td><td>This function will be called on the given thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-EIO if the message could not be sent to the destination thread, due to an already outstanding critical message </dd></dl>

</div>
</div>
<a id="a07b662b152c21dad824ad2738d0733ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b662b152c21dad824ad2738d0733ec">&#9670;&nbsp;</a></span>spdk_thread_send_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_send_msg </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to the given thread. </p>
<p>The message will be sent asynchronously - i.e. spdk_thread_send_msg will always return prior to <code>fn</code> being called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The target thread. </td></tr>
    <tr><td class="paramname">fn</td><td>This function will be called on the given thread. </td></tr>
    <tr><td class="paramname">ctx</td><td>This context will be passed to fn when called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-ENOMEM if the message could not be allocated </dd>
<dd>
-EIO if the message could not be sent to the destination thread </dd></dl>

</div>
</div>
<a id="a44c27f304a333a80bbdb48f1df12721f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c27f304a333a80bbdb48f1df12721f">&#9670;&nbsp;</a></span>spdk_thread_set_cpumask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_set_cpumask </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *&#160;</td>
          <td class="paramname"><em>cpumask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current thread's cpumask to the specified value. </p>
<p>The thread may be rescheduled to one of the CPUs specified in the cpumask.</p>
<p>This API requires SPDK thread operation supports SPDK_THREAD_OP_RESCHED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpumask</td><td>The new cpumask for the thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negated errno otherwise. </dd></dl>

</div>
</div>
<a id="a5c98f015b55188cabb829aaf83a797c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c98f015b55188cabb829aaf83a797c6">&#9670;&nbsp;</a></span>spdk_thread_set_interrupt_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_thread_set_interrupt_mode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_interrupt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set current spdk_thread into interrupt mode or back to poll mode. </p>
<p>Only valid when thread interrupt facility is enabled by <a class="el" href="thread_8h.html#a0cac0f188b5f46ff8bcdd5d4ffa37e84" title="Set SPDK run as event driven mode.">spdk_interrupt_mode_enable()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable_interrupt</td><td>Set interrupt mode for true, or poll mode for false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.1 </li>
</ul>
</div>
</div>
</body>
</html>
