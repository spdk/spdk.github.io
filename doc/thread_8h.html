<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.14">
  <title>SPDK: thread.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="two.min.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-xs-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://spdk.io/ci/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://trello.com/b/MN8auadQ/spdk-roadmap">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('thread_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">thread.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Thread.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__io__channel.html">spdk_io_channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a per-thread channel for accessing an I/O device.  <a href="structspdk__io__channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__thread__stats.html">spdk_thread_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afab3d4339c5bca4dfde209816a9e560f"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#afab3d4339c5bca4dfde209816a9e560f">spdk_new_thread_fn</a>) (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:afab3d4339c5bca4dfde209816a9e560f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that is called each time a new thread is created.  <a href="#afab3d4339c5bca4dfde209816a9e560f">More...</a><br /></td></tr>
<tr class="separator:afab3d4339c5bca4dfde209816a9e560f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0da6b1b784d4f165dcd48b526d12ad"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>) (void *ctx)</td></tr>
<tr class="memdesc:adc0da6b1b784d4f165dcd48b526d12ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that will be called on the target thread.  <a href="#adc0da6b1b784d4f165dcd48b526d12ad">More...</a><br /></td></tr>
<tr class="separator:adc0da6b1b784d4f165dcd48b526d12ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0e155fc3fa0150aa4a505dd1801e91"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4a0e155fc3fa0150aa4a505dd1801e91">spdk_thread_pass_msg</a>) (<a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn, void *ctx, void *thread_ctx)</td></tr>
<tr class="memdesc:a4a0e155fc3fa0150aa4a505dd1801e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called to pass a message to a thread.  <a href="#a4a0e155fc3fa0150aa4a505dd1801e91">More...</a><br /></td></tr>
<tr class="separator:a4a0e155fc3fa0150aa4a505dd1801e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c421accdc2a0a61bb7be916106293b"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a>) (void *ctx)</td></tr>
<tr class="memdesc:a35c421accdc2a0a61bb7be916106293b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function for a poller.  <a href="#a35c421accdc2a0a61bb7be916106293b">More...</a><br /></td></tr>
<tr class="separator:a35c421accdc2a0a61bb7be916106293b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f70f5e9b4d498e843f81f1a6ada6370"><td class="memItemLeft" align="right" valign="top">typedef struct spdk_poller *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6f70f5e9b4d498e843f81f1a6ada6370">spdk_start_poller</a>) (void *thread_ctx, <a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a> fn, void *arg, uint64_t period_microseconds)</td></tr>
<tr class="memdesc:a6f70f5e9b4d498e843f81f1a6ada6370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called to start a poller for the thread.  <a href="#a6f70f5e9b4d498e843f81f1a6ada6370">More...</a><br /></td></tr>
<tr class="separator:a6f70f5e9b4d498e843f81f1a6ada6370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfddbbbb13145f26741106cb8296a05a"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#adfddbbbb13145f26741106cb8296a05a">spdk_stop_poller</a>) (struct spdk_poller *poller, void *thread_ctx)</td></tr>
<tr class="memdesc:adfddbbbb13145f26741106cb8296a05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called to stop a poller.  <a href="#adfddbbbb13145f26741106cb8296a05a">More...</a><br /></td></tr>
<tr class="separator:adfddbbbb13145f26741106cb8296a05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1d14292cfee8553d4a1ebb519b210a"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aed1d14292cfee8553d4a1ebb519b210a">spdk_io_channel_create_cb</a>) (void *io_device, void *ctx_buf)</td></tr>
<tr class="memdesc:aed1d14292cfee8553d4a1ebb519b210a"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O channel creation callback.  <a href="#aed1d14292cfee8553d4a1ebb519b210a">More...</a><br /></td></tr>
<tr class="separator:aed1d14292cfee8553d4a1ebb519b210a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aa6a61877f23f79bb75c8fc5e68202"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a75aa6a61877f23f79bb75c8fc5e68202">spdk_io_channel_destroy_cb</a>) (void *io_device, void *ctx_buf)</td></tr>
<tr class="memdesc:a75aa6a61877f23f79bb75c8fc5e68202"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O channel destruction callback.  <a href="#a75aa6a61877f23f79bb75c8fc5e68202">More...</a><br /></td></tr>
<tr class="separator:a75aa6a61877f23f79bb75c8fc5e68202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae044f4141737c7f2df49cdfb03fd58ca"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae044f4141737c7f2df49cdfb03fd58ca">spdk_io_device_unregister_cb</a>) (void *io_device)</td></tr>
<tr class="memdesc:ae044f4141737c7f2df49cdfb03fd58ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O device unregister callback.  <a href="#ae044f4141737c7f2df49cdfb03fd58ca">More...</a><br /></td></tr>
<tr class="separator:ae044f4141737c7f2df49cdfb03fd58ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd91f3094f8b4cf60f460e3f88bbf0c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a2dd91f3094f8b4cf60f460e3f88bbf0c">spdk_channel_msg</a>) (struct spdk_io_channel_iter *i)</td></tr>
<tr class="memdesc:a2dd91f3094f8b4cf60f460e3f88bbf0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called on the appropriate thread for each channel associated with io_device.  <a href="#a2dd91f3094f8b4cf60f460e3f88bbf0c">More...</a><br /></td></tr>
<tr class="separator:a2dd91f3094f8b4cf60f460e3f88bbf0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f03fe115196f1de03292ed6d86fd46"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a96f03fe115196f1de03292ed6d86fd46">spdk_channel_for_each_cpl</a>) (struct spdk_io_channel_iter *i, int status)</td></tr>
<tr class="memdesc:a96f03fe115196f1de03292ed6d86fd46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1" title="Call &#39;fn&#39; on each channel associated with io_device. ">spdk_for_each_channel()</a> callback.  <a href="#a96f03fe115196f1de03292ed6d86fd46">More...</a><br /></td></tr>
<tr class="separator:a96f03fe115196f1de03292ed6d86fd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a96c6e1cadb3b5a83c5723487e3f02c23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a96c6e1cadb3b5a83c5723487e3f02c23">spdk_thread_lib_init</a> (<a class="el" href="thread_8h.html#afab3d4339c5bca4dfde209816a9e560f">spdk_new_thread_fn</a> new_thread_fn, size_t ctx_sz)</td></tr>
<tr class="memdesc:a96c6e1cadb3b5a83c5723487e3f02c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the threading library.  <a href="#a96c6e1cadb3b5a83c5723487e3f02c23">More...</a><br /></td></tr>
<tr class="separator:a96c6e1cadb3b5a83c5723487e3f02c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe409bf16664f461daa516b6a6d1682c"><td class="memItemLeft" align="right" valign="top"><a id="afe409bf16664f461daa516b6a6d1682c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#afe409bf16664f461daa516b6a6d1682c">spdk_thread_lib_fini</a> (void)</td></tr>
<tr class="memdesc:afe409bf16664f461daa516b6a6d1682c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all resources associated with this library. <br /></td></tr>
<tr class="separator:afe409bf16664f461daa516b6a6d1682c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eada7bac2a5c7ceaea891d57f8d3e21"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4eada7bac2a5c7ceaea891d57f8d3e21">spdk_thread_create</a> (const char *name, struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *cpumask)</td></tr>
<tr class="memdesc:a4eada7bac2a5c7ceaea891d57f8d3e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new SPDK thread object.  <a href="#a4eada7bac2a5c7ceaea891d57f8d3e21">More...</a><br /></td></tr>
<tr class="separator:a4eada7bac2a5c7ceaea891d57f8d3e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dac2a0fc19b23be6fecb1e5b6f8a7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a60dac2a0fc19b23be6fecb1e5b6f8a7a">spdk_set_thread</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a60dac2a0fc19b23be6fecb1e5b6f8a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the current system thread to act as if executing the given SPDK thread.  <a href="#a60dac2a0fc19b23be6fecb1e5b6f8a7a">More...</a><br /></td></tr>
<tr class="separator:a60dac2a0fc19b23be6fecb1e5b6f8a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42fa5ed7447767885f700875b28a84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ac42fa5ed7447767885f700875b28a84b">spdk_thread_exit</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:ac42fa5ed7447767885f700875b28a84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the thread as exited, failing all future <a class="el" href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91" title="Perform one iteration worth of processing on the thread. ">spdk_thread_poll()</a> calls.  <a href="#ac42fa5ed7447767885f700875b28a84b">More...</a><br /></td></tr>
<tr class="separator:ac42fa5ed7447767885f700875b28a84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10aa5a8ec5228fa87db97f7655f8c0d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a10aa5a8ec5228fa87db97f7655f8c0d6">spdk_thread_destroy</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a10aa5a8ec5228fa87db97f7655f8c0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a thread, releasing all of its resources.  <a href="#a10aa5a8ec5228fa87db97f7655f8c0d6">More...</a><br /></td></tr>
<tr class="separator:a10aa5a8ec5228fa87db97f7655f8c0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deb97a85a8240119cf46fa8a0b71388"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388">spdk_thread_get_ctx</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a1deb97a85a8240119cf46fa8a0b71388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to this thread's context.  <a href="#a1deb97a85a8240119cf46fa8a0b71388">More...</a><br /></td></tr>
<tr class="separator:a1deb97a85a8240119cf46fa8a0b71388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f06d559046d570e025d6b67c7e8d507"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9f06d559046d570e025d6b67c7e8d507">spdk_thread_get_cpumask</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a9f06d559046d570e025d6b67c7e8d507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread's cpumask.  <a href="#a9f06d559046d570e025d6b67c7e8d507">More...</a><br /></td></tr>
<tr class="separator:a9f06d559046d570e025d6b67c7e8d507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af813fe52c71ec5e254f8671570f57bdc"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#af813fe52c71ec5e254f8671570f57bdc">spdk_thread_get_from_ctx</a> (void *ctx)</td></tr>
<tr class="memdesc:af813fe52c71ec5e254f8671570f57bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread object associated with the context handle previously obtained by calling <a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388" title="Return a pointer to this thread&#39;s context. ">spdk_thread_get_ctx()</a>.  <a href="#af813fe52c71ec5e254f8671570f57bdc">More...</a><br /></td></tr>
<tr class="separator:af813fe52c71ec5e254f8671570f57bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e3693e8e9e6c9063ea36414294ae91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91">spdk_thread_poll</a> (struct spdk_thread *thread, uint32_t max_msgs, uint64_t now)</td></tr>
<tr class="memdesc:ad9e3693e8e9e6c9063ea36414294ae91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one iteration worth of processing on the thread.  <a href="#ad9e3693e8e9e6c9063ea36414294ae91">More...</a><br /></td></tr>
<tr class="separator:ad9e3693e8e9e6c9063ea36414294ae91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474fcfc5c14928eda42c684ba2b4cba9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a474fcfc5c14928eda42c684ba2b4cba9">spdk_thread_next_poller_expiration</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a474fcfc5c14928eda42c684ba2b4cba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of ticks until the next timed poller would expire.  <a href="#a474fcfc5c14928eda42c684ba2b4cba9">More...</a><br /></td></tr>
<tr class="separator:a474fcfc5c14928eda42c684ba2b4cba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a143ecbc5ce7edcd57e76cffd74bde5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a5a143ecbc5ce7edcd57e76cffd74bde5">spdk_thread_has_active_pollers</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a5a143ecbc5ce7edcd57e76cffd74bde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there are any active pollers (pollers for which period_microseconds equals 0) registered to be run on the thread.  <a href="#a5a143ecbc5ce7edcd57e76cffd74bde5">More...</a><br /></td></tr>
<tr class="separator:a5a143ecbc5ce7edcd57e76cffd74bde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f877dd192ccdd30572941aa4e453c48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9f877dd192ccdd30572941aa4e453c48">spdk_thread_has_pollers</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:a9f877dd192ccdd30572941aa4e453c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there are any pollers registered to be run on the thread.  <a href="#a9f877dd192ccdd30572941aa4e453c48">More...</a><br /></td></tr>
<tr class="separator:a9f877dd192ccdd30572941aa4e453c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc45e09bda68d13cfc0ae010738cd658"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#adc45e09bda68d13cfc0ae010738cd658">spdk_thread_is_idle</a> (struct spdk_thread *thread)</td></tr>
<tr class="memdesc:adc45e09bda68d13cfc0ae010738cd658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether there are scheduled operations to be run on the thread.  <a href="#adc45e09bda68d13cfc0ae010738cd658">More...</a><br /></td></tr>
<tr class="separator:adc45e09bda68d13cfc0ae010738cd658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d77f05c2461acb75f333e67e6aeb1ed"><td class="memItemLeft" align="right" valign="top"><a id="a1d77f05c2461acb75f333e67e6aeb1ed"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a1d77f05c2461acb75f333e67e6aeb1ed">spdk_thread_get_count</a> (void)</td></tr>
<tr class="memdesc:a1d77f05c2461acb75f333e67e6aeb1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get count of allocated threads. <br /></td></tr>
<tr class="separator:a1d77f05c2461acb75f333e67e6aeb1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34754a98debd5e095bf06889fbaed6aa"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a34754a98debd5e095bf06889fbaed6aa">spdk_get_thread</a> (void)</td></tr>
<tr class="memdesc:a34754a98debd5e095bf06889fbaed6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the current thread.  <a href="#a34754a98debd5e095bf06889fbaed6aa">More...</a><br /></td></tr>
<tr class="separator:a34754a98debd5e095bf06889fbaed6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae367048fa89366e845d72015064e6f76"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae367048fa89366e845d72015064e6f76">spdk_thread_get_name</a> (const struct spdk_thread *thread)</td></tr>
<tr class="memdesc:ae367048fa89366e845d72015064e6f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a thread's name.  <a href="#ae367048fa89366e845d72015064e6f76">More...</a><br /></td></tr>
<tr class="separator:ae367048fa89366e845d72015064e6f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f07dd00b0b4140155713aca312d46b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ab6f07dd00b0b4140155713aca312d46b">spdk_thread_get_stats</a> (struct <a class="el" href="structspdk__thread__stats.html">spdk_thread_stats</a> *stats)</td></tr>
<tr class="memdesc:ab6f07dd00b0b4140155713aca312d46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get statistics about the current thread.  <a href="#ab6f07dd00b0b4140155713aca312d46b">More...</a><br /></td></tr>
<tr class="separator:ab6f07dd00b0b4140155713aca312d46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b662b152c21dad824ad2738d0733ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a07b662b152c21dad824ad2738d0733ec">spdk_thread_send_msg</a> (const struct spdk_thread *thread, <a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn, void *ctx)</td></tr>
<tr class="memdesc:a07b662b152c21dad824ad2738d0733ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the given thread.  <a href="#a07b662b152c21dad824ad2738d0733ec">More...</a><br /></td></tr>
<tr class="separator:a07b662b152c21dad824ad2738d0733ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a7e9d44c2a332dfcea5e23df471c8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a91a7e9d44c2a332dfcea5e23df471c8d">spdk_thread_send_critical_msg</a> (struct spdk_thread *thread, <a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn)</td></tr>
<tr class="memdesc:a91a7e9d44c2a332dfcea5e23df471c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the given thread.  <a href="#a91a7e9d44c2a332dfcea5e23df471c8d">More...</a><br /></td></tr>
<tr class="separator:a91a7e9d44c2a332dfcea5e23df471c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bb098e6398d2a63577e805f1423a3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a16bb098e6398d2a63577e805f1423a3e">spdk_for_each_thread</a> (<a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn, void *ctx, <a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> cpl)</td></tr>
<tr class="memdesc:a16bb098e6398d2a63577e805f1423a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to each thread, serially.  <a href="#a16bb098e6398d2a63577e805f1423a3e">More...</a><br /></td></tr>
<tr class="separator:a16bb098e6398d2a63577e805f1423a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3e883ddce01ae8d93541304d1e9126"><td class="memItemLeft" align="right" valign="top">struct spdk_poller *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6b3e883ddce01ae8d93541304d1e9126">spdk_poller_register</a> (<a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a> fn, void *arg, uint64_t period_microseconds)</td></tr>
<tr class="memdesc:a6b3e883ddce01ae8d93541304d1e9126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a poller on the current thread.  <a href="#a6b3e883ddce01ae8d93541304d1e9126">More...</a><br /></td></tr>
<tr class="separator:a6b3e883ddce01ae8d93541304d1e9126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c26cbd781063f5ee627d6aba2c73fe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9c26cbd781063f5ee627d6aba2c73fe3">spdk_poller_unregister</a> (struct spdk_poller **ppoller)</td></tr>
<tr class="memdesc:a9c26cbd781063f5ee627d6aba2c73fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a poller on the current thread.  <a href="#a9c26cbd781063f5ee627d6aba2c73fe3">More...</a><br /></td></tr>
<tr class="separator:a9c26cbd781063f5ee627d6aba2c73fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0c05dd1c9cb0b31eee89213b89f3c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a0f0c05dd1c9cb0b31eee89213b89f3c3">spdk_poller_pause</a> (struct spdk_poller *poller)</td></tr>
<tr class="memdesc:a0f0c05dd1c9cb0b31eee89213b89f3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause a poller on the current thread.  <a href="#a0f0c05dd1c9cb0b31eee89213b89f3c3">More...</a><br /></td></tr>
<tr class="separator:a0f0c05dd1c9cb0b31eee89213b89f3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3de0ffe9dfc29361b092d467d37017e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ab3de0ffe9dfc29361b092d467d37017e">spdk_poller_resume</a> (struct spdk_poller *poller)</td></tr>
<tr class="memdesc:ab3de0ffe9dfc29361b092d467d37017e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a poller on the current thread.  <a href="#ab3de0ffe9dfc29361b092d467d37017e">More...</a><br /></td></tr>
<tr class="separator:ab3de0ffe9dfc29361b092d467d37017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f5c71056d8c39ff05a6610d55edcf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a75f5c71056d8c39ff05a6610d55edcf5">spdk_io_device_register</a> (void *io_device, <a class="el" href="thread_8h.html#aed1d14292cfee8553d4a1ebb519b210a">spdk_io_channel_create_cb</a> create_cb, <a class="el" href="thread_8h.html#a75aa6a61877f23f79bb75c8fc5e68202">spdk_io_channel_destroy_cb</a> destroy_cb, uint32_t ctx_size, const char *name)</td></tr>
<tr class="memdesc:a75f5c71056d8c39ff05a6610d55edcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the opaque io_device context as an I/O device.  <a href="#a75f5c71056d8c39ff05a6610d55edcf5">More...</a><br /></td></tr>
<tr class="separator:a75f5c71056d8c39ff05a6610d55edcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6c3df3a611c10c176cb87966c622f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4c6c3df3a611c10c176cb87966c622f0">spdk_io_device_unregister</a> (void *io_device, <a class="el" href="thread_8h.html#ae044f4141737c7f2df49cdfb03fd58ca">spdk_io_device_unregister_cb</a> unregister_cb)</td></tr>
<tr class="memdesc:a4c6c3df3a611c10c176cb87966c622f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister the opaque io_device context as an I/O device.  <a href="#a4c6c3df3a611c10c176cb87966c622f0">More...</a><br /></td></tr>
<tr class="separator:a4c6c3df3a611c10c176cb87966c622f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8537c42a7aa203b50578efed509d9ba8"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8">spdk_get_io_channel</a> (void *io_device)</td></tr>
<tr class="memdesc:a8537c42a7aa203b50578efed509d9ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an I/O channel for the specified io_device to be used by the calling thread.  <a href="#a8537c42a7aa203b50578efed509d9ba8">More...</a><br /></td></tr>
<tr class="separator:a8537c42a7aa203b50578efed509d9ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717571a5011db0cdd730498146f25f9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a717571a5011db0cdd730498146f25f9a">spdk_put_io_channel</a> (struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *ch)</td></tr>
<tr class="memdesc:a717571a5011db0cdd730498146f25f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a reference to an I/O channel.  <a href="#a717571a5011db0cdd730498146f25f9a">More...</a><br /></td></tr>
<tr class="separator:a717571a5011db0cdd730498146f25f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf6e22252bc768003c7bbc165fc3c51"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#adbf6e22252bc768003c7bbc165fc3c51">spdk_io_channel_get_ctx</a> (struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *ch)</td></tr>
<tr class="memdesc:adbf6e22252bc768003c7bbc165fc3c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the context buffer associated with an I/O channel.  <a href="#adbf6e22252bc768003c7bbc165fc3c51">More...</a><br /></td></tr>
<tr class="separator:adbf6e22252bc768003c7bbc165fc3c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9608b7b0fd448edec6ea5dd38ad04a57"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9608b7b0fd448edec6ea5dd38ad04a57">spdk_io_channel_from_ctx</a> (void *ctx)</td></tr>
<tr class="memdesc:a9608b7b0fd448edec6ea5dd38ad04a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I/O channel from the context buffer.  <a href="#a9608b7b0fd448edec6ea5dd38ad04a57">More...</a><br /></td></tr>
<tr class="separator:a9608b7b0fd448edec6ea5dd38ad04a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9537d26ac923a7a93cd55ba315b5b"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a8ff9537d26ac923a7a93cd55ba315b5b">spdk_io_channel_get_thread</a> (struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *ch)</td></tr>
<tr class="memdesc:a8ff9537d26ac923a7a93cd55ba315b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thread associated with an I/O channel.  <a href="#a8ff9537d26ac923a7a93cd55ba315b5b">More...</a><br /></td></tr>
<tr class="separator:a8ff9537d26ac923a7a93cd55ba315b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a2ca9bd0497544e852c65fd5263cd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1">spdk_for_each_channel</a> (void *io_device, <a class="el" href="thread_8h.html#a2dd91f3094f8b4cf60f460e3f88bbf0c">spdk_channel_msg</a> fn, void *ctx, <a class="el" href="thread_8h.html#a96f03fe115196f1de03292ed6d86fd46">spdk_channel_for_each_cpl</a> cpl)</td></tr>
<tr class="memdesc:aa7a2ca9bd0497544e852c65fd5263cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call 'fn' on each channel associated with io_device.  <a href="#aa7a2ca9bd0497544e852c65fd5263cd1">More...</a><br /></td></tr>
<tr class="separator:aa7a2ca9bd0497544e852c65fd5263cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939935cee4dac6636f2b7c6db0b2fec1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a939935cee4dac6636f2b7c6db0b2fec1">spdk_io_channel_iter_get_io_device</a> (struct spdk_io_channel_iter *i)</td></tr>
<tr class="memdesc:a939935cee4dac6636f2b7c6db0b2fec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get io_device from the I/O channel iterator.  <a href="#a939935cee4dac6636f2b7c6db0b2fec1">More...</a><br /></td></tr>
<tr class="separator:a939935cee4dac6636f2b7c6db0b2fec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83adef6c3df9568bdea346b8e7dcbaa5"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a83adef6c3df9568bdea346b8e7dcbaa5">spdk_io_channel_iter_get_channel</a> (struct spdk_io_channel_iter *i)</td></tr>
<tr class="memdesc:a83adef6c3df9568bdea346b8e7dcbaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I/O channel from the I/O channel iterator.  <a href="#a83adef6c3df9568bdea346b8e7dcbaa5">More...</a><br /></td></tr>
<tr class="separator:a83adef6c3df9568bdea346b8e7dcbaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3ebaac7b55dddb239c720c80d97dea"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#add3ebaac7b55dddb239c720c80d97dea">spdk_io_channel_iter_get_ctx</a> (struct spdk_io_channel_iter *i)</td></tr>
<tr class="memdesc:add3ebaac7b55dddb239c720c80d97dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get context buffer from the I/O channel iterator.  <a href="#add3ebaac7b55dddb239c720c80d97dea">More...</a><br /></td></tr>
<tr class="separator:add3ebaac7b55dddb239c720c80d97dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e87fc8c0fc870769c068a2752cdc359"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4e87fc8c0fc870769c068a2752cdc359">spdk_for_each_channel_continue</a> (struct spdk_io_channel_iter *i, int status)</td></tr>
<tr class="memdesc:a4e87fc8c0fc870769c068a2752cdc359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to iterate all channels for <a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1" title="Call &#39;fn&#39; on each channel associated with io_device. ">spdk_for_each_channel()</a>.  <a href="#a4e87fc8c0fc870769c068a2752cdc359">More...</a><br /></td></tr>
<tr class="separator:a4e87fc8c0fc870769c068a2752cdc359"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Thread. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a96f03fe115196f1de03292ed6d86fd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f03fe115196f1de03292ed6d86fd46">&#9670;&nbsp;</a></span>spdk_channel_for_each_cpl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_channel_for_each_cpl) (struct spdk_io_channel_iter *i, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1" title="Call &#39;fn&#39; on each channel associated with io_device. ">spdk_for_each_channel()</a> callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator. </td></tr>
    <tr><td class="paramname">status</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2dd91f3094f8b4cf60f460e3f88bbf0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd91f3094f8b4cf60f460e3f88bbf0c">&#9670;&nbsp;</a></span>spdk_channel_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_channel_msg) (struct spdk_io_channel_iter *i)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called on the appropriate thread for each channel associated with io_device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed1d14292cfee8553d4a1ebb519b210a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1d14292cfee8553d4a1ebb519b210a">&#9670;&nbsp;</a></span>spdk_io_channel_create_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_io_channel_create_cb) (void *io_device, void *ctx_buf)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O channel creation callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>I/O device associated with this channel. </td></tr>
    <tr><td class="paramname">ctx_buf</td><td>Context for the I/O device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75aa6a61877f23f79bb75c8fc5e68202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75aa6a61877f23f79bb75c8fc5e68202">&#9670;&nbsp;</a></span>spdk_io_channel_destroy_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_io_channel_destroy_cb) (void *io_device, void *ctx_buf)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O channel destruction callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>I/O device associated with this channel. </td></tr>
    <tr><td class="paramname">ctx_buf</td><td>Context for the I/O device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae044f4141737c7f2df49cdfb03fd58ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae044f4141737c7f2df49cdfb03fd58ca">&#9670;&nbsp;</a></span>spdk_io_device_unregister_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_io_device_unregister_cb) (void *io_device)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O device unregister callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>Unregistered I/O device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc0da6b1b784d4f165dcd48b526d12ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0da6b1b784d4f165dcd48b526d12ad">&#9670;&nbsp;</a></span>spdk_msg_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_msg_fn) (void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that will be called on the target thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context passed as arg to <a class="el" href="thread_8h.html#a4a0e155fc3fa0150aa4a505dd1801e91" title="Function to be called to pass a message to a thread. ">spdk_thread_pass_msg()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afab3d4339c5bca4dfde209816a9e560f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab3d4339c5bca4dfde209816a9e560f">&#9670;&nbsp;</a></span>spdk_new_thread_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_new_thread_fn) (struct spdk_thread *thread)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that is called each time a new thread is created. </p>
<p>The implementor of this function should frequently call <a class="el" href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91" title="Perform one iteration worth of processing on the thread. ">spdk_thread_poll()</a> on the thread provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The new spdk_thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35c421accdc2a0a61bb7be916106293b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c421accdc2a0a61bb7be916106293b">&#9670;&nbsp;</a></span>spdk_poller_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* spdk_poller_fn) (void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function for a poller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context passed as arg to <a class="el" href="thread_8h.html#a6b3e883ddce01ae8d93541304d1e9126" title="Register a poller on the current thread. ">spdk_poller_register()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 to indicate that polling took place but no events were found; positive to indicate that polling took place and some events were processed; negative if the poller does not provide spin-wait information. </dd></dl>

</div>
</div>
<a id="a6f70f5e9b4d498e843f81f1a6ada6370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f70f5e9b4d498e843f81f1a6ada6370">&#9670;&nbsp;</a></span>spdk_start_poller</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct spdk_poller*(* spdk_start_poller) (void *thread_ctx, <a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a> fn, void *arg, uint64_t period_microseconds)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called to start a poller for the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_ctx</td><td>Context for the thread. </td></tr>
    <tr><td class="paramname">fn</td><td>Callback function for a poller. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to callback. </td></tr>
    <tr><td class="paramname">period</td><td>Polling period in microseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the poller on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="adfddbbbb13145f26741106cb8296a05a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfddbbbb13145f26741106cb8296a05a">&#9670;&nbsp;</a></span>spdk_stop_poller</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_stop_poller) (struct spdk_poller *poller, void *thread_ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called to stop a poller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>Poller to stop. </td></tr>
    <tr><td class="paramname">thread_ctx</td><td>Context for the thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a0e155fc3fa0150aa4a505dd1801e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0e155fc3fa0150aa4a505dd1801e91">&#9670;&nbsp;</a></span>spdk_thread_pass_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_thread_pass_msg) (<a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a> fn, void *ctx, void *thread_ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called to pass a message to a thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>Callback function for a thread. </td></tr>
    <tr><td class="paramname">ctx</td><td>Context passed to fn. </td></tr>
    <tr><td class="paramname">thread_ctx</td><td>Context for the thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa7a2ca9bd0497544e852c65fd5263cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a2ca9bd0497544e852c65fd5263cd1">&#9670;&nbsp;</a></span>spdk_for_each_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_for_each_channel </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a2dd91f3094f8b4cf60f460e3f88bbf0c">spdk_channel_msg</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a96f03fe115196f1de03292ed6d86fd46">spdk_channel_for_each_cpl</a>&#160;</td>
          <td class="paramname"><em>cpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call 'fn' on each channel associated with io_device. </p>
<p>This happens asynchronously, so fn may be called after spdk_for_each_channel returns. 'fn' will be called for each channel serially, such that two calls to 'fn' will not overlap in time. After 'fn' has been called, call <a class="el" href="thread_8h.html#a4e87fc8c0fc870769c068a2752cdc359" title="Helper function to iterate all channels for spdk_for_each_channel(). ">spdk_for_each_channel_continue()</a> to continue iterating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>'fn' will be called on each channel associated with this io_device. </td></tr>
    <tr><td class="paramname">fn</td><td>Called on the appropriate thread for each channel associated with io_device. </td></tr>
    <tr><td class="paramname">ctx</td><td>Context buffer registered to spdk_io_channel_iter that can be obatined form the function <a class="el" href="thread_8h.html#add3ebaac7b55dddb239c720c80d97dea" title="Get context buffer from the I/O channel iterator. ">spdk_io_channel_iter_get_ctx()</a>. </td></tr>
    <tr><td class="paramname">cpl</td><td>Called on the thread that spdk_for_each_channel was initially called from when 'fn' has been called on each channel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e87fc8c0fc870769c068a2752cdc359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e87fc8c0fc870769c068a2752cdc359">&#9670;&nbsp;</a></span>spdk_for_each_channel_continue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_for_each_channel_continue </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel_iter *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to iterate all channels for <a class="el" href="thread_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1" title="Call &#39;fn&#39; on each channel associated with io_device. ">spdk_for_each_channel()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator. </td></tr>
    <tr><td class="paramname">status</td><td>Status for the I/O channel iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16bb098e6398d2a63577e805f1423a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bb098e6398d2a63577e805f1423a3e">&#9670;&nbsp;</a></span>spdk_for_each_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_for_each_thread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>&#160;</td>
          <td class="paramname"><em>cpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to each thread, serially. </p>
<p>The message is sent asynchronously - i.e. spdk_for_each_thread will return prior to <code>fn</code> being called on each thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>This is the function that will be called on each thread. </td></tr>
    <tr><td class="paramname">ctx</td><td>This context will be passed to fn when called. </td></tr>
    <tr><td class="paramname">cpl</td><td>This will be called on the originating thread after <code>fn</code> has been called on each thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8537c42a7aa203b50578efed509d9ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8537c42a7aa203b50578efed509d9ba8">&#9670;&nbsp;</a></span>spdk_get_io_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a>* spdk_get_io_channel </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an I/O channel for the specified io_device to be used by the calling thread. </p>
<p>The io_device context pointer specified must have previously been registered using <a class="el" href="thread_8h.html#a75f5c71056d8c39ff05a6610d55edcf5" title="Register the opaque io_device context as an I/O device. ">spdk_io_device_register()</a>. If an existing I/O channel does not exist yet for the given io_device on the calling thread, it will allocate an I/O channel and invoke the create_cb function pointer specified in <a class="el" href="thread_8h.html#a75f5c71056d8c39ff05a6610d55edcf5" title="Register the opaque io_device context as an I/O device. ">spdk_io_device_register()</a>. If an I/O channel already exists for the given io_device on the calling thread, its reference is returned rather than creating a new I/O channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>The pointer to io_device context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the I/O channel for this device on success or NULL on failure. </dd></dl>

</div>
</div>
<a id="a34754a98debd5e095bf06889fbaed6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34754a98debd5e095bf06889fbaed6aa">&#9670;&nbsp;</a></span>spdk_get_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_get_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to the current thread. </p>
<p>This handle may be passed to other threads and used as the target of <a class="el" href="thread_8h.html#a07b662b152c21dad824ad2738d0733ec" title="Send a message to the given thread. ">spdk_thread_send_msg()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a8ff9537d26ac923a7a93cd55ba315b5b" title="Get the thread associated with an I/O channel. ">spdk_io_channel_get_thread()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the current thread on success or NULL on failure. </dd></dl>

</div>
</div>
<a id="a9608b7b0fd448edec6ea5dd38ad04a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9608b7b0fd448edec6ea5dd38ad04a57">&#9670;&nbsp;</a></span>spdk_io_channel_from_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a>* spdk_io_channel_from_ctx </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I/O channel from the context buffer. </p>
<p>This is the inverse of <a class="el" href="thread_8h.html#adbf6e22252bc768003c7bbc165fc3c51" title="Get the context buffer associated with an I/O channel. ">spdk_io_channel_get_ctx()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The pointer to the context buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the I/O channel associated with the context buffer. </dd></dl>

</div>
</div>
<a id="adbf6e22252bc768003c7bbc165fc3c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf6e22252bc768003c7bbc165fc3c51">&#9670;&nbsp;</a></span>spdk_io_channel_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* spdk_io_channel_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the context buffer associated with an I/O channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>I/O channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the context buffer. </dd></dl>

</div>
</div>
<a id="a8ff9537d26ac923a7a93cd55ba315b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff9537d26ac923a7a93cd55ba315b5b">&#9670;&nbsp;</a></span>spdk_io_channel_get_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_io_channel_get_thread </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread associated with an I/O channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>I/O channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the thread associated with the I/O channel </dd></dl>

</div>
</div>
<a id="a83adef6c3df9568bdea346b8e7dcbaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83adef6c3df9568bdea346b8e7dcbaa5">&#9670;&nbsp;</a></span>spdk_io_channel_iter_get_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a>* spdk_io_channel_iter_get_channel </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel_iter *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I/O channel from the I/O channel iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the I/O channel. </dd></dl>

</div>
</div>
<a id="add3ebaac7b55dddb239c720c80d97dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3ebaac7b55dddb239c720c80d97dea">&#9670;&nbsp;</a></span>spdk_io_channel_iter_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_io_channel_iter_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel_iter *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get context buffer from the I/O channel iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the context buffer. </dd></dl>

</div>
</div>
<a id="a939935cee4dac6636f2b7c6db0b2fec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939935cee4dac6636f2b7c6db0b2fec1">&#9670;&nbsp;</a></span>spdk_io_channel_iter_get_io_device()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_io_channel_iter_get_io_device </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel_iter *&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get io_device from the I/O channel iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>I/O channel iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the io_device. </dd></dl>

</div>
</div>
<a id="a75f5c71056d8c39ff05a6610d55edcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f5c71056d8c39ff05a6610d55edcf5">&#9670;&nbsp;</a></span>spdk_io_device_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_io_device_register </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#aed1d14292cfee8553d4a1ebb519b210a">spdk_io_channel_create_cb</a>&#160;</td>
          <td class="paramname"><em>create_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a75aa6a61877f23f79bb75c8fc5e68202">spdk_io_channel_destroy_cb</a>&#160;</td>
          <td class="paramname"><em>destroy_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctx_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the opaque io_device context as an I/O device. </p>
<p>After an I/O device is registered, it can return I/O channels using the <a class="el" href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8" title="Get an I/O channel for the specified io_device to be used by the calling thread. ">spdk_get_io_channel()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>The pointer to io_device context. </td></tr>
    <tr><td class="paramname">create_cb</td><td>Callback function invoked to allocate any resources required for a new I/O channel. </td></tr>
    <tr><td class="paramname">destroy_cb</td><td>Callback function invoked to release the resources for an I/O channel. </td></tr>
    <tr><td class="paramname">ctx_size</td><td>The size of the context buffer allocated to store references to allocated I/O channel resources. </td></tr>
    <tr><td class="paramname">name</td><td>A string name for the device used only for debugging. Optional - may be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c6c3df3a611c10c176cb87966c622f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6c3df3a611c10c176cb87966c622f0">&#9670;&nbsp;</a></span>spdk_io_device_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_io_device_unregister </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#ae044f4141737c7f2df49cdfb03fd58ca">spdk_io_device_unregister_cb</a>&#160;</td>
          <td class="paramname"><em>unregister_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister the opaque io_device context as an I/O device. </p>
<p>The actual unregistration might be deferred until all active I/O channels are destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_device</td><td>The pointer to io_device context. </td></tr>
    <tr><td class="paramname">unregister_cb</td><td>An optional callback function invoked to release any references to this I/O device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f0c05dd1c9cb0b31eee89213b89f3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0c05dd1c9cb0b31eee89213b89f3c3">&#9670;&nbsp;</a></span>spdk_poller_pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_poller_pause </td>
          <td>(</td>
          <td class="paramtype">struct spdk_poller *&#160;</td>
          <td class="paramname"><em>poller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause a poller on the current thread. </p>
<p>The poller is not run until it is resumed with <a class="el" href="thread_8h.html#ab3de0ffe9dfc29361b092d467d37017e" title="Resume a poller on the current thread. ">spdk_poller_resume()</a>. It is perfectly fine to pause an already paused poller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>The poller to pause. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b3e883ddce01ae8d93541304d1e9126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3e883ddce01ae8d93541304d1e9126">&#9670;&nbsp;</a></span>spdk_poller_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_poller* spdk_poller_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a35c421accdc2a0a61bb7be916106293b">spdk_poller_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>period_microseconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a poller on the current thread. </p>
<p>The poller can be unregistered by calling <a class="el" href="thread_8h.html#a9c26cbd781063f5ee627d6aba2c73fe3" title="Unregister a poller on the current thread. ">spdk_poller_unregister()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>This function will be called every <code>period_microseconds</code>. </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to fn. </td></tr>
    <tr><td class="paramname">period_microseconds</td><td>How often to call <code>fn</code>. If 0, call <code>fn</code> as often as possible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the poller registered on the current thread on success or NULL on failure. </dd></dl>

</div>
</div>
<a id="ab3de0ffe9dfc29361b092d467d37017e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3de0ffe9dfc29361b092d467d37017e">&#9670;&nbsp;</a></span>spdk_poller_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_poller_resume </td>
          <td>(</td>
          <td class="paramtype">struct spdk_poller *&#160;</td>
          <td class="paramname"><em>poller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a poller on the current thread. </p>
<p>Resumes a poller paused with <a class="el" href="thread_8h.html#a0f0c05dd1c9cb0b31eee89213b89f3c3" title="Pause a poller on the current thread. ">spdk_poller_pause()</a>. It is perfectly fine to resume an unpaused poller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poller</td><td>The poller to resume. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c26cbd781063f5ee627d6aba2c73fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c26cbd781063f5ee627d6aba2c73fe3">&#9670;&nbsp;</a></span>spdk_poller_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_poller_unregister </td>
          <td>(</td>
          <td class="paramtype">struct spdk_poller **&#160;</td>
          <td class="paramname"><em>ppoller</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a poller on the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppoller</td><td>The poller to unregister. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a717571a5011db0cdd730498146f25f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717571a5011db0cdd730498146f25f9a">&#9670;&nbsp;</a></span>spdk_put_io_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_put_io_channel </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__io__channel.html">spdk_io_channel</a> *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a reference to an I/O channel. </p>
<p>This happens asynchronously.</p>
<p>Actual release will happen on the same thread that called <a class="el" href="thread_8h.html#a8537c42a7aa203b50578efed509d9ba8" title="Get an I/O channel for the specified io_device to be used by the calling thread. ">spdk_get_io_channel()</a> for the specified I/O channel. If this releases the last reference to the I/O channel, The destroy_cb function specified in <a class="el" href="thread_8h.html#a75f5c71056d8c39ff05a6610d55edcf5" title="Register the opaque io_device context as an I/O device. ">spdk_io_device_register()</a> will be invoked to release any associated resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>I/O channel to release a reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60dac2a0fc19b23be6fecb1e5b6f8a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60dac2a0fc19b23be6fecb1e5b6f8a7a">&#9670;&nbsp;</a></span>spdk_set_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_set_thread </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the current system thread to act as if executing the given SPDK thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4eada7bac2a5c7ceaea891d57f8d3e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eada7bac2a5c7ceaea891d57f8d3e21">&#9670;&nbsp;</a></span>spdk_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_thread_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a> *&#160;</td>
          <td class="paramname"><em>cpumask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new SPDK thread object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Human-readable name for the thread; can be retrieved with <a class="el" href="thread_8h.html#ae367048fa89366e845d72015064e6f76" title="Get a thread&#39;s name. ">spdk_thread_get_name()</a>. The string is copied, so the pointed-to data only needs to be valid during the <a class="el" href="thread_8h.html#a4eada7bac2a5c7ceaea891d57f8d3e21" title="Creates a new SPDK thread object. ">spdk_thread_create()</a> call. May be NULL to specify no name. </td></tr>
    <tr><td class="paramname">cpumask</td><td>Optional mask of CPU cores on which to schedule this thread. This is only a suggestion to the scheduler. The value is copied, so cpumask may be released when this function returns. May be NULL if no mask is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the allocated thread on success or NULL on failure.. </dd></dl>

</div>
</div>
<a id="a10aa5a8ec5228fa87db97f7655f8c0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10aa5a8ec5228fa87db97f7655f8c0d6">&#9670;&nbsp;</a></span>spdk_thread_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_thread_destroy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a thread, releasing all of its resources. </p>
<p>May only be called on a thread previously marked as exited.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac42fa5ed7447767885f700875b28a84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42fa5ed7447767885f700875b28a84b">&#9670;&nbsp;</a></span>spdk_thread_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_thread_exit </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the thread as exited, failing all future <a class="el" href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91" title="Perform one iteration worth of processing on the thread. ">spdk_thread_poll()</a> calls. </p>
<p>May only be called within an spdk poller or message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>All I/O channel references associated with the thread must be released using <a class="el" href="thread_8h.html#a717571a5011db0cdd730498146f25f9a" title="Release a reference to an I/O channel. ">spdk_put_io_channel()</a> prior to calling this function. </p>

</div>
</div>
<a id="a9f06d559046d570e025d6b67c7e8d507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f06d559046d570e025d6b67c7e8d507">&#9670;&nbsp;</a></span>spdk_thread_get_cpumask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__cpuset.html">spdk_cpuset</a>* spdk_thread_get_cpumask </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thread's cpumask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to get the cpumask for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cpuset pointer </dd></dl>

</div>
</div>
<a id="a1deb97a85a8240119cf46fa8a0b71388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1deb97a85a8240119cf46fa8a0b71388">&#9670;&nbsp;</a></span>spdk_thread_get_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* spdk_thread_get_ctx </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to this thread's context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread on which to get the context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the per-thread context, or NULL if there is no per-thread context. </dd></dl>

</div>
</div>
<a id="af813fe52c71ec5e254f8671570f57bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af813fe52c71ec5e254f8671570f57bdc">&#9670;&nbsp;</a></span>spdk_thread_get_from_ctx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_thread_get_from_ctx </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the thread object associated with the context handle previously obtained by calling <a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388" title="Return a pointer to this thread&#39;s context. ">spdk_thread_get_ctx()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>A context previously obtained by calling <a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388" title="Return a pointer to this thread&#39;s context. ">spdk_thread_get_ctx()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated thread. </dd></dl>

</div>
</div>
<a id="ae367048fa89366e845d72015064e6f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae367048fa89366e845d72015064e6f76">&#9670;&nbsp;</a></span>spdk_thread_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_thread_get_name </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a thread's name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>Thread to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the thread. </dd></dl>

</div>
</div>
<a id="ab6f07dd00b0b4140155713aca312d46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f07dd00b0b4140155713aca312d46b">&#9670;&nbsp;</a></span>spdk_thread_get_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_get_stats </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__thread__stats.html">spdk_thread_stats</a> *&#160;</td>
          <td class="paramname"><em>stats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get statistics about the current thread. </p>
<p>Copy cumulative thread stats values to the provided thread stats structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stats</td><td>User's thread_stats structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a143ecbc5ce7edcd57e76cffd74bde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a143ecbc5ce7edcd57e76cffd74bde5">&#9670;&nbsp;</a></span>spdk_thread_has_active_pollers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_has_active_pollers </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether there are any active pollers (pollers for which period_microseconds equals 0) registered to be run on the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if there is at least one active poller, 0 otherwise. </dd></dl>

</div>
</div>
<a id="a9f877dd192ccdd30572941aa4e453c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f877dd192ccdd30572941aa4e453c48">&#9670;&nbsp;</a></span>spdk_thread_has_pollers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_thread_has_pollers </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether there are any pollers registered to be run on the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is any active poller, false otherwise. </dd></dl>

</div>
</div>
<a id="adc45e09bda68d13cfc0ae010738cd658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc45e09bda68d13cfc0ae010738cd658">&#9670;&nbsp;</a></span>spdk_thread_is_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_thread_is_idle </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether there are scheduled operations to be run on the thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there are no scheduled operations, false otherwise. </dd></dl>

</div>
</div>
<a id="a96c6e1cadb3b5a83c5723487e3f02c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c6e1cadb3b5a83c5723487e3f02c23">&#9670;&nbsp;</a></span>spdk_thread_lib_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_lib_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#afab3d4339c5bca4dfde209816a9e560f">spdk_new_thread_fn</a>&#160;</td>
          <td class="paramname"><em>new_thread_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ctx_sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the threading library. </p>
<p>Must be called once prior to allocating any threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_thread_fn</td><td>Called each time a new SPDK thread is created. The implementor is expected to frequently call <a class="el" href="thread_8h.html#ad9e3693e8e9e6c9063ea36414294ae91" title="Perform one iteration worth of processing on the thread. ">spdk_thread_poll()</a> on the provided thread. </td></tr>
    <tr><td class="paramname">ctx_sz</td><td>For each thread allocated, an additional region of memory of size ctx_size will also be allocated, for use by the thread scheduler. A pointer to this region may be obtained by calling <a class="el" href="thread_8h.html#a1deb97a85a8240119cf46fa8a0b71388" title="Return a pointer to this thread&#39;s context. ">spdk_thread_get_ctx()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. Negated errno on failure. </dd></dl>

</div>
</div>
<a id="a474fcfc5c14928eda42c684ba2b4cba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474fcfc5c14928eda42c684ba2b4cba9">&#9670;&nbsp;</a></span>spdk_thread_next_poller_expiration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t spdk_thread_next_poller_expiration </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of ticks until the next timed poller would expire. </p>
<p>Timed pollers are pollers for which period_microseconds is greater than 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to check poller expiration times on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of ticks. If no timed pollers, return 0. </dd></dl>

</div>
</div>
<a id="ad9e3693e8e9e6c9063ea36414294ae91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e3693e8e9e6c9063ea36414294ae91">&#9670;&nbsp;</a></span>spdk_thread_poll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_poll </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_msgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform one iteration worth of processing on the thread. </p>
<p>This includes both expired and continuous pollers as well as messages. If the thread has exited, return immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The thread to process </td></tr>
    <tr><td class="paramname">max_msgs</td><td>The maximum number of messages that will be processed. Use 0 to process the default number of messages (8). </td></tr>
    <tr><td class="paramname">now</td><td>The current time, in ticks. Optional. If 0 is passed, this function may call <a class="el" href="env_8h.html#a7d868d272aa0c000f6135966dfadc596" title="Get a monotonic timestamp counter. ">spdk_get_ticks()</a> to get the current time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if work was done. 0 if no work was done. </dd></dl>

</div>
</div>
<a id="a91a7e9d44c2a332dfcea5e23df471c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a7e9d44c2a332dfcea5e23df471c8d">&#9670;&nbsp;</a></span>spdk_thread_send_critical_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_send_critical_msg </td>
          <td>(</td>
          <td class="paramtype">struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to the given thread. </p>
<p>Only one critical message can be outstanding at the same time. It's intended to use this function in any cases that might interrupt the execution of the application, such as signal handlers.</p>
<p>The message will be sent asynchronously - i.e. spdk_thread_send_critical_msg will always return prior to <code>fn</code> being called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The target thread. </td></tr>
    <tr><td class="paramname">fn</td><td>This function will be called on the given thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-EIO if the message could not be sent to the destination thread, due to an already outstanding critical message </dd></dl>

</div>
</div>
<a id="a07b662b152c21dad824ad2738d0733ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b662b152c21dad824ad2738d0733ec">&#9670;&nbsp;</a></span>spdk_thread_send_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_thread_send_msg </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thread_8h.html#adc0da6b1b784d4f165dcd48b526d12ad">spdk_msg_fn</a>&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to the given thread. </p>
<p>The message will be sent asynchronously - i.e. spdk_thread_send_msg will always return prior to <code>fn</code> being called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The target thread. </td></tr>
    <tr><td class="paramname">fn</td><td>This function will be called on the given thread. </td></tr>
    <tr><td class="paramname">ctx</td><td>This context will be passed to fn when called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd>
<dd>
-ENOMEM if the message could not be allocated </dd>
<dd>
-EIO if the message could not be sent to the destination thread </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
