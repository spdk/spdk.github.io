<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.13">
  <title>SPDK: Block Device Layer Programming Guide</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-sm-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://ci.spdk.io/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/roadmap/">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('bdev_pg.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Block Device Layer Programming Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Target Audience</h2>
<p>This programming guide is intended for developers authoring applications that use the SPDK bdev library to access block devices.</p>
<h2>Introduction</h2>
<p>A block device is a storage device that supports reading and writing data in fixed-size blocks. These blocks are usually 512 or 4096 bytes. The devices may be logical constructs in software or correspond to physical devices like NVMe SSDs.</p>
<p>The block device layer consists of a single generic library in <code>lib/bdev</code>, plus a number of optional modules (as separate libraries) that implement various types of block devices. The public header file for the generic library is <a class="el" href="bdev_8h.html" title="Block device abstraction layer. ">bdev.h</a>, which is the entirety of the API needed to interact with any type of block device. This guide will cover how to interact with bdevs using that API. For a guide to implementing a bdev module, see <a class="el" href="bdev_module.html">Writing a Custom Block Device Module</a>.</p>
<p>The bdev layer provides a number of useful features in addition to providing a common abstraction for all block devices:</p>
<ul>
<li>Automatic queueing of I/O requests in response to queue full or out-of-memory conditions</li>
<li>Hot remove support, even while I/O traffic is occurring.</li>
<li>I/O statistics such as bandwidth and latency</li>
<li>Device reset support and I/O timeout tracking</li>
</ul>
<h2>Basic Primitives</h2>
<p>Users of the bdev API interact with a number of basic objects.</p>
<p>struct spdk_bdev, which this guide will refer to as a <em>bdev</em>, represents a generic block device. struct spdk_bdev_desc, heretofore called a <em>descriptor</em>, represents a handle to a given block device. Descriptors are used to establish and track permissions to use the underlying block device, much like a file descriptor on UNIX systems. Requests to the block device are asynchronous and represented by spdk_bdev_io objects. Requests must be submitted on an associated I/O channel. The motivation and design of I/O channels is described in <a class="el" href="concurrency.html">Message Passing and Concurrency</a>.</p>
<p>Bdevs can be layered, such that some bdevs service I/O by routing requests to other bdevs. This can be used to implement caching, RAID, logical volume management, and more. Bdevs that route I/O to other bdevs are often referred to as virtual bdevs, or <em>vbdevs</em> for short.</p>
<h2>Initializing The Library</h2>
<p>The bdev layer depends on the generic message passing infrastructure abstracted by the header file include/io_channel.h. See <a class="el" href="concurrency.html">Message Passing and Concurrency</a> for a full description. Most importantly, calls into the bdev library may only be made from threads that have been allocated with SPDK by calling <a class="el" href="io__channel_8h.html#ae7db1055a27d2ccbd6f0b50a07fa20d0" title="Initializes the calling thread for I/O channel allocation. ">spdk_allocate_thread()</a>.</p>
<p>From an allocated thread, the bdev library may be initialized by calling <a class="el" href="bdev_8h.html#a854eb960c06597051071023a3d70e887" title="Initialize block device modules. ">spdk_bdev_initialize()</a>, which is an asynchronous operation. Until the completion callback is called, no other bdev library functions may be invoked. Similarly, to tear down the bdev library, call spdk_bdev_finish.</p>
<h2>Discovering Block Devices</h2>
<p>All block devices have a simple string name. At any time, a pointer to the device object can be obtained by calling <a class="el" href="bdev_8h.html#a89c759c53d028e3e408d19156f0e1eb1" title="Get block device by the block device name. ">spdk_bdev_get_by_name()</a>, or the entire set of bdevs may be iterated using <a class="el" href="bdev_8h.html#a578b0a9d444ddbb23c8181d9a5ea4f46" title="Get the first registered block device. ">spdk_bdev_first()</a> and <a class="el" href="bdev_8h.html#aa1c0b9cb8dde1177df3442206cf87d2d" title="Get the next registered block device. ">spdk_bdev_next()</a> and their variants.</p>
<p>Some block devices may also be given aliases, which are also string names. Aliases behave like symlinks - they can be used interchangeably with the real name to look up the block device.</p>
<h2>Preparing To Use A Block Device</h2>
<p>In order to send I/O requests to a block device, it must first be opened by calling <a class="el" href="bdev_8h.html#aeacdfd5debd3917d84d18be0277203ff" title="Open a block device for I/O operations. ">spdk_bdev_open()</a>. This will return a descriptor. Multiple users may have a bdev open at the same time, and coordination of reads and writes between users must be handled by some higher level mechanism outside of the bdev layer. Opening a bdev with write permission may fail if a virtual bdev module has <em>claimed</em> the bdev. Virtual bdev modules implement logic like RAID or logical volume management and forward their I/O to lower level bdevs, so they mark these lower level bdevs as claimed to prevent outside users from issuing writes.</p>
<p>When a block device is opened, an optional callback and context can be provided that will be called if the underlying storage servicing the block device is removed. For example, the remove callback will be called on each open descriptor for a bdev backed by a physical NVMe SSD when the NVMe SSD is hot-unplugged. The callback can be thought of as a request to close the open descriptor so other memory may be freed. A bdev cannot be torn down while open descriptors exist, so it is highly recommended that a callback is provided.</p>
<p>When a user is done with a descriptor, they may release it by calling <a class="el" href="bdev_8h.html#aaf5fc830851a2eb0aa34bbb40cf5eac6" title="Close a previously opened block device. ">spdk_bdev_close()</a>.</p>
<p>Descriptors may be passed to and used from multiple threads simultaneously. However, for each thread a separate I/O channel must be obtained by calling <a class="el" href="bdev_8h.html#ab5bb9e746b030d7c4c89cbcf60076c7e" title="Obtain an I/O channel for the block device opened by the specified descriptor. ">spdk_bdev_get_io_channel()</a>. This will allocate the necessary per-thread resources to submit I/O requests to the bdev without taking locks. To release a channel, call <a class="el" href="io__channel_8h.html#a717571a5011db0cdd730498146f25f9a" title="Release a reference to an I/O channel. ">spdk_put_io_channel()</a>. A descriptor cannot be closed until all associated channels have been destroyed.</p>
<h2>Sending I/O</h2>
<p>Once a descriptor and a channel have been obtained, I/O may be sent by calling the various I/O submission functions such as <a class="el" href="bdev_8h.html#a4b500ce84df1d2551f76e635c9dafbd5" title="Submit a read request to the bdev on the given channel. ">spdk_bdev_read()</a>. These calls each take a callback as an argument which will be called some time later with a handle to an spdk_bdev_io object. In response to that completion, the user must call spdk_free_bdev_io() to release the resources. Within this callback, the user may also use the functions <a class="el" href="bdev_8h.html#afe43254747db3cd072dfb596be3bbf2f" title="Get the status of bdev_io as an NVMe status code. ">spdk_bdev_io_get_nvme_status()</a> and <a class="el" href="bdev_8h.html#ac3c213b4317d5077197950253af1ac50" title="Get the status of bdev_io as a SCSI status code. ">spdk_bdev_io_get_scsi_status()</a> to obtain error information in the format of their choosing.</p>
<p>I/O submission is performed by calling functions such as <a class="el" href="bdev_8h.html#a4b500ce84df1d2551f76e635c9dafbd5" title="Submit a read request to the bdev on the given channel. ">spdk_bdev_read()</a> or <a class="el" href="bdev_8h.html#aa740a114ef34d6a2f126d4e3a9dd9e9b" title="Submit a write request to the bdev on the given channel. ">spdk_bdev_write()</a>. These functions take as an argument a pointer to a region of memory or a scatter gather list describing memory that will be transferred to the block device. This memory must be allocated through <a class="el" href="env_8h.html#a0874731c44ac31e4b14d91c6844a87d1" title="Allocate a pinned, physically contiguous memory buffer with the given size and alignment. ">spdk_dma_malloc()</a> or its variants. For a full explanation of why the memory must come from a special allocation pool, see <a class="el" href="memory.html">Memory Management for User Space Drivers</a>. Where possible, data in memory will be <em>directly transferred to the block device</em> using <a href="https://en.wikipedia.org/wiki/Direct_memory_access">Direct Memory Access</a>. That means it is not copied.</p>
<p>All I/O submission functions are asynchronous and non-blocking. They will not block or stall the thread for any reason. However, the I/O submission functions may fail in one of two ways. First, they may fail immediately and return an error code. In that case, the provided callback will not be called. Second, they may fail asynchronously. In that case, the associated spdk_bdev_io will be passed to the callback and it will report error information.</p>
<p>Some I/O request types are optional and may not be supported by a given bdev. To query a bdev for the I/O request types it supports, call <a class="el" href="bdev_8h.html#a7cd5dff692dc162459801d5649fe7655" title="Check whether the block device supports the I/O type. ">spdk_bdev_io_type_supported()</a>.</p>
<h2>Resetting A Block Device</h2>
<p>In order to handle unexpected failure conditions, the bdev library provides a mechanism to perform a device reset by calling <a class="el" href="bdev_8h.html#aca574d3e94be6150343823dd2e7ecf46" title="Submit a reset request to the bdev on the given channel. ">spdk_bdev_reset()</a>. This will pass a message to every other thread for which an I/O channel exists for the bdev, pause it, then forward a reset request to the underlying bdev module and wait for completion. Upon completion, the I/O channels will resume and the reset will complete. The specific behavior inside the bdev module is module-specific. For example, NVMe devices will delete all queue pairs, perform an NVMe reset, then recreate the queue pairs and continue. Most importantly, regardless of device type, <em>all I/O outstanding to the block device will be completed prior to the reset completing.</em> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
</div>
