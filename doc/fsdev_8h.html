<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="generator" content="Doxygen 1.10.0" />
  <title>SPDK: fsdev.h File Reference</title>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  <script type="text/javascript" src="../js/doxyboot.js"></script>
  <script type="text/javascript" src="./navtree.js"></script>
  <link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
<body>
  <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/" aria-label="SPDK">
      <img src="/img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <div class="navbar-nav me-auto">
        <a class="nav-link header-link active" href="../doc/">Documentation</a>
        <a class="nav-link header-link" href="../development/">Development</a>
        <a class="nav-link header-link" href="../community/">Community</a>
        <a class="nav-link header-link" href="../blog/">Blog</a>
      </div>
      <div class="navbar-nav ms-auto me-3">
        <a class="nav-link header-link" href="https://github.com/spdk/spdk">
          <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
      </div>
    </div>
  </nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('fsdev_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">fsdev.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Filesystem device abstraction layer.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__fsdev__opts.html">spdk_fsdev_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">fsdev library options  <a href="structspdk__fsdev__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__fsdev__open__opts.html">spdk_fsdev_open_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">fsdev device options  <a href="structspdk__fsdev__open__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__fsdev__io__opts.html">spdk_fsdev_io_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure with optional fsdev IO parameters The content of this structure must be valid until the IO is completed.  <a href="structspdk__fsdev__io__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__fsdev__file__statfs.html">spdk_fsdev_file_statfs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6de4a0f27f66288492e4835d9341812b" id="r_a6de4a0f27f66288492e4835d9341812b"><td class="memItemLeft" align="right" valign="top"><a id="a6de4a0f27f66288492e4835d9341812b" name="a6de4a0f27f66288492e4835d9341812b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSDEV_SET_ATTR_MODE</b>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="separator:a6de4a0f27f66288492e4835d9341812b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d5d282eb933217b22a09dcd78dc086" id="r_a07d5d282eb933217b22a09dcd78dc086"><td class="memItemLeft" align="right" valign="top"><a id="a07d5d282eb933217b22a09dcd78dc086" name="a07d5d282eb933217b22a09dcd78dc086"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSDEV_SET_ATTR_UID</b>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="separator:a07d5d282eb933217b22a09dcd78dc086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0d62f544b8ef3ebff0b21933005a2e" id="r_abd0d62f544b8ef3ebff0b21933005a2e"><td class="memItemLeft" align="right" valign="top"><a id="abd0d62f544b8ef3ebff0b21933005a2e" name="abd0d62f544b8ef3ebff0b21933005a2e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSDEV_SET_ATTR_GID</b>&#160;&#160;&#160;(1 &lt;&lt; 2)</td></tr>
<tr class="separator:abd0d62f544b8ef3ebff0b21933005a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d628b1ccf0eee6228c75380f6597868" id="r_a9d628b1ccf0eee6228c75380f6597868"><td class="memItemLeft" align="right" valign="top"><a id="a9d628b1ccf0eee6228c75380f6597868" name="a9d628b1ccf0eee6228c75380f6597868"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSDEV_SET_ATTR_SIZE</b>&#160;&#160;&#160;(1 &lt;&lt; 3)</td></tr>
<tr class="separator:a9d628b1ccf0eee6228c75380f6597868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa157bbef52a65846efb688f0e4427afd" id="r_aa157bbef52a65846efb688f0e4427afd"><td class="memItemLeft" align="right" valign="top"><a id="aa157bbef52a65846efb688f0e4427afd" name="aa157bbef52a65846efb688f0e4427afd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSDEV_SET_ATTR_ATIME</b>&#160;&#160;&#160;(1 &lt;&lt; 4)</td></tr>
<tr class="separator:aa157bbef52a65846efb688f0e4427afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df21ce7515539197383913aa1ea1ad1" id="r_a8df21ce7515539197383913aa1ea1ad1"><td class="memItemLeft" align="right" valign="top"><a id="a8df21ce7515539197383913aa1ea1ad1" name="a8df21ce7515539197383913aa1ea1ad1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSDEV_SET_ATTR_MTIME</b>&#160;&#160;&#160;(1 &lt;&lt; 5)</td></tr>
<tr class="separator:a8df21ce7515539197383913aa1ea1ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0852c1bb69e2e99b8b87f989be9a476a" id="r_a0852c1bb69e2e99b8b87f989be9a476a"><td class="memItemLeft" align="right" valign="top"><a id="a0852c1bb69e2e99b8b87f989be9a476a" name="a0852c1bb69e2e99b8b87f989be9a476a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSDEV_SET_ATTR_ATIME_NOW</b>&#160;&#160;&#160;(1 &lt;&lt; 6)</td></tr>
<tr class="separator:a0852c1bb69e2e99b8b87f989be9a476a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cacb2a474a46f368400caec3e170dd8" id="r_a3cacb2a474a46f368400caec3e170dd8"><td class="memItemLeft" align="right" valign="top"><a id="a3cacb2a474a46f368400caec3e170dd8" name="a3cacb2a474a46f368400caec3e170dd8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSDEV_SET_ATTR_MTIME_NOW</b>&#160;&#160;&#160;(1 &lt;&lt; 7)</td></tr>
<tr class="separator:a3cacb2a474a46f368400caec3e170dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ef9fb33f64d98459d3ad83012fe012" id="r_ad1ef9fb33f64d98459d3ad83012fe012"><td class="memItemLeft" align="right" valign="top"><a id="ad1ef9fb33f64d98459d3ad83012fe012" name="ad1ef9fb33f64d98459d3ad83012fe012"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FSDEV_SET_ATTR_CTIME</b>&#160;&#160;&#160;(1 &lt;&lt; 8)</td></tr>
<tr class="separator:ad1ef9fb33f64d98459d3ad83012fe012"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7f17c8dc7e348a41b50aca23d758eecb" id="r_a7f17c8dc7e348a41b50aca23d758eecb"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f17c8dc7e348a41b50aca23d758eecb">spdk_fsdev_event_cb_t</a>) (enum <a class="el" href="#aaa2135c0f733ac3657a8d593f0668574">spdk_fsdev_event_type</a> type, struct <a class="el" href="structspdk__fsdev.html">spdk_fsdev</a> *fsdev, void *event_ctx)</td></tr>
<tr class="memdesc:a7f17c8dc7e348a41b50aca23d758eecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filesystem device event callback.  <br /></td></tr>
<tr class="separator:a7f17c8dc7e348a41b50aca23d758eecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ec9ba3beeca665c63b03fcf5c35474" id="r_a67ec9ba3beeca665c63b03fcf5c35474"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67ec9ba3beeca665c63b03fcf5c35474">spdk_fsdev_init_cb</a>) (void *cb_arg, int rc)</td></tr>
<tr class="memdesc:a67ec9ba3beeca665c63b03fcf5c35474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filesystem device initialization callback.  <br /></td></tr>
<tr class="separator:a67ec9ba3beeca665c63b03fcf5c35474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab100fbd39944f97ce0f8c7bf88591ff5" id="r_ab100fbd39944f97ce0f8c7bf88591ff5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab100fbd39944f97ce0f8c7bf88591ff5">spdk_fsdev_fini_cb</a>) (void *cb_arg)</td></tr>
<tr class="memdesc:ab100fbd39944f97ce0f8c7bf88591ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filesystem device finish callback.  <br /></td></tr>
<tr class="separator:ab100fbd39944f97ce0f8c7bf88591ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbba08fcf598beb5d98340ba28b617c2" id="r_afbba08fcf598beb5d98340ba28b617c2"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbba08fcf598beb5d98340ba28b617c2">spdk_fsdev_lookup_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_object *fobject, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr)</td></tr>
<tr class="memdesc:afbba08fcf598beb5d98340ba28b617c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup file operation completion callback.  <br /></td></tr>
<tr class="separator:afbba08fcf598beb5d98340ba28b617c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3a236dd6a7d31734e92cadadd5f969" id="r_a8f3a236dd6a7d31734e92cadadd5f969"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f3a236dd6a7d31734e92cadadd5f969">spdk_fsdev_forget_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:a8f3a236dd6a7d31734e92cadadd5f969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up file operation completion callback.  <br /></td></tr>
<tr class="separator:a8f3a236dd6a7d31734e92cadadd5f969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0db0a51f3856194393230b9e1112b3" id="r_a2e0db0a51f3856194393230b9e1112b3"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e0db0a51f3856194393230b9e1112b3">spdk_fsdev_readlink_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, const char *linkname)</td></tr>
<tr class="memdesc:a2e0db0a51f3856194393230b9e1112b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read symbolic link operation completion callback.  <br /></td></tr>
<tr class="separator:a2e0db0a51f3856194393230b9e1112b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf65b6f5edbe0f4ecc9e67f4f83d55e" id="r_aebf65b6f5edbe0f4ecc9e67f4f83d55e"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebf65b6f5edbe0f4ecc9e67f4f83d55e">spdk_fsdev_symlink_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_object *fobject, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr)</td></tr>
<tr class="memdesc:aebf65b6f5edbe0f4ecc9e67f4f83d55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbolic link operation completion callback.  <br /></td></tr>
<tr class="separator:aebf65b6f5edbe0f4ecc9e67f4f83d55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc350530e00392a380a912d1199c088d" id="r_adc350530e00392a380a912d1199c088d"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc350530e00392a380a912d1199c088d">spdk_fsdev_mknod_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_object *fobject, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr)</td></tr>
<tr class="memdesc:adc350530e00392a380a912d1199c088d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create file node operation completion callback.  <br /></td></tr>
<tr class="separator:adc350530e00392a380a912d1199c088d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a07bfc8d04a00846b7496bb1dbeeaa" id="r_ac6a07bfc8d04a00846b7496bb1dbeeaa"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6a07bfc8d04a00846b7496bb1dbeeaa">spdk_fsdev_mkdir_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_object *fobject, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr)</td></tr>
<tr class="memdesc:ac6a07bfc8d04a00846b7496bb1dbeeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory operation completion callback.  <br /></td></tr>
<tr class="separator:ac6a07bfc8d04a00846b7496bb1dbeeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437ddf6056312ce3d8db8c2772b77595" id="r_a437ddf6056312ce3d8db8c2772b77595"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a437ddf6056312ce3d8db8c2772b77595">spdk_fsdev_unlink_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:a437ddf6056312ce3d8db8c2772b77595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a file operation completion callback.  <br /></td></tr>
<tr class="separator:a437ddf6056312ce3d8db8c2772b77595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16062da8ec770fa4efdf0e46021d9ca1" id="r_a16062da8ec770fa4efdf0e46021d9ca1"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16062da8ec770fa4efdf0e46021d9ca1">spdk_fsdev_rmdir_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:a16062da8ec770fa4efdf0e46021d9ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a directory operation completion callback.  <br /></td></tr>
<tr class="separator:a16062da8ec770fa4efdf0e46021d9ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09c4f1a0a8118e98bb1561a2992ecb1" id="r_af09c4f1a0a8118e98bb1561a2992ecb1"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af09c4f1a0a8118e98bb1561a2992ecb1">spdk_fsdev_rename_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:af09c4f1a0a8118e98bb1561a2992ecb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a file operation completion callback.  <br /></td></tr>
<tr class="separator:af09c4f1a0a8118e98bb1561a2992ecb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef43a61e382a554a25582a040dd4f34" id="r_a7ef43a61e382a554a25582a040dd4f34"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ef43a61e382a554a25582a040dd4f34">spdk_fsdev_link_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_object *fobject, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr)</td></tr>
<tr class="memdesc:a7ef43a61e382a554a25582a040dd4f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a hard link operation completion callback.  <br /></td></tr>
<tr class="separator:a7ef43a61e382a554a25582a040dd4f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecb3929bb231f19ce2b2d839677cd16" id="r_a2ecb3929bb231f19ce2b2d839677cd16"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ecb3929bb231f19ce2b2d839677cd16">spdk_fsdev_statfs_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, const struct <a class="el" href="structspdk__fsdev__file__statfs.html">spdk_fsdev_file_statfs</a> *statfs)</td></tr>
<tr class="memdesc:a2ecb3929bb231f19ce2b2d839677cd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get file system statistic operation completion callback.  <br /></td></tr>
<tr class="separator:a2ecb3929bb231f19ce2b2d839677cd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6435227d65f41b7e5b91594d9bba4fb0" id="r_a6435227d65f41b7e5b91594d9bba4fb0"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6435227d65f41b7e5b91594d9bba4fb0">spdk_fsdev_setxattr_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:a6435227d65f41b7e5b91594d9bba4fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an extended attribute operation completion callback.  <br /></td></tr>
<tr class="separator:a6435227d65f41b7e5b91594d9bba4fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e6feb766cdd699b6cec8861f36e6a0" id="r_ae3e6feb766cdd699b6cec8861f36e6a0"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3e6feb766cdd699b6cec8861f36e6a0">spdk_fsdev_getxattr_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, size_t value_size)</td></tr>
<tr class="memdesc:ae3e6feb766cdd699b6cec8861f36e6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extended attribute operation completion callback.  <br /></td></tr>
<tr class="separator:ae3e6feb766cdd699b6cec8861f36e6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bc6ff9892aad590e97357ff791c465" id="r_a15bc6ff9892aad590e97357ff791c465"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15bc6ff9892aad590e97357ff791c465">spdk_fsdev_listxattr_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, size_t size, bool size_only)</td></tr>
<tr class="memdesc:a15bc6ff9892aad590e97357ff791c465"><td class="mdescLeft">&#160;</td><td class="mdescRight">List extended attribute names operation completion callback.  <br /></td></tr>
<tr class="separator:a15bc6ff9892aad590e97357ff791c465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505469ea31ee0dd47c5b92b6732d59a2" id="r_a505469ea31ee0dd47c5b92b6732d59a2"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a505469ea31ee0dd47c5b92b6732d59a2">spdk_fsdev_removexattr_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:a505469ea31ee0dd47c5b92b6732d59a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an extended attribute operation completion callback.  <br /></td></tr>
<tr class="separator:a505469ea31ee0dd47c5b92b6732d59a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2e6587b4b405ca41f0f80050698e3e" id="r_a8f2e6587b4b405ca41f0f80050698e3e"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f2e6587b4b405ca41f0f80050698e3e">spdk_fsdev_fopen_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_handle *fhandle)</td></tr>
<tr class="memdesc:a8f2e6587b4b405ca41f0f80050698e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file operation completion callback.  <br /></td></tr>
<tr class="separator:a8f2e6587b4b405ca41f0f80050698e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77bf4c150b8d685c22726eec7b06516" id="r_ae77bf4c150b8d685c22726eec7b06516"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae77bf4c150b8d685c22726eec7b06516">spdk_fsdev_create_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_object *fobject, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr, struct spdk_fsdev_file_handle *fhandle)</td></tr>
<tr class="memdesc:ae77bf4c150b8d685c22726eec7b06516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and open a file operation completion callback.  <br /></td></tr>
<tr class="separator:ae77bf4c150b8d685c22726eec7b06516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5299f1535c59c11d2e2df1c8136d07a" id="r_ab5299f1535c59c11d2e2df1c8136d07a"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5299f1535c59c11d2e2df1c8136d07a">spdk_fsdev_release_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:ab5299f1535c59c11d2e2df1c8136d07a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release an open file operation completion callback.  <br /></td></tr>
<tr class="separator:ab5299f1535c59c11d2e2df1c8136d07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae26d6253c295d4a55add390333be682" id="r_aae26d6253c295d4a55add390333be682"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae26d6253c295d4a55add390333be682">spdk_fsdev_getattr_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr)</td></tr>
<tr class="memdesc:aae26d6253c295d4a55add390333be682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get file attributes operation completion callback.  <br /></td></tr>
<tr class="separator:aae26d6253c295d4a55add390333be682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfd4916266bd5453ba5c80ffe608e21" id="r_a7bfd4916266bd5453ba5c80ffe608e21"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bfd4916266bd5453ba5c80ffe608e21">spdk_fsdev_setattr_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr)</td></tr>
<tr class="memdesc:a7bfd4916266bd5453ba5c80ffe608e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set file attributes operation completion callback.  <br /></td></tr>
<tr class="separator:a7bfd4916266bd5453ba5c80ffe608e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe88dee7a3cd449bb8aca4396eed032c" id="r_afe88dee7a3cd449bb8aca4396eed032c"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe88dee7a3cd449bb8aca4396eed032c">spdk_fsdev_read_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, uint32_t data_size)</td></tr>
<tr class="memdesc:afe88dee7a3cd449bb8aca4396eed032c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data operation completion callback.  <br /></td></tr>
<tr class="separator:afe88dee7a3cd449bb8aca4396eed032c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f367b7c67799b1d2ddd7a2342006bb" id="r_ac8f367b7c67799b1d2ddd7a2342006bb"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8f367b7c67799b1d2ddd7a2342006bb">spdk_fsdev_write_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, uint32_t data_size)</td></tr>
<tr class="memdesc:ac8f367b7c67799b1d2ddd7a2342006bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data operation completion callback.  <br /></td></tr>
<tr class="separator:ac8f367b7c67799b1d2ddd7a2342006bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d8f1a7a5c0569941342cdad445c811" id="r_aa5d8f1a7a5c0569941342cdad445c811"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5d8f1a7a5c0569941342cdad445c811">spdk_fsdev_fsync_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:aa5d8f1a7a5c0569941342cdad445c811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize file contents operation completion callback.  <br /></td></tr>
<tr class="separator:aa5d8f1a7a5c0569941342cdad445c811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d995c33ef1719f79dc39eda69e1fc9" id="r_a42d995c33ef1719f79dc39eda69e1fc9"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42d995c33ef1719f79dc39eda69e1fc9">spdk_fsdev_flush_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:a42d995c33ef1719f79dc39eda69e1fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush operation completion callback.  <br /></td></tr>
<tr class="separator:a42d995c33ef1719f79dc39eda69e1fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71c1a2d51d70ba1034ec232658fa635" id="r_ab71c1a2d51d70ba1034ec232658fa635"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab71c1a2d51d70ba1034ec232658fa635">spdk_fsdev_opendir_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_handle *fhandle)</td></tr>
<tr class="memdesc:ab71c1a2d51d70ba1034ec232658fa635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a directory operation completion callback.  <br /></td></tr>
<tr class="separator:ab71c1a2d51d70ba1034ec232658fa635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa47bc61002d7f310c31bdc80ef435f" id="r_a1aa47bc61002d7f310c31bdc80ef435f"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1aa47bc61002d7f310c31bdc80ef435f">spdk_fsdev_readdir_entry_cb</a>(void *cb_arg, struct spdk_io_channel *ch, const char *name, struct spdk_fsdev_file_object *fobject, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr, off_t offset)</td></tr>
<tr class="memdesc:a1aa47bc61002d7f310c31bdc80ef435f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read directory per-entry callback.  <br /></td></tr>
<tr class="separator:a1aa47bc61002d7f310c31bdc80ef435f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef775cb309379a2065e4e317841bd1a7" id="r_aef775cb309379a2065e4e317841bd1a7"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef775cb309379a2065e4e317841bd1a7">spdk_fsdev_readdir_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:aef775cb309379a2065e4e317841bd1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read directory operation completion callback.  <br /></td></tr>
<tr class="separator:aef775cb309379a2065e4e317841bd1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa240cd5c16eb78164e18ae4e66175623" id="r_aa240cd5c16eb78164e18ae4e66175623"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa240cd5c16eb78164e18ae4e66175623">spdk_fsdev_releasedir_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:aa240cd5c16eb78164e18ae4e66175623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a directory operation completion callback.  <br /></td></tr>
<tr class="separator:aa240cd5c16eb78164e18ae4e66175623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7a14eafb9606811a10ec4498bcc706" id="r_acb7a14eafb9606811a10ec4498bcc706"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb7a14eafb9606811a10ec4498bcc706">spdk_fsdev_fsyncdir_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:acb7a14eafb9606811a10ec4498bcc706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize directory contents operation completion callback.  <br /></td></tr>
<tr class="separator:acb7a14eafb9606811a10ec4498bcc706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c43928d312b741a572656c3a89640e4" id="r_a8c43928d312b741a572656c3a89640e4"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c43928d312b741a572656c3a89640e4">spdk_fsdev_flock_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:a8c43928d312b741a572656c3a89640e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire, modify or release a BSD file lock operation completion callback.  <br /></td></tr>
<tr class="separator:a8c43928d312b741a572656c3a89640e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ec5b2843a7be514ac9d6c693118610" id="r_a87ec5b2843a7be514ac9d6c693118610"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87ec5b2843a7be514ac9d6c693118610">spdk_fsdev_fallocate_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:a87ec5b2843a7be514ac9d6c693118610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate requested space operation completion callback.  <br /></td></tr>
<tr class="separator:a87ec5b2843a7be514ac9d6c693118610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2013cde86098390bbb73e346b96c55" id="r_a9d2013cde86098390bbb73e346b96c55"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d2013cde86098390bbb73e346b96c55">spdk_fsdev_copy_file_range_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status, uint32_t data_size)</td></tr>
<tr class="memdesc:a9d2013cde86098390bbb73e346b96c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a range of data from one file to another operation completion callback.  <br /></td></tr>
<tr class="separator:a9d2013cde86098390bbb73e346b96c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee99e3dbae9e06861dc205156050c2a" id="r_a7ee99e3dbae9e06861dc205156050c2a"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ee99e3dbae9e06861dc205156050c2a">spdk_fsdev_abort_cpl_cb</a>(void *cb_arg, struct spdk_io_channel *ch, int status)</td></tr>
<tr class="memdesc:a7ee99e3dbae9e06861dc205156050c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O operation abortion completion callback.  <br /></td></tr>
<tr class="separator:a7ee99e3dbae9e06861dc205156050c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aaa2135c0f733ac3657a8d593f0668574" id="r_aaa2135c0f733ac3657a8d593f0668574"><td class="memItemLeft" align="right" valign="top"><a id="aaa2135c0f733ac3657a8d593f0668574" name="aaa2135c0f733ac3657a8d593f0668574"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa2135c0f733ac3657a8d593f0668574">spdk_fsdev_event_type</a> { <b>SPDK_FSDEV_EVENT_REMOVE</b>
 }</td></tr>
<tr class="memdesc:aaa2135c0f733ac3657a8d593f0668574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous event type. <br /></td></tr>
<tr class="separator:aaa2135c0f733ac3657a8d593f0668574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dea72d4673ad54ff84893a702f63d0" id="r_a37dea72d4673ad54ff84893a702f63d0"><td class="memItemLeft" align="right" valign="top"><a id="a37dea72d4673ad54ff84893a702f63d0" name="a37dea72d4673ad54ff84893a702f63d0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37dea72d4673ad54ff84893a702f63d0">spdk_fsdev_status</a> { <b>SPDK_FSDEV_STATUS_INVALID</b>
, <b>SPDK_FSDEV_STATUS_READY</b>
, <b>SPDK_FSDEV_STATUS_UNREGISTERING</b>
, <b>SPDK_FSDEV_STATUS_REMOVING</b>
 }</td></tr>
<tr class="memdesc:a37dea72d4673ad54ff84893a702f63d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">fsdev status <br /></td></tr>
<tr class="separator:a37dea72d4673ad54ff84893a702f63d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7547c9310ab8179ffb305fee0f49a191" id="r_a7547c9310ab8179ffb305fee0f49a191"><td class="memItemLeft" align="right" valign="top"><a id="a7547c9310ab8179ffb305fee0f49a191" name="a7547c9310ab8179ffb305fee0f49a191"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__fsdev__opts.html">spdk_fsdev_opts</a>)==12, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a7547c9310ab8179ffb305fee0f49a191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0976296f07dc9e8c2328fc5eb8d0265a" id="r_a0976296f07dc9e8c2328fc5eb8d0265a"><td class="memItemLeft" align="right" valign="top"><a id="a0976296f07dc9e8c2328fc5eb8d0265a" name="a0976296f07dc9e8c2328fc5eb8d0265a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__fsdev__open__opts.html">spdk_fsdev_open_opts</a>)==9, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a0976296f07dc9e8c2328fc5eb8d0265a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad610183967b5153554a57f903291938d" id="r_ad610183967b5153554a57f903291938d"><td class="memItemLeft" align="right" valign="top"><a id="ad610183967b5153554a57f903291938d" name="ad610183967b5153554a57f903291938d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__fsdev__io__opts.html">spdk_fsdev_io_opts</a>)==24, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:ad610183967b5153554a57f903291938d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461c6b7db40fbc5b484aa1cff6e2886b" id="r_a461c6b7db40fbc5b484aa1cff6e2886b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a461c6b7db40fbc5b484aa1cff6e2886b">spdk_fsdev_initialize</a> (<a class="el" href="#a67ec9ba3beeca665c63b03fcf5c35474">spdk_fsdev_init_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a461c6b7db40fbc5b484aa1cff6e2886b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize filesystem device modules.  <br /></td></tr>
<tr class="separator:a461c6b7db40fbc5b484aa1cff6e2886b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c92e93895b45782a302018fbb214a3e" id="r_a7c92e93895b45782a302018fbb214a3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c92e93895b45782a302018fbb214a3e">spdk_fsdev_finish</a> (<a class="el" href="#ab100fbd39944f97ce0f8c7bf88591ff5">spdk_fsdev_fini_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a7c92e93895b45782a302018fbb214a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform cleanup work to remove the registered filesystem device modules.  <br /></td></tr>
<tr class="separator:a7c92e93895b45782a302018fbb214a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f51fbafc195f38628dcef020b6dfe3b" id="r_a3f51fbafc195f38628dcef020b6dfe3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f51fbafc195f38628dcef020b6dfe3b">spdk_fsdev_subsystem_config_json</a> (struct spdk_json_write_ctx *w)</td></tr>
<tr class="memdesc:a3f51fbafc195f38628dcef020b6dfe3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the full configuration options for the registered filesystem device modules and created fsdevs.  <br /></td></tr>
<tr class="separator:a3f51fbafc195f38628dcef020b6dfe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485e0c0cea34f8ca3961036564763fa2" id="r_a485e0c0cea34f8ca3961036564763fa2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a485e0c0cea34f8ca3961036564763fa2">spdk_fsdev_get_module_name</a> (const struct <a class="el" href="structspdk__fsdev.html">spdk_fsdev</a> *fsdev)</td></tr>
<tr class="memdesc:a485e0c0cea34f8ca3961036564763fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get filesystem device module name.  <br /></td></tr>
<tr class="separator:a485e0c0cea34f8ca3961036564763fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b937aa4d9f9cd617fa715b68f10f63" id="r_a70b937aa4d9f9cd617fa715b68f10f63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70b937aa4d9f9cd617fa715b68f10f63">spdk_fsdev_open</a> (const char *fsdev_name, <a class="el" href="#a7f17c8dc7e348a41b50aca23d758eecb">spdk_fsdev_event_cb_t</a> event_cb, void *event_ctx, struct <a class="el" href="structspdk__fsdev__open__opts.html">spdk_fsdev_open_opts</a> *opts, struct spdk_fsdev_desc **desc)</td></tr>
<tr class="memdesc:a70b937aa4d9f9cd617fa715b68f10f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a filesystem device for I/O operations.  <br /></td></tr>
<tr class="separator:a70b937aa4d9f9cd617fa715b68f10f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712e671bc4fd1d13a7e5d4acc87c8ecb" id="r_a712e671bc4fd1d13a7e5d4acc87c8ecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a712e671bc4fd1d13a7e5d4acc87c8ecb">spdk_fsdev_close</a> (struct spdk_fsdev_desc *desc)</td></tr>
<tr class="memdesc:a712e671bc4fd1d13a7e5d4acc87c8ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a previously opened filesystem device.  <br /></td></tr>
<tr class="separator:a712e671bc4fd1d13a7e5d4acc87c8ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569b39eca2ea19aeb1dc4cb80f4ed701" id="r_a569b39eca2ea19aeb1dc4cb80f4ed701"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a569b39eca2ea19aeb1dc4cb80f4ed701">spdk_fsdev_get_name</a> (const struct <a class="el" href="structspdk__fsdev.html">spdk_fsdev</a> *fsdev)</td></tr>
<tr class="memdesc:a569b39eca2ea19aeb1dc4cb80f4ed701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get filesystem device name.  <br /></td></tr>
<tr class="separator:a569b39eca2ea19aeb1dc4cb80f4ed701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac830f6b4fc1f87eea1bcbb6e692534fe" id="r_ac830f6b4fc1f87eea1bcbb6e692534fe"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__fsdev.html">spdk_fsdev</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac830f6b4fc1f87eea1bcbb6e692534fe">spdk_fsdev_desc_get_fsdev</a> (struct spdk_fsdev_desc *desc)</td></tr>
<tr class="memdesc:ac830f6b4fc1f87eea1bcbb6e692534fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the fsdev associated with a fsdev descriptor.  <br /></td></tr>
<tr class="separator:ac830f6b4fc1f87eea1bcbb6e692534fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5efcb1e492d8d707cbca77ebd3f41b" id="r_a2d5efcb1e492d8d707cbca77ebd3f41b"><td class="memItemLeft" align="right" valign="top">struct spdk_io_channel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d5efcb1e492d8d707cbca77ebd3f41b">spdk_fsdev_get_io_channel</a> (struct spdk_fsdev_desc *desc)</td></tr>
<tr class="memdesc:a2d5efcb1e492d8d707cbca77ebd3f41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain an I/O channel for the filesystem device opened by the specified descriptor.  <br /></td></tr>
<tr class="separator:a2d5efcb1e492d8d707cbca77ebd3f41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fe72a67ff7e25f606fc530b27b70d8" id="r_af5fe72a67ff7e25f606fc530b27b70d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5fe72a67ff7e25f606fc530b27b70d8">spdk_fsdev_set_opts</a> (const struct <a class="el" href="structspdk__fsdev__opts.html">spdk_fsdev_opts</a> *opts)</td></tr>
<tr class="memdesc:af5fe72a67ff7e25f606fc530b27b70d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the options for the fsdev library.  <br /></td></tr>
<tr class="separator:af5fe72a67ff7e25f606fc530b27b70d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b092800101af1d310d48a7eb11c8965" id="r_a6b092800101af1d310d48a7eb11c8965"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b092800101af1d310d48a7eb11c8965">spdk_fsdev_get_opts</a> (struct <a class="el" href="structspdk__fsdev__opts.html">spdk_fsdev_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:a6b092800101af1d310d48a7eb11c8965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the options for the fsdev library.  <br /></td></tr>
<tr class="separator:a6b092800101af1d310d48a7eb11c8965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c8d01fc94e53cc4c63761af4bece45" id="r_a42c8d01fc94e53cc4c63761af4bece45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c8d01fc94e53cc4c63761af4bece45">spdk_fsdev_get_memory_domains</a> (struct <a class="el" href="structspdk__fsdev.html">spdk_fsdev</a> *fsdev, struct spdk_memory_domain **domains, int array_size)</td></tr>
<tr class="memdesc:a42c8d01fc94e53cc4c63761af4bece45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SPDK memory domains used by the given fsdev.  <br /></td></tr>
<tr class="separator:a42c8d01fc94e53cc4c63761af4bece45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f54649c163ca6ea4f70a4ef870fdce" id="r_ac2f54649c163ca6ea4f70a4ef870fdce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2f54649c163ca6ea4f70a4ef870fdce">spdk_fsdev_lookup</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *parent_fobject, const char *name, <a class="el" href="#afbba08fcf598beb5d98340ba28b617c2">spdk_fsdev_lookup_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ac2f54649c163ca6ea4f70a4ef870fdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a directory entry by name and get its attributes.  <br /></td></tr>
<tr class="separator:ac2f54649c163ca6ea4f70a4ef870fdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5c2f4c08d60c3a8dd80c731b3519fc" id="r_a8b5c2f4c08d60c3a8dd80c731b3519fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b5c2f4c08d60c3a8dd80c731b3519fc">spdk_fsdev_forget</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, uint64_t nlookup, <a class="el" href="#a8f3a236dd6a7d31734e92cadadd5f969">spdk_fsdev_forget_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a8b5c2f4c08d60c3a8dd80c731b3519fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove file object from internal cache.  <br /></td></tr>
<tr class="separator:a8b5c2f4c08d60c3a8dd80c731b3519fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06950b3ad069d4fd0c0fcfb84438ee3c" id="r_a06950b3ad069d4fd0c0fcfb84438ee3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06950b3ad069d4fd0c0fcfb84438ee3c">spdk_fsdev_readlink</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, <a class="el" href="#a2e0db0a51f3856194393230b9e1112b3">spdk_fsdev_readlink_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a06950b3ad069d4fd0c0fcfb84438ee3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read symbolic link.  <br /></td></tr>
<tr class="separator:a06950b3ad069d4fd0c0fcfb84438ee3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3920d9f40ce3ab669b3a51fede001a28" id="r_a3920d9f40ce3ab669b3a51fede001a28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3920d9f40ce3ab669b3a51fede001a28">spdk_fsdev_symlink</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *parent_fobject, const char *target, const char *linkpath, uid_t euid, gid_t egid, <a class="el" href="#aebf65b6f5edbe0f4ecc9e67f4f83d55e">spdk_fsdev_symlink_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a3920d9f40ce3ab669b3a51fede001a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbolic link.  <br /></td></tr>
<tr class="separator:a3920d9f40ce3ab669b3a51fede001a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc09b676f62ff9388cf00b9516f43479" id="r_abc09b676f62ff9388cf00b9516f43479"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc09b676f62ff9388cf00b9516f43479">spdk_fsdev_mknod</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *parent_fobject, const char *name, mode_t mode, dev_t rdev, uid_t euid, gid_t egid, <a class="el" href="#adc350530e00392a380a912d1199c088d">spdk_fsdev_mknod_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:abc09b676f62ff9388cf00b9516f43479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create file node.  <br /></td></tr>
<tr class="separator:abc09b676f62ff9388cf00b9516f43479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcae8afd51d4274fb113dd21e0e41d7c" id="r_abcae8afd51d4274fb113dd21e0e41d7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcae8afd51d4274fb113dd21e0e41d7c">spdk_fsdev_mkdir</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *parent_fobject, const char *name, mode_t mode, uid_t euid, gid_t egid, <a class="el" href="#ac6a07bfc8d04a00846b7496bb1dbeeaa">spdk_fsdev_mkdir_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:abcae8afd51d4274fb113dd21e0e41d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory.  <br /></td></tr>
<tr class="separator:abcae8afd51d4274fb113dd21e0e41d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870e94773227fd79e069b3011b61a0af" id="r_a870e94773227fd79e069b3011b61a0af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a870e94773227fd79e069b3011b61a0af">spdk_fsdev_unlink</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *parent_fobject, const char *name, <a class="el" href="#a437ddf6056312ce3d8db8c2772b77595">spdk_fsdev_unlink_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a870e94773227fd79e069b3011b61a0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a file.  <br /></td></tr>
<tr class="separator:a870e94773227fd79e069b3011b61a0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb84d99338e586d017fa5c88e162287d" id="r_aeb84d99338e586d017fa5c88e162287d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb84d99338e586d017fa5c88e162287d">spdk_fsdev_rmdir</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *parent_fobject, const char *name, <a class="el" href="#a16062da8ec770fa4efdf0e46021d9ca1">spdk_fsdev_rmdir_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aeb84d99338e586d017fa5c88e162287d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a directory.  <br /></td></tr>
<tr class="separator:aeb84d99338e586d017fa5c88e162287d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ddce0d15cbcd874e841208cd18597d" id="r_a64ddce0d15cbcd874e841208cd18597d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64ddce0d15cbcd874e841208cd18597d">spdk_fsdev_rename</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *parent_fobject, const char *name, struct spdk_fsdev_file_object *new_parent_fobject, const char *new_name, uint32_t flags, <a class="el" href="#af09c4f1a0a8118e98bb1561a2992ecb1">spdk_fsdev_rename_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a64ddce0d15cbcd874e841208cd18597d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a file.  <br /></td></tr>
<tr class="separator:a64ddce0d15cbcd874e841208cd18597d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381e101cc24fe8084bc8436a04ffb268" id="r_a381e101cc24fe8084bc8436a04ffb268"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a381e101cc24fe8084bc8436a04ffb268">spdk_fsdev_link</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, struct spdk_fsdev_file_object *new_parent_fobject, const char *name, <a class="el" href="#a7ef43a61e382a554a25582a040dd4f34">spdk_fsdev_link_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a381e101cc24fe8084bc8436a04ffb268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a hard link.  <br /></td></tr>
<tr class="separator:a381e101cc24fe8084bc8436a04ffb268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dd0d6871a5a114bbb9383fb537a5a4" id="r_a59dd0d6871a5a114bbb9383fb537a5a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59dd0d6871a5a114bbb9383fb537a5a4">spdk_fsdev_statfs</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, <a class="el" href="#a2ecb3929bb231f19ce2b2d839677cd16">spdk_fsdev_statfs_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a59dd0d6871a5a114bbb9383fb537a5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get file system statistics.  <br /></td></tr>
<tr class="separator:a59dd0d6871a5a114bbb9383fb537a5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6f207ced0ceb7a923b941b12568285" id="r_a4e6f207ced0ceb7a923b941b12568285"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e6f207ced0ceb7a923b941b12568285">spdk_fsdev_setxattr</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, const char *name, const char *value, size_t size, uint32_t flags, <a class="el" href="#a6435227d65f41b7e5b91594d9bba4fb0">spdk_fsdev_setxattr_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a4e6f207ced0ceb7a923b941b12568285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an extended attribute.  <br /></td></tr>
<tr class="separator:a4e6f207ced0ceb7a923b941b12568285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c66e6f781d2ded027588affb82e756" id="r_ac2c66e6f781d2ded027588affb82e756"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2c66e6f781d2ded027588affb82e756">spdk_fsdev_getxattr</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, const char *name, void *buffer, size_t size, <a class="el" href="#ae3e6feb766cdd699b6cec8861f36e6a0">spdk_fsdev_getxattr_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ac2c66e6f781d2ded027588affb82e756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an extended attribute.  <br /></td></tr>
<tr class="separator:ac2c66e6f781d2ded027588affb82e756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faa40867d34572801b8d295f4cf7b4f" id="r_a4faa40867d34572801b8d295f4cf7b4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4faa40867d34572801b8d295f4cf7b4f">spdk_fsdev_listxattr</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, char *buffer, size_t size, <a class="el" href="#a15bc6ff9892aad590e97357ff791c465">spdk_fsdev_listxattr_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a4faa40867d34572801b8d295f4cf7b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">List extended attribute names.  <br /></td></tr>
<tr class="separator:a4faa40867d34572801b8d295f4cf7b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6379024e43a1335afe9ebadd5542ea5e" id="r_a6379024e43a1335afe9ebadd5542ea5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6379024e43a1335afe9ebadd5542ea5e">spdk_fsdev_removexattr</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, const char *name, <a class="el" href="#a505469ea31ee0dd47c5b92b6732d59a2">spdk_fsdev_removexattr_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a6379024e43a1335afe9ebadd5542ea5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an extended attribute.  <br /></td></tr>
<tr class="separator:a6379024e43a1335afe9ebadd5542ea5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eee91f3e261692a35bbbf52365a00c4" id="r_a6eee91f3e261692a35bbbf52365a00c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eee91f3e261692a35bbbf52365a00c4">spdk_fsdev_fopen</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, uint32_t flags, <a class="el" href="#a8f2e6587b4b405ca41f0f80050698e3e">spdk_fsdev_fopen_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a6eee91f3e261692a35bbbf52365a00c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file.  <br /></td></tr>
<tr class="separator:a6eee91f3e261692a35bbbf52365a00c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3564c2f6559cdebcb8b1c17e08584d05" id="r_a3564c2f6559cdebcb8b1c17e08584d05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3564c2f6559cdebcb8b1c17e08584d05">spdk_fsdev_create</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *parent_fobject, const char *name, mode_t mode, uint32_t flags, mode_t umask, uid_t euid, gid_t egid, <a class="el" href="#ae77bf4c150b8d685c22726eec7b06516">spdk_fsdev_create_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a3564c2f6559cdebcb8b1c17e08584d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and open a file.  <br /></td></tr>
<tr class="separator:a3564c2f6559cdebcb8b1c17e08584d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd94dedbe5998473878788857e198e8" id="r_a3dd94dedbe5998473878788857e198e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dd94dedbe5998473878788857e198e8">spdk_fsdev_release</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, struct spdk_fsdev_file_handle *fhandle, <a class="el" href="#ab5299f1535c59c11d2e2df1c8136d07a">spdk_fsdev_release_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a3dd94dedbe5998473878788857e198e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release an open file.  <br /></td></tr>
<tr class="separator:a3dd94dedbe5998473878788857e198e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7e9ece453f910a189550787cd37ee1" id="r_a6a7e9ece453f910a189550787cd37ee1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a7e9ece453f910a189550787cd37ee1">spdk_fsdev_getattr</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, struct spdk_fsdev_file_handle *fhandle, <a class="el" href="#aae26d6253c295d4a55add390333be682">spdk_fsdev_getattr_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a6a7e9ece453f910a189550787cd37ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get file attributes.  <br /></td></tr>
<tr class="separator:a6a7e9ece453f910a189550787cd37ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fb19e2a443ce35ad48753ea905dbed" id="r_a78fb19e2a443ce35ad48753ea905dbed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78fb19e2a443ce35ad48753ea905dbed">spdk_fsdev_setattr</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, struct spdk_fsdev_file_handle *fhandle, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr, uint32_t to_set, <a class="el" href="#a7bfd4916266bd5453ba5c80ffe608e21">spdk_fsdev_setattr_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a78fb19e2a443ce35ad48753ea905dbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set file attributes.  <br /></td></tr>
<tr class="separator:a78fb19e2a443ce35ad48753ea905dbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b90c2bb0862efbcf6105b220414bc4" id="r_a26b90c2bb0862efbcf6105b220414bc4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26b90c2bb0862efbcf6105b220414bc4">spdk_fsdev_read</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, struct spdk_fsdev_file_handle *fhandle, size_t size, uint64_t offs, uint32_t flags, struct iovec *iov, uint32_t iovcnt, struct <a class="el" href="structspdk__fsdev__io__opts.html">spdk_fsdev_io_opts</a> *opts, <a class="el" href="#afe88dee7a3cd449bb8aca4396eed032c">spdk_fsdev_read_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a26b90c2bb0862efbcf6105b220414bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data.  <br /></td></tr>
<tr class="separator:a26b90c2bb0862efbcf6105b220414bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da55f1fb613157da8341d94f806dca7" id="r_a0da55f1fb613157da8341d94f806dca7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0da55f1fb613157da8341d94f806dca7">spdk_fsdev_write</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, struct spdk_fsdev_file_handle *fhandle, size_t size, uint64_t offs, uint64_t flags, const struct iovec *iov, uint32_t iovcnt, struct <a class="el" href="structspdk__fsdev__io__opts.html">spdk_fsdev_io_opts</a> *opts, <a class="el" href="#ac8f367b7c67799b1d2ddd7a2342006bb">spdk_fsdev_write_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a0da55f1fb613157da8341d94f806dca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data.  <br /></td></tr>
<tr class="separator:a0da55f1fb613157da8341d94f806dca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cf3a7ecbcf5bfe5ecda2c8bb904ddd" id="r_a41cf3a7ecbcf5bfe5ecda2c8bb904ddd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41cf3a7ecbcf5bfe5ecda2c8bb904ddd">spdk_fsdev_fsync</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, struct spdk_fsdev_file_handle *fhandle, bool datasync, <a class="el" href="#aa5d8f1a7a5c0569941342cdad445c811">spdk_fsdev_fsync_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a41cf3a7ecbcf5bfe5ecda2c8bb904ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize file contents.  <br /></td></tr>
<tr class="separator:a41cf3a7ecbcf5bfe5ecda2c8bb904ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce72dea1f37667b1bbba02c414c3290" id="r_afce72dea1f37667b1bbba02c414c3290"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afce72dea1f37667b1bbba02c414c3290">spdk_fsdev_flush</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, struct spdk_fsdev_file_handle *fhandle, <a class="el" href="#a42d995c33ef1719f79dc39eda69e1fc9">spdk_fsdev_flush_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:afce72dea1f37667b1bbba02c414c3290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush.  <br /></td></tr>
<tr class="separator:afce72dea1f37667b1bbba02c414c3290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da97eca8509134bc35673ec720d8704" id="r_a9da97eca8509134bc35673ec720d8704"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9da97eca8509134bc35673ec720d8704">spdk_fsdev_opendir</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, uint32_t flags, <a class="el" href="#ab71c1a2d51d70ba1034ec232658fa635">spdk_fsdev_opendir_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a9da97eca8509134bc35673ec720d8704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a directory.  <br /></td></tr>
<tr class="separator:a9da97eca8509134bc35673ec720d8704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dbcbb61f2f5c7c172363bea7a07726" id="r_a82dbcbb61f2f5c7c172363bea7a07726"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82dbcbb61f2f5c7c172363bea7a07726">spdk_fsdev_readdir</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, struct spdk_fsdev_file_handle *fhandle, uint64_t offset, <a class="el" href="#a1aa47bc61002d7f310c31bdc80ef435f">spdk_fsdev_readdir_entry_cb</a> entry_cb_fn, <a class="el" href="#aef775cb309379a2065e4e317841bd1a7">spdk_fsdev_readdir_cpl_cb</a> cpl_cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a82dbcbb61f2f5c7c172363bea7a07726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read directory.  <br /></td></tr>
<tr class="separator:a82dbcbb61f2f5c7c172363bea7a07726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2604b7c0ad1de65d94b393b0be3949" id="r_a6e2604b7c0ad1de65d94b393b0be3949"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e2604b7c0ad1de65d94b393b0be3949">spdk_fsdev_releasedir</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, struct spdk_fsdev_file_handle *fhandle, <a class="el" href="#aa240cd5c16eb78164e18ae4e66175623">spdk_fsdev_releasedir_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a6e2604b7c0ad1de65d94b393b0be3949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a directory.  <br /></td></tr>
<tr class="separator:a6e2604b7c0ad1de65d94b393b0be3949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7378a08029cfee87b3675c3daa7536e" id="r_ac7378a08029cfee87b3675c3daa7536e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7378a08029cfee87b3675c3daa7536e">spdk_fsdev_fsyncdir</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, struct spdk_fsdev_file_handle *fhandle, bool datasync, <a class="el" href="#acb7a14eafb9606811a10ec4498bcc706">spdk_fsdev_fsyncdir_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ac7378a08029cfee87b3675c3daa7536e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize directory contents.  <br /></td></tr>
<tr class="separator:ac7378a08029cfee87b3675c3daa7536e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ffc97a4a90e2176116fe9ec092b7c5" id="r_a16ffc97a4a90e2176116fe9ec092b7c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16ffc97a4a90e2176116fe9ec092b7c5">spdk_fsdev_flock</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, struct spdk_fsdev_file_handle *fhandle, int operation, <a class="el" href="#a8c43928d312b741a572656c3a89640e4">spdk_fsdev_flock_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a16ffc97a4a90e2176116fe9ec092b7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire, modify or release a BSD file lock.  <br /></td></tr>
<tr class="separator:a16ffc97a4a90e2176116fe9ec092b7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f56dc50121d78c1e74f838612c09f4" id="r_ab9f56dc50121d78c1e74f838612c09f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9f56dc50121d78c1e74f838612c09f4">spdk_fsdev_fallocate</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject, struct spdk_fsdev_file_handle *fhandle, int mode, off_t offset, off_t length, <a class="el" href="#a87ec5b2843a7be514ac9d6c693118610">spdk_fsdev_fallocate_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:ab9f56dc50121d78c1e74f838612c09f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate requested space.  <br /></td></tr>
<tr class="separator:ab9f56dc50121d78c1e74f838612c09f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd38b4d0e724e8038905c0d568f3f30" id="r_a3cd38b4d0e724e8038905c0d568f3f30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cd38b4d0e724e8038905c0d568f3f30">spdk_fsdev_copy_file_range</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique, struct spdk_fsdev_file_object *fobject_in, struct spdk_fsdev_file_handle *fhandle_in, off_t off_in, struct spdk_fsdev_file_object *fobject_out, struct spdk_fsdev_file_handle *fhandle_out, off_t off_out, size_t len, uint32_t flags, <a class="el" href="#a9d2013cde86098390bbb73e346b96c55">spdk_fsdev_copy_file_range_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a3cd38b4d0e724e8038905c0d568f3f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a range of data from one file to another.  <br /></td></tr>
<tr class="separator:a3cd38b4d0e724e8038905c0d568f3f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0658ad22120fbf51f4f0cf72a1f90386" id="r_a0658ad22120fbf51f4f0cf72a1f90386"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0658ad22120fbf51f4f0cf72a1f90386">spdk_fsdev_abort</a> (struct spdk_fsdev_desc *desc, struct spdk_io_channel *ch, uint64_t unique_to_abort, <a class="el" href="#a7ee99e3dbae9e06861dc205156050c2a">spdk_fsdev_abort_cpl_cb</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a0658ad22120fbf51f4f0cf72a1f90386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort an I/O.  <br /></td></tr>
<tr class="separator:a0658ad22120fbf51f4f0cf72a1f90386"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Filesystem device abstraction layer. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a7ee99e3dbae9e06861dc205156050c2a" name="a7ee99e3dbae9e06861dc205156050c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee99e3dbae9e06861dc205156050c2a">&#9670;&#160;</a></span>spdk_fsdev_abort_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_abort_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O operation abortion completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d2013cde86098390bbb73e346b96c55" name="a9d2013cde86098390bbb73e346b96c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2013cde86098390bbb73e346b96c55">&#9670;&#160;</a></span>spdk_fsdev_copy_file_range_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_copy_file_range_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, uint32_t data_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a range of data from one file to another operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
    <tr><td class="paramname">data_size</td><td>Number of bytes written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae77bf4c150b8d685c22726eec7b06516" name="ae77bf4c150b8d685c22726eec7b06516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77bf4c150b8d685c22726eec7b06516">&#9670;&#160;</a></span>spdk_fsdev_create_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_create_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_object *fobject, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr, struct spdk_fsdev_file_handle *fhandle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and open a file operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">attr</td><td>File attributes. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f17c8dc7e348a41b50aca23d758eecb" name="a7f17c8dc7e348a41b50aca23d758eecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f17c8dc7e348a41b50aca23d758eecb">&#9670;&#160;</a></span>spdk_fsdev_event_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_fsdev_event_cb_t) (enum <a class="el" href="#aaa2135c0f733ac3657a8d593f0668574">spdk_fsdev_event_type</a> type, struct <a class="el" href="structspdk__fsdev.html">spdk_fsdev</a> *fsdev, void *event_ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filesystem device event callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Event type. </td></tr>
    <tr><td class="paramname">fsdev</td><td>Filesystem device that triggered event. </td></tr>
    <tr><td class="paramname">event_ctx</td><td>Context for the filesystem device event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87ec5b2843a7be514ac9d6c693118610" name="a87ec5b2843a7be514ac9d6c693118610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ec5b2843a7be514ac9d6c693118610">&#9670;&#160;</a></span>spdk_fsdev_fallocate_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_fallocate_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate requested space operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab100fbd39944f97ce0f8c7bf88591ff5" name="ab100fbd39944f97ce0f8c7bf88591ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab100fbd39944f97ce0f8c7bf88591ff5">&#9670;&#160;</a></span>spdk_fsdev_fini_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_fsdev_fini_cb) (void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filesystem device finish callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c43928d312b741a572656c3a89640e4" name="a8c43928d312b741a572656c3a89640e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c43928d312b741a572656c3a89640e4">&#9670;&#160;</a></span>spdk_fsdev_flock_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_flock_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire, modify or release a BSD file lock operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42d995c33ef1719f79dc39eda69e1fc9" name="a42d995c33ef1719f79dc39eda69e1fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d995c33ef1719f79dc39eda69e1fc9">&#9670;&#160;</a></span>spdk_fsdev_flush_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_flush_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f2e6587b4b405ca41f0f80050698e3e" name="a8f2e6587b4b405ca41f0f80050698e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2e6587b4b405ca41f0f80050698e3e">&#9670;&#160;</a></span>spdk_fsdev_fopen_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_fopen_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_handle *fhandle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. Following parameters should be ignored if status != 0. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f3a236dd6a7d31734e92cadadd5f969" name="a8f3a236dd6a7d31734e92cadadd5f969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3a236dd6a7d31734e92cadadd5f969">&#9670;&#160;</a></span>spdk_fsdev_forget_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_forget_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up file operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>Operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5d8f1a7a5c0569941342cdad445c811" name="aa5d8f1a7a5c0569941342cdad445c811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d8f1a7a5c0569941342cdad445c811">&#9670;&#160;</a></span>spdk_fsdev_fsync_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_fsync_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize file contents operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb7a14eafb9606811a10ec4498bcc706" name="acb7a14eafb9606811a10ec4498bcc706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7a14eafb9606811a10ec4498bcc706">&#9670;&#160;</a></span>spdk_fsdev_fsyncdir_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_fsyncdir_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize directory contents operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae26d6253c295d4a55add390333be682" name="aae26d6253c295d4a55add390333be682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae26d6253c295d4a55add390333be682">&#9670;&#160;</a></span>spdk_fsdev_getattr_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_getattr_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get file attributes operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>Operation result. 0 if the operation succeeded, an error code otherwise. Following parameters should be ignored if status != 0. </td></tr>
    <tr><td class="paramname">attr</td><td>file attributes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3e6feb766cdd699b6cec8861f36e6a0" name="ae3e6feb766cdd699b6cec8861f36e6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e6feb766cdd699b6cec8861f36e6a0">&#9670;&#160;</a></span>spdk_fsdev_getxattr_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_getxattr_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, size_t value_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an extended attribute operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. Following parameters should be ignored if status != 0. </td></tr>
    <tr><td class="paramname">value_size</td><td>Size of an data copied to the value buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67ec9ba3beeca665c63b03fcf5c35474" name="a67ec9ba3beeca665c63b03fcf5c35474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ec9ba3beeca665c63b03fcf5c35474">&#9670;&#160;</a></span>spdk_fsdev_init_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_fsdev_init_cb) (void *cb_arg, int rc)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filesystem device initialization callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument. </td></tr>
    <tr><td class="paramname">rc</td><td>0 if filesystem device initialized successfully or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ef43a61e382a554a25582a040dd4f34" name="a7ef43a61e382a554a25582a040dd4f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef43a61e382a554a25582a040dd4f34">&#9670;&#160;</a></span>spdk_fsdev_link_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_link_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_object *fobject, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a hard link operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. Following parameters should be ignored if status != 0. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">attr</td><td>File attributes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15bc6ff9892aad590e97357ff791c465" name="a15bc6ff9892aad590e97357ff791c465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bc6ff9892aad590e97357ff791c465">&#9670;&#160;</a></span>spdk_fsdev_listxattr_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_listxattr_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, size_t size, bool size_only)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List extended attribute names operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. Following parameters should be ignored if status != 0. </td></tr>
    <tr><td class="paramname">size</td><td>Size of an extended attribute list. </td></tr>
    <tr><td class="paramname">size_only</td><td>true if buffer was NULL or size was 0 upon the <a class="el" href="#a4faa40867d34572801b8d295f4cf7b4f">spdk_fsdev_listxattr</a> call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbba08fcf598beb5d98340ba28b617c2" name="afbba08fcf598beb5d98340ba28b617c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbba08fcf598beb5d98340ba28b617c2">&#9670;&#160;</a></span>spdk_fsdev_lookup_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_lookup_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_object *fobject, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup file operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. Following parameters should be ignored if status != 0. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">attr</td><td>File attributes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6a07bfc8d04a00846b7496bb1dbeeaa" name="ac6a07bfc8d04a00846b7496bb1dbeeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a07bfc8d04a00846b7496bb1dbeeaa">&#9670;&#160;</a></span>spdk_fsdev_mkdir_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_mkdir_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_object *fobject, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a directory operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. Following parameters should be ignored if status != 0. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">attr</td><td>File attributes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc350530e00392a380a912d1199c088d" name="adc350530e00392a380a912d1199c088d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc350530e00392a380a912d1199c088d">&#9670;&#160;</a></span>spdk_fsdev_mknod_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_mknod_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_object *fobject, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create file node operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. Following parameters should be ignored if status != 0. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">attr</td><td>File attributes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab71c1a2d51d70ba1034ec232658fa635" name="ab71c1a2d51d70ba1034ec232658fa635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71c1a2d51d70ba1034ec232658fa635">&#9670;&#160;</a></span>spdk_fsdev_opendir_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_opendir_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_handle *fhandle)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a directory operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. Following parameters should be ignored if status != 0. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe88dee7a3cd449bb8aca4396eed032c" name="afe88dee7a3cd449bb8aca4396eed032c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe88dee7a3cd449bb8aca4396eed032c">&#9670;&#160;</a></span>spdk_fsdev_read_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_read_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, uint32_t data_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
    <tr><td class="paramname">data_size</td><td>Number of bytes read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef775cb309379a2065e4e317841bd1a7" name="aef775cb309379a2065e4e317841bd1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef775cb309379a2065e4e317841bd1a7">&#9670;&#160;</a></span>spdk_fsdev_readdir_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_readdir_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read directory operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1aa47bc61002d7f310c31bdc80ef435f" name="a1aa47bc61002d7f310c31bdc80ef435f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa47bc61002d7f310c31bdc80ef435f">&#9670;&#160;</a></span>spdk_fsdev_readdir_entry_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int spdk_fsdev_readdir_entry_cb(void *cb_arg, struct spdk_io_channel *ch, const char *name, struct spdk_fsdev_file_object *fobject, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr, off_t offset)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read directory per-entry callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the entry </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. NULL for "." and "..". </td></tr>
    <tr><td class="paramname">attr</td><td>File attributes. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset of the next entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 to continue the enumeration, an error code otherwise. </dd></dl>

</div>
</div>
<a id="a2e0db0a51f3856194393230b9e1112b3" name="a2e0db0a51f3856194393230b9e1112b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0db0a51f3856194393230b9e1112b3">&#9670;&#160;</a></span>spdk_fsdev_readlink_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_readlink_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, const char *linkname)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read symbolic link operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>Operation result. 0 if the operation succeeded, an error code otherwise. Following parameters should be ignored if status != 0. </td></tr>
    <tr><td class="paramname">linkname</td><td>symbolic link contents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5299f1535c59c11d2e2df1c8136d07a" name="ab5299f1535c59c11d2e2df1c8136d07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5299f1535c59c11d2e2df1c8136d07a">&#9670;&#160;</a></span>spdk_fsdev_release_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_release_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release an open file operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa240cd5c16eb78164e18ae4e66175623" name="aa240cd5c16eb78164e18ae4e66175623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa240cd5c16eb78164e18ae4e66175623">&#9670;&#160;</a></span>spdk_fsdev_releasedir_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_releasedir_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a directory operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a505469ea31ee0dd47c5b92b6732d59a2" name="a505469ea31ee0dd47c5b92b6732d59a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505469ea31ee0dd47c5b92b6732d59a2">&#9670;&#160;</a></span>spdk_fsdev_removexattr_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_removexattr_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an extended attribute operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af09c4f1a0a8118e98bb1561a2992ecb1" name="af09c4f1a0a8118e98bb1561a2992ecb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09c4f1a0a8118e98bb1561a2992ecb1">&#9670;&#160;</a></span>spdk_fsdev_rename_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_rename_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename a file operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16062da8ec770fa4efdf0e46021d9ca1" name="a16062da8ec770fa4efdf0e46021d9ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16062da8ec770fa4efdf0e46021d9ca1">&#9670;&#160;</a></span>spdk_fsdev_rmdir_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_rmdir_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a directory operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bfd4916266bd5453ba5c80ffe608e21" name="a7bfd4916266bd5453ba5c80ffe608e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfd4916266bd5453ba5c80ffe608e21">&#9670;&#160;</a></span>spdk_fsdev_setattr_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_setattr_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set file attributes operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>Operation result. 0 if the operation succeeded, an error code otherwise. Following parameters should be ignored if status != 0. </td></tr>
    <tr><td class="paramname">attr</td><td>file attributes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6435227d65f41b7e5b91594d9bba4fb0" name="a6435227d65f41b7e5b91594d9bba4fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6435227d65f41b7e5b91594d9bba4fb0">&#9670;&#160;</a></span>spdk_fsdev_setxattr_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_setxattr_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an extended attribute operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ecb3929bb231f19ce2b2d839677cd16" name="a2ecb3929bb231f19ce2b2d839677cd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ecb3929bb231f19ce2b2d839677cd16">&#9670;&#160;</a></span>spdk_fsdev_statfs_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_statfs_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, const struct <a class="el" href="structspdk__fsdev__file__statfs.html">spdk_fsdev_file_statfs</a> *statfs)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get file system statistic operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. Following parameters should be ignored if status != 0. </td></tr>
    <tr><td class="paramname">statfs</td><td>filesystem statistics </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebf65b6f5edbe0f4ecc9e67f4f83d55e" name="aebf65b6f5edbe0f4ecc9e67f4f83d55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf65b6f5edbe0f4ecc9e67f4f83d55e">&#9670;&#160;</a></span>spdk_fsdev_symlink_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_symlink_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, struct spdk_fsdev_file_object *fobject, const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *attr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a symbolic link operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. Following parameters should be ignored if status != 0. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">attr</td><td>File attributes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a437ddf6056312ce3d8db8c2772b77595" name="a437ddf6056312ce3d8db8c2772b77595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437ddf6056312ce3d8db8c2772b77595">&#9670;&#160;</a></span>spdk_fsdev_unlink_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_unlink_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a file operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8f367b7c67799b1d2ddd7a2342006bb" name="ac8f367b7c67799b1d2ddd7a2342006bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f367b7c67799b1d2ddd7a2342006bb">&#9670;&#160;</a></span>spdk_fsdev_write_cpl_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void spdk_fsdev_write_cpl_cb(void *cb_arg, struct spdk_io_channel *ch, int status, uint32_t data_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data operation completion callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Context passed to the corresponding spdk_fsdev_ API </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">status</td><td>operation result. 0 if the operation succeeded, an error code otherwise. </td></tr>
    <tr><td class="paramname">data_size</td><td>Number of bytes written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0658ad22120fbf51f4f0cf72a1f90386" name="a0658ad22120fbf51f4f0cf72a1f90386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0658ad22120fbf51f4f0cf72a1f90386">&#9670;&#160;</a></span>spdk_fsdev_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_abort </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique_to_abort</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7ee99e3dbae9e06861dc205156050c2a">spdk_fsdev_abort_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort an I/O. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique_to_abort</td><td>Unique I/O id of the IO to abort. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a712e671bc4fd1d13a7e5d4acc87c8ecb" name="a712e671bc4fd1d13a7e5d4acc87c8ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712e671bc4fd1d13a7e5d4acc87c8ecb">&#9670;&#160;</a></span>spdk_fsdev_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_fsdev_close </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a previously opened filesystem device. </p>
<p>Must be called on the same thread that the <a class="el" href="#a70b937aa4d9f9cd617fa715b68f10f63" title="Open a filesystem device for I/O operations.">spdk_fsdev_open()</a> was performed on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cd38b4d0e724e8038905c0d568f3f30" name="a3cd38b4d0e724e8038905c0d568f3f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd38b4d0e724e8038905c0d568f3f30">&#9670;&#160;</a></span>spdk_fsdev_copy_file_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_copy_file_range </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject_in</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_handle *</td>          <td class="paramname"><span class="paramname"><em>fhandle_in</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t</td>          <td class="paramname"><span class="paramname"><em>off_in</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject_out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_handle *</td>          <td class="paramname"><span class="paramname"><em>fhandle_out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t</td>          <td class="paramname"><span class="paramname"><em>off_out</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>flags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9d2013cde86098390bbb73e346b96c55">spdk_fsdev_copy_file_range_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a range of data from one file to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject_in</td><td>IN File object. </td></tr>
    <tr><td class="paramname">fhandle_in</td><td>IN File handle. </td></tr>
    <tr><td class="paramname">off_in</td><td>Starting point from were the data should be read. </td></tr>
    <tr><td class="paramname">fobject_out</td><td>OUT File object. </td></tr>
    <tr><td class="paramname">fhandle_out</td><td>OUT File handle. </td></tr>
    <tr><td class="paramname">off_out</td><td>Starting point from were the data should be written. </td></tr>
    <tr><td class="paramname">len</td><td>Maximum size of the data to copy. </td></tr>
    <tr><td class="paramname">flags</td><td>Operation flags, see the copy_file_range() </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a3564c2f6559cdebcb8b1c17e08584d05" name="a3564c2f6559cdebcb8b1c17e08584d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3564c2f6559cdebcb8b1c17e08584d05">&#9670;&#160;</a></span>spdk_fsdev_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_create </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>parent_fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t</td>          <td class="paramname"><span class="paramname"><em>mode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>flags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t</td>          <td class="paramname"><span class="paramname"><em>umask</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t</td>          <td class="paramname"><span class="paramname"><em>euid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t</td>          <td class="paramname"><span class="paramname"><em>egid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae77bf4c150b8d685c22726eec7b06516">spdk_fsdev_create_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and open a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">parent_fobject</td><td>Parent directory </td></tr>
    <tr><td class="paramname">name</td><td>Name to create. </td></tr>
    <tr><td class="paramname">mode</td><td>File type and mode with which to create the new file. </td></tr>
    <tr><td class="paramname">flags</td><td>Operation flags. </td></tr>
    <tr><td class="paramname">umask</td><td>Umask of the calling process. </td></tr>
    <tr><td class="paramname">euid</td><td>Effective user ID of the calling process. </td></tr>
    <tr><td class="paramname">egid</td><td>Effective group ID of the calling process. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects -ENOMEM - operation cannot be initiated as there is not enough memory available </dd></dl>

</div>
</div>
<a id="ac830f6b4fc1f87eea1bcbb6e692534fe" name="ac830f6b4fc1f87eea1bcbb6e692534fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac830f6b4fc1f87eea1bcbb6e692534fe">&#9670;&#160;</a></span>spdk_fsdev_desc_get_fsdev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__fsdev.html">spdk_fsdev</a> * spdk_fsdev_desc_get_fsdev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the fsdev associated with a fsdev descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Open filesystem device descriptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fsdev associated with the descriptor </dd></dl>

</div>
</div>
<a id="ab9f56dc50121d78c1e74f838612c09f4" name="ab9f56dc50121d78c1e74f838612c09f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f56dc50121d78c1e74f838612c09f4">&#9670;&#160;</a></span>spdk_fsdev_fallocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_fallocate </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_handle *</td>          <td class="paramname"><span class="paramname"><em>fhandle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t</td>          <td class="paramname"><span class="paramname"><em>length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a87ec5b2843a7be514ac9d6c693118610">spdk_fsdev_fallocate_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate requested space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object.. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle. </td></tr>
    <tr><td class="paramname">mode</td><td>determines the operation to be performed on the given range, see fallocate(2) </td></tr>
    <tr><td class="paramname">offset</td><td>starting point for allocated region. </td></tr>
    <tr><td class="paramname">length</td><td>size of allocated region. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a7c92e93895b45782a302018fbb214a3e" name="a7c92e93895b45782a302018fbb214a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c92e93895b45782a302018fbb214a3e">&#9670;&#160;</a></span>spdk_fsdev_finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_fsdev_finish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab100fbd39944f97ce0f8c7bf88591ff5">spdk_fsdev_fini_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform cleanup work to remove the registered filesystem device modules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_fn</td><td>Called when the removal is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16ffc97a4a90e2176116fe9ec092b7c5" name="a16ffc97a4a90e2176116fe9ec092b7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ffc97a4a90e2176116fe9ec092b7c5">&#9670;&#160;</a></span>spdk_fsdev_flock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_flock </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_handle *</td>          <td class="paramname"><span class="paramname"><em>fhandle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>operation</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8c43928d312b741a572656c3a89640e4">spdk_fsdev_flock_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire, modify or release a BSD file lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object.. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle. </td></tr>
    <tr><td class="paramname">operation</td><td>Lock operation (see man flock, LOCK_NB will always be added). </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="afce72dea1f37667b1bbba02c414c3290" name="afce72dea1f37667b1bbba02c414c3290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce72dea1f37667b1bbba02c414c3290">&#9670;&#160;</a></span>spdk_fsdev_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_flush </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_handle *</td>          <td class="paramname"><span class="paramname"><em>fhandle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a42d995c33ef1719f79dc39eda69e1fc9">spdk_fsdev_flush_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a6eee91f3e261692a35bbbf52365a00c4" name="a6eee91f3e261692a35bbbf52365a00c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eee91f3e261692a35bbbf52365a00c4">&#9670;&#160;</a></span>spdk_fsdev_fopen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_fopen </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>flags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8f2e6587b4b405ca41f0f80050698e3e">spdk_fsdev_fopen_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">flags</td><td>Operation flags. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a8b5c2f4c08d60c3a8dd80c731b3519fc" name="a8b5c2f4c08d60c3a8dd80c731b3519fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5c2f4c08d60c3a8dd80c731b3519fc">&#9670;&#160;</a></span>spdk_fsdev_forget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_forget </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>nlookup</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8f3a236dd6a7d31734e92cadadd5f969">spdk_fsdev_forget_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove file object from internal cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">nlookup</td><td>Number of lookups to forget. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a41cf3a7ecbcf5bfe5ecda2c8bb904ddd" name="a41cf3a7ecbcf5bfe5ecda2c8bb904ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cf3a7ecbcf5bfe5ecda2c8bb904ddd">&#9670;&#160;</a></span>spdk_fsdev_fsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_fsync </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_handle *</td>          <td class="paramname"><span class="paramname"><em>fhandle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>datasync</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa5d8f1a7a5c0569941342cdad445c811">spdk_fsdev_fsync_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize file contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle. </td></tr>
    <tr><td class="paramname">datasync</td><td>Flag indicating if only data should be flushed. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="ac7378a08029cfee87b3675c3daa7536e" name="ac7378a08029cfee87b3675c3daa7536e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7378a08029cfee87b3675c3daa7536e">&#9670;&#160;</a></span>spdk_fsdev_fsyncdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_fsyncdir </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_handle *</td>          <td class="paramname"><span class="paramname"><em>fhandle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>datasync</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acb7a14eafb9606811a10ec4498bcc706">spdk_fsdev_fsyncdir_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize directory contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle </td></tr>
    <tr><td class="paramname">datasync</td><td>Flag indicating if only data should be flushed. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a2d5efcb1e492d8d707cbca77ebd3f41b" name="a2d5efcb1e492d8d707cbca77ebd3f41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5efcb1e492d8d707cbca77ebd3f41b">&#9670;&#160;</a></span>spdk_fsdev_get_io_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_io_channel * spdk_fsdev_get_io_channel </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain an I/O channel for the filesystem device opened by the specified descriptor. </p>
<p>I/O channels are bound to threads, so the resulting I/O channel may only be used from the thread it was originally obtained from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the I/O channel or NULL on failure. </dd></dl>

</div>
</div>
<a id="a42c8d01fc94e53cc4c63761af4bece45" name="a42c8d01fc94e53cc4c63761af4bece45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c8d01fc94e53cc4c63761af4bece45">&#9670;&#160;</a></span>spdk_fsdev_get_memory_domains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_get_memory_domains </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__fsdev.html">spdk_fsdev</a> *</td>          <td class="paramname"><span class="paramname"><em>fsdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_memory_domain **</td>          <td class="paramname"><span class="paramname"><em>domains</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>array_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get SPDK memory domains used by the given fsdev. </p>
<p>If fsdev reports that it uses memory domains that means that it can work with data buffers located in those memory domains.</p>
<p>The user can call this function with <b>domains</b> set to NULL and <b>array_size</b> set to 0 to get the number of memory domains used by fsdev</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fsdev</td><td>filesystem device </td></tr>
    <tr><td class="paramname">domains</td><td>pointer to an array of memory domains to be filled by this function. The user should allocate big enough array to keep all memory domains used by fsdev and all underlying fsdevs </td></tr>
    <tr><td class="paramname">array_size</td><td>size of <b>domains</b> array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of entries in <b>domains</b> array or negated errno. If returned value is bigger than <b>array_size</b> passed by the user then the user should increase the size of <b>domains</b> array and call this function again. There is no guarantees that the content of <b>domains</b> array is valid in that case. -EINVAL if input parameters were invalid </dd></dl>

</div>
</div>
<a id="a485e0c0cea34f8ca3961036564763fa2" name="a485e0c0cea34f8ca3961036564763fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485e0c0cea34f8ca3961036564763fa2">&#9670;&#160;</a></span>spdk_fsdev_get_module_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_fsdev_get_module_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__fsdev.html">spdk_fsdev</a> *</td>          <td class="paramname"><span class="paramname"><em>fsdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get filesystem device module name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fsdev</td><td>Filesystem device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of fsdev module as a null-terminated string. </dd></dl>

</div>
</div>
<a id="a569b39eca2ea19aeb1dc4cb80f4ed701" name="a569b39eca2ea19aeb1dc4cb80f4ed701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569b39eca2ea19aeb1dc4cb80f4ed701">&#9670;&#160;</a></span>spdk_fsdev_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_fsdev_get_name </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__fsdev.html">spdk_fsdev</a> *</td>          <td class="paramname"><span class="paramname"><em>fsdev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get filesystem device name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fsdev</td><td>filesystem device to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name of fsdev as a null-terminated string. </dd></dl>

</div>
</div>
<a id="a6b092800101af1d310d48a7eb11c8965" name="a6b092800101af1d310d48a7eb11c8965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b092800101af1d310d48a7eb11c8965">&#9670;&#160;</a></span>spdk_fsdev_get_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_get_opts </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__fsdev__opts.html">spdk_fsdev_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>opts_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the options for the fsdev library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Output parameter for options. </td></tr>
    <tr><td class="paramname">opts_size</td><td>sizeof(*opts) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a7e9ece453f910a189550787cd37ee1" name="a6a7e9ece453f910a189550787cd37ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7e9ece453f910a189550787cd37ee1">&#9670;&#160;</a></span>spdk_fsdev_getattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_getattr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_handle *</td>          <td class="paramname"><span class="paramname"><em>fhandle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aae26d6253c295d4a55add390333be682">spdk_fsdev_getattr_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get file attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="ac2c66e6f781d2ded027588affb82e756" name="ac2c66e6f781d2ded027588affb82e756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c66e6f781d2ded027588affb82e756">&#9670;&#160;</a></span>spdk_fsdev_getxattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_getxattr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae3e6feb766cdd699b6cec8861f36e6a0">spdk_fsdev_getxattr_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an extended attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">name</td><td>Name of an extended attribute. </td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer to put the extended attribute's value. </td></tr>
    <tr><td class="paramname">size</td><td>Size of value's buffer. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects -ENOMEM - operation cannot be initiated as there is not enough memory available </dd></dl>

</div>
</div>
<a id="a461c6b7db40fbc5b484aa1cff6e2886b" name="a461c6b7db40fbc5b484aa1cff6e2886b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461c6b7db40fbc5b484aa1cff6e2886b">&#9670;&#160;</a></span>spdk_fsdev_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_fsdev_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a67ec9ba3beeca665c63b03fcf5c35474">spdk_fsdev_init_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize filesystem device modules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_fn</td><td>Called when the initialization is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to function cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a381e101cc24fe8084bc8436a04ffb268" name="a381e101cc24fe8084bc8436a04ffb268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381e101cc24fe8084bc8436a04ffb268">&#9670;&#160;</a></span>spdk_fsdev_link()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_link </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>new_parent_fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7ef43a61e382a554a25582a040dd4f34">spdk_fsdev_link_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a hard link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">new_parent_fobject</td><td>New parent directory. </td></tr>
    <tr><td class="paramname">name</td><td>Link name. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects -ENOMEM - operation cannot be initiated as there is not enough memory available </dd></dl>

</div>
</div>
<a id="a4faa40867d34572801b8d295f4cf7b4f" name="a4faa40867d34572801b8d295f4cf7b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4faa40867d34572801b8d295f4cf7b4f">&#9670;&#160;</a></span>spdk_fsdev_listxattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_listxattr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a15bc6ff9892aad590e97357ff791c465">spdk_fsdev_listxattr_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List extended attribute names. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer to to be used for the attribute names. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the <b>buffer</b>. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="ac2f54649c163ca6ea4f70a4ef870fdce" name="ac2f54649c163ca6ea4f70a4ef870fdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f54649c163ca6ea4f70a4ef870fdce">&#9670;&#160;</a></span>spdk_fsdev_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_lookup </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>parent_fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afbba08fcf598beb5d98340ba28b617c2">spdk_fsdev_lookup_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up a directory entry by name and get its attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">parent_fobject</td><td>Parent directory. NULL for the root directory. </td></tr>
    <tr><td class="paramname">name</td><td>The name to look up. Ignored if parent_fobject is NULL. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects -ENOMEM - operation cannot be initiated as there is not enough memory available </dd></dl>

</div>
</div>
<a id="abcae8afd51d4274fb113dd21e0e41d7c" name="abcae8afd51d4274fb113dd21e0e41d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcae8afd51d4274fb113dd21e0e41d7c">&#9670;&#160;</a></span>spdk_fsdev_mkdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_mkdir </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>parent_fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t</td>          <td class="paramname"><span class="paramname"><em>mode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t</td>          <td class="paramname"><span class="paramname"><em>euid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t</td>          <td class="paramname"><span class="paramname"><em>egid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac6a07bfc8d04a00846b7496bb1dbeeaa">spdk_fsdev_mkdir_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">parent_fobject</td><td>Parent directory </td></tr>
    <tr><td class="paramname">name</td><td>Directory name to create. </td></tr>
    <tr><td class="paramname">mode</td><td>Directory type and mode with which to create the new directory. </td></tr>
    <tr><td class="paramname">euid</td><td>Effective user ID of the calling process. </td></tr>
    <tr><td class="paramname">egid</td><td>Effective group ID of the calling process. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects -ENOMEM - operation cannot be initiated as there is not enough memory available </dd></dl>

</div>
</div>
<a id="abc09b676f62ff9388cf00b9516f43479" name="abc09b676f62ff9388cf00b9516f43479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc09b676f62ff9388cf00b9516f43479">&#9670;&#160;</a></span>spdk_fsdev_mknod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_mknod </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>parent_fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t</td>          <td class="paramname"><span class="paramname"><em>mode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dev_t</td>          <td class="paramname"><span class="paramname"><em>rdev</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t</td>          <td class="paramname"><span class="paramname"><em>euid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t</td>          <td class="paramname"><span class="paramname"><em>egid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#adc350530e00392a380a912d1199c088d">spdk_fsdev_mknod_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create file node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">parent_fobject</td><td>Parent directory </td></tr>
    <tr><td class="paramname">name</td><td>File name to create. </td></tr>
    <tr><td class="paramname">mode</td><td>File type and mode with which to create the new file. </td></tr>
    <tr><td class="paramname">rdev</td><td>The device number (only valid if created file is a device) </td></tr>
    <tr><td class="paramname">euid</td><td>Effective user ID of the calling process. </td></tr>
    <tr><td class="paramname">egid</td><td>Effective group ID of the calling process. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects -ENOMEM - operation cannot be initiated as there is not enough memory available </dd></dl>

</div>
</div>
<a id="a70b937aa4d9f9cd617fa715b68f10f63" name="a70b937aa4d9f9cd617fa715b68f10f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b937aa4d9f9cd617fa715b68f10f63">&#9670;&#160;</a></span>spdk_fsdev_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_open </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fsdev_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7f17c8dc7e348a41b50aca23d758eecb">spdk_fsdev_event_cb_t</a></td>          <td class="paramname"><span class="paramname"><em>event_cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>event_ctx</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__fsdev__open__opts.html">spdk_fsdev_open_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_desc **</td>          <td class="paramname"><span class="paramname"><em>desc</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a filesystem device for I/O operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fsdev_name</td><td>Filesystem device name to open. </td></tr>
    <tr><td class="paramname">event_cb</td><td>notification callback to be called when the fsdev triggers asynchronous event such as fsdev removal. This will always be called on the same thread that <a class="el" href="#a70b937aa4d9f9cd617fa715b68f10f63" title="Open a filesystem device for I/O operations.">spdk_fsdev_open()</a> was called on. In case of removal event the descriptor will have to be manually closed to make the fsdev unregister proceed. </td></tr>
    <tr><td class="paramname">event_ctx</td><td>param for event_cb. </td></tr>
    <tr><td class="paramname">opts</td><td>optional open opts. </td></tr>
    <tr><td class="paramname">desc</td><td>output parameter for the descriptor when operation is successful </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if operation is successful, suitable errno value otherwise </dd></dl>

</div>
</div>
<a id="a9da97eca8509134bc35673ec720d8704" name="a9da97eca8509134bc35673ec720d8704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da97eca8509134bc35673ec720d8704">&#9670;&#160;</a></span>spdk_fsdev_opendir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_opendir </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>flags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab71c1a2d51d70ba1034ec232658fa635">spdk_fsdev_opendir_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">flags</td><td>Operation flags. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a26b90c2bb0862efbcf6105b220414bc4" name="a26b90c2bb0862efbcf6105b220414bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b90c2bb0862efbcf6105b220414bc4">&#9670;&#160;</a></span>spdk_fsdev_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_read </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_handle *</td>          <td class="paramname"><span class="paramname"><em>fhandle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>flags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__fsdev__io__opts.html">spdk_fsdev_io_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#afe88dee7a3cd449bb8aca4396eed032c">spdk_fsdev_read_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to read. </td></tr>
    <tr><td class="paramname">offs</td><td>Offset to read from. </td></tr>
    <tr><td class="paramname">flags</td><td>Operation flags. </td></tr>
    <tr><td class="paramname">iov</td><td>Array of iovec to be used for the data. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Size of the <b>iov</b> array. </td></tr>
    <tr><td class="paramname">opts</td><td>Optional structure with extended File Operation options. If set, this structure must be valid until the operation is completed. <code>size</code> member of this structure is used for ABI compatibility and must be set to sizeof(struct spdk_fsdev_io_opts). </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a82dbcbb61f2f5c7c172363bea7a07726" name="a82dbcbb61f2f5c7c172363bea7a07726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dbcbb61f2f5c7c172363bea7a07726">&#9670;&#160;</a></span>spdk_fsdev_readdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_readdir </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_handle *</td>          <td class="paramname"><span class="paramname"><em>fhandle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1aa47bc61002d7f310c31bdc80ef435f">spdk_fsdev_readdir_entry_cb</a></td>          <td class="paramname"><span class="paramname"><em>entry_cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aef775cb309379a2065e4e317841bd1a7">spdk_fsdev_readdir_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cpl_cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle </td></tr>
    <tr><td class="paramname">offset</td><td>Offset to continue reading the directory stream </td></tr>
    <tr><td class="paramname">entry_cb_fn</td><td>Per-entry callback. </td></tr>
    <tr><td class="paramname">cpl_cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a06950b3ad069d4fd0c0fcfb84438ee3c" name="a06950b3ad069d4fd0c0fcfb84438ee3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06950b3ad069d4fd0c0fcfb84438ee3c">&#9670;&#160;</a></span>spdk_fsdev_readlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_readlink </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2e0db0a51f3856194393230b9e1112b3">spdk_fsdev_readlink_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read symbolic link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a3dd94dedbe5998473878788857e198e8" name="a3dd94dedbe5998473878788857e198e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd94dedbe5998473878788857e198e8">&#9670;&#160;</a></span>spdk_fsdev_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_release </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_handle *</td>          <td class="paramname"><span class="paramname"><em>fhandle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab5299f1535c59c11d2e2df1c8136d07a">spdk_fsdev_release_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release an open file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a6e2604b7c0ad1de65d94b393b0be3949" name="a6e2604b7c0ad1de65d94b393b0be3949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2604b7c0ad1de65d94b393b0be3949">&#9670;&#160;</a></span>spdk_fsdev_releasedir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_releasedir </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_handle *</td>          <td class="paramname"><span class="paramname"><em>fhandle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aa240cd5c16eb78164e18ae4e66175623">spdk_fsdev_releasedir_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a6379024e43a1335afe9ebadd5542ea5e" name="a6379024e43a1335afe9ebadd5542ea5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6379024e43a1335afe9ebadd5542ea5e">&#9670;&#160;</a></span>spdk_fsdev_removexattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_removexattr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a505469ea31ee0dd47c5b92b6732d59a2">spdk_fsdev_removexattr_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an extended attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">name</td><td>Name of an extended attribute. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects -ENOMEM - operation cannot be initiated as there is not enough memory available </dd></dl>

</div>
</div>
<a id="a64ddce0d15cbcd874e841208cd18597d" name="a64ddce0d15cbcd874e841208cd18597d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ddce0d15cbcd874e841208cd18597d">&#9670;&#160;</a></span>spdk_fsdev_rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_rename </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>parent_fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>new_parent_fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>new_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>flags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af09c4f1a0a8118e98bb1561a2992ecb1">spdk_fsdev_rename_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">parent_fobject</td><td>Parent directory. </td></tr>
    <tr><td class="paramname">name</td><td>Old rename. </td></tr>
    <tr><td class="paramname">new_parent_fobject</td><td>New parent directory. </td></tr>
    <tr><td class="paramname">new_name</td><td>New name. </td></tr>
    <tr><td class="paramname">flags</td><td>Operation flags. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects -ENOMEM - operation cannot be initiated as there is not enough memory available </dd></dl>

</div>
</div>
<a id="aeb84d99338e586d017fa5c88e162287d" name="aeb84d99338e586d017fa5c88e162287d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb84d99338e586d017fa5c88e162287d">&#9670;&#160;</a></span>spdk_fsdev_rmdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_rmdir </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>parent_fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a16062da8ec770fa4efdf0e46021d9ca1">spdk_fsdev_rmdir_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">parent_fobject</td><td>Parent directory </td></tr>
    <tr><td class="paramname">name</td><td>Name to remove. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects -ENOMEM - operation cannot be initiated as there is not enough memory available </dd></dl>

</div>
</div>
<a id="af5fe72a67ff7e25f606fc530b27b70d8" name="af5fe72a67ff7e25f606fc530b27b70d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fe72a67ff7e25f606fc530b27b70d8">&#9670;&#160;</a></span>spdk_fsdev_set_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_set_opts </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__fsdev__opts.html">spdk_fsdev_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the options for the fsdev library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>options to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-EINVAL if the options are invalid. </dd></dl>

</div>
</div>
<a id="a78fb19e2a443ce35ad48753ea905dbed" name="a78fb19e2a443ce35ad48753ea905dbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fb19e2a443ce35ad48753ea905dbed">&#9670;&#160;</a></span>spdk_fsdev_setattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_setattr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_handle *</td>          <td class="paramname"><span class="paramname"><em>fhandle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__fsdev__file__attr.html">spdk_fsdev_file_attr</a> *</td>          <td class="paramname"><span class="paramname"><em>attr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>to_set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7bfd4916266bd5453ba5c80ffe608e21">spdk_fsdev_setattr_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set file attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle </td></tr>
    <tr><td class="paramname">attr</td><td>file attributes to set. </td></tr>
    <tr><td class="paramname">to_set</td><td>Bit mask of attributes which should be set. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a4e6f207ced0ceb7a923b941b12568285" name="a4e6f207ced0ceb7a923b941b12568285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6f207ced0ceb7a923b941b12568285">&#9670;&#160;</a></span>spdk_fsdev_setxattr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_setxattr </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>flags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a6435227d65f41b7e5b91594d9bba4fb0">spdk_fsdev_setxattr_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an extended attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">name</td><td>Name of an extended attribute. </td></tr>
    <tr><td class="paramname">value</td><td>Buffer that contains value of an extended attribute. </td></tr>
    <tr><td class="paramname">size</td><td>Size of an extended attribute. </td></tr>
    <tr><td class="paramname">flags</td><td>Operation flags. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects -ENOMEM - operation cannot be initiated as there is not enough memory available </dd></dl>

</div>
</div>
<a id="a59dd0d6871a5a114bbb9383fb537a5a4" name="a59dd0d6871a5a114bbb9383fb537a5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59dd0d6871a5a114bbb9383fb537a5a4">&#9670;&#160;</a></span>spdk_fsdev_statfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_statfs </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2ecb3929bb231f19ce2b2d839677cd16">spdk_fsdev_statfs_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get file system statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
<a id="a3f51fbafc195f38628dcef020b6dfe3b" name="a3f51fbafc195f38628dcef020b6dfe3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f51fbafc195f38628dcef020b6dfe3b">&#9670;&#160;</a></span>spdk_fsdev_subsystem_config_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_fsdev_subsystem_config_json </td>
          <td>(</td>
          <td class="paramtype">struct spdk_json_write_ctx *</td>          <td class="paramname"><span class="paramname"><em>w</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the full configuration options for the registered filesystem device modules and created fsdevs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>pointer to a JSON write context where the configuration will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3920d9f40ce3ab669b3a51fede001a28" name="a3920d9f40ce3ab669b3a51fede001a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3920d9f40ce3ab669b3a51fede001a28">&#9670;&#160;</a></span>spdk_fsdev_symlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_symlink </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>parent_fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>target</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>linkpath</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t</td>          <td class="paramname"><span class="paramname"><em>euid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t</td>          <td class="paramname"><span class="paramname"><em>egid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aebf65b6f5edbe0f4ecc9e67f4f83d55e">spdk_fsdev_symlink_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a symbolic link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">parent_fobject</td><td>Parent directory </td></tr>
    <tr><td class="paramname">target</td><td>symbolic link's content </td></tr>
    <tr><td class="paramname">linkpath</td><td>symbolic link's name </td></tr>
    <tr><td class="paramname">euid</td><td>Effective user ID of the calling process. </td></tr>
    <tr><td class="paramname">egid</td><td>Effective group ID of the calling process. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects -ENOMEM - operation cannot be initiated as there is not enough memory available </dd></dl>

</div>
</div>
<a id="a870e94773227fd79e069b3011b61a0af" name="a870e94773227fd79e069b3011b61a0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870e94773227fd79e069b3011b61a0af">&#9670;&#160;</a></span>spdk_fsdev_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_unlink </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>parent_fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a437ddf6056312ce3d8db8c2772b77595">spdk_fsdev_unlink_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">parent_fobject</td><td>Parent directory </td></tr>
    <tr><td class="paramname">name</td><td>Name to remove. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects -ENOMEM - operation cannot be initiated as there is not enough memory available </dd></dl>

</div>
</div>
<a id="a0da55f1fb613157da8341d94f806dca7" name="a0da55f1fb613157da8341d94f806dca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da55f1fb613157da8341d94f806dca7">&#9670;&#160;</a></span>spdk_fsdev_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_fsdev_write </td>
          <td>(</td>
          <td class="paramtype">struct spdk_fsdev_desc *</td>          <td class="paramname"><span class="paramname"><em>desc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_io_channel *</td>          <td class="paramname"><span class="paramname"><em>ch</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unique</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_object *</td>          <td class="paramname"><span class="paramname"><em>fobject</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_fsdev_file_handle *</td>          <td class="paramname"><span class="paramname"><em>fhandle</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>offs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>flags</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *</td>          <td class="paramname"><span class="paramname"><em>iov</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>iovcnt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__fsdev__io__opts.html">spdk_fsdev_io_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac8f367b7c67799b1d2ddd7a2342006bb">spdk_fsdev_write_cpl_cb</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>Filesystem device descriptor. </td></tr>
    <tr><td class="paramname">ch</td><td>I/O channel. </td></tr>
    <tr><td class="paramname">unique</td><td>Unique I/O id. </td></tr>
    <tr><td class="paramname">fobject</td><td>File object. </td></tr>
    <tr><td class="paramname">fhandle</td><td>File handle. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write. </td></tr>
    <tr><td class="paramname">offs</td><td>Offset to write to. </td></tr>
    <tr><td class="paramname">flags</td><td>Operation flags. </td></tr>
    <tr><td class="paramname">iov</td><td>Array of iovec to where the data is stored. </td></tr>
    <tr><td class="paramname">iovcnt</td><td>Size of the <b>iov</b> array. </td></tr>
    <tr><td class="paramname">opts</td><td>Optional structure with extended File Operation options. If set, this structure must be valid until the operation is completed. <code>size</code> member of this structure is used for ABI compatibility and must be set to sizeof(struct spdk_fsdev_io_opts). </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Completion callback. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Context to be passed to the completion callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. On success, the callback will always be called (even if the request ultimately failed). Return negated errno on failure, in which case the callback will not be called. -ENOBUFS - operation cannot be initiated due to a lack of the internal IO objects </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.10.0 </li>
</ul>
</div>
</div>
</body>
</html>
