<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.13">
  <title>SPDK: io_channel.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-sm-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://ci.spdk.io/status/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://github.com/spdk/spdk/wiki/Roadmap">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://github.com/spdk/spdk/wiki/News">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_67fbcc0b4317645100def1406b508c33.html">spdk</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">io_channel.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>IO channel.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a964c3690cb5eea9bcf2e0f91b001a239"><td class="memItemLeft" align="right" valign="top"><a id="a964c3690cb5eea9bcf2e0f91b001a239"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_thread_fn</b>) (void *ctx)</td></tr>
<tr class="separator:a964c3690cb5eea9bcf2e0f91b001a239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72dfa5b3490733f3d307d2303a551661"><td class="memItemLeft" align="right" valign="top"><a id="a72dfa5b3490733f3d307d2303a551661"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_thread_pass_msg</b>) (spdk_thread_fn fn, void *ctx, void *thread_ctx)</td></tr>
<tr class="separator:a72dfa5b3490733f3d307d2303a551661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1d14292cfee8553d4a1ebb519b210a"><td class="memItemLeft" align="right" valign="top"><a id="aed1d14292cfee8553d4a1ebb519b210a"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_io_channel_create_cb</b>) (void *io_device, void *ctx_buf)</td></tr>
<tr class="separator:aed1d14292cfee8553d4a1ebb519b210a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aa6a61877f23f79bb75c8fc5e68202"><td class="memItemLeft" align="right" valign="top"><a id="a75aa6a61877f23f79bb75c8fc5e68202"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_io_channel_destroy_cb</b>) (void *io_device, void *ctx_buf)</td></tr>
<tr class="separator:a75aa6a61877f23f79bb75c8fc5e68202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae044f4141737c7f2df49cdfb03fd58ca"><td class="memItemLeft" align="right" valign="top"><a id="ae044f4141737c7f2df49cdfb03fd58ca"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_io_device_unregister_cb</b>) (void *io_device)</td></tr>
<tr class="separator:ae044f4141737c7f2df49cdfb03fd58ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b7239eb25263787bba6b64036f9792"><td class="memItemLeft" align="right" valign="top"><a id="ad7b7239eb25263787bba6b64036f9792"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_channel_msg</b>) (void *io_device, struct spdk_io_channel *ch, void *ctx)</td></tr>
<tr class="separator:ad7b7239eb25263787bba6b64036f9792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0acde747bbebfc981589c11e170515"><td class="memItemLeft" align="right" valign="top"><a id="a1c0acde747bbebfc981589c11e170515"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_channel_for_each_cpl</b>) (void *io_device, void *ctx)</td></tr>
<tr class="separator:a1c0acde747bbebfc981589c11e170515"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a42b58701b6440005e866e6e7dd080bae"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io__channel_8h.html#a42b58701b6440005e866e6e7dd080bae">spdk_allocate_thread</a> (spdk_thread_pass_msg fn, void *thread_ctx, const char *name)</td></tr>
<tr class="memdesc:a42b58701b6440005e866e6e7dd080bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the calling thread for I/O channel allocation.  <a href="#a42b58701b6440005e866e6e7dd080bae">More...</a><br /></td></tr>
<tr class="separator:a42b58701b6440005e866e6e7dd080bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbbc16ee4c35466974ca6d5b5c6ee7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io__channel_8h.html#adfbbc16ee4c35466974ca6d5b5c6ee7d">spdk_free_thread</a> (void)</td></tr>
<tr class="memdesc:adfbbc16ee4c35466974ca6d5b5c6ee7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases any resources related to the calling thread for I/O channel allocation.  <a href="#adfbbc16ee4c35466974ca6d5b5c6ee7d">More...</a><br /></td></tr>
<tr class="separator:adfbbc16ee4c35466974ca6d5b5c6ee7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34754a98debd5e095bf06889fbaed6aa"><td class="memItemLeft" align="right" valign="top">struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io__channel_8h.html#a34754a98debd5e095bf06889fbaed6aa">spdk_get_thread</a> (void)</td></tr>
<tr class="memdesc:a34754a98debd5e095bf06889fbaed6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the current thread.  <a href="#a34754a98debd5e095bf06889fbaed6aa">More...</a><br /></td></tr>
<tr class="separator:a34754a98debd5e095bf06889fbaed6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae367048fa89366e845d72015064e6f76"><td class="memItemLeft" align="right" valign="top"><a id="ae367048fa89366e845d72015064e6f76"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io__channel_8h.html#ae367048fa89366e845d72015064e6f76">spdk_thread_get_name</a> (const struct spdk_thread *thread)</td></tr>
<tr class="memdesc:ae367048fa89366e845d72015064e6f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a thread's name. <br /></td></tr>
<tr class="separator:ae367048fa89366e845d72015064e6f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa832fea18a9160429b5383f36d8539"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io__channel_8h.html#a6aa832fea18a9160429b5383f36d8539">spdk_thread_send_msg</a> (const struct spdk_thread *thread, spdk_thread_fn fn, void *ctx)</td></tr>
<tr class="memdesc:a6aa832fea18a9160429b5383f36d8539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the given thread.  <a href="#a6aa832fea18a9160429b5383f36d8539">More...</a><br /></td></tr>
<tr class="separator:a6aa832fea18a9160429b5383f36d8539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0b6fdbfd40673bce799a1a7ebab187"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io__channel_8h.html#a6a0b6fdbfd40673bce799a1a7ebab187">spdk_io_device_register</a> (void *io_device, spdk_io_channel_create_cb create_cb, spdk_io_channel_destroy_cb destroy_cb, uint32_t ctx_size)</td></tr>
<tr class="memdesc:a6a0b6fdbfd40673bce799a1a7ebab187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the opaque io_device context as an I/O device.  <a href="#a6a0b6fdbfd40673bce799a1a7ebab187">More...</a><br /></td></tr>
<tr class="separator:a6a0b6fdbfd40673bce799a1a7ebab187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6c3df3a611c10c176cb87966c622f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io__channel_8h.html#a4c6c3df3a611c10c176cb87966c622f0">spdk_io_device_unregister</a> (void *io_device, spdk_io_device_unregister_cb unregister_cb)</td></tr>
<tr class="memdesc:a4c6c3df3a611c10c176cb87966c622f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister the opaque io_device context as an I/O device.  <a href="#a4c6c3df3a611c10c176cb87966c622f0">More...</a><br /></td></tr>
<tr class="separator:a4c6c3df3a611c10c176cb87966c622f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8537c42a7aa203b50578efed509d9ba8"><td class="memItemLeft" align="right" valign="top">struct spdk_io_channel *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io__channel_8h.html#a8537c42a7aa203b50578efed509d9ba8">spdk_get_io_channel</a> (void *io_device)</td></tr>
<tr class="memdesc:a8537c42a7aa203b50578efed509d9ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an I/O channel for the specified io_device to be used by the calling thread.  <a href="#a8537c42a7aa203b50578efed509d9ba8">More...</a><br /></td></tr>
<tr class="separator:a8537c42a7aa203b50578efed509d9ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717571a5011db0cdd730498146f25f9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io__channel_8h.html#a717571a5011db0cdd730498146f25f9a">spdk_put_io_channel</a> (struct spdk_io_channel *ch)</td></tr>
<tr class="memdesc:a717571a5011db0cdd730498146f25f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a reference to an I/O channel.  <a href="#a717571a5011db0cdd730498146f25f9a">More...</a><br /></td></tr>
<tr class="separator:a717571a5011db0cdd730498146f25f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23226b333cc3d87b2ce0d6f188bc22fa"><td class="memItemLeft" align="right" valign="top"><a id="a23226b333cc3d87b2ce0d6f188bc22fa"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io__channel_8h.html#a23226b333cc3d87b2ce0d6f188bc22fa">spdk_io_channel_get_ctx</a> (struct spdk_io_channel *ch)</td></tr>
<tr class="memdesc:a23226b333cc3d87b2ce0d6f188bc22fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the context buffer associated with an I/O channel. <br /></td></tr>
<tr class="separator:a23226b333cc3d87b2ce0d6f188bc22fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff9537d26ac923a7a93cd55ba315b5b"><td class="memItemLeft" align="right" valign="top"><a id="a8ff9537d26ac923a7a93cd55ba315b5b"></a>
struct spdk_thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io__channel_8h.html#a8ff9537d26ac923a7a93cd55ba315b5b">spdk_io_channel_get_thread</a> (struct spdk_io_channel *ch)</td></tr>
<tr class="memdesc:a8ff9537d26ac923a7a93cd55ba315b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the spdk_thread associated with an I/O channel. <br /></td></tr>
<tr class="separator:a8ff9537d26ac923a7a93cd55ba315b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a2ca9bd0497544e852c65fd5263cd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="io__channel_8h.html#aa7a2ca9bd0497544e852c65fd5263cd1">spdk_for_each_channel</a> (void *io_device, spdk_channel_msg fn, void *ctx, spdk_channel_for_each_cpl cpl)</td></tr>
<tr class="memdesc:aa7a2ca9bd0497544e852c65fd5263cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call 'fn' on each channel associated with io_device.  <a href="#aa7a2ca9bd0497544e852c65fd5263cd1">More...</a><br /></td></tr>
<tr class="separator:aa7a2ca9bd0497544e852c65fd5263cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>IO channel. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a42b58701b6440005e866e6e7dd080bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42b58701b6440005e866e6e7dd080bae">&#9670;&nbsp;</a></span>spdk_allocate_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_allocate_thread </td>
          <td>(</td>
          <td class="paramtype">spdk_thread_pass_msg&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>thread_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the calling thread for I/O channel allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>A function that may be called from any thread and is passed a function pointer (spdk_thread_fn) that must be called on the same thread that spdk_allocate_thread was called from. </td></tr>
    <tr><td class="paramname">thread_ctx</td><td>Context that will be passed to fn. </td></tr>
    <tr><td class="paramname">name</td><td>Human-readable name for the thread; can be retrieved with <a class="el" href="io__channel_8h.html#ae367048fa89366e845d72015064e6f76" title="Get a thread&#39;s name. ">spdk_thread_get_name()</a>. The string is copied, so the pointed-to data only needs to be valid during the <a class="el" href="io__channel_8h.html#a42b58701b6440005e866e6e7dd080bae" title="Initializes the calling thread for I/O channel allocation. ">spdk_allocate_thread()</a> call. May be NULL to specify no name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7a2ca9bd0497544e852c65fd5263cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a2ca9bd0497544e852c65fd5263cd1">&#9670;&nbsp;</a></span>spdk_for_each_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_for_each_channel </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_channel_msg&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_channel_for_each_cpl&#160;</td>
          <td class="paramname"><em>cpl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call 'fn' on each channel associated with io_device. </p>
<p>This happens asynchronously, so fn may be called after spdk_for_each_channel returns. 'fn' will be called on the correct thread for each channel. 'fn' will be called for each channel serially, such that two calls to 'fn' will not overlap in time.</p>
<p>Once 'fn' has been called on each channel, 'cpl' will be called on the thread that spdk_for_each_channel was initially called from. </p>

</div>
</div>
<a id="adfbbc16ee4c35466974ca6d5b5c6ee7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbbc16ee4c35466974ca6d5b5c6ee7d">&#9670;&nbsp;</a></span>spdk_free_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_free_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases any resources related to the calling thread for I/O channel allocation. </p>
<p>All I/O channel references related to the calling thread must be released using <a class="el" href="io__channel_8h.html#a717571a5011db0cdd730498146f25f9a" title="Releases a reference to an I/O channel. ">spdk_put_io_channel()</a> prior to calling this function. </p>

</div>
</div>
<a id="a8537c42a7aa203b50578efed509d9ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8537c42a7aa203b50578efed509d9ba8">&#9670;&nbsp;</a></span>spdk_get_io_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_io_channel* spdk_get_io_channel </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an I/O channel for the specified io_device to be used by the calling thread. </p>
<p>The io_device context pointer specified must have previously been registered using <a class="el" href="io__channel_8h.html#a6a0b6fdbfd40673bce799a1a7ebab187" title="Register the opaque io_device context as an I/O device. ">spdk_io_device_register()</a>. If an existing I/O channel does not exist yet for the given io_device on the calling thread, it will allocate an I/O channel and invoke the create_cb function pointer specified in <a class="el" href="io__channel_8h.html#a6a0b6fdbfd40673bce799a1a7ebab187" title="Register the opaque io_device context as an I/O device. ">spdk_io_device_register()</a>. If an I/O channel already exists for the given io_device on the calling thread, its reference is returned rather than creating a new I/O channel. </p>

</div>
</div>
<a id="a34754a98debd5e095bf06889fbaed6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34754a98debd5e095bf06889fbaed6aa">&#9670;&nbsp;</a></span>spdk_get_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_thread* spdk_get_thread </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a handle to the current thread. </p>
<p>This handle may be passed to other threads and used as the target of <a class="el" href="io__channel_8h.html#a6aa832fea18a9160429b5383f36d8539" title="Send a message to the given thread. ">spdk_thread_send_msg()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="io__channel_8h.html#a8ff9537d26ac923a7a93cd55ba315b5b" title="Returns the spdk_thread associated with an I/O channel. ">spdk_io_channel_get_thread()</a> </dd></dl>

</div>
</div>
<a id="a6a0b6fdbfd40673bce799a1a7ebab187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0b6fdbfd40673bce799a1a7ebab187">&#9670;&nbsp;</a></span>spdk_io_device_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_io_device_register </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_io_channel_create_cb&#160;</td>
          <td class="paramname"><em>create_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_io_channel_destroy_cb&#160;</td>
          <td class="paramname"><em>destroy_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctx_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the opaque io_device context as an I/O device. </p>
<p>After an I/O device is registered, it can return I/O channels using the <a class="el" href="io__channel_8h.html#a8537c42a7aa203b50578efed509d9ba8" title="Gets an I/O channel for the specified io_device to be used by the calling thread. ...">spdk_get_io_channel()</a> function. create_cb is the callback function invoked to allocate any resources required for a new I/O channel. destroy_cb is the callback function invoked to release the resources for an I/O channel. ctx_size is the size of the context buffer allocated to store references to allocated I/O channel resources. </p>

</div>
</div>
<a id="a4c6c3df3a611c10c176cb87966c622f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6c3df3a611c10c176cb87966c622f0">&#9670;&nbsp;</a></span>spdk_io_device_unregister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_io_device_unregister </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>io_device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_io_device_unregister_cb&#160;</td>
          <td class="paramname"><em>unregister_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister the opaque io_device context as an I/O device. </p>
<p>The actual unregistration might be deferred until all active I/O channels are destroyed. unregister_cb is an optional callback function invoked to release any references to this I/O device. </p>

</div>
</div>
<a id="a717571a5011db0cdd730498146f25f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717571a5011db0cdd730498146f25f9a">&#9670;&nbsp;</a></span>spdk_put_io_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_put_io_channel </td>
          <td>(</td>
          <td class="paramtype">struct spdk_io_channel *&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a reference to an I/O channel. </p>
<p>This happens asynchronously.</p>
<p>Actual release will happen on the same thread that called <a class="el" href="io__channel_8h.html#a8537c42a7aa203b50578efed509d9ba8" title="Gets an I/O channel for the specified io_device to be used by the calling thread. ...">spdk_get_io_channel()</a> for the specified I/O channel. If this releases the last reference to the I/O channel, The destroy_cb function specified in <a class="el" href="io__channel_8h.html#a6a0b6fdbfd40673bce799a1a7ebab187" title="Register the opaque io_device context as an I/O device. ">spdk_io_device_register()</a> will be invoked to release any associated resources. </p>

</div>
</div>
<a id="a6aa832fea18a9160429b5383f36d8539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa832fea18a9160429b5383f36d8539">&#9670;&nbsp;</a></span>spdk_thread_send_msg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_thread_send_msg </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_thread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_thread_fn&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to the given thread. </p>
<p>The message may be sent asynchronously - i.e. spdk_thread_send_msg may return prior to <code>fn</code> being called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The target thread. </td></tr>
    <tr><td class="paramname">fn</td><td>This function will be called on the given thread. </td></tr>
    <tr><td class="paramname">ctx</td><td>This context will be passed to fn when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div>
