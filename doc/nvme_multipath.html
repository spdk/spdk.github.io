<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="generator" content="Doxygen 1.9.1" />
  <title>SPDK: NVMe Multipath</title>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  <script type="text/javascript" src="../js/doxyboot.js"></script>
  <script type="text/javascript" src="./navtree.js"></script>
  <link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
<body>
  <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/" aria-label="SPDK">
      <img src="/img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <div class="navbar-nav me-auto">
        <a class="nav-link header-link active" href="../doc/">Documentation</a>
        <a class="nav-link header-link" href="../development/">Development</a>
        <a class="nav-link header-link" href="../community/">Community</a>
        <a class="nav-link header-link" href="../blog/">Blog</a>
      </div>
      <div class="navbar-nav ms-auto me-3">
        <a class="nav-link header-link" href="https://github.com/spdk/spdk">
          <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
      </div>
    </div>
  </nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('nvme_multipath.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">NVMe Multipath </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_nvme_multipath"></a> </p><h1>Introduction</h1>
<p>The NVMe bdev module supports two modes: failover and multipath. In failover mode, only one active connection is maintained and alternate paths are connected only during the switch-over. This can lead to delays and failed I/O reported to upper layers, but it does reduce the number of active connections at any given time. In multipath, active connections are maintained for every path and used based on a policy of either active-passive or active-active. The multipath mode also supports Asymmetric Namespace Access (ANA) and uses that to make policy decisions.</p>
<h1>Design</h1>
<h2>Multipath Mode</h2>
<p>A user may establish connections on multiple independent paths to the same NVMe-oF subsystem for NVMe bdevs by calling the <code>bdev_nvme_attach_controller</code> RPC multiple times with the same NVMe bdev controller name. Additionally, the <code>multipath</code> parameter for this RPC must be set to "multipath" when connecting the second or later paths.</p>
<p>For each path created by the <code>bdev_nvme_attach_controller</code> RPC, an NVMe-oF controller is created. Then the set of namespaces presented by that controller are discovered. For each namespace found, the NVMe bdev module attempts to match it with an existing NVMe bdev. If it finds a match, it adds the given namespace as an alternate path. If it does not find a match, it creates a new NVMe bdev.</p>
<p>I/O and admin qpairs are necessary to access an NVMe-oF controller. A single admin qpair is created and is shared by all SPDK threads. To submit I/O without taking locks, for each SPDK thread, an I/O qpair is created as a dynamic context of an I/O channel for an NVMe-oF controller.</p>
<p>For each SPDK thread, the NVMe bdev module creates an I/O channel for an NVMe bdev and provides it to the upper layer. The I/O channel for the NVMe bdev has an I/O path for each namespace. I/O path is an additional abstraction to submit I/O to a namespace, and consists of an I/O qpair context and a namespace. If an NVMe bdev has multiple namespaces, an I/O channel for the NVMe bdev has a list of multiple I/O paths. The I/O channel for the NVMe bdev has a retry I/O list and has a path selection policy.</p>
<h2>Path Error Recovery</h2>
<p>If the NVMe driver detects an error on a qpair, it disconnects the qpair and notifies the error to the NVMe bdev module. Then the NVMe bdev module starts resetting the corresponding NVMe-oF controller. The NVMe-oF controller reset consists of the following steps: 1) disconnect and delete all I/O qpairs, 2) disconnect admin qpair, 3) connect admin qpair, 4) configure the NVMe-oF controller, and 5) create and connect all I/O qpairs.</p>
<p>If the step 3, 4, or 5 fails, the reset reverts to the step 3 and then it is retried after <code>reconnect_delay_sec</code> seconds. Then the NVMe-oF controller is deleted automatically if it is not recovered within <code>ctrlr_loss_timeout_sec</code> seconds. If <code>ctrlr_loss_timeout_sec</code> is -1, it retries indefinitely.</p>
<p>By default, error detection on a qpair is very slow for TCP and RDMA transports. For fast error detection, a global option, <code>transport_ack_timeout</code>, is useful.</p>
<h2>Path Selection</h2>
<p>Multipath mode supports two path selection policies, active-passive or active-active.</p>
<p>For both path selection policies, only ANA optimal I/O paths are used unless there are no ANA optimal I/O paths available.</p>
<p>For active-passive policy, each I/O channel for an NVMe bdev has a cache to store the first found I/O path which is connected and optimal from ANA and use it for I/O submission. Some users may want to specify the preferred I/O path manually. They can dynamically set the preferred I/O path using the <code>bdev_nvme_set_preferred_path</code> RPC. Such assignment is realized naturally by moving the I/O path to the head of the I/O path list. By default, if the preferred I/O path is restored, failback to it is done automatically. The automatic failback can be disabled by a global option <code>disable_auto_failback</code>. In this case, the <code>bdev_nvme_set_preferred_path</code> RPC can be used to do manual failback.</p>
<p>The active-active policy uses the round-robin algorithm and submits an I/O to each I/O path in circular order.</p>
<h2>I/O Retry</h2>
<p>The NVMe bdev module has a global option, <code>bdev_retry_count</code>, to control the number of retries when an I/O is returned with error. Each I/O has a retry count. If the retry count of an I/O is less than the <code>bdev_retry_count</code>, the I/O is allowed to retry and the retry count is incremented.</p>
<p>NOTE: The <code>bdev_retry_count</code> is not directly used but is required to be non-zero for the process of multipath mode failing over to a different path because the retry count is checked first always when an I/O is returned with error.</p>
<p>Each I/O has a timer to schedule an I/O retry at a particular time in the future. Each I/O channel for an NVMe bdev has a sorted I/O retry list. Retried I/Os are inserted into the I/O retry list.</p>
<p>If an I/O is returned with error, the I/O completion handler in the NVMe bdev module executes the following steps:</p>
<ol type="1">
<li>If the DNR (Do Not Retry) bit is set or the retry count exceeds the limit, then complete the I/O with the returned error.</li>
<li>If the error is a path error, insert the I/O to the I/O retry list with no delay.</li>
<li>Otherwise, insert the I/O to the I/O retry list with the delay reported by the CRD (Command Retry Delay).</li>
</ol>
<p>Then the I/O retry poller is scheduled to the closest expiration. If there is no retried I/O, the I/O retry poller is stopped.</p>
<p>When submitting an I/O, there may be no available I/O path. If there is any I/O path which is recovering, the I/O is inserted to the I/O retry list with one second delay. This may result in queueing many I/Os indefinitely. To avoid such indefinite queueing, per NVMe-oF controller option, <code>fast_io_fail_timeout_sec</code>, is added. If the corresponding NVMe-oF controller is not recovered within <code>fast_io_fail_timeout_sec</code> seconds, the I/O is not queued to wait the recovery but returned with an I/O error to the upper layer.</p>
<h2>Asymmetric Namespace Accesses (ANA) Handling</h2>
<p>If an I/O is returned with an ANA error or an ANA change notice event is received, the ANA log page may be changed. In this case, the NVMe bdev module reads the ANA log page to check the ANA state changes.</p>
<p>As described before, only ANA optimal I/O paths will be used unless there are no ANA optimal paths available.</p>
<p>If an I/O path is in ANA transition, i.e., its namespace reports the ANA inaccessible state or the ANA change state, the NVMe bdev module queues I/Os to wait until the namespace becomes accessible again. The ANA transition should end within the ANATT (ANA Transition Time) seconds. If the namespace does not report the ANA optimized state or the ANA accessible state within the ANATT seconds, I/Os are returned with an I/O error to the upper layer.</p>
<h2>I/O Timeout</h2>
<p>The NVMe driver supports I/O timeout for submitted I/Os. The NVMe bdev module provides three actions when an I/O timeout is notified from the NVMe driver, ABORT, RESET, or NONE. Users can choose one of the actions as a global option, <code>action_on_timeout</code>. Users can set different timeout values for I/O commands and admin commands by global options, <code>timeout_us</code> and <code>timeout_admin_us</code>.</p>
<p>For ABORT, the NVMe bdev module tries aborting the timed out I/O, and if failed, it starts the NVMe-oF controller reset. For RESET, the NVMe bdev module starts the NVMe-oF controller reset.</p>
<h1>Usage</h1>
<p>The following is an example to attach two NVMe-oF controllers and aggregate these into a single NVMe bdev controller <code>Nvme0</code>.</p>
<div class="fragment"><div class="line">./scripts/rpc.py bdev_nvme_attach_controller -b Nvme0 -t rdma -a 192.168.100.8 -s 4420 -f ipv4 -n nqn.2016-06.io.spdk:cnode1 -l -1 -o 20</div>
<div class="line">./scripts/rpc.py bdev_nvme_attach_controller -b Nvme0 -t rdma -a 192.168.100.9 -s 4420 -f ipv4 -n nqn.2016-06.io.spdk:cnode1 -l -1 -o 20 -x multipath</div>
</div><!-- fragment --><p>In this example, if these two NVMe-oF controllers have a shared namespace whose namespace ID is 1, a single NVMe bdev <code>Nvme0n1</code> is created. For the NVMe bdev module, the default value of <code>bdev_retry_count</code> is 3 and I/O retry is enabled by default. <code>ctrlr_loss_timeout_sec</code> is set to -1 and <code>reconnect_delay_sec</code> is set to 20. Hence, NVMe-oF controller reconnect will be retried once per 20 seconds until it succeeds.</p>
<p>To confirm if multipath is configured correctly, two RPCs, <code>bdev_get_bdevs</code> and <code>bdev_nvme_get_controllers</code> are available.</p>
<div class="fragment"><div class="line">./scripts/rpc.py bdev_get_bdevs -b Nvme0n1</div>
<div class="line">./scripts/rpc.py bdev_nvme_get_controllers -n Nvme0</div>
</div><!-- fragment --><p>To monitor the current multipath state, a RPC <code>bdev_nvme_get_io_paths</code> are available.</p>
<div class="fragment"><div class="line">./scripts/rpc.py bdev_nvme_get_io_paths -n Nvme0n1</div>
</div><!-- fragment --><h1>Limitations</h1>
<p>SPDK NVMe multipath is transport protocol independent. Heterogeneous multipath configuration (e.g., TCP and RDMA) is supported. However, in this type of configuration, memory domain is not available yet because memory domain is supported only by the RDMA transport now.</p>
<p>The RPCs, <code>bdev_get_iostat</code> and <code>bdev_nvme_get_transport_statistics</code> display I/O statistics but both are not aware of multipath. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.1 </li>
</ul>
</div>
</div>
</body>
</html>
