<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Doxygen 1.10.0" />
	<title>SPDK: nvmf.h File Reference</title>
	<script src="https://code.jquery.com/jquery-3.7.1.slim.min.js" integrity="sha256-kmHvs0B+OpCW5GVHUNjv9rOmY0IvSIRcf7zGUDTDQM8=" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.11.8/umd/popper.min.js" integrity="sha512-TPh2Oxlg1zp+kz3nFA0C5vVC6leG/6mm1z9+mA81MI5eaUVqasPLO8Cuk4gMF4gUfP5etR73rgU/8PNMsSesoQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js" integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+" crossorigin="anonymous"></script>
	<script type="text/javascript" src="../js/doxyboot.js"></script>
	<script type="text/javascript">
		$( document ).ready(function() {
			$("#cn_lang_btn").remove();
		});
	</script>
	<script type="text/javascript" src="./navtree.js"></script>
	<link rel="stylesheet" href='https://fonts.googleapis.com/css?family=Roboto:400,900' type='text/css'>
	<link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
	<link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
  <body>
    <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <a class="navbar-brand" href="/" aria-label="SPDK">
    <img src="../img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
  </a>
  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <div class="navbar-nav me-auto">
      <a class="nav-link header-link"
      href="../releases/">
        download
      </a>
      <a class="nav-link header-link active text-white"
      href="/doc/">
        documentation
      </a>
      <a class="nav-link header-link"
      href="../development/">
        development
      </a>
      <a class="nav-link header-link"
      href="/ci/">
        CI status
      </a>
      <a class="nav-link header-link"
      href="../community/">
        community
      </a>
      <a class="nav-link header-link"
      href="../blog/">
        Blog
      </a>
      <a class="nav-link header-link"
      href="https://github.com/orgs/spdk/projects/5">
        Roadmap
      </a>
      <a class="nav-link header-link"
      href="../news/">
        News
      </a>
    </div>
    <div class="navbar-nav ms-auto me-3">
      <a class="nav-link header-link" href="https://github.com/spdk/spdk">
        <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
      </a>
      <a id="cn_lang_btn" href="/cn/doc/" class="nav-link header-link">中文</a>
    </div>
  </div>
</nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('nvmf_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">nvmf.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>NVMe over Fabrics target public API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__target__opts.html">spdk_nvmf_target_opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__listen__opts.html">spdk_nvmf_listen_opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__poll__group__stat.html">spdk_nvmf_poll_group_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__referral__opts.html">spdk_nvmf_referral_opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__host__opts.html">spdk_nvmf_host_opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__listener__opts.html">spdk_nvmf_listener_opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe-oF target namespace creation options.  <a href="structspdk__nvmf__ns__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__registrant__info.html">spdk_nvmf_registrant_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__reservation__info.html">spdk_nvmf_reservation_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__ns__reservation__ops.html">spdk_nvmf_ns_reservation_ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa14fa429c146d151fd9ef3d53df80da8" id="r_aa14fa429c146d151fd9ef3d53df80da8"><td class="memItemLeft" align="right" valign="top"><a id="aa14fa429c146d151fd9ef3d53df80da8" name="aa14fa429c146d151fd9ef3d53df80da8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NVMF_TGT_NAME_MAX_LENGTH</b>&#160;&#160;&#160;256</td></tr>
<tr class="separator:aa14fa429c146d151fd9ef3d53df80da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f78e79bc3f8adf4f29bee917f9a4490" id="r_a3f78e79bc3f8adf4f29bee917f9a4490"><td class="memItemLeft" align="right" valign="top"><a id="a3f78e79bc3f8adf4f29bee917f9a4490" name="a3f78e79bc3f8adf4f29bee917f9a4490"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_TLS_PSK_MAX_LEN</b>&#160;&#160;&#160;200</td></tr>
<tr class="separator:a3f78e79bc3f8adf4f29bee917f9a4490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad363e22da22e132efbce02f253f37b5" id="r_aad363e22da22e132efbce02f253f37b5"><td class="memItemLeft" align="right" valign="top"><a id="aad363e22da22e132efbce02f253f37b5" name="aad363e22da22e132efbce02f253f37b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVMF_MAX_NUM_REGISTRANTS</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:aad363e22da22e132efbce02f253f37b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aad52ac090dcb26b03da0e689ea71df89" id="r_aad52ac090dcb26b03da0e689ea71df89"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad52ac090dcb26b03da0e689ea71df89">spdk_nvmf_tgt_subsystem_listen_done_fn</a>) (void *ctx, int status)</td></tr>
<tr class="memdesc:aad52ac090dcb26b03da0e689ea71df89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called once asynchronous listen add and remove operations are completed.  <br /></td></tr>
<tr class="separator:aad52ac090dcb26b03da0e689ea71df89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8c1a891179b653f21004c06b58058b" id="r_a6c8c1a891179b653f21004c06b58058b"><td class="memItemLeft" align="right" valign="top"><a id="a6c8c1a891179b653f21004c06b58058b" name="a6c8c1a891179b653f21004c06b58058b"></a>
typedef void&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvmf_tgt_destroy_done_fn</b>(void *ctx, int status)</td></tr>
<tr class="separator:a6c8c1a891179b653f21004c06b58058b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a00f59bb3a8fc493a6cf4c3e8744dab" id="r_a9a00f59bb3a8fc493a6cf4c3e8744dab"><td class="memItemLeft" align="right" valign="top"><a id="a9a00f59bb3a8fc493a6cf4c3e8744dab" name="a9a00f59bb3a8fc493a6cf4c3e8744dab"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvmf_poll_group_destroy_done_fn</b>) (void *cb_arg, int status)</td></tr>
<tr class="separator:a9a00f59bb3a8fc493a6cf4c3e8744dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd02f30e6fcb57338c723ffd5c307f0d" id="r_abd02f30e6fcb57338c723ffd5c307f0d"><td class="memItemLeft" align="right" valign="top"><a id="abd02f30e6fcb57338c723ffd5c307f0d" name="abd02f30e6fcb57338c723ffd5c307f0d"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>nvmf_qpair_disconnect_cb</b>) (void *ctx)</td></tr>
<tr class="separator:abd02f30e6fcb57338c723ffd5c307f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc166b0c39cb5deafea627e5bd16789a" id="r_acc166b0c39cb5deafea627e5bd16789a"><td class="memItemLeft" align="right" valign="top"><a id="acc166b0c39cb5deafea627e5bd16789a" name="acc166b0c39cb5deafea627e5bd16789a"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>nvmf_subsystem_destroy_cb</b>) (void *cb_arg)</td></tr>
<tr class="separator:acc166b0c39cb5deafea627e5bd16789a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7dc3c1e2f740c1cbffa028ad5c5bff" id="r_aec7dc3c1e2f740c1cbffa028ad5c5bff"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a>) (struct spdk_nvmf_subsystem *subsystem, void *cb_arg, int status)</td></tr>
<tr class="memdesc:aec7dc3c1e2f740c1cbffa028ad5c5bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called once the subsystem has changed state.  <br /></td></tr>
<tr class="separator:aec7dc3c1e2f740c1cbffa028ad5c5bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1184eb39bafa4c16dd49f5530118693d" id="r_a1184eb39bafa4c16dd49f5530118693d"><td class="memItemLeft" align="right" valign="top"><a id="a1184eb39bafa4c16dd49f5530118693d" name="a1184eb39bafa4c16dd49f5530118693d"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvmf_transport_create_done_cb</b>) (void *cb_arg, struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *transport)</td></tr>
<tr class="separator:a1184eb39bafa4c16dd49f5530118693d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4f9aa851bdf5f3a5e2f8e384ba74c2" id="r_afc4f9aa851bdf5f3a5e2f8e384ba74c2"><td class="memItemLeft" align="right" valign="top"><a id="afc4f9aa851bdf5f3a5e2f8e384ba74c2" name="afc4f9aa851bdf5f3a5e2f8e384ba74c2"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvmf_transport_destroy_done_cb</b>) (void *cb_arg)</td></tr>
<tr class="separator:afc4f9aa851bdf5f3a5e2f8e384ba74c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53086e85e4a7103ab2b714483b4f2aec" id="r_a53086e85e4a7103ab2b714483b4f2aec"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53086e85e4a7103ab2b714483b4f2aec">spdk_nvmf_tgt_add_transport_done_fn</a>) (void *cb_arg, int status)</td></tr>
<tr class="memdesc:a53086e85e4a7103ab2b714483b4f2aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called once transport add is complete.  <br /></td></tr>
<tr class="separator:a53086e85e4a7103ab2b714483b4f2aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bd8ee037dbbe33729db2eb626267cf" id="r_a50bd8ee037dbbe33729db2eb626267cf"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50bd8ee037dbbe33729db2eb626267cf">spdk_nvmf_tgt_pause_polling_cb_fn</a>) (void *cb_arg, int status)</td></tr>
<tr class="memdesc:a50bd8ee037dbbe33729db2eb626267cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called once target pause is complete.  <br /></td></tr>
<tr class="separator:a50bd8ee037dbbe33729db2eb626267cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654c4a14a9de2ba863abfc1538a3b158" id="r_a654c4a14a9de2ba863abfc1538a3b158"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a654c4a14a9de2ba863abfc1538a3b158">spdk_nvmf_tgt_resume_polling_cb_fn</a>) (void *cb_arg, int status)</td></tr>
<tr class="memdesc:a654c4a14a9de2ba863abfc1538a3b158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called once target resume is complete.  <br /></td></tr>
<tr class="separator:a654c4a14a9de2ba863abfc1538a3b158"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:adad870498ded3fa2168a2f3f663881f3" id="r_adad870498ded3fa2168a2f3f663881f3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adad870498ded3fa2168a2f3f663881f3">spdk_nvmf_tgt_discovery_filter</a> { <a class="el" href="#adad870498ded3fa2168a2f3f663881f3ababebed136f083311d77a55d9182aa85">SPDK_NVMF_TGT_DISCOVERY_MATCH_ANY</a> = 0
, <a class="el" href="#adad870498ded3fa2168a2f3f663881f3ace922fc963e9598bb4e7569b145a3629">SPDK_NVMF_TGT_DISCOVERY_MATCH_TRANSPORT_TYPE</a> = 1u &lt;&lt; 0u
, <a class="el" href="#adad870498ded3fa2168a2f3f663881f3a7805f8d4d557f754e3725eb7b7c60605">SPDK_NVMF_TGT_DISCOVERY_MATCH_TRANSPORT_ADDRESS</a> = 1u &lt;&lt; 1u
, <a class="el" href="#adad870498ded3fa2168a2f3f663881f3a2980fd83e5e8eb239cc1c8dd6d4dc12d">SPDK_NVMF_TGT_DISCOVERY_MATCH_TRANSPORT_SVCID</a> = 1u &lt;&lt; 2u
 }</td></tr>
<tr class="memdesc:adad870498ded3fa2168a2f3f663881f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify filter rules which are applied during discovery log generation.  <a href="#adad870498ded3fa2168a2f3f663881f3">More...</a><br /></td></tr>
<tr class="separator:adad870498ded3fa2168a2f3f663881f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a98f880c34bbea6b3d60895357957ad9d" id="r_a98f880c34bbea6b3d60895357957ad9d"><td class="memItemLeft" align="right" valign="top"><a id="a98f880c34bbea6b3d60895357957ad9d" name="a98f880c34bbea6b3d60895357957ad9d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a>)==72, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a98f880c34bbea6b3d60895357957ad9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa5c20d19d2f6387b833eb1af42d50c" id="r_adaa5c20d19d2f6387b833eb1af42d50c"><td class="memItemLeft" align="right" valign="top"><a id="adaa5c20d19d2f6387b833eb1af42d50c" name="adaa5c20d19d2f6387b833eb1af42d50c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvmf__listen__opts.html">spdk_nvmf_listen_opts</a>)==32, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:adaa5c20d19d2f6387b833eb1af42d50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2405fb75a31157942621df179c7426" id="r_a1b2405fb75a31157942621df179c7426"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b2405fb75a31157942621df179c7426">spdk_nvmf_listen_opts_init</a> (struct <a class="el" href="structspdk__nvmf__listen__opts.html">spdk_nvmf_listen_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:a1b2405fb75a31157942621df179c7426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize listen options.  <br /></td></tr>
<tr class="separator:a1b2405fb75a31157942621df179c7426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a1143157acef6330d8c8c71362793c" id="r_aa9a1143157acef6330d8c8c71362793c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9a1143157acef6330d8c8c71362793c">spdk_nvmf_tgt_add_referral</a> (struct spdk_nvmf_tgt *tgt, const struct <a class="el" href="structspdk__nvmf__referral__opts.html">spdk_nvmf_referral_opts</a> *opts)</td></tr>
<tr class="memdesc:aa9a1143157acef6330d8c8c71362793c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a discovery service referral to an NVMe-oF target.  <br /></td></tr>
<tr class="separator:aa9a1143157acef6330d8c8c71362793c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28824d5f18a5ddf04007906f012199be" id="r_a28824d5f18a5ddf04007906f012199be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28824d5f18a5ddf04007906f012199be">spdk_nvmf_tgt_remove_referral</a> (struct spdk_nvmf_tgt *tgt, const struct <a class="el" href="structspdk__nvmf__referral__opts.html">spdk_nvmf_referral_opts</a> *opts)</td></tr>
<tr class="memdesc:a28824d5f18a5ddf04007906f012199be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a discovery service referral from an NVMeoF target.  <br /></td></tr>
<tr class="separator:a28824d5f18a5ddf04007906f012199be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5d2cb5cc403b1451279e8438340115" id="r_a0c5d2cb5cc403b1451279e8438340115"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_tgt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c5d2cb5cc403b1451279e8438340115">spdk_nvmf_tgt_create</a> (struct <a class="el" href="structspdk__nvmf__target__opts.html">spdk_nvmf_target_opts</a> *opts)</td></tr>
<tr class="memdesc:a0c5d2cb5cc403b1451279e8438340115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an NVMe-oF target.  <br /></td></tr>
<tr class="separator:a0c5d2cb5cc403b1451279e8438340115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21638f4d81002e93d410cd0d267f608c" id="r_a21638f4d81002e93d410cd0d267f608c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21638f4d81002e93d410cd0d267f608c">spdk_nvmf_tgt_destroy</a> (struct spdk_nvmf_tgt *tgt, spdk_nvmf_tgt_destroy_done_fn cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a21638f4d81002e93d410cd0d267f608c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an NVMe-oF target.  <br /></td></tr>
<tr class="separator:a21638f4d81002e93d410cd0d267f608c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6710270c6c14a135c59274f33b07d024" id="r_a6710270c6c14a135c59274f33b07d024"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6710270c6c14a135c59274f33b07d024">spdk_nvmf_tgt_get_name</a> (struct spdk_nvmf_tgt *tgt)</td></tr>
<tr class="memdesc:a6710270c6c14a135c59274f33b07d024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of an NVMe-oF target.  <br /></td></tr>
<tr class="separator:a6710270c6c14a135c59274f33b07d024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb14133ab561a2d9963f5b618181cd16" id="r_afb14133ab561a2d9963f5b618181cd16"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_tgt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb14133ab561a2d9963f5b618181cd16">spdk_nvmf_get_tgt</a> (const char *name)</td></tr>
<tr class="memdesc:afb14133ab561a2d9963f5b618181cd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to an NVMe-oF target.  <br /></td></tr>
<tr class="separator:afb14133ab561a2d9963f5b618181cd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa7d5eab3564dff746939fa5bdb6a54" id="r_a9fa7d5eab3564dff746939fa5bdb6a54"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_tgt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fa7d5eab3564dff746939fa5bdb6a54">spdk_nvmf_get_first_tgt</a> (void)</td></tr>
<tr class="memdesc:a9fa7d5eab3564dff746939fa5bdb6a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the first NVMe-oF target.  <br /></td></tr>
<tr class="separator:a9fa7d5eab3564dff746939fa5bdb6a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bd844f45b587531b7da7b9412cbe05" id="r_ad1bd844f45b587531b7da7b9412cbe05"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_tgt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1bd844f45b587531b7da7b9412cbe05">spdk_nvmf_get_next_tgt</a> (struct spdk_nvmf_tgt *prev)</td></tr>
<tr class="memdesc:ad1bd844f45b587531b7da7b9412cbe05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the first NVMe-oF target.  <br /></td></tr>
<tr class="separator:ad1bd844f45b587531b7da7b9412cbe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aad508811686a6d16f3bfd221ba99a9" id="r_a2aad508811686a6d16f3bfd221ba99a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2aad508811686a6d16f3bfd221ba99a9">spdk_nvmf_tgt_write_config_json</a> (struct spdk_json_write_ctx *w, struct spdk_nvmf_tgt *tgt)</td></tr>
<tr class="memdesc:a2aad508811686a6d16f3bfd221ba99a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write NVMe-oF target configuration into provided JSON context.  <br /></td></tr>
<tr class="separator:a2aad508811686a6d16f3bfd221ba99a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f711797bfc4bc5abf9264daf53b1ef" id="r_a82f711797bfc4bc5abf9264daf53b1ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82f711797bfc4bc5abf9264daf53b1ef">spdk_nvmf_tgt_listen_ext</a> (struct spdk_nvmf_tgt *tgt, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct <a class="el" href="structspdk__nvmf__listen__opts.html">spdk_nvmf_listen_opts</a> *opts)</td></tr>
<tr class="memdesc:a82f711797bfc4bc5abf9264daf53b1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin accepting new connections at the address provided.  <br /></td></tr>
<tr class="separator:a82f711797bfc4bc5abf9264daf53b1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac796e8f25381f344119ef0f44c2a017c" id="r_ac796e8f25381f344119ef0f44c2a017c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac796e8f25381f344119ef0f44c2a017c">spdk_nvmf_tgt_stop_listen</a> (struct spdk_nvmf_tgt *tgt, struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:ac796e8f25381f344119ef0f44c2a017c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop accepting new connections at the provided address.  <br /></td></tr>
<tr class="separator:ac796e8f25381f344119ef0f44c2a017c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1260cb0c712487ad25ae45f32f03b1a4" id="r_a1260cb0c712487ad25ae45f32f03b1a4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__nvmf__poll__group.html">spdk_nvmf_poll_group</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1260cb0c712487ad25ae45f32f03b1a4">spdk_nvmf_poll_group_create</a> (struct spdk_nvmf_tgt *tgt)</td></tr>
<tr class="memdesc:a1260cb0c712487ad25ae45f32f03b1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a poll group.  <br /></td></tr>
<tr class="separator:a1260cb0c712487ad25ae45f32f03b1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468e2246d5e93c69c16a61f3f0bee4fc" id="r_a468e2246d5e93c69c16a61f3f0bee4fc"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__nvmf__poll__group.html">spdk_nvmf_poll_group</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a468e2246d5e93c69c16a61f3f0bee4fc">spdk_nvmf_get_optimal_poll_group</a> (struct <a class="el" href="structspdk__nvmf__qpair.html">spdk_nvmf_qpair</a> *qpair)</td></tr>
<tr class="memdesc:a468e2246d5e93c69c16a61f3f0bee4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get optimal nvmf poll group for the qpair.  <br /></td></tr>
<tr class="separator:a468e2246d5e93c69c16a61f3f0bee4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a23b74ddfec6b8683b3a0afccba10d" id="r_a12a23b74ddfec6b8683b3a0afccba10d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12a23b74ddfec6b8683b3a0afccba10d">spdk_nvmf_poll_group_destroy</a> (struct <a class="el" href="structspdk__nvmf__poll__group.html">spdk_nvmf_poll_group</a> *group, spdk_nvmf_poll_group_destroy_done_fn cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a12a23b74ddfec6b8683b3a0afccba10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a poll group.  <br /></td></tr>
<tr class="separator:a12a23b74ddfec6b8683b3a0afccba10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37eea41a3c3856e0ea2cd383af20183d" id="r_a37eea41a3c3856e0ea2cd383af20183d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37eea41a3c3856e0ea2cd383af20183d">spdk_nvmf_poll_group_add</a> (struct <a class="el" href="structspdk__nvmf__poll__group.html">spdk_nvmf_poll_group</a> *group, struct <a class="el" href="structspdk__nvmf__qpair.html">spdk_nvmf_qpair</a> *qpair)</td></tr>
<tr class="memdesc:a37eea41a3c3856e0ea2cd383af20183d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given qpair to the poll group.  <br /></td></tr>
<tr class="separator:a37eea41a3c3856e0ea2cd383af20183d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5056f8043ae301e8f79cd96172face9" id="r_ab5056f8043ae301e8f79cd96172face9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5056f8043ae301e8f79cd96172face9">spdk_nvmf_qpair_disconnect</a> (struct <a class="el" href="structspdk__nvmf__qpair.html">spdk_nvmf_qpair</a> *qpair)</td></tr>
<tr class="memdesc:ab5056f8043ae301e8f79cd96172face9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect an NVMe-oF qpair.  <br /></td></tr>
<tr class="separator:ab5056f8043ae301e8f79cd96172face9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145a3a2e51799674837dcb1ebf9a13c3" id="r_a145a3a2e51799674837dcb1ebf9a13c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a145a3a2e51799674837dcb1ebf9a13c3">spdk_nvmf_qpair_get_peer_trid</a> (struct <a class="el" href="structspdk__nvmf__qpair.html">spdk_nvmf_qpair</a> *qpair, struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:a145a3a2e51799674837dcb1ebf9a13c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the peer's transport ID for this queue pair.  <br /></td></tr>
<tr class="separator:a145a3a2e51799674837dcb1ebf9a13c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad269e6b66abf6b758569453f4b6fd41a" id="r_ad269e6b66abf6b758569453f4b6fd41a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad269e6b66abf6b758569453f4b6fd41a">spdk_nvmf_qpair_get_local_trid</a> (struct <a class="el" href="structspdk__nvmf__qpair.html">spdk_nvmf_qpair</a> *qpair, struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:ad269e6b66abf6b758569453f4b6fd41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local transport ID for this queue pair.  <br /></td></tr>
<tr class="separator:ad269e6b66abf6b758569453f4b6fd41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261e8613de83e1a557e95a6e06bd0a19" id="r_a261e8613de83e1a557e95a6e06bd0a19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a261e8613de83e1a557e95a6e06bd0a19">spdk_nvmf_qpair_get_listen_trid</a> (struct <a class="el" href="structspdk__nvmf__qpair.html">spdk_nvmf_qpair</a> *qpair, struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:a261e8613de83e1a557e95a6e06bd0a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the associated listener transport ID for this queue pair.  <br /></td></tr>
<tr class="separator:a261e8613de83e1a557e95a6e06bd0a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a593cd20d82a159e7bc6cdfe233242e" id="r_a8a593cd20d82a159e7bc6cdfe233242e"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_subsystem *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a593cd20d82a159e7bc6cdfe233242e">spdk_nvmf_subsystem_create</a> (struct spdk_nvmf_tgt *tgt, const char *nqn, enum <a class="el" href="nvmf__spec_8h.html#a808272f050cc373f3a90871c1528afd4">spdk_nvmf_subtype</a> type, uint32_t num_ns)</td></tr>
<tr class="memdesc:a8a593cd20d82a159e7bc6cdfe233242e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an NVMe-oF subsystem.  <br /></td></tr>
<tr class="separator:a8a593cd20d82a159e7bc6cdfe233242e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fec6c155a532a9a6e4c786930f507a2" id="r_a3fec6c155a532a9a6e4c786930f507a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fec6c155a532a9a6e4c786930f507a2">spdk_nvmf_subsystem_destroy</a> (struct spdk_nvmf_subsystem *subsystem, nvmf_subsystem_destroy_cb cpl_cb, void *cpl_cb_arg)</td></tr>
<tr class="memdesc:a3fec6c155a532a9a6e4c786930f507a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an NVMe-oF subsystem.  <br /></td></tr>
<tr class="separator:a3fec6c155a532a9a6e4c786930f507a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0584bea11782561b13355b89de25b6c0" id="r_a0584bea11782561b13355b89de25b6c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0584bea11782561b13355b89de25b6c0">spdk_nvmf_subsystem_start</a> (struct spdk_nvmf_subsystem *subsystem, <a class="el" href="#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a0584bea11782561b13355b89de25b6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition an NVMe-oF subsystem from Inactive to Active state.  <br /></td></tr>
<tr class="separator:a0584bea11782561b13355b89de25b6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af438291b914963a6c582aad500ded6ef" id="r_af438291b914963a6c582aad500ded6ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af438291b914963a6c582aad500ded6ef">spdk_nvmf_subsystem_stop</a> (struct spdk_nvmf_subsystem *subsystem, <a class="el" href="#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:af438291b914963a6c582aad500ded6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition an NVMe-oF subsystem from Active to Inactive state.  <br /></td></tr>
<tr class="separator:af438291b914963a6c582aad500ded6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be3b7421b631e48f9a0178ed8db8842" id="r_a7be3b7421b631e48f9a0178ed8db8842"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7be3b7421b631e48f9a0178ed8db8842">spdk_nvmf_subsystem_pause</a> (struct spdk_nvmf_subsystem *subsystem, uint32_t nsid, <a class="el" href="#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a7be3b7421b631e48f9a0178ed8db8842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition an NVMe-oF subsystem from Active to Paused state.  <br /></td></tr>
<tr class="separator:a7be3b7421b631e48f9a0178ed8db8842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac21e50a3e893cf2629955dd553e9e32" id="r_aac21e50a3e893cf2629955dd553e9e32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac21e50a3e893cf2629955dd553e9e32">spdk_nvmf_subsystem_resume</a> (struct spdk_nvmf_subsystem *subsystem, <a class="el" href="#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aac21e50a3e893cf2629955dd553e9e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition an NVMe-oF subsystem from Paused to Active state.  <br /></td></tr>
<tr class="separator:aac21e50a3e893cf2629955dd553e9e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e3492d645803e4627134734213c128" id="r_a11e3492d645803e4627134734213c128"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_subsystem *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11e3492d645803e4627134734213c128">spdk_nvmf_tgt_find_subsystem</a> (struct spdk_nvmf_tgt *tgt, const char *subnqn)</td></tr>
<tr class="memdesc:a11e3492d645803e4627134734213c128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the target for a subsystem with the given NQN.  <br /></td></tr>
<tr class="separator:a11e3492d645803e4627134734213c128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb49801320a11c70a6616f140437fc5" id="r_aecb49801320a11c70a6616f140437fc5"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_subsystem *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecb49801320a11c70a6616f140437fc5">spdk_nvmf_subsystem_get_first</a> (struct spdk_nvmf_tgt *tgt)</td></tr>
<tr class="memdesc:aecb49801320a11c70a6616f140437fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterating over all known subsystems.  <br /></td></tr>
<tr class="separator:aecb49801320a11c70a6616f140437fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3bb6efbd00ae6f179bbd0c26114517" id="r_add3bb6efbd00ae6f179bbd0c26114517"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_subsystem *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add3bb6efbd00ae6f179bbd0c26114517">spdk_nvmf_subsystem_get_next</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:add3bb6efbd00ae6f179bbd0c26114517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continue iterating over all known subsystems.  <br /></td></tr>
<tr class="separator:add3bb6efbd00ae6f179bbd0c26114517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efd2d18b66ecd33afadfacc6d5d6f2c" id="r_a7efd2d18b66ecd33afadfacc6d5d6f2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7efd2d18b66ecd33afadfacc6d5d6f2c">spdk_nvmf_ns_add_host</a> (struct spdk_nvmf_subsystem *subsystem, uint32_t nsid, const char *hostnqn, uint32_t flags)</td></tr>
<tr class="memdesc:a7efd2d18b66ecd33afadfacc6d5d6f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the specified namespace visible to the specified host.  <br /></td></tr>
<tr class="separator:a7efd2d18b66ecd33afadfacc6d5d6f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4adca2b5850519d70d7b8295cfc36e8" id="r_af4adca2b5850519d70d7b8295cfc36e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4adca2b5850519d70d7b8295cfc36e8">spdk_nvmf_ns_remove_host</a> (struct spdk_nvmf_subsystem *subsystem, uint32_t nsid, const char *hostnqn, uint32_t flags)</td></tr>
<tr class="memdesc:af4adca2b5850519d70d7b8295cfc36e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the specified namespace not visible to the specified host.  <br /></td></tr>
<tr class="separator:af4adca2b5850519d70d7b8295cfc36e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4082cbddea58f9fc309504a6e8254113" id="r_a4082cbddea58f9fc309504a6e8254113"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4082cbddea58f9fc309504a6e8254113">spdk_nvmf_subsystem_add_host</a> (struct spdk_nvmf_subsystem *subsystem, const char *hostnqn, const struct <a class="el" href="structspdk__json__val.html">spdk_json_val</a> *params)</td></tr>
<tr class="memdesc:a4082cbddea58f9fc309504a6e8254113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow the given host NQN to connect to the given subsystem.  <br /></td></tr>
<tr class="separator:a4082cbddea58f9fc309504a6e8254113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ac57c01bd72c15d94ce6dc8ca14a0c" id="r_a27ac57c01bd72c15d94ce6dc8ca14a0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27ac57c01bd72c15d94ce6dc8ca14a0c">spdk_nvmf_subsystem_add_host_ext</a> (struct spdk_nvmf_subsystem *subsystem, const char *hostnqn, struct <a class="el" href="structspdk__nvmf__host__opts.html">spdk_nvmf_host_opts</a> *opts)</td></tr>
<tr class="memdesc:a27ac57c01bd72c15d94ce6dc8ca14a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow the given host to connect to the given subsystem.  <br /></td></tr>
<tr class="separator:a27ac57c01bd72c15d94ce6dc8ca14a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028b2b8739dfdd896414b5c2fb84faf6" id="r_a028b2b8739dfdd896414b5c2fb84faf6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a028b2b8739dfdd896414b5c2fb84faf6">spdk_nvmf_subsystem_remove_host</a> (struct spdk_nvmf_subsystem *subsystem, const char *hostnqn)</td></tr>
<tr class="memdesc:a028b2b8739dfdd896414b5c2fb84faf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given host NQN from the list of allowed hosts.  <br /></td></tr>
<tr class="separator:a028b2b8739dfdd896414b5c2fb84faf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b4cfdef8236b13193ad8e69be247fe" id="r_a18b4cfdef8236b13193ad8e69be247fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18b4cfdef8236b13193ad8e69be247fe">spdk_nvmf_subsystem_disconnect_host</a> (struct spdk_nvmf_subsystem *subsystem, const char *hostnqn, <a class="el" href="#aad52ac090dcb26b03da0e689ea71df89">spdk_nvmf_tgt_subsystem_listen_done_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a18b4cfdef8236b13193ad8e69be247fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect all connections originating from the provided hostnqn.  <br /></td></tr>
<tr class="separator:a18b4cfdef8236b13193ad8e69be247fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6453b746f3c470e00e23fa4a194cfbd" id="r_ad6453b746f3c470e00e23fa4a194cfbd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6453b746f3c470e00e23fa4a194cfbd">spdk_nvmf_subsystem_set_allow_any_host</a> (struct spdk_nvmf_subsystem *subsystem, bool allow_any_host)</td></tr>
<tr class="memdesc:ad6453b746f3c470e00e23fa4a194cfbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether a subsystem should allow any host or only hosts in the allowed list.  <br /></td></tr>
<tr class="separator:ad6453b746f3c470e00e23fa4a194cfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc793839e2268a097f97962e79e4a1ef" id="r_abc793839e2268a097f97962e79e4a1ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc793839e2268a097f97962e79e4a1ef">spdk_nvmf_subsystem_get_allow_any_host</a> (const struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:abc793839e2268a097f97962e79e4a1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a subsystem should allow any host or only hosts in the allowed list.  <br /></td></tr>
<tr class="separator:abc793839e2268a097f97962e79e4a1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8ded88254cb17d8ee5c378f0e35a25" id="r_a5f8ded88254cb17d8ee5c378f0e35a25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f8ded88254cb17d8ee5c378f0e35a25">spdk_nvmf_subsystem_host_allowed</a> (struct spdk_nvmf_subsystem *subsystem, const char *hostnqn)</td></tr>
<tr class="memdesc:a5f8ded88254cb17d8ee5c378f0e35a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given host is allowed to connect to the subsystem.  <br /></td></tr>
<tr class="separator:a5f8ded88254cb17d8ee5c378f0e35a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ac11a781cf424f6fc519786da5afe9" id="r_a05ac11a781cf424f6fc519786da5afe9"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_host *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05ac11a781cf424f6fc519786da5afe9">spdk_nvmf_subsystem_get_first_host</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a05ac11a781cf424f6fc519786da5afe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first allowed host in a subsystem.  <br /></td></tr>
<tr class="separator:a05ac11a781cf424f6fc519786da5afe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c2f2404cbd46432f0f3289507bc636" id="r_aa7c2f2404cbd46432f0f3289507bc636"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_host *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7c2f2404cbd46432f0f3289507bc636">spdk_nvmf_subsystem_get_next_host</a> (struct spdk_nvmf_subsystem *subsystem, struct spdk_nvmf_host *prev_host)</td></tr>
<tr class="memdesc:aa7c2f2404cbd46432f0f3289507bc636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next allowed host in a subsystem.  <br /></td></tr>
<tr class="separator:aa7c2f2404cbd46432f0f3289507bc636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdcbb06e3dea79cbae4d1e6572dcfd7" id="r_adfdcbb06e3dea79cbae4d1e6572dcfd7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfdcbb06e3dea79cbae4d1e6572dcfd7">spdk_nvmf_host_get_nqn</a> (const struct spdk_nvmf_host *host)</td></tr>
<tr class="memdesc:adfdcbb06e3dea79cbae4d1e6572dcfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a host's NQN.  <br /></td></tr>
<tr class="separator:adfdcbb06e3dea79cbae4d1e6572dcfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ece790c05df3a1f410ef617b2e5cb4" id="r_a96ece790c05df3a1f410ef617b2e5cb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96ece790c05df3a1f410ef617b2e5cb4">spdk_nvmf_subsystem_add_listener</a> (struct spdk_nvmf_subsystem *subsystem, struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, <a class="el" href="#aad52ac090dcb26b03da0e689ea71df89">spdk_nvmf_tgt_subsystem_listen_done_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a96ece790c05df3a1f410ef617b2e5cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept new connections on the address provided.  <br /></td></tr>
<tr class="separator:a96ece790c05df3a1f410ef617b2e5cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1830f7a43d251340587edff8f43809" id="r_aec1830f7a43d251340587edff8f43809"><td class="memItemLeft" align="right" valign="top"><a id="aec1830f7a43d251340587edff8f43809" name="aec1830f7a43d251340587edff8f43809"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvmf__listener__opts.html">spdk_nvmf_listener_opts</a>)==24, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:aec1830f7a43d251340587edff8f43809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59957bc6819accf6a7df37f6352b9a61" id="r_a59957bc6819accf6a7df37f6352b9a61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59957bc6819accf6a7df37f6352b9a61">spdk_nvmf_subsystem_listener_opts_init</a> (struct <a class="el" href="structspdk__nvmf__listener__opts.html">spdk_nvmf_listener_opts</a> *opts, size_t size)</td></tr>
<tr class="memdesc:a59957bc6819accf6a7df37f6352b9a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize options structure for listener creation.  <br /></td></tr>
<tr class="separator:a59957bc6819accf6a7df37f6352b9a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264077cd7633ac2103bd4e293e8a94f5" id="r_a264077cd7633ac2103bd4e293e8a94f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a264077cd7633ac2103bd4e293e8a94f5">spdk_nvmf_subsystem_add_listener_ext</a> (struct spdk_nvmf_subsystem *subsystem, struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, <a class="el" href="#aad52ac090dcb26b03da0e689ea71df89">spdk_nvmf_tgt_subsystem_listen_done_fn</a> cb_fn, void *cb_arg, struct <a class="el" href="structspdk__nvmf__listener__opts.html">spdk_nvmf_listener_opts</a> *opts)</td></tr>
<tr class="memdesc:a264077cd7633ac2103bd4e293e8a94f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept new connections on the address provided.  <br /></td></tr>
<tr class="separator:a264077cd7633ac2103bd4e293e8a94f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77830eafd0e5bdf209be8d9c196fc11" id="r_af77830eafd0e5bdf209be8d9c196fc11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af77830eafd0e5bdf209be8d9c196fc11">spdk_nvmf_subsystem_remove_listener</a> (struct spdk_nvmf_subsystem *subsystem, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:af77830eafd0e5bdf209be8d9c196fc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the listener from subsystem.  <br /></td></tr>
<tr class="separator:af77830eafd0e5bdf209be8d9c196fc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add30a7c425fdb3e986f7bfdcfd1c9a5d" id="r_add30a7c425fdb3e986f7bfdcfd1c9a5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add30a7c425fdb3e986f7bfdcfd1c9a5d">spdk_nvmf_subsystem_listener_allowed</a> (struct spdk_nvmf_subsystem *subsystem, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:add30a7c425fdb3e986f7bfdcfd1c9a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if connections originated from the given address are allowed to connect to the subsystem.  <br /></td></tr>
<tr class="separator:add30a7c425fdb3e986f7bfdcfd1c9a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc73a9ea95c34d1537a2098f04d745b" id="r_affc73a9ea95c34d1537a2098f04d745b"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_subsystem_listener *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affc73a9ea95c34d1537a2098f04d745b">spdk_nvmf_subsystem_get_first_listener</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:affc73a9ea95c34d1537a2098f04d745b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first allowed listen address in the subsystem.  <br /></td></tr>
<tr class="separator:affc73a9ea95c34d1537a2098f04d745b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89bceb864245ef412a2b6513640a6fa" id="r_aa89bceb864245ef412a2b6513640a6fa"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_subsystem_listener *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa89bceb864245ef412a2b6513640a6fa">spdk_nvmf_subsystem_get_next_listener</a> (struct spdk_nvmf_subsystem *subsystem, struct spdk_nvmf_subsystem_listener *prev_listener)</td></tr>
<tr class="memdesc:aa89bceb864245ef412a2b6513640a6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next allowed listen address in a subsystem.  <br /></td></tr>
<tr class="separator:aa89bceb864245ef412a2b6513640a6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b9bf282c51cbd3c8f15377f08dcb6b" id="r_a26b9bf282c51cbd3c8f15377f08dcb6b"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26b9bf282c51cbd3c8f15377f08dcb6b">spdk_nvmf_subsystem_listener_get_trid</a> (struct spdk_nvmf_subsystem_listener *listener)</td></tr>
<tr class="memdesc:a26b9bf282c51cbd3c8f15377f08dcb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a listen address' transport ID.  <br /></td></tr>
<tr class="separator:a26b9bf282c51cbd3c8f15377f08dcb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5747c07b3d4ce75b4825597ecf32fde" id="r_ad5747c07b3d4ce75b4825597ecf32fde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5747c07b3d4ce75b4825597ecf32fde">spdk_nvmf_subsystem_allow_any_listener</a> (struct spdk_nvmf_subsystem *subsystem, bool allow_any_listener)</td></tr>
<tr class="memdesc:ad5747c07b3d4ce75b4825597ecf32fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether a subsystem should allow any listen address or only addresses in the allowed list.  <br /></td></tr>
<tr class="separator:ad5747c07b3d4ce75b4825597ecf32fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4f76f43797274eaf8b08a0894526f6" id="r_a8f4f76f43797274eaf8b08a0894526f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f4f76f43797274eaf8b08a0894526f6">spdk_nvmf_subsystem_any_listener_allowed</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a8f4f76f43797274eaf8b08a0894526f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a subsystem allows any listen address or only addresses in the allowed list.  <br /></td></tr>
<tr class="separator:a8f4f76f43797274eaf8b08a0894526f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488442d5a27c5e3c4a88184bd8a5301b" id="r_a488442d5a27c5e3c4a88184bd8a5301b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a488442d5a27c5e3c4a88184bd8a5301b">spdk_nvmf_subsystem_set_ana_reporting</a> (struct spdk_nvmf_subsystem *subsystem, bool ana_reporting)</td></tr>
<tr class="memdesc:a488442d5a27c5e3c4a88184bd8a5301b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether a subsystem supports Asymmetric Namespace Access (ANA) reporting.  <br /></td></tr>
<tr class="separator:a488442d5a27c5e3c4a88184bd8a5301b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2865d5c13e5c7ca972e1577796d8dcf" id="r_af2865d5c13e5c7ca972e1577796d8dcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2865d5c13e5c7ca972e1577796d8dcf">spdk_nvmf_subsystem_get_ana_reporting</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:af2865d5c13e5c7ca972e1577796d8dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether a subsystem supports Asymmetric Namespace Access (ANA) reporting.  <br /></td></tr>
<tr class="separator:af2865d5c13e5c7ca972e1577796d8dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9124f6370456043e55419fdf64879c3e" id="r_a9124f6370456043e55419fdf64879c3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9124f6370456043e55419fdf64879c3e">spdk_nvmf_subsystem_set_ana_state</a> (struct spdk_nvmf_subsystem *subsystem, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, enum spdk_nvme_ana_state ana_state, uint32_t anagrpid, <a class="el" href="#aad52ac090dcb26b03da0e689ea71df89">spdk_nvmf_tgt_subsystem_listen_done_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a9124f6370456043e55419fdf64879c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Asymmetric Namespace Access (ANA) state for the specified ANA group id.  <br /></td></tr>
<tr class="separator:a9124f6370456043e55419fdf64879c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07cc53c49f75e299aa3987f21aa3cbc" id="r_aa07cc53c49f75e299aa3987f21aa3cbc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa07cc53c49f75e299aa3987f21aa3cbc">spdk_nvmf_subsystem_get_ana_state</a> (struct spdk_nvmf_subsystem *subsystem, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, uint32_t anagrpid, enum spdk_nvme_ana_state *ana_state)</td></tr>
<tr class="memdesc:aa07cc53c49f75e299aa3987f21aa3cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Asymmetric Namespace Access (ANA) state for the specified ANA group id.  <br /></td></tr>
<tr class="separator:aa07cc53c49f75e299aa3987f21aa3cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0707ae94a9fd707e2619a938bbfb5bf7" id="r_a0707ae94a9fd707e2619a938bbfb5bf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0707ae94a9fd707e2619a938bbfb5bf7">spdk_nvmf_subsystem_set_cntlid_range</a> (struct spdk_nvmf_subsystem *subsystem, uint16_t min_cntlid, uint16_t max_cntlid)</td></tr>
<tr class="memdesc:a0707ae94a9fd707e2619a938bbfb5bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the controller ID range for a subsystem.  <br /></td></tr>
<tr class="separator:a0707ae94a9fd707e2619a938bbfb5bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ade1fce95316c88732cf605311df1a0" id="r_a7ade1fce95316c88732cf605311df1a0"><td class="memItemLeft" align="right" valign="top"><a id="a7ade1fce95316c88732cf605311df1a0" name="a7ade1fce95316c88732cf605311df1a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_STATIC_ASSERT</b> (sizeof(struct <a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a>)==72, &quot;Incorrect size&quot;)</td></tr>
<tr class="separator:a7ade1fce95316c88732cf605311df1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97d60b3fba2761118d21e411a08e542" id="r_aa97d60b3fba2761118d21e411a08e542"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa97d60b3fba2761118d21e411a08e542">spdk_nvmf_ns_opts_get_defaults</a> (struct <a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:aa97d60b3fba2761118d21e411a08e542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default namespace creation options.  <br /></td></tr>
<tr class="separator:aa97d60b3fba2761118d21e411a08e542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9778ef2894d69144defb4f1547bfec15" id="r_a9778ef2894d69144defb4f1547bfec15"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9778ef2894d69144defb4f1547bfec15">spdk_nvmf_subsystem_add_ns_ext</a> (struct spdk_nvmf_subsystem *subsystem, const char *bdev_name, const struct <a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a> *opts, size_t opts_size, const char *ptpl_file)</td></tr>
<tr class="memdesc:a9778ef2894d69144defb4f1547bfec15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a namespace to a subsystems in the PAUSED or INACTIVE states.  <br /></td></tr>
<tr class="separator:a9778ef2894d69144defb4f1547bfec15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10ac07a403de72643a5e9801e9fec0b" id="r_aa10ac07a403de72643a5e9801e9fec0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa10ac07a403de72643a5e9801e9fec0b">spdk_nvmf_subsystem_remove_ns</a> (struct spdk_nvmf_subsystem *subsystem, uint32_t nsid)</td></tr>
<tr class="memdesc:aa10ac07a403de72643a5e9801e9fec0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a namespace from a subsystem.  <br /></td></tr>
<tr class="separator:aa10ac07a403de72643a5e9801e9fec0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d305c9ee5bd7e1c81a858e4a8ce52c" id="r_a67d305c9ee5bd7e1c81a858e4a8ce52c"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_ns *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67d305c9ee5bd7e1c81a858e4a8ce52c">spdk_nvmf_subsystem_get_first_ns</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a67d305c9ee5bd7e1c81a858e4a8ce52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first allocated namespace in a subsystem.  <br /></td></tr>
<tr class="separator:a67d305c9ee5bd7e1c81a858e4a8ce52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5f0b547113706f119fd6941cc97cc6" id="r_a2d5f0b547113706f119fd6941cc97cc6"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_ns *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d5f0b547113706f119fd6941cc97cc6">spdk_nvmf_subsystem_get_next_ns</a> (struct spdk_nvmf_subsystem *subsystem, struct spdk_nvmf_ns *prev_ns)</td></tr>
<tr class="memdesc:a2d5f0b547113706f119fd6941cc97cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next allocated namespace in a subsystem.  <br /></td></tr>
<tr class="separator:a2d5f0b547113706f119fd6941cc97cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d64a8d0706413597df7a7861a5a9d54" id="r_a3d64a8d0706413597df7a7861a5a9d54"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_ns *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d64a8d0706413597df7a7861a5a9d54">spdk_nvmf_subsystem_get_ns</a> (struct spdk_nvmf_subsystem *subsystem, uint32_t nsid)</td></tr>
<tr class="memdesc:a3d64a8d0706413597df7a7861a5a9d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a namespace in a subsystem by NSID.  <br /></td></tr>
<tr class="separator:a3d64a8d0706413597df7a7861a5a9d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414b91bad7200ab931f14a06585ccc74" id="r_a414b91bad7200ab931f14a06585ccc74"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a414b91bad7200ab931f14a06585ccc74">spdk_nvmf_subsystem_get_max_namespaces</a> (const struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a414b91bad7200ab931f14a06585ccc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of namespaces allowed in a subsystem.  <br /></td></tr>
<tr class="separator:a414b91bad7200ab931f14a06585ccc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b02975c7384755db60436a49e64faec" id="r_a5b02975c7384755db60436a49e64faec"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b02975c7384755db60436a49e64faec">spdk_nvmf_subsystem_get_min_cntlid</a> (const struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a5b02975c7384755db60436a49e64faec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum controller ID allowed in a subsystem.  <br /></td></tr>
<tr class="separator:a5b02975c7384755db60436a49e64faec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf923218a78791aaea0653fbb61bfdc" id="r_afcf923218a78791aaea0653fbb61bfdc"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcf923218a78791aaea0653fbb61bfdc">spdk_nvmf_subsystem_get_max_cntlid</a> (const struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:afcf923218a78791aaea0653fbb61bfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum controller ID allowed in a subsystem.  <br /></td></tr>
<tr class="separator:afcf923218a78791aaea0653fbb61bfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcd2be73f2653c6c14141c4cb481fe2" id="r_afdcd2be73f2653c6c14141c4cb481fe2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdcd2be73f2653c6c14141c4cb481fe2">spdk_nvmf_ns_get_id</a> (const struct spdk_nvmf_ns *ns)</td></tr>
<tr class="memdesc:afdcd2be73f2653c6c14141c4cb481fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a namespace's NSID.  <br /></td></tr>
<tr class="separator:afdcd2be73f2653c6c14141c4cb481fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e66a6397398aed1593cbf38e51b9eb1" id="r_a3e66a6397398aed1593cbf38e51b9eb1"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e66a6397398aed1593cbf38e51b9eb1">spdk_nvmf_ns_get_bdev</a> (struct spdk_nvmf_ns *ns)</td></tr>
<tr class="memdesc:a3e66a6397398aed1593cbf38e51b9eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a namespace's associated bdev.  <br /></td></tr>
<tr class="separator:a3e66a6397398aed1593cbf38e51b9eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af133c734616e019eecb372ce7b096ff5" id="r_af133c734616e019eecb372ce7b096ff5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af133c734616e019eecb372ce7b096ff5">spdk_nvmf_ns_get_opts</a> (const struct spdk_nvmf_ns *ns, struct <a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:af133c734616e019eecb372ce7b096ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the options specified for a namespace.  <br /></td></tr>
<tr class="separator:af133c734616e019eecb372ce7b096ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cfadf7b2f1086f0448a6ccedf6b458" id="r_ad9cfadf7b2f1086f0448a6ccedf6b458"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9cfadf7b2f1086f0448a6ccedf6b458">spdk_nvmf_subsystem_get_sn</a> (const struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:ad9cfadf7b2f1086f0448a6ccedf6b458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the serial number of the specified subsystem.  <br /></td></tr>
<tr class="separator:ad9cfadf7b2f1086f0448a6ccedf6b458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb053c9573460d29898b184957ce05fd" id="r_abb053c9573460d29898b184957ce05fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb053c9573460d29898b184957ce05fd">spdk_nvmf_subsystem_set_sn</a> (struct spdk_nvmf_subsystem *subsystem, const char *sn)</td></tr>
<tr class="memdesc:abb053c9573460d29898b184957ce05fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the serial number for the specified subsystem.  <br /></td></tr>
<tr class="separator:abb053c9573460d29898b184957ce05fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fb4f5b1806fcb56ba39d135de8e4d4" id="r_aa9fb4f5b1806fcb56ba39d135de8e4d4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9fb4f5b1806fcb56ba39d135de8e4d4">spdk_nvmf_subsystem_get_mn</a> (const struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:aa9fb4f5b1806fcb56ba39d135de8e4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the model number of the specified subsystem.  <br /></td></tr>
<tr class="separator:aa9fb4f5b1806fcb56ba39d135de8e4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270a2bbd77c6b97116c7e61b4f1a56ce" id="r_a270a2bbd77c6b97116c7e61b4f1a56ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a270a2bbd77c6b97116c7e61b4f1a56ce">spdk_nvmf_subsystem_set_mn</a> (struct spdk_nvmf_subsystem *subsystem, const char *mn)</td></tr>
<tr class="memdesc:a270a2bbd77c6b97116c7e61b4f1a56ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the model number for the specified subsystem.  <br /></td></tr>
<tr class="separator:a270a2bbd77c6b97116c7e61b4f1a56ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e0404fee2bdf6385c6d09b7e38b62b" id="r_a39e0404fee2bdf6385c6d09b7e38b62b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39e0404fee2bdf6385c6d09b7e38b62b">spdk_nvmf_subsystem_get_nqn</a> (const struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a39e0404fee2bdf6385c6d09b7e38b62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NQN of the specified subsystem.  <br /></td></tr>
<tr class="separator:a39e0404fee2bdf6385c6d09b7e38b62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fbe4ab1d90cda9a1f3fcbf2cb857d" id="r_a0f3fbe4ab1d90cda9a1f3fcbf2cb857d"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="nvmf__spec_8h.html#a808272f050cc373f3a90871c1528afd4">spdk_nvmf_subtype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f3fbe4ab1d90cda9a1f3fcbf2cb857d">spdk_nvmf_subsystem_get_type</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a0f3fbe4ab1d90cda9a1f3fcbf2cb857d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the specified subsystem.  <br /></td></tr>
<tr class="separator:a0f3fbe4ab1d90cda9a1f3fcbf2cb857d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfae99734ec18b90dbb6ef39d1b73860" id="r_acfae99734ec18b90dbb6ef39d1b73860"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfae99734ec18b90dbb6ef39d1b73860">spdk_nvmf_subsystem_get_max_nsid</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:acfae99734ec18b90dbb6ef39d1b73860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum namespace id of the specified subsystem.  <br /></td></tr>
<tr class="separator:acfae99734ec18b90dbb6ef39d1b73860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0241868432ed4cd5687f5add03e52860" id="r_a0241868432ed4cd5687f5add03e52860"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0241868432ed4cd5687f5add03e52860">spdk_nvmf_subsystem_is_discovery</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a0241868432ed4cd5687f5add03e52860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a given subsystem is a discovery subsystem.  <br /></td></tr>
<tr class="separator:a0241868432ed4cd5687f5add03e52860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8e8b2a3f7a8d4b8ab52e1beef87ab0" id="r_a8e8e8b2a3f7a8d4b8ab52e1beef87ab0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e8e8b2a3f7a8d4b8ab52e1beef87ab0">spdk_nvmf_transport_opts_init</a> (const char *transport_name, struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:a8e8e8b2a3f7a8d4b8ab52e1beef87ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize transport options.  <br /></td></tr>
<tr class="separator:a8e8e8b2a3f7a8d4b8ab52e1beef87ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0630939fcf5e862823e2f4f865a3aa4f" id="r_a0630939fcf5e862823e2f4f865a3aa4f"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0630939fcf5e862823e2f4f865a3aa4f">spdk_nvmf_transport_create</a> (const char *transport_name, struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a> *opts)</td></tr>
<tr class="memdesc:a0630939fcf5e862823e2f4f865a3aa4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a protocol transport - deprecated, please use <a class="el" href="#a0849e6b60e188527618dcbde9067b9d3">spdk_nvmf_transport_create_async</a>.  <br /></td></tr>
<tr class="separator:a0630939fcf5e862823e2f4f865a3aa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0849e6b60e188527618dcbde9067b9d3" id="r_a0849e6b60e188527618dcbde9067b9d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0849e6b60e188527618dcbde9067b9d3">spdk_nvmf_transport_create_async</a> (const char *transport_name, struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a> *opts, spdk_nvmf_transport_create_done_cb cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a0849e6b60e188527618dcbde9067b9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a protocol transport.  <br /></td></tr>
<tr class="separator:a0849e6b60e188527618dcbde9067b9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35ee91438fbca24adac655694c64a27" id="r_af35ee91438fbca24adac655694c64a27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af35ee91438fbca24adac655694c64a27">spdk_nvmf_transport_destroy</a> (struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *transport, spdk_nvmf_transport_destroy_done_cb cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:af35ee91438fbca24adac655694c64a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a protocol transport.  <br /></td></tr>
<tr class="separator:af35ee91438fbca24adac655694c64a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70818cdd5ece37e31b93f5856805e0af" id="r_a70818cdd5ece37e31b93f5856805e0af"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70818cdd5ece37e31b93f5856805e0af">spdk_nvmf_tgt_get_transport</a> (struct spdk_nvmf_tgt *tgt, const char *transport_name)</td></tr>
<tr class="memdesc:a70818cdd5ece37e31b93f5856805e0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an existing transport from the target.  <br /></td></tr>
<tr class="separator:a70818cdd5ece37e31b93f5856805e0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fe2a41ba662c8cead03594cd51b154" id="r_a44fe2a41ba662c8cead03594cd51b154"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44fe2a41ba662c8cead03594cd51b154">spdk_nvmf_transport_get_first</a> (struct spdk_nvmf_tgt *tgt)</td></tr>
<tr class="memdesc:a44fe2a41ba662c8cead03594cd51b154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first transport registered with the given target.  <br /></td></tr>
<tr class="separator:a44fe2a41ba662c8cead03594cd51b154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526ce328a1c623a133731e8d03991128" id="r_a526ce328a1c623a133731e8d03991128"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a526ce328a1c623a133731e8d03991128">spdk_nvmf_transport_get_next</a> (struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *transport)</td></tr>
<tr class="memdesc:a526ce328a1c623a133731e8d03991128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next transport in a target's list.  <br /></td></tr>
<tr class="separator:a526ce328a1c623a133731e8d03991128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2b8ad2b192851f1a1f398de8c8a725" id="r_a8f2b8ad2b192851f1a1f398de8c8a725"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f2b8ad2b192851f1a1f398de8c8a725">spdk_nvmf_get_transport_opts</a> (struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *transport)</td></tr>
<tr class="memdesc:a8f2b8ad2b192851f1a1f398de8c8a725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the opts for a given transport.  <br /></td></tr>
<tr class="separator:a8f2b8ad2b192851f1a1f398de8c8a725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63937e4be5fad005cfe7ce15cf60a198" id="r_a63937e4be5fad005cfe7ce15cf60a198"><td class="memItemLeft" align="right" valign="top">spdk_nvme_transport_type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63937e4be5fad005cfe7ce15cf60a198">spdk_nvmf_get_transport_type</a> (struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *transport)</td></tr>
<tr class="memdesc:a63937e4be5fad005cfe7ce15cf60a198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transport type for a given transport.  <br /></td></tr>
<tr class="separator:a63937e4be5fad005cfe7ce15cf60a198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe2dcfdaa1b1bfab7d916fba5c50ec1" id="r_a9fe2dcfdaa1b1bfab7d916fba5c50ec1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fe2dcfdaa1b1bfab7d916fba5c50ec1">spdk_nvmf_get_transport_name</a> (struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *transport)</td></tr>
<tr class="memdesc:a9fe2dcfdaa1b1bfab7d916fba5c50ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transport name for a given transport.  <br /></td></tr>
<tr class="separator:a9fe2dcfdaa1b1bfab7d916fba5c50ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac996bda413ddfc830c6f46aab4fd181" id="r_aac996bda413ddfc830c6f46aab4fd181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac996bda413ddfc830c6f46aab4fd181">spdk_nvmf_tgt_add_transport</a> (struct spdk_nvmf_tgt *tgt, struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *transport, <a class="el" href="#a53086e85e4a7103ab2b714483b4f2aec">spdk_nvmf_tgt_add_transport_done_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aac996bda413ddfc830c6f46aab4fd181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a transport to a target.  <br /></td></tr>
<tr class="separator:aac996bda413ddfc830c6f46aab4fd181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92156a86ff95452980a34428c9312f62" id="r_a92156a86ff95452980a34428c9312f62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92156a86ff95452980a34428c9312f62">spdk_nvmf_tgt_pause_polling</a> (struct spdk_nvmf_tgt *tgt, <a class="el" href="#a50bd8ee037dbbe33729db2eb626267cf">spdk_nvmf_tgt_pause_polling_cb_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a92156a86ff95452980a34428c9312f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause polling on the given target.  <br /></td></tr>
<tr class="separator:a92156a86ff95452980a34428c9312f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d98c9772e618a0eff5bfc5a4a799c3a" id="r_a3d98c9772e618a0eff5bfc5a4a799c3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d98c9772e618a0eff5bfc5a4a799c3a">spdk_nvmf_tgt_resume_polling</a> (struct spdk_nvmf_tgt *tgt, <a class="el" href="#a654c4a14a9de2ba863abfc1538a3b158">spdk_nvmf_tgt_resume_polling_cb_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a3d98c9772e618a0eff5bfc5a4a799c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume polling on the given target.  <br /></td></tr>
<tr class="separator:a3d98c9772e618a0eff5bfc5a4a799c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4a5e4fcd04e30ea3fe4c079e4d9a3a" id="r_aab4a5e4fcd04e30ea3fe4c079e4d9a3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab4a5e4fcd04e30ea3fe4c079e4d9a3a">spdk_nvmf_transport_listen</a> (struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *transport, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct <a class="el" href="structspdk__nvmf__listen__opts.html">spdk_nvmf_listen_opts</a> *opts)</td></tr>
<tr class="memdesc:aab4a5e4fcd04e30ea3fe4c079e4d9a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add listener to transport and begin accepting new connections.  <br /></td></tr>
<tr class="separator:aab4a5e4fcd04e30ea3fe4c079e4d9a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae261eff09a7b8e6d14d2710c169b17df" id="r_ae261eff09a7b8e6d14d2710c169b17df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae261eff09a7b8e6d14d2710c169b17df">spdk_nvmf_transport_stop_listen</a> (struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *transport, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:ae261eff09a7b8e6d14d2710c169b17df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove listener from transport and stop accepting new connections.  <br /></td></tr>
<tr class="separator:ae261eff09a7b8e6d14d2710c169b17df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c3554ddcd16dc80f8d016c9d5d7c9f" id="r_a51c3554ddcd16dc80f8d016c9d5d7c9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51c3554ddcd16dc80f8d016c9d5d7c9f">spdk_nvmf_transport_stop_listen_async</a> (struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *transport, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, struct spdk_nvmf_subsystem *subsystem, <a class="el" href="#aad52ac090dcb26b03da0e689ea71df89">spdk_nvmf_tgt_subsystem_listen_done_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a51c3554ddcd16dc80f8d016c9d5d7c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop accepting new connections at the provided address.  <br /></td></tr>
<tr class="separator:a51c3554ddcd16dc80f8d016c9d5d7c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3584185c147f5b10cf8c2e2b3fa181" id="r_aba3584185c147f5b10cf8c2e2b3fa181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba3584185c147f5b10cf8c2e2b3fa181">spdk_nvmf_poll_group_dump_stat</a> (struct <a class="el" href="structspdk__nvmf__poll__group.html">spdk_nvmf_poll_group</a> *group, struct spdk_json_write_ctx *w)</td></tr>
<tr class="memdesc:aba3584185c147f5b10cf8c2e2b3fa181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump poll group statistics into JSON.  <br /></td></tr>
<tr class="separator:aba3584185c147f5b10cf8c2e2b3fa181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae1cb4c373e0dd8146b81b5ba57ff0b" id="r_a9ae1cb4c373e0dd8146b81b5ba57ff0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ae1cb4c373e0dd8146b81b5ba57ff0b">spdk_nvmf_rdma_init_hooks</a> (struct <a class="el" href="structspdk__nvme__rdma__hooks.html">spdk_nvme_rdma_hooks</a> *hooks)</td></tr>
<tr class="memdesc:a9ae1cb4c373e0dd8146b81b5ba57ff0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global hooks for the RDMA transport, if necessary.  <br /></td></tr>
<tr class="separator:a9ae1cb4c373e0dd8146b81b5ba57ff0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae365f2d881a64ca5adcfe9a179a84597" id="r_ae365f2d881a64ca5adcfe9a179a84597"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae365f2d881a64ca5adcfe9a179a84597">spdk_nvmf_set_custom_ns_reservation_ops</a> (const struct <a class="el" href="structspdk__nvmf__ns__reservation__ops.html">spdk_nvmf_ns_reservation_ops</a> *ops)</td></tr>
<tr class="memdesc:ae365f2d881a64ca5adcfe9a179a84597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set custom handlers for namespace reservation operations.  <br /></td></tr>
<tr class="separator:ae365f2d881a64ca5adcfe9a179a84597"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>NVMe over Fabrics target public API. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aec7dc3c1e2f740c1cbffa028ad5c5bff" name="aec7dc3c1e2f740c1cbffa028ad5c5bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7dc3c1e2f740c1cbffa028ad5c5bff">&#9670;&#160;</a></span>spdk_nvmf_subsystem_state_change_done</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvmf_subsystem_state_change_done) (struct spdk_nvmf_subsystem *subsystem, void *cb_arg, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called once the subsystem has changed state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>NVMe-oF subsystem that has changed state. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to callback function. </td></tr>
    <tr><td class="paramname">status</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53086e85e4a7103ab2b714483b4f2aec" name="a53086e85e4a7103ab2b714483b4f2aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53086e85e4a7103ab2b714483b4f2aec">&#9670;&#160;</a></span>spdk_nvmf_tgt_add_transport_done_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvmf_tgt_add_transport_done_fn) (void *cb_arg, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called once transport add is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument passed to this function. </td></tr>
    <tr><td class="paramname">status</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50bd8ee037dbbe33729db2eb626267cf" name="a50bd8ee037dbbe33729db2eb626267cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50bd8ee037dbbe33729db2eb626267cf">&#9670;&#160;</a></span>spdk_nvmf_tgt_pause_polling_cb_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvmf_tgt_pause_polling_cb_fn) (void *cb_arg, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called once target pause is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument passed to this function. </td></tr>
    <tr><td class="paramname">status</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a654c4a14a9de2ba863abfc1538a3b158" name="a654c4a14a9de2ba863abfc1538a3b158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654c4a14a9de2ba863abfc1538a3b158">&#9670;&#160;</a></span>spdk_nvmf_tgt_resume_polling_cb_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvmf_tgt_resume_polling_cb_fn) (void *cb_arg, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called once target resume is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument passed to this function. </td></tr>
    <tr><td class="paramname">status</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad52ac090dcb26b03da0e689ea71df89" name="aad52ac090dcb26b03da0e689ea71df89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad52ac090dcb26b03da0e689ea71df89">&#9670;&#160;</a></span>spdk_nvmf_tgt_subsystem_listen_done_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvmf_tgt_subsystem_listen_done_fn) (void *ctx, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called once asynchronous listen add and remove operations are completed. </p>
<p>See <a class="el" href="#a96ece790c05df3a1f410ef617b2e5cb4" title="Accept new connections on the address provided.">spdk_nvmf_subsystem_add_listener()</a> and <a class="el" href="#a51c3554ddcd16dc80f8d016c9d5d7c9f" title="Stop accepting new connections at the provided address.">spdk_nvmf_transport_stop_listen_async()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context argument passed to this function. </td></tr>
    <tr><td class="paramname">status</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adad870498ded3fa2168a2f3f663881f3" name="adad870498ded3fa2168a2f3f663881f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad870498ded3fa2168a2f3f663881f3">&#9670;&#160;</a></span>spdk_nvmf_tgt_discovery_filter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#adad870498ded3fa2168a2f3f663881f3">spdk_nvmf_tgt_discovery_filter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify filter rules which are applied during discovery log generation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adad870498ded3fa2168a2f3f663881f3ababebed136f083311d77a55d9182aa85" name="adad870498ded3fa2168a2f3f663881f3ababebed136f083311d77a55d9182aa85"></a>SPDK_NVMF_TGT_DISCOVERY_MATCH_ANY&#160;</td><td class="fielddoc"><p>Log all listeners in discovery log page. </p>
</td></tr>
<tr><td class="fieldname"><a id="adad870498ded3fa2168a2f3f663881f3ace922fc963e9598bb4e7569b145a3629" name="adad870498ded3fa2168a2f3f663881f3ace922fc963e9598bb4e7569b145a3629"></a>SPDK_NVMF_TGT_DISCOVERY_MATCH_TRANSPORT_TYPE&#160;</td><td class="fielddoc"><p>Only log listeners with the same transport type on which the DISCOVERY command was received. </p>
</td></tr>
<tr><td class="fieldname"><a id="adad870498ded3fa2168a2f3f663881f3a7805f8d4d557f754e3725eb7b7c60605" name="adad870498ded3fa2168a2f3f663881f3a7805f8d4d557f754e3725eb7b7c60605"></a>SPDK_NVMF_TGT_DISCOVERY_MATCH_TRANSPORT_ADDRESS&#160;</td><td class="fielddoc"><p>Only log listeners with the same transport address on which the DISCOVERY command was received. </p>
</td></tr>
<tr><td class="fieldname"><a id="adad870498ded3fa2168a2f3f663881f3a2980fd83e5e8eb239cc1c8dd6d4dc12d" name="adad870498ded3fa2168a2f3f663881f3a2980fd83e5e8eb239cc1c8dd6d4dc12d"></a>SPDK_NVMF_TGT_DISCOVERY_MATCH_TRANSPORT_SVCID&#160;</td><td class="fielddoc"><p>Only log listeners with the same transport svcid on which the DISCOVERY command was received. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9fa7d5eab3564dff746939fa5bdb6a54" name="a9fa7d5eab3564dff746939fa5bdb6a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa7d5eab3564dff746939fa5bdb6a54">&#9670;&#160;</a></span>spdk_nvmf_get_first_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_tgt * spdk_nvmf_get_first_tgt </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pointer to the first NVMe-oF target. </p>
<p>Combined with spdk_nvmf_get_next_tgt to iterate over all available targets.</p>
<dl class="section return"><dt>Returns</dt><dd>The first NVMe-oF target. </dd></dl>

</div>
</div>
<a id="ad1bd844f45b587531b7da7b9412cbe05" name="ad1bd844f45b587531b7da7b9412cbe05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bd844f45b587531b7da7b9412cbe05">&#9670;&#160;</a></span>spdk_nvmf_get_next_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_tgt * spdk_nvmf_get_next_tgt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>prev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pointer to the first NVMe-oF target. </p>
<p>Combined with spdk_nvmf_get_first_tgt to iterate over all available targets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>A pointer to the last NVMe-oF target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first NVMe-oF target. </dd></dl>

</div>
</div>
<a id="a468e2246d5e93c69c16a61f3f0bee4fc" name="a468e2246d5e93c69c16a61f3f0bee4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468e2246d5e93c69c16a61f3f0bee4fc">&#9670;&#160;</a></span>spdk_nvmf_get_optimal_poll_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__nvmf__poll__group.html">spdk_nvmf_poll_group</a> * spdk_nvmf_get_optimal_poll_group </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__qpair.html">spdk_nvmf_qpair</a> *</td>          <td class="paramname"><span class="paramname"><em>qpair</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get optimal nvmf poll group for the qpair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>Requested qpair</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a poll group on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="afb14133ab561a2d9963f5b618181cd16" name="afb14133ab561a2d9963f5b618181cd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb14133ab561a2d9963f5b618181cd16">&#9670;&#160;</a></span>spdk_nvmf_get_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_tgt * spdk_nvmf_get_tgt </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to an NVMe-oF target. </p>
<p>In order to support some legacy applications and RPC methods that may rely on the concept that there is only one target, the name parameter can be passed as NULL. If there is only one available target, that target will be returned. Otherwise, name is a required parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name provided when the target was created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The target with the given name, or NULL if no match was found. </dd></dl>

</div>
</div>
<a id="a9fe2dcfdaa1b1bfab7d916fba5c50ec1" name="a9fe2dcfdaa1b1bfab7d916fba5c50ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe2dcfdaa1b1bfab7d916fba5c50ec1">&#9670;&#160;</a></span>spdk_nvmf_get_transport_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_nvmf_get_transport_name </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *</td>          <td class="paramname"><span class="paramname"><em>transport</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transport name for a given transport. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The transport to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transport name for the given transport </dd></dl>

</div>
</div>
<a id="a8f2b8ad2b192851f1a1f398de8c8a725" name="a8f2b8ad2b192851f1a1f398de8c8a725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2b8ad2b192851f1a1f398de8c8a725">&#9670;&#160;</a></span>spdk_nvmf_get_transport_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a> * spdk_nvmf_get_transport_opts </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *</td>          <td class="paramname"><span class="paramname"><em>transport</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the opts for a given transport. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The transport to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The opts associated with the given transport </dd></dl>

</div>
</div>
<a id="a63937e4be5fad005cfe7ce15cf60a198" name="a63937e4be5fad005cfe7ce15cf60a198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63937e4be5fad005cfe7ce15cf60a198">&#9670;&#160;</a></span>spdk_nvmf_get_transport_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spdk_nvme_transport_type_t spdk_nvmf_get_transport_type </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *</td>          <td class="paramname"><span class="paramname"><em>transport</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transport type for a given transport. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The transport to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transport type for the given transport </dd></dl>

</div>
</div>
<a id="adfdcbb06e3dea79cbae4d1e6572dcfd7" name="adfdcbb06e3dea79cbae4d1e6572dcfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdcbb06e3dea79cbae4d1e6572dcfd7">&#9670;&#160;</a></span>spdk_nvmf_host_get_nqn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_nvmf_host_get_nqn </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_host *</td>          <td class="paramname"><span class="paramname"><em>host</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a host's NQN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Host to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NQN of host. </dd></dl>

</div>
</div>
<a id="a1b2405fb75a31157942621df179c7426" name="a1b2405fb75a31157942621df179c7426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2405fb75a31157942621df179c7426">&#9670;&#160;</a></span>spdk_nvmf_listen_opts_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_listen_opts_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__listen__opts.html">spdk_nvmf_listen_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>opts_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize listen options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Listener options. </td></tr>
    <tr><td class="paramname">opts_size</td><td>Must be set to sizeof(struct spdk_nvmf_listen_opts). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7efd2d18b66ecd33afadfacc6d5d6f2c" name="a7efd2d18b66ecd33afadfacc6d5d6f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efd2d18b66ecd33afadfacc6d5d6f2c">&#9670;&#160;</a></span>spdk_nvmf_ns_add_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_ns_add_host </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>nsid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>hostnqn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make the specified namespace visible to the specified host. </p>
<p>May only be performed on subsystems in the PAUSED or INACTIVE states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem the namespace belong to. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace ID to be made visible. </td></tr>
    <tr><td class="paramname">hostnqn</td><td>The NQN for the host. </td></tr>
    <tr><td class="paramname">flags</td><td>Must be zero (reserved for future use).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="a3e66a6397398aed1593cbf38e51b9eb1" name="a3e66a6397398aed1593cbf38e51b9eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e66a6397398aed1593cbf38e51b9eb1">&#9670;&#160;</a></span>spdk_nvmf_ns_get_bdev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> * spdk_nvmf_ns_get_bdev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_ns *</td>          <td class="paramname"><span class="paramname"><em>ns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a namespace's associated bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>backing bdev of ns. </dd></dl>

</div>
</div>
<a id="afdcd2be73f2653c6c14141c4cb481fe2" name="afdcd2be73f2653c6c14141c4cb481fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcd2be73f2653c6c14141c4cb481fe2">&#9670;&#160;</a></span>spdk_nvmf_ns_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvmf_ns_get_id </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_ns *</td>          <td class="paramname"><span class="paramname"><em>ns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a namespace's NSID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSID of ns. </dd></dl>

</div>
</div>
<a id="af133c734616e019eecb372ce7b096ff5" name="af133c734616e019eecb372ce7b096ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af133c734616e019eecb372ce7b096ff5">&#9670;&#160;</a></span>spdk_nvmf_ns_get_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_ns_get_opts </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_ns *</td>          <td class="paramname"><span class="paramname"><em>ns</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>opts_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the options specified for a namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query. </td></tr>
    <tr><td class="paramname">opts</td><td>Output parameter for options. </td></tr>
    <tr><td class="paramname">opts_size</td><td>sizeof(*opts) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa97d60b3fba2761118d21e411a08e542" name="aa97d60b3fba2761118d21e411a08e542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97d60b3fba2761118d21e411a08e542">&#9670;&#160;</a></span>spdk_nvmf_ns_opts_get_defaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_ns_opts_get_defaults </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>opts_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get default namespace creation options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Namespace options to fill with defaults. </td></tr>
    <tr><td class="paramname">opts_size</td><td>sizeof(struct spdk_nvmf_ns_opts) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4adca2b5850519d70d7b8295cfc36e8" name="af4adca2b5850519d70d7b8295cfc36e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4adca2b5850519d70d7b8295cfc36e8">&#9670;&#160;</a></span>spdk_nvmf_ns_remove_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_ns_remove_host </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>nsid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>hostnqn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make the specified namespace not visible to the specified host. </p>
<p>May only be performed on subsystems in the PAUSED or INACTIVE states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem the namespace belong to. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace ID to be made not visible. </td></tr>
    <tr><td class="paramname">hostnqn</td><td>The NQN for the host. </td></tr>
    <tr><td class="paramname">flags</td><td>Must be zero (reserved for future use).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="a37eea41a3c3856e0ea2cd383af20183d" name="a37eea41a3c3856e0ea2cd383af20183d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37eea41a3c3856e0ea2cd383af20183d">&#9670;&#160;</a></span>spdk_nvmf_poll_group_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_poll_group_add </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__poll__group.html">spdk_nvmf_poll_group</a> *</td>          <td class="paramname"><span class="paramname"><em>group</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__qpair.html">spdk_nvmf_qpair</a> *</td>          <td class="paramname"><span class="paramname"><em>qpair</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the given qpair to the poll group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The group to add qpair to. </td></tr>
    <tr><td class="paramname">qpair</td><td>The qpair to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a1260cb0c712487ad25ae45f32f03b1a4" name="a1260cb0c712487ad25ae45f32f03b1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1260cb0c712487ad25ae45f32f03b1a4">&#9670;&#160;</a></span>spdk_nvmf_poll_group_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__nvmf__poll__group.html">spdk_nvmf_poll_group</a> * spdk_nvmf_poll_group_create </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a poll group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The target to create a poll group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a poll group on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a12a23b74ddfec6b8683b3a0afccba10d" name="a12a23b74ddfec6b8683b3a0afccba10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a23b74ddfec6b8683b3a0afccba10d">&#9670;&#160;</a></span>spdk_nvmf_poll_group_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_poll_group_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__poll__group.html">spdk_nvmf_poll_group</a> *</td>          <td class="paramname"><span class="paramname"><em>group</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_nvmf_poll_group_destroy_done_fn</td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a poll group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The poll group to destroy. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A callback that will be called once the poll group is destroyed. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>A context argument passed to cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba3584185c147f5b10cf8c2e2b3fa181" name="aba3584185c147f5b10cf8c2e2b3fa181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3584185c147f5b10cf8c2e2b3fa181">&#9670;&#160;</a></span>spdk_nvmf_poll_group_dump_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_poll_group_dump_stat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__poll__group.html">spdk_nvmf_poll_group</a> *</td>          <td class="paramname"><span class="paramname"><em>group</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_json_write_ctx *</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump poll group statistics into JSON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The group which statistics should be dumped. </td></tr>
    <tr><td class="paramname">w</td><td>The JSON write context to which statistics should be dumped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5056f8043ae301e8f79cd96172face9" name="ab5056f8043ae301e8f79cd96172face9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5056f8043ae301e8f79cd96172face9">&#9670;&#160;</a></span>spdk_nvmf_qpair_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_qpair_disconnect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__qpair.html">spdk_nvmf_qpair</a> *</td>          <td class="paramname"><span class="paramname"><em>qpair</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect an NVMe-oF qpair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The NVMe-oF qpair to disconnect.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success. </dd>
<dd>
-ENOMEM if the function specific context could not be allocated. </dd>
<dd>
-EINPROGRESS if the qpair is already in the process of disconnect. </dd></dl>

</div>
</div>
<a id="a261e8613de83e1a557e95a6e06bd0a19" name="a261e8613de83e1a557e95a6e06bd0a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261e8613de83e1a557e95a6e06bd0a19">&#9670;&#160;</a></span>spdk_nvmf_qpair_get_listen_trid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_qpair_get_listen_trid </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__qpair.html">spdk_nvmf_qpair</a> *</td>          <td class="paramname"><span class="paramname"><em>qpair</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *</td>          <td class="paramname"><span class="paramname"><em>trid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the associated listener transport ID for this queue pair. </p>
<p>This function will first zero the trid structure, and then fill in the relevant trid fields to identify the listener. The relevant fields will depend on the transport, but the subnqn will never be a relevant field for purposes of this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The NVMe-oF qpair </td></tr>
    <tr><td class="paramname">trid</td><td>Output parameter that will contain the transport id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success. </dd>
<dd>
-EINVAL if the qpair is not connected. </dd></dl>

</div>
</div>
<a id="ad269e6b66abf6b758569453f4b6fd41a" name="ad269e6b66abf6b758569453f4b6fd41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad269e6b66abf6b758569453f4b6fd41a">&#9670;&#160;</a></span>spdk_nvmf_qpair_get_local_trid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_qpair_get_local_trid </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__qpair.html">spdk_nvmf_qpair</a> *</td>          <td class="paramname"><span class="paramname"><em>qpair</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *</td>          <td class="paramname"><span class="paramname"><em>trid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local transport ID for this queue pair. </p>
<p>This function will first zero the trid structure, and then fill in the relevant trid fields to identify the listener. The relevant fields will depend on the transport, but the subnqn will never be a relevant field for purposes of this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The NVMe-oF qpair </td></tr>
    <tr><td class="paramname">trid</td><td>Output parameter that will contain the transport id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success. </dd>
<dd>
-EINVAL if the qpair is not connected. </dd></dl>

</div>
</div>
<a id="a145a3a2e51799674837dcb1ebf9a13c3" name="a145a3a2e51799674837dcb1ebf9a13c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145a3a2e51799674837dcb1ebf9a13c3">&#9670;&#160;</a></span>spdk_nvmf_qpair_get_peer_trid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_qpair_get_peer_trid </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__qpair.html">spdk_nvmf_qpair</a> *</td>          <td class="paramname"><span class="paramname"><em>qpair</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *</td>          <td class="paramname"><span class="paramname"><em>trid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the peer's transport ID for this queue pair. </p>
<p>This function will first zero the trid structure, and then fill in the relevant trid fields to identify the listener. The relevant fields will depend on the transport, but the subnqn will never be a relevant field for purposes of this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The NVMe-oF qpair </td></tr>
    <tr><td class="paramname">trid</td><td>Output parameter that will contain the transport id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success. </dd>
<dd>
-EINVAL if the qpair is not connected. </dd></dl>

</div>
</div>
<a id="a9ae1cb4c373e0dd8146b81b5ba57ff0b" name="a9ae1cb4c373e0dd8146b81b5ba57ff0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae1cb4c373e0dd8146b81b5ba57ff0b">&#9670;&#160;</a></span>spdk_nvmf_rdma_init_hooks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_rdma_init_hooks </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__rdma__hooks.html">spdk_nvme_rdma_hooks</a> *</td>          <td class="paramname"><span class="paramname"><em>hooks</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global hooks for the RDMA transport, if necessary. </p>
<p>This call is optional and must be performed prior to probing for any devices. By default, the RDMA transport will use the ibverbs library to create protection domains and register memory. This is a mechanism to subvert that and use an existing registration.</p>
<p>This function may only be called one time per process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hooks</td><td>for initializing global hooks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae365f2d881a64ca5adcfe9a179a84597" name="ae365f2d881a64ca5adcfe9a179a84597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae365f2d881a64ca5adcfe9a179a84597">&#9670;&#160;</a></span>spdk_nvmf_set_custom_ns_reservation_ops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_set_custom_ns_reservation_ops </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvmf__ns__reservation__ops.html">spdk_nvmf_ns_reservation_ops</a> *</td>          <td class="paramname"><span class="paramname"><em>ops</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set custom handlers for namespace reservation operations. </p>
<p>This call allows to override the default namespace reservation operations with custom handlers. This function may only be called before any namespace has been added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>The reservation ops handers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4082cbddea58f9fc309504a6e8254113" name="a4082cbddea58f9fc309504a6e8254113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4082cbddea58f9fc309504a6e8254113">&#9670;&#160;</a></span>spdk_nvmf_subsystem_add_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_add_host </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>hostnqn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__json__val.html">spdk_json_val</a> *</td>          <td class="paramname"><span class="paramname"><em>params</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow the given host NQN to connect to the given subsystem. </p>
<p>Adding a host that's already allowed results in an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to add host to. </td></tr>
    <tr><td class="paramname">hostnqn</td><td>The NQN for the host. </td></tr>
    <tr><td class="paramname">params</td><td>Transport specific parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="a27ac57c01bd72c15d94ce6dc8ca14a0c" name="a27ac57c01bd72c15d94ce6dc8ca14a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ac57c01bd72c15d94ce6dc8ca14a0c">&#9670;&#160;</a></span>spdk_nvmf_subsystem_add_host_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_add_host_ext </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>hostnqn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__host__opts.html">spdk_nvmf_host_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow the given host to connect to the given subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to add host to. </td></tr>
    <tr><td class="paramname">hostnqn</td><td>Host's NQN. </td></tr>
    <tr><td class="paramname">opts</td><td>Host's options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="a96ece790c05df3a1f410ef617b2e5cb4" name="a96ece790c05df3a1f410ef617b2e5cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ece790c05df3a1f410ef617b2e5cb4">&#9670;&#160;</a></span>spdk_nvmf_subsystem_add_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_subsystem_add_listener </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *</td>          <td class="paramname"><span class="paramname"><em>trid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aad52ac090dcb26b03da0e689ea71df89">spdk_nvmf_tgt_subsystem_listen_done_fn</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept new connections on the address provided. </p>
<p>This does not start the listener. Use <a class="el" href="#a82f711797bfc4bc5abf9264daf53b1ef" title="Begin accepting new connections at the address provided.">spdk_nvmf_tgt_listen_ext()</a> for that.</p>
<p>May only be performed on subsystems in the PAUSED or INACTIVE states. No namespaces are required to be paused.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to add listener to. </td></tr>
    <tr><td class="paramname">trid</td><td>The address to accept connections from. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A callback that will be called once the association is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a264077cd7633ac2103bd4e293e8a94f5" name="a264077cd7633ac2103bd4e293e8a94f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a264077cd7633ac2103bd4e293e8a94f5">&#9670;&#160;</a></span>spdk_nvmf_subsystem_add_listener_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_subsystem_add_listener_ext </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *</td>          <td class="paramname"><span class="paramname"><em>trid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aad52ac090dcb26b03da0e689ea71df89">spdk_nvmf_tgt_subsystem_listen_done_fn</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__listener__opts.html">spdk_nvmf_listener_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept new connections on the address provided. </p>
<p>This does not start the listener. Use <a class="el" href="#a82f711797bfc4bc5abf9264daf53b1ef" title="Begin accepting new connections at the address provided.">spdk_nvmf_tgt_listen_ext()</a> for that.</p>
<p>May only be performed on subsystems in the PAUSED or INACTIVE states. No namespaces are required to be paused.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to add listener to. </td></tr>
    <tr><td class="paramname">trid</td><td>The address to accept connections from. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A callback that will be called once the association is complete. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb_fn. </td></tr>
    <tr><td class="paramname">opts</td><td>NULL or options requested for listener creation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9778ef2894d69144defb4f1547bfec15" name="a9778ef2894d69144defb4f1547bfec15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9778ef2894d69144defb4f1547bfec15">&#9670;&#160;</a></span>spdk_nvmf_subsystem_add_ns_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvmf_subsystem_add_ns_ext </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>bdev_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>opts_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>ptpl_file</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a namespace to a subsystems in the PAUSED or INACTIVE states. </p>
<p>May only be performed on subsystems in the PAUSED or INACTIVE states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to add namespace to. </td></tr>
    <tr><td class="paramname">bdev_name</td><td>Block device name to add as a namespace. </td></tr>
    <tr><td class="paramname">opts</td><td>Namespace options, or NULL to use defaults. </td></tr>
    <tr><td class="paramname">opts_size</td><td>sizeof(*opts) </td></tr>
    <tr><td class="paramname">ptpl_file</td><td>Persist through power loss file path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly added NSID on success, or 0 on failure. </dd></dl>

</div>
</div>
<a id="ad5747c07b3d4ce75b4825597ecf32fde" name="ad5747c07b3d4ce75b4825597ecf32fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5747c07b3d4ce75b4825597ecf32fde">&#9670;&#160;</a></span>spdk_nvmf_subsystem_allow_any_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_subsystem_allow_any_listener </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_any_listener</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether a subsystem should allow any listen address or only addresses in the allowed list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to allow dynamic listener assignment. </td></tr>
    <tr><td class="paramname">allow_any_listener</td><td>true to allow dynamic listener assignment for this subsystem, or false to enforce the list configured during subsystem setup. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f4f76f43797274eaf8b08a0894526f6" name="a8f4f76f43797274eaf8b08a0894526f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4f76f43797274eaf8b08a0894526f6">&#9670;&#160;</a></span>spdk_nvmf_subsystem_any_listener_allowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvmf_subsystem_any_listener_allowed </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a subsystem allows any listen address or only addresses in the allowed list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this subsystem allows dynamic management of listen address list, or false if only allows addresses in the list configured during subsystem setup. </dd></dl>

</div>
</div>
<a id="a8a593cd20d82a159e7bc6cdfe233242e" name="a8a593cd20d82a159e7bc6cdfe233242e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a593cd20d82a159e7bc6cdfe233242e">&#9670;&#160;</a></span>spdk_nvmf_subsystem_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_subsystem * spdk_nvmf_subsystem_create </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>nqn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvmf__spec_8h.html#a808272f050cc373f3a90871c1528afd4">spdk_nvmf_subtype</a></td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>num_ns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an NVMe-oF subsystem. </p>
<p>Subsystems are in one of three states: Inactive, Active, Paused. This state affects which operations may be performed on the subsystem. Upon creation, the subsystem will be in the Inactive state and may be activated by calling <a class="el" href="#a0584bea11782561b13355b89de25b6c0" title="Transition an NVMe-oF subsystem from Inactive to Active state.">spdk_nvmf_subsystem_start()</a>. No I/O will be processed in the Inactive or Paused states, but changes to the state of the subsystem may be made.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target that will own this subsystem. </td></tr>
    <tr><td class="paramname">nqn</td><td>The NVMe qualified name of this subsystem. </td></tr>
    <tr><td class="paramname">type</td><td>Whether this subsystem is an I/O subsystem or a Discovery subsystem. </td></tr>
    <tr><td class="paramname">num_ns</td><td>The maximum number of namespaces this subsystem may contain.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a NVMe-oF subsystem on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a3fec6c155a532a9a6e4c786930f507a2" name="a3fec6c155a532a9a6e4c786930f507a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fec6c155a532a9a6e4c786930f507a2">&#9670;&#160;</a></span>spdk_nvmf_subsystem_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_destroy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nvmf_subsystem_destroy_cb</td>          <td class="paramname"><span class="paramname"><em>cpl_cb</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cpl_cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an NVMe-oF subsystem. </p>
<p>A subsystem may only be destroyed when in the Inactive state. See <a class="el" href="#af438291b914963a6c582aad500ded6ef" title="Transition an NVMe-oF subsystem from Active to Inactive state.">spdk_nvmf_subsystem_stop()</a>. A subsystem may be destroyed asynchronously, in that case <b>cpl_cb</b> will be called</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>The NVMe-oF subsystem to destroy. </td></tr>
    <tr><td class="paramname">cpl_cb</td><td>Optional callback to be called if the subsystem is destroyed asynchronously, only called if return value is -EINPROGRESS </td></tr>
    <tr><td class="paramname">cpl_cb_arg</td><td>Optional user context to be passed to <b>cpl_cb</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if subsystem is destroyed, <b>cpl_cb</b> is not called is that case </td></tr>
    <tr><td class="paramname">-EINVAl</td><td>if <b>subsystem</b> is a NULL pointer </td></tr>
    <tr><td class="paramname">-EAGAIN</td><td>if <b>subsystem</b> is not in INACTIVE state </td></tr>
    <tr><td class="paramname">-EALREADY</td><td>if subsystem destruction is already started </td></tr>
    <tr><td class="paramname">-EINPROGRESS</td><td>if subsystem is destroyed asynchronously, cpl_cb will be called in that case </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18b4cfdef8236b13193ad8e69be247fe" name="a18b4cfdef8236b13193ad8e69be247fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b4cfdef8236b13193ad8e69be247fe">&#9670;&#160;</a></span>spdk_nvmf_subsystem_disconnect_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_disconnect_host </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>hostnqn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aad52ac090dcb26b03da0e689ea71df89">spdk_nvmf_tgt_subsystem_listen_done_fn</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect all connections originating from the provided hostnqn. </p>
<p>To disconnect and block all new connections from a host, first call <a class="el" href="#a028b2b8739dfdd896414b5c2fb84faf6" title="Remove the given host NQN from the list of allowed hosts.">spdk_nvmf_subsystem_remove_host()</a> to remove it from the list of allowed hosts, then call <a class="el" href="#a18b4cfdef8236b13193ad8e69be247fe" title="Disconnect all connections originating from the provided hostnqn.">spdk_nvmf_subsystem_disconnect_host()</a> to close any remaining connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to operate on </td></tr>
    <tr><td class="paramname">hostnqn</td><td>The NQN for the host </td></tr>
    <tr><td class="paramname">cb_fn</td><td>The function to call on completion. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>The argument to pass to the cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int. 0 when the asynchronous process starts successfully or a negated errno on failure. </dd></dl>

</div>
</div>
<a id="abc793839e2268a097f97962e79e4a1ef" name="abc793839e2268a097f97962e79e4a1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc793839e2268a097f97962e79e4a1ef">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_allow_any_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvmf_subsystem_get_allow_any_host </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a subsystem should allow any host or only hosts in the allowed list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any host is allowed to connect to this subsystem, or false if connecting hosts must be in the list configured with <a class="el" href="#a4082cbddea58f9fc309504a6e8254113" title="Allow the given host NQN to connect to the given subsystem.">spdk_nvmf_subsystem_add_host()</a>. </dd></dl>

</div>
</div>
<a id="af2865d5c13e5c7ca972e1577796d8dcf" name="af2865d5c13e5c7ca972e1577796d8dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2865d5c13e5c7ca972e1577796d8dcf">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_ana_reporting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvmf_subsystem_get_ana_reporting </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether a subsystem supports Asymmetric Namespace Access (ANA) reporting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if subsystem supports ANA reporting, false otherwise. </dd></dl>

</div>
</div>
<a id="aa07cc53c49f75e299aa3987f21aa3cbc" name="aa07cc53c49f75e299aa3987f21aa3cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07cc53c49f75e299aa3987f21aa3cbc">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_ana_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_get_ana_state </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *</td>          <td class="paramname"><span class="paramname"><em>trid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>anagrpid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum spdk_nvme_ana_state *</td>          <td class="paramname"><span class="paramname"><em>ana_state</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Asymmetric Namespace Access (ANA) state for the specified ANA group id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to operate on </td></tr>
    <tr><td class="paramname">trid</td><td>Address for which the ANA is to be looked up </td></tr>
    <tr><td class="paramname">anagrpid</td><td>The ANA group ID to check for </td></tr>
    <tr><td class="paramname">ana_state</td><td>Output parameter that will contain the ANA state</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="aecb49801320a11c70a6616f140437fc5" name="aecb49801320a11c70a6616f140437fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecb49801320a11c70a6616f140437fc5">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_subsystem * spdk_nvmf_subsystem_get_first </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin iterating over all known subsystems. </p>
<p>If no subsystems are present, return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target to iterate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first NVMe-oF subsystem on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a05ac11a781cf424f6fc519786da5afe9" name="a05ac11a781cf424f6fc519786da5afe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ac11a781cf424f6fc519786da5afe9">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_first_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_host * spdk_nvmf_subsystem_get_first_host </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first allowed host in a subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first allowed host in this subsystem, or NULL if none allowed. </dd></dl>

</div>
</div>
<a id="affc73a9ea95c34d1537a2098f04d745b" name="affc73a9ea95c34d1537a2098f04d745b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc73a9ea95c34d1537a2098f04d745b">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_first_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_subsystem_listener * spdk_nvmf_subsystem_get_first_listener </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first allowed listen address in the subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first allowed listen address in this subsystem, or NULL if none allowed. </dd></dl>

</div>
</div>
<a id="a67d305c9ee5bd7e1c81a858e4a8ce52c" name="a67d305c9ee5bd7e1c81a858e4a8ce52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d305c9ee5bd7e1c81a858e4a8ce52c">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_first_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_ns * spdk_nvmf_subsystem_get_first_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first allocated namespace in a subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first allocated namespace in this subsystem, or NULL if this subsystem has no namespaces. </dd></dl>

</div>
</div>
<a id="afcf923218a78791aaea0653fbb61bfdc" name="afcf923218a78791aaea0653fbb61bfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf923218a78791aaea0653fbb61bfdc">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_max_cntlid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t spdk_nvmf_subsystem_get_max_cntlid </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum controller ID allowed in a subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum controller ID allowed in the subsystem. </dd></dl>

</div>
</div>
<a id="a414b91bad7200ab931f14a06585ccc74" name="a414b91bad7200ab931f14a06585ccc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414b91bad7200ab931f14a06585ccc74">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_max_namespaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvmf_subsystem_get_max_namespaces </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum number of namespaces allowed in a subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of namespaces allowed in the subsystem, or 0 for unlimited. </dd></dl>

</div>
</div>
<a id="acfae99734ec18b90dbb6ef39d1b73860" name="acfae99734ec18b90dbb6ef39d1b73860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfae99734ec18b90dbb6ef39d1b73860">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_max_nsid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvmf_subsystem_get_max_nsid </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get maximum namespace id of the specified subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum namespace id </dd></dl>

</div>
</div>
<a id="a5b02975c7384755db60436a49e64faec" name="a5b02975c7384755db60436a49e64faec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b02975c7384755db60436a49e64faec">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_min_cntlid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t spdk_nvmf_subsystem_get_min_cntlid </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the minimum controller ID allowed in a subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Minimum controller ID allowed in the subsystem. </dd></dl>

</div>
</div>
<a id="aa9fb4f5b1806fcb56ba39d135de8e4d4" name="aa9fb4f5b1806fcb56ba39d135de8e4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fb4f5b1806fcb56ba39d135de8e4d4">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_mn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_nvmf_subsystem_get_mn </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the model number of the specified subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>model number of the specified subsystem. </dd></dl>

</div>
</div>
<a id="add3bb6efbd00ae6f179bbd0c26114517" name="add3bb6efbd00ae6f179bbd0c26114517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3bb6efbd00ae6f179bbd0c26114517">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_subsystem * spdk_nvmf_subsystem_get_next </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Continue iterating over all known subsystems. </p>
<p>If no additional subsystems, return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Previous subsystem returned from <a class="el" href="#aecb49801320a11c70a6616f140437fc5">spdk_nvmf_subsystem_get_first</a> or <a class="el" href="#add3bb6efbd00ae6f179bbd0c26114517">spdk_nvmf_subsystem_get_next</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the next NVMe-oF subsystem on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="aa7c2f2404cbd46432f0f3289507bc636" name="aa7c2f2404cbd46432f0f3289507bc636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c2f2404cbd46432f0f3289507bc636">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_next_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_host * spdk_nvmf_subsystem_get_next_host </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvmf_host *</td>          <td class="paramname"><span class="paramname"><em>prev_host</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next allowed host in a subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query. </td></tr>
    <tr><td class="paramname">prev_host</td><td>Previous host returned from this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next allowed host in this subsystem, or NULL if prev_host was the last host. </dd></dl>

</div>
</div>
<a id="aa89bceb864245ef412a2b6513640a6fa" name="aa89bceb864245ef412a2b6513640a6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89bceb864245ef412a2b6513640a6fa">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_next_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_subsystem_listener * spdk_nvmf_subsystem_get_next_listener </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvmf_subsystem_listener *</td>          <td class="paramname"><span class="paramname"><em>prev_listener</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next allowed listen address in a subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query. </td></tr>
    <tr><td class="paramname">prev_listener</td><td>Previous listen address for this subsystem.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next allowed listen address in this subsystem, or NULL if prev_listener was the last address. </dd></dl>

</div>
</div>
<a id="a2d5f0b547113706f119fd6941cc97cc6" name="a2d5f0b547113706f119fd6941cc97cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5f0b547113706f119fd6941cc97cc6">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_next_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_ns * spdk_nvmf_subsystem_get_next_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvmf_ns *</td>          <td class="paramname"><span class="paramname"><em>prev_ns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next allocated namespace in a subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query. </td></tr>
    <tr><td class="paramname">prev_ns</td><td>Previous ns returned from this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next allocated namespace in this subsystem, or NULL if prev_ns was the last namespace. </dd></dl>

</div>
</div>
<a id="a39e0404fee2bdf6385c6d09b7e38b62b" name="a39e0404fee2bdf6385c6d09b7e38b62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e0404fee2bdf6385c6d09b7e38b62b">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_nqn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_nvmf_subsystem_get_nqn </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NQN of the specified subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NQN of the specified subsystem. </dd></dl>

</div>
</div>
<a id="a3d64a8d0706413597df7a7861a5a9d54" name="a3d64a8d0706413597df7a7861a5a9d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d64a8d0706413597df7a7861a5a9d54">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_ns * spdk_nvmf_subsystem_get_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>nsid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a namespace in a subsystem by NSID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to search. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace ID to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>namespace matching nsid, or NULL if nsid was not found. </dd></dl>

</div>
</div>
<a id="ad9cfadf7b2f1086f0448a6ccedf6b458" name="ad9cfadf7b2f1086f0448a6ccedf6b458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cfadf7b2f1086f0448a6ccedf6b458">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_sn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_nvmf_subsystem_get_sn </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the serial number of the specified subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>serial number of the specified subsystem. </dd></dl>

</div>
</div>
<a id="a0f3fbe4ab1d90cda9a1f3fcbf2cb857d" name="a0f3fbe4ab1d90cda9a1f3fcbf2cb857d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3fbe4ab1d90cda9a1f3fcbf2cb857d">&#9670;&#160;</a></span>spdk_nvmf_subsystem_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvmf__spec_8h.html#a808272f050cc373f3a90871c1528afd4">spdk_nvmf_subtype</a> spdk_nvmf_subsystem_get_type </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of the specified subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type of the specified subsystem. </dd></dl>

</div>
</div>
<a id="a5f8ded88254cb17d8ee5c378f0e35a25" name="a5f8ded88254cb17d8ee5c378f0e35a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8ded88254cb17d8ee5c378f0e35a25">&#9670;&#160;</a></span>spdk_nvmf_subsystem_host_allowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvmf_subsystem_host_allowed </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>hostnqn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given host is allowed to connect to the subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>The subsystem to query. </td></tr>
    <tr><td class="paramname">hostnqn</td><td>The NQN of the host.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if allowed, false if not. </dd></dl>

</div>
</div>
<a id="a0241868432ed4cd5687f5add03e52860" name="a0241868432ed4cd5687f5add03e52860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0241868432ed4cd5687f5add03e52860">&#9670;&#160;</a></span>spdk_nvmf_subsystem_is_discovery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvmf_subsystem_is_discovery </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a given subsystem is a discovery subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a given subsystem is a discovery subsystem, false if the subsystem is an nvm subsystem </dd></dl>

</div>
</div>
<a id="add30a7c425fdb3e986f7bfdcfd1c9a5d" name="add30a7c425fdb3e986f7bfdcfd1c9a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add30a7c425fdb3e986f7bfdcfd1c9a5d">&#9670;&#160;</a></span>spdk_nvmf_subsystem_listener_allowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvmf_subsystem_listener_allowed </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *</td>          <td class="paramname"><span class="paramname"><em>trid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if connections originated from the given address are allowed to connect to the subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>The subsystem to query. </td></tr>
    <tr><td class="paramname">trid</td><td>The listen address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if allowed, or false if not. </dd></dl>

</div>
</div>
<a id="a26b9bf282c51cbd3c8f15377f08dcb6b" name="a26b9bf282c51cbd3c8f15377f08dcb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b9bf282c51cbd3c8f15377f08dcb6b">&#9670;&#160;</a></span>spdk_nvmf_subsystem_listener_get_trid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> * spdk_nvmf_subsystem_listener_get_trid </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem_listener *</td>          <td class="paramname"><span class="paramname"><em>listener</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a listen address' transport ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>This listener.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transport ID for this listener. </dd></dl>

</div>
</div>
<a id="a59957bc6819accf6a7df37f6352b9a61" name="a59957bc6819accf6a7df37f6352b9a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59957bc6819accf6a7df37f6352b9a61">&#9670;&#160;</a></span>spdk_nvmf_subsystem_listener_opts_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_subsystem_listener_opts_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__listener__opts.html">spdk_nvmf_listener_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize options structure for listener creation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Options structure to initialize. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7be3b7421b631e48f9a0178ed8db8842" name="a7be3b7421b631e48f9a0178ed8db8842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be3b7421b631e48f9a0178ed8db8842">&#9670;&#160;</a></span>spdk_nvmf_subsystem_pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_pause </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>nsid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition an NVMe-oF subsystem from Active to Paused state. </p>
<p>In a paused state, all admin queues are frozen across the whole subsystem. If a namespace ID is provided, all commands to that namespace are quiesced and incoming commands for that namespace are queued until the subsystem is resumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>The NVMe-oF subsystem. </td></tr>
    <tr><td class="paramname">nsid</td><td>The namespace to pause. If 0, pause no namespaces. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A function that will be called once the subsystem has changed state. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno on failure. The callback provided will only be called on success. </dd></dl>

</div>
</div>
<a id="a028b2b8739dfdd896414b5c2fb84faf6" name="a028b2b8739dfdd896414b5c2fb84faf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028b2b8739dfdd896414b5c2fb84faf6">&#9670;&#160;</a></span>spdk_nvmf_subsystem_remove_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_remove_host </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>hostnqn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the given host NQN from the list of allowed hosts. </p>
<p>This call only removes the host from the allowed list of hosts. If a host with the given NQN is already connected it will not be disconnected, but it will not be able to create new connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to remove host from. </td></tr>
    <tr><td class="paramname">hostnqn</td><td>The NQN for the host.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="af77830eafd0e5bdf209be8d9c196fc11" name="af77830eafd0e5bdf209be8d9c196fc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77830eafd0e5bdf209be8d9c196fc11">&#9670;&#160;</a></span>spdk_nvmf_subsystem_remove_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_remove_listener </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *</td>          <td class="paramname"><span class="paramname"><em>trid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the listener from subsystem. </p>
<p>New connections to the address won't be propagated to the subsystem. However to stop listening at target level one must use the <a class="el" href="#ac796e8f25381f344119ef0f44c2a017c" title="Stop accepting new connections at the provided address.">spdk_nvmf_tgt_stop_listen()</a>.</p>
<p>May only be performed on subsystems in the PAUSED or INACTIVE states. No namespaces are required to be paused.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to remove listener from. </td></tr>
    <tr><td class="paramname">trid</td><td>The address to no longer accept connections from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="aa10ac07a403de72643a5e9801e9fec0b" name="aa10ac07a403de72643a5e9801e9fec0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10ac07a403de72643a5e9801e9fec0b">&#9670;&#160;</a></span>spdk_nvmf_subsystem_remove_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_remove_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>nsid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a namespace from a subsystem. </p>
<p>May only be performed on subsystems in the PAUSED or INACTIVE states. Additionally, the namespace must be paused.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem the namespace belong to. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace ID to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="aac21e50a3e893cf2629955dd553e9e32" name="aac21e50a3e893cf2629955dd553e9e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac21e50a3e893cf2629955dd553e9e32">&#9670;&#160;</a></span>spdk_nvmf_subsystem_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_resume </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition an NVMe-oF subsystem from Paused to Active state. </p>
<p>This resumes the entire subsystem, including any paused namespaces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>The NVMe-oF subsystem. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A function that will be called once the subsystem has changed state. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno on failure. The callback provided will only be called on success. </dd></dl>

</div>
</div>
<a id="ad6453b746f3c470e00e23fa4a194cfbd" name="ad6453b746f3c470e00e23fa4a194cfbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6453b746f3c470e00e23fa4a194cfbd">&#9670;&#160;</a></span>spdk_nvmf_subsystem_set_allow_any_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_set_allow_any_host </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_any_host</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether a subsystem should allow any host or only hosts in the allowed list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to modify. </td></tr>
    <tr><td class="paramname">allow_any_host</td><td>true to allow any host to connect to this subsystem, or false to enforce the list configured with <a class="el" href="#a4082cbddea58f9fc309504a6e8254113" title="Allow the given host NQN to connect to the given subsystem.">spdk_nvmf_subsystem_add_host()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="a488442d5a27c5e3c4a88184bd8a5301b" name="a488442d5a27c5e3c4a88184bd8a5301b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488442d5a27c5e3c4a88184bd8a5301b">&#9670;&#160;</a></span>spdk_nvmf_subsystem_set_ana_reporting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_set_ana_reporting </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ana_reporting</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether a subsystem supports Asymmetric Namespace Access (ANA) reporting. </p>
<p>May only be performed on subsystems in the INACTIVE state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to modify. </td></tr>
    <tr><td class="paramname">ana_reporting</td><td>true to support or false not to support ANA reporting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="a9124f6370456043e55419fdf64879c3e" name="a9124f6370456043e55419fdf64879c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9124f6370456043e55419fdf64879c3e">&#9670;&#160;</a></span>spdk_nvmf_subsystem_set_ana_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_subsystem_set_ana_state </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *</td>          <td class="paramname"><span class="paramname"><em>trid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum spdk_nvme_ana_state</td>          <td class="paramname"><span class="paramname"><em>ana_state</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>anagrpid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aad52ac090dcb26b03da0e689ea71df89">spdk_nvmf_tgt_subsystem_listen_done_fn</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Asymmetric Namespace Access (ANA) state for the specified ANA group id. </p>
<p>May only be performed on subsystems in the INACTIVE or PAUSED state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to operate on </td></tr>
    <tr><td class="paramname">trid</td><td>Address for which the new state will apply </td></tr>
    <tr><td class="paramname">ana_state</td><td>The ANA state which is to be set </td></tr>
    <tr><td class="paramname">anagrpid</td><td>The ANA group ID to operate on </td></tr>
    <tr><td class="paramname">cb_fn</td><td>The function to call on completion </td></tr>
    <tr><td class="paramname">cb_arg</td><td>The argument to pass to the cb_fn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0707ae94a9fd707e2619a938bbfb5bf7" name="a0707ae94a9fd707e2619a938bbfb5bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0707ae94a9fd707e2619a938bbfb5bf7">&#9670;&#160;</a></span>spdk_nvmf_subsystem_set_cntlid_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_set_cntlid_range </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>min_cntlid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>max_cntlid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the controller ID range for a subsystem. </p>
<p>Valid range is [1, 0xFFEF]. May only be performed on subsystems in the INACTIVE state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to modify. </td></tr>
    <tr><td class="paramname">min_cntlid</td><td>Minimum controller ID. </td></tr>
    <tr><td class="paramname">max_cntlid</td><td>Maximum controller ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="a270a2bbd77c6b97116c7e61b4f1a56ce" name="a270a2bbd77c6b97116c7e61b4f1a56ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270a2bbd77c6b97116c7e61b4f1a56ce">&#9670;&#160;</a></span>spdk_nvmf_subsystem_set_mn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_set_mn </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>mn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the model number for the specified subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to set for. </td></tr>
    <tr><td class="paramname">mn</td><td>model number to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="abb053c9573460d29898b184957ce05fd" name="abb053c9573460d29898b184957ce05fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb053c9573460d29898b184957ce05fd">&#9670;&#160;</a></span>spdk_nvmf_subsystem_set_sn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_set_sn </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>sn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the serial number for the specified subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to set for. </td></tr>
    <tr><td class="paramname">sn</td><td>serial number to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a0584bea11782561b13355b89de25b6c0" name="a0584bea11782561b13355b89de25b6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0584bea11782561b13355b89de25b6c0">&#9670;&#160;</a></span>spdk_nvmf_subsystem_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_start </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition an NVMe-oF subsystem from Inactive to Active state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>The NVMe-oF subsystem. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A function that will be called once the subsystem has changed state. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno on failure. The callback provided will only be called on success. </dd></dl>

</div>
</div>
<a id="af438291b914963a6c582aad500ded6ef" name="af438291b914963a6c582aad500ded6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af438291b914963a6c582aad500ded6ef">&#9670;&#160;</a></span>spdk_nvmf_subsystem_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_stop </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition an NVMe-oF subsystem from Active to Inactive state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>The NVMe-oF subsystem. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A function that will be called once the subsystem has changed state. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno on failure. The callback provided will only be called on success. </dd></dl>

</div>
</div>
<a id="aa9a1143157acef6330d8c8c71362793c" name="aa9a1143157acef6330d8c8c71362793c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a1143157acef6330d8c8c71362793c">&#9670;&#160;</a></span>spdk_nvmf_tgt_add_referral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_tgt_add_referral </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvmf__referral__opts.html">spdk_nvmf_referral_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a discovery service referral to an NVMe-oF target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The target to which the referral will be added </td></tr>
    <tr><td class="paramname">opts</td><td>Options describing the referral referral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negated errno on failure </dd></dl>

</div>
</div>
<a id="aac996bda413ddfc830c6f46aab4fd181" name="aac996bda413ddfc830c6f46aab4fd181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac996bda413ddfc830c6f46aab4fd181">&#9670;&#160;</a></span>spdk_nvmf_tgt_add_transport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_tgt_add_transport </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *</td>          <td class="paramname"><span class="paramname"><em>transport</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a53086e85e4a7103ab2b714483b4f2aec">spdk_nvmf_tgt_add_transport_done_fn</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a transport to a target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target </td></tr>
    <tr><td class="paramname">transport</td><td>The transport to add </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A callback that will be called once the transport is created </td></tr>
    <tr><td class="paramname">cb_arg</td><td>A context argument passed to cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c5d2cb5cc403b1451279e8438340115" name="a0c5d2cb5cc403b1451279e8438340115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5d2cb5cc403b1451279e8438340115">&#9670;&#160;</a></span>spdk_nvmf_tgt_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_tgt * spdk_nvmf_tgt_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__target__opts.html">spdk_nvmf_target_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an NVMe-oF target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>a pointer to an <a class="el" href="structspdk__nvmf__target__opts.html">spdk_nvmf_target_opts</a> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a NVMe-oF target on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a21638f4d81002e93d410cd0d267f608c" name="a21638f4d81002e93d410cd0d267f608c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21638f4d81002e93d410cd0d267f608c">&#9670;&#160;</a></span>spdk_nvmf_tgt_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_tgt_destroy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_nvmf_tgt_destroy_done_fn</td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an NVMe-oF target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The target to destroy. This releases all resources. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A callback that will be called once the target is destroyed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>A context argument passed to cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11e3492d645803e4627134734213c128" name="a11e3492d645803e4627134734213c128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e3492d645803e4627134734213c128">&#9670;&#160;</a></span>spdk_nvmf_tgt_find_subsystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_subsystem * spdk_nvmf_tgt_find_subsystem </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>subnqn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the target for a subsystem with the given NQN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target to search from. </td></tr>
    <tr><td class="paramname">subnqn</td><td>NQN of the subsystem.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the NVMe-oF subsystem on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a6710270c6c14a135c59274f33b07d024" name="a6710270c6c14a135c59274f33b07d024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6710270c6c14a135c59274f33b07d024">&#9670;&#160;</a></span>spdk_nvmf_tgt_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * spdk_nvmf_tgt_get_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of an NVMe-oF target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The target from which to get the name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the target as a null terminated string. </dd></dl>

</div>
</div>
<a id="a70818cdd5ece37e31b93f5856805e0af" name="a70818cdd5ece37e31b93f5856805e0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70818cdd5ece37e31b93f5856805e0af">&#9670;&#160;</a></span>spdk_nvmf_tgt_get_transport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> * spdk_nvmf_tgt_get_transport </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>transport_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an existing transport from the target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target </td></tr>
    <tr><td class="paramname">transport_name</td><td>The name of the transport type to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transport or NULL if not found </dd></dl>

</div>
</div>
<a id="a82f711797bfc4bc5abf9264daf53b1ef" name="a82f711797bfc4bc5abf9264daf53b1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f711797bfc4bc5abf9264daf53b1ef">&#9670;&#160;</a></span>spdk_nvmf_tgt_listen_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_tgt_listen_ext </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *</td>          <td class="paramname"><span class="paramname"><em>trid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__listen__opts.html">spdk_nvmf_listen_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin accepting new connections at the address provided. </p>
<p>The connections will be matched with a subsystem, which may or may not allow the connection based on a subsystem-specific list of allowed hosts. See <a class="el" href="#a4082cbddea58f9fc309504a6e8254113" title="Allow the given host NQN to connect to the given subsystem.">spdk_nvmf_subsystem_add_host()</a> and <a class="el" href="#a96ece790c05df3a1f410ef617b2e5cb4" title="Accept new connections on the address provided.">spdk_nvmf_subsystem_add_listener()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The target associated with this listen address. </td></tr>
    <tr><td class="paramname">trid</td><td>The address to listen at. </td></tr>
    <tr><td class="paramname">opts</td><td>Listener options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negated errno on failure. </dd></dl>

</div>
</div>
<a id="a92156a86ff95452980a34428c9312f62" name="a92156a86ff95452980a34428c9312f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92156a86ff95452980a34428c9312f62">&#9670;&#160;</a></span>spdk_nvmf_tgt_pause_polling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_tgt_pause_polling </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a50bd8ee037dbbe33729db2eb626267cf">spdk_nvmf_tgt_pause_polling_cb_fn</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause polling on the given target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The target to pause </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A callback that will be called once the target is paused </td></tr>
    <tr><td class="paramname">cb_arg</td><td>A context argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if it completed successfully, or negative errno if it failed. </dd></dl>

</div>
</div>
<a id="a28824d5f18a5ddf04007906f012199be" name="a28824d5f18a5ddf04007906f012199be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28824d5f18a5ddf04007906f012199be">&#9670;&#160;</a></span>spdk_nvmf_tgt_remove_referral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_tgt_remove_referral </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvmf__referral__opts.html">spdk_nvmf_referral_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a discovery service referral from an NVMeoF target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The target from which the referral will be removed </td></tr>
    <tr><td class="paramname">opts</td><td>Options describing the referral referral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or a negated errno on failure. </dd></dl>

</div>
</div>
<a id="a3d98c9772e618a0eff5bfc5a4a799c3a" name="a3d98c9772e618a0eff5bfc5a4a799c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d98c9772e618a0eff5bfc5a4a799c3a">&#9670;&#160;</a></span>spdk_nvmf_tgt_resume_polling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_tgt_resume_polling </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a654c4a14a9de2ba863abfc1538a3b158">spdk_nvmf_tgt_resume_polling_cb_fn</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume polling on the given target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The target to resume </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A callback that will be called once the target is resumed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>A context argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if it completed successfully, or negative errno if it failed. </dd></dl>

</div>
</div>
<a id="ac796e8f25381f344119ef0f44c2a017c" name="ac796e8f25381f344119ef0f44c2a017c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac796e8f25381f344119ef0f44c2a017c">&#9670;&#160;</a></span>spdk_nvmf_tgt_stop_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_tgt_stop_listen </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *</td>          <td class="paramname"><span class="paramname"><em>trid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop accepting new connections at the provided address. </p>
<p>This is a counterpart to <a class="el" href="#a82f711797bfc4bc5abf9264daf53b1ef" title="Begin accepting new connections at the address provided.">spdk_nvmf_tgt_listen_ext()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The target associated with the listen address. </td></tr>
    <tr><td class="paramname">trid</td><td>The address to stop listening at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int. 0 on success or a negated errno on failure. </dd></dl>

</div>
</div>
<a id="a2aad508811686a6d16f3bfd221ba99a9" name="a2aad508811686a6d16f3bfd221ba99a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aad508811686a6d16f3bfd221ba99a9">&#9670;&#160;</a></span>spdk_nvmf_tgt_write_config_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_tgt_write_config_json </td>
          <td>(</td>
          <td class="paramtype">struct spdk_json_write_ctx *</td>          <td class="paramname"><span class="paramname"><em>w</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write NVMe-oF target configuration into provided JSON context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>JSON write context </td></tr>
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0630939fcf5e862823e2f4f865a3aa4f" name="a0630939fcf5e862823e2f4f865a3aa4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0630939fcf5e862823e2f4f865a3aa4f">&#9670;&#160;</a></span>spdk_nvmf_transport_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> * spdk_nvmf_transport_create </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>transport_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a protocol transport - deprecated, please use <a class="el" href="#a0849e6b60e188527618dcbde9067b9d3">spdk_nvmf_transport_create_async</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport_name</td><td>The transport type to create </td></tr>
    <tr><td class="paramname">opts</td><td>The transport options (e.g. max_io_size). It should not be NULL, and opts_size pointed in this structure should not be zero value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new transport or NULL if create fails </dd></dl>

</div>
</div>
<a id="a0849e6b60e188527618dcbde9067b9d3" name="a0849e6b60e188527618dcbde9067b9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0849e6b60e188527618dcbde9067b9d3">&#9670;&#160;</a></span>spdk_nvmf_transport_create_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_transport_create_async </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>transport_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_nvmf_transport_create_done_cb</td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a protocol transport. </p>
<p>The callback will be executed asynchronously - i.e. spdk_nvmf_transport_create_async will always return prior to <code>cb_fn</code> being called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport_name</td><td>The transport type to create </td></tr>
    <tr><td class="paramname">opts</td><td>The transport options (e.g. max_io_size). It should not be NULL, and opts_size pointed in this structure should not be zero value. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A callback that will be called once the transport is created </td></tr>
    <tr><td class="paramname">cb_arg</td><td>A context argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negative errno on failure (<code>cb_fn</code> will not be executed then). </dd></dl>

</div>
</div>
<a id="af35ee91438fbca24adac655694c64a27" name="af35ee91438fbca24adac655694c64a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35ee91438fbca24adac655694c64a27">&#9670;&#160;</a></span>spdk_nvmf_transport_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_transport_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *</td>          <td class="paramname"><span class="paramname"><em>transport</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_nvmf_transport_destroy_done_cb</td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a protocol transport. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The transport to destroy </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A callback that will be called once the transport is destroyed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>A context argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a44fe2a41ba662c8cead03594cd51b154" name="a44fe2a41ba662c8cead03594cd51b154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fe2a41ba662c8cead03594cd51b154">&#9670;&#160;</a></span>spdk_nvmf_transport_get_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> * spdk_nvmf_transport_get_first </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *</td>          <td class="paramname"><span class="paramname"><em>tgt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first transport registered with the given target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first transport registered on the target </dd></dl>

</div>
</div>
<a id="a526ce328a1c623a133731e8d03991128" name="a526ce328a1c623a133731e8d03991128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526ce328a1c623a133731e8d03991128">&#9670;&#160;</a></span>spdk_nvmf_transport_get_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> * spdk_nvmf_transport_get_next </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *</td>          <td class="paramname"><span class="paramname"><em>transport</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next transport in a target's list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>A handle to a transport object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next transport associated with the NVMe-oF target </dd></dl>

</div>
</div>
<a id="aab4a5e4fcd04e30ea3fe4c079e4d9a3a" name="aab4a5e4fcd04e30ea3fe4c079e4d9a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4a5e4fcd04e30ea3fe4c079e4d9a3a">&#9670;&#160;</a></span>spdk_nvmf_transport_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_transport_listen </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *</td>          <td class="paramname"><span class="paramname"><em>transport</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *</td>          <td class="paramname"><span class="paramname"><em>trid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__listen__opts.html">spdk_nvmf_listen_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add listener to transport and begin accepting new connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The transport to add listener to. </td></tr>
    <tr><td class="paramname">trid</td><td>The address to listen at. </td></tr>
    <tr><td class="paramname">opts</td><td>Listener options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int. 0 if it completed successfully, or negative errno if it failed. </dd></dl>

</div>
</div>
<a id="a8e8e8b2a3f7a8d4b8ab52e1beef87ab0" name="a8e8e8b2a3f7a8d4b8ab52e1beef87ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8e8b2a3f7a8d4b8ab52e1beef87ab0">&#9670;&#160;</a></span>spdk_nvmf_transport_opts_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvmf_transport_opts_init </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>transport_name</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a> *</td>          <td class="paramname"><span class="paramname"><em>opts</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>opts_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize transport options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport_name</td><td>The transport type to create </td></tr>
    <tr><td class="paramname">opts</td><td>The transport options (e.g. max_io_size) </td></tr>
    <tr><td class="paramname">opts_size</td><td>Must be set to sizeof(struct spdk_nvmf_transport_opts).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool. true if successful, false if transport type not found. </dd></dl>

</div>
</div>
<a id="ae261eff09a7b8e6d14d2710c169b17df" name="ae261eff09a7b8e6d14d2710c169b17df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae261eff09a7b8e6d14d2710c169b17df">&#9670;&#160;</a></span>spdk_nvmf_transport_stop_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_transport_stop_listen </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *</td>          <td class="paramname"><span class="paramname"><em>transport</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *</td>          <td class="paramname"><span class="paramname"><em>trid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove listener from transport and stop accepting new connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The transport to remove listener from </td></tr>
    <tr><td class="paramname">trid</td><td>Address to stop listen at</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int. 0 if it completed successfully, or negative errno if it failed. </dd></dl>

</div>
</div>
<a id="a51c3554ddcd16dc80f8d016c9d5d7c9f" name="a51c3554ddcd16dc80f8d016c9d5d7c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c3554ddcd16dc80f8d016c9d5d7c9f">&#9670;&#160;</a></span>spdk_nvmf_transport_stop_listen_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_transport_stop_listen_async </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport.html">spdk_nvmf_transport</a> *</td>          <td class="paramname"><span class="paramname"><em>transport</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *</td>          <td class="paramname"><span class="paramname"><em>trid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvmf_subsystem *</td>          <td class="paramname"><span class="paramname"><em>subsystem</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aad52ac090dcb26b03da0e689ea71df89">spdk_nvmf_tgt_subsystem_listen_done_fn</a></td>          <td class="paramname"><span class="paramname"><em>cb_fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>cb_arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop accepting new connections at the provided address. </p>
<p>This is a counterpart to <a class="el" href="#a82f711797bfc4bc5abf9264daf53b1ef" title="Begin accepting new connections at the address provided.">spdk_nvmf_tgt_listen_ext()</a>. It differs from <a class="el" href="#ae261eff09a7b8e6d14d2710c169b17df" title="Remove listener from transport and stop accepting new connections.">spdk_nvmf_transport_stop_listen()</a> in that it also destroys qpairs that are connected to the specified listener. Because this function disconnects the qpairs, it has to be asynchronous.</p>
<p>The subsystem is matched using the subsystem parameter, not the subnqn field in the trid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The transport associated with the listen address. </td></tr>
    <tr><td class="paramname">trid</td><td>The address to stop listening at. subnqn must be an empty string. </td></tr>
    <tr><td class="paramname">subsystem</td><td>The subsystem to match for qpairs with the specified trid. If NULL, it will disconnect all qpairs with the specified trid. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>The function to call on completion. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>The argument to pass to the cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int. 0 when the asynchronous process starts successfully or a negated errno on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.10.0 </li>
</ul>
</div>
</div>
</body>
</html>
