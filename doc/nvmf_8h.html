<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.14">
  <title>SPDK: nvmf.h File Reference</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="two.min.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-xs-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://spdk.io/ci/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://trello.com/b/MN8auadQ/spdk-roadmap">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('nvmf_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nvmf.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>NVMe over Fabrics target public API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__target__opts.html">spdk_nvmf_target_opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__poll__group__stat.html">spdk_nvmf_poll_group_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__rdma__device__stat.html">spdk_nvmf_rdma_device_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__transport__poll__group__stat.html">spdk_nvmf_transport_poll_group_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__transport__ops.html">spdk_nvmf_transport_ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NVMe-oF target namespace creation options.  <a href="structspdk__nvmf__ns__opts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa14fa429c146d151fd9ef3d53df80da8"><td class="memItemLeft" align="right" valign="top"><a id="aa14fa429c146d151fd9ef3d53df80da8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NVMF_TGT_NAME_MAX_LENGTH</b>&#160;&#160;&#160;256</td></tr>
<tr class="separator:aa14fa429c146d151fd9ef3d53df80da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeebe98da8b8183865537af9d2fd42f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>SPDK_NVMF_TRANSPORT_REGISTER</b>(name,  transport_ops)</td></tr>
<tr class="separator:abeebe98da8b8183865537af9d2fd42f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa999ebee65c92711a5dce79d06cf81c2"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#aa999ebee65c92711a5dce79d06cf81c2">new_qpair_fn</a>) (struct spdk_nvmf_qpair *qpair, void *cb_arg)</td></tr>
<tr class="memdesc:aa999ebee65c92711a5dce79d06cf81c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called for each newly discovered qpair.  <a href="#aa999ebee65c92711a5dce79d06cf81c2">More...</a><br /></td></tr>
<tr class="separator:aa999ebee65c92711a5dce79d06cf81c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854e30bf69f07bb06b2cbcdd08ca7eba"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a854e30bf69f07bb06b2cbcdd08ca7eba">spdk_nvmf_tgt_listen_done_fn</a>) (void *ctx, int status)</td></tr>
<tr class="memdesc:a854e30bf69f07bb06b2cbcdd08ca7eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called once the target is listening.  <a href="#a854e30bf69f07bb06b2cbcdd08ca7eba">More...</a><br /></td></tr>
<tr class="separator:a854e30bf69f07bb06b2cbcdd08ca7eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c5ae0565e487633e00cdd8819d2d00"><td class="memItemLeft" align="right" valign="top"><a id="a26c5ae0565e487633e00cdd8819d2d00"></a>
typedef void()&#160;</td><td class="memItemRight" valign="bottom"><b>spdk_nvmf_tgt_destroy_done_fn</b>(void *ctx, int status)</td></tr>
<tr class="separator:a26c5ae0565e487633e00cdd8819d2d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd02f30e6fcb57338c723ffd5c307f0d"><td class="memItemLeft" align="right" valign="top"><a id="abd02f30e6fcb57338c723ffd5c307f0d"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>nvmf_qpair_disconnect_cb</b>) (void *ctx)</td></tr>
<tr class="separator:abd02f30e6fcb57338c723ffd5c307f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7dc3c1e2f740c1cbffa028ad5c5bff"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a>) (struct spdk_nvmf_subsystem *subsystem, void *cb_arg, int status)</td></tr>
<tr class="memdesc:aec7dc3c1e2f740c1cbffa028ad5c5bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called once the subsystem has changed state.  <a href="#aec7dc3c1e2f740c1cbffa028ad5c5bff">More...</a><br /></td></tr>
<tr class="separator:aec7dc3c1e2f740c1cbffa028ad5c5bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53086e85e4a7103ab2b714483b4f2aec"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a53086e85e4a7103ab2b714483b4f2aec">spdk_nvmf_tgt_add_transport_done_fn</a>) (void *cb_arg, int status)</td></tr>
<tr class="memdesc:a53086e85e4a7103ab2b714483b4f2aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to be called once transport add is complete.  <a href="#a53086e85e4a7103ab2b714483b4f2aec">More...</a><br /></td></tr>
<tr class="separator:a53086e85e4a7103ab2b714483b4f2aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a16bd65e94dea554b50bd7169850c567d"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_tgt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a16bd65e94dea554b50bd7169850c567d">spdk_nvmf_tgt_create</a> (struct <a class="el" href="structspdk__nvmf__target__opts.html">spdk_nvmf_target_opts</a> *opts)</td></tr>
<tr class="memdesc:a16bd65e94dea554b50bd7169850c567d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an NVMe-oF target.  <a href="#a16bd65e94dea554b50bd7169850c567d">More...</a><br /></td></tr>
<tr class="separator:a16bd65e94dea554b50bd7169850c567d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21638f4d81002e93d410cd0d267f608c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a21638f4d81002e93d410cd0d267f608c">spdk_nvmf_tgt_destroy</a> (struct spdk_nvmf_tgt *tgt, spdk_nvmf_tgt_destroy_done_fn cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a21638f4d81002e93d410cd0d267f608c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an NVMe-oF target.  <a href="#a21638f4d81002e93d410cd0d267f608c">More...</a><br /></td></tr>
<tr class="separator:a21638f4d81002e93d410cd0d267f608c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6882b7cc35f2fe656c8a8c08f9af5a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a4b6882b7cc35f2fe656c8a8c08f9af5a">spdk_nvmf_tgt_get_name</a> (struct spdk_nvmf_tgt *tgt)</td></tr>
<tr class="memdesc:a4b6882b7cc35f2fe656c8a8c08f9af5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of an NVMe-oF target.  <a href="#a4b6882b7cc35f2fe656c8a8c08f9af5a">More...</a><br /></td></tr>
<tr class="separator:a4b6882b7cc35f2fe656c8a8c08f9af5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ac2675a2d592cc584ee403b8bb324a"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_tgt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a43ac2675a2d592cc584ee403b8bb324a">spdk_nvmf_get_tgt</a> (const char *name)</td></tr>
<tr class="memdesc:a43ac2675a2d592cc584ee403b8bb324a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to an NVMe-oF target.  <a href="#a43ac2675a2d592cc584ee403b8bb324a">More...</a><br /></td></tr>
<tr class="separator:a43ac2675a2d592cc584ee403b8bb324a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306b55570dbe1da898083657d382f6f5"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_tgt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a306b55570dbe1da898083657d382f6f5">spdk_nvmf_get_first_tgt</a> (void)</td></tr>
<tr class="memdesc:a306b55570dbe1da898083657d382f6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the first NVMe-oF target.  <a href="#a306b55570dbe1da898083657d382f6f5">More...</a><br /></td></tr>
<tr class="separator:a306b55570dbe1da898083657d382f6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1565a46b36efef782d8cee2f8c6489e8"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_tgt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a1565a46b36efef782d8cee2f8c6489e8">spdk_nvmf_get_next_tgt</a> (struct spdk_nvmf_tgt *prev)</td></tr>
<tr class="memdesc:a1565a46b36efef782d8cee2f8c6489e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the pointer to the first NVMe-oF target.  <a href="#a1565a46b36efef782d8cee2f8c6489e8">More...</a><br /></td></tr>
<tr class="separator:a1565a46b36efef782d8cee2f8c6489e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aad508811686a6d16f3bfd221ba99a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a2aad508811686a6d16f3bfd221ba99a9">spdk_nvmf_tgt_write_config_json</a> (struct spdk_json_write_ctx *w, struct spdk_nvmf_tgt *tgt)</td></tr>
<tr class="memdesc:a2aad508811686a6d16f3bfd221ba99a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write NVMe-oF target configuration into provided JSON context.  <a href="#a2aad508811686a6d16f3bfd221ba99a9">More...</a><br /></td></tr>
<tr class="separator:a2aad508811686a6d16f3bfd221ba99a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c31e57f4634daadf4238bf213a989d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a2c31e57f4634daadf4238bf213a989d6">spdk_nvmf_tgt_listen</a> (struct spdk_nvmf_tgt *tgt, struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, <a class="el" href="nvmf_8h.html#a854e30bf69f07bb06b2cbcdd08ca7eba">spdk_nvmf_tgt_listen_done_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a2c31e57f4634daadf4238bf213a989d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin accepting new connections at the address provided.  <a href="#a2c31e57f4634daadf4238bf213a989d6">More...</a><br /></td></tr>
<tr class="separator:a2c31e57f4634daadf4238bf213a989d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39b568e5ae11462a3e0aef59f8e9fd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#aa39b568e5ae11462a3e0aef59f8e9fd3">spdk_nvmf_tgt_accept</a> (struct spdk_nvmf_tgt *tgt, <a class="el" href="nvmf_8h.html#aa999ebee65c92711a5dce79d06cf81c2">new_qpair_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aa39b568e5ae11462a3e0aef59f8e9fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll the target for incoming connections.  <a href="#aa39b568e5ae11462a3e0aef59f8e9fd3">More...</a><br /></td></tr>
<tr class="separator:aa39b568e5ae11462a3e0aef59f8e9fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1de2ab69c992ce2c732c354a08238f"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_poll_group *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a3b1de2ab69c992ce2c732c354a08238f">spdk_nvmf_poll_group_create</a> (struct spdk_nvmf_tgt *tgt)</td></tr>
<tr class="memdesc:a3b1de2ab69c992ce2c732c354a08238f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a poll group.  <a href="#a3b1de2ab69c992ce2c732c354a08238f">More...</a><br /></td></tr>
<tr class="separator:a3b1de2ab69c992ce2c732c354a08238f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744188acd6e709ed4bc3f7f98a2230f8"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_poll_group *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a744188acd6e709ed4bc3f7f98a2230f8">spdk_nvmf_get_optimal_poll_group</a> (struct spdk_nvmf_qpair *qpair)</td></tr>
<tr class="memdesc:a744188acd6e709ed4bc3f7f98a2230f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get optimal nvmf poll group for the qpair.  <a href="#a744188acd6e709ed4bc3f7f98a2230f8">More...</a><br /></td></tr>
<tr class="separator:a744188acd6e709ed4bc3f7f98a2230f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38d9ac50a79883df08d7faf3a647018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#aa38d9ac50a79883df08d7faf3a647018">spdk_nvmf_poll_group_destroy</a> (struct spdk_nvmf_poll_group *group)</td></tr>
<tr class="memdesc:aa38d9ac50a79883df08d7faf3a647018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a poll group.  <a href="#aa38d9ac50a79883df08d7faf3a647018">More...</a><br /></td></tr>
<tr class="separator:aa38d9ac50a79883df08d7faf3a647018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37eea41a3c3856e0ea2cd383af20183d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a37eea41a3c3856e0ea2cd383af20183d">spdk_nvmf_poll_group_add</a> (struct spdk_nvmf_poll_group *group, struct spdk_nvmf_qpair *qpair)</td></tr>
<tr class="memdesc:a37eea41a3c3856e0ea2cd383af20183d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given qpair to the poll group.  <a href="#a37eea41a3c3856e0ea2cd383af20183d">More...</a><br /></td></tr>
<tr class="separator:a37eea41a3c3856e0ea2cd383af20183d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d5611a2cd71a7d71a08c990cbd29e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ac5d5611a2cd71a7d71a08c990cbd29e7">spdk_nvmf_poll_group_get_stat</a> (struct spdk_nvmf_tgt *tgt, struct <a class="el" href="structspdk__nvmf__poll__group__stat.html">spdk_nvmf_poll_group_stat</a> *stat)</td></tr>
<tr class="memdesc:ac5d5611a2cd71a7d71a08c990cbd29e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current poll group statistics.  <a href="#ac5d5611a2cd71a7d71a08c990cbd29e7">More...</a><br /></td></tr>
<tr class="separator:ac5d5611a2cd71a7d71a08c990cbd29e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa33cb1cf39e04ee533f874ed82e24e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#afa33cb1cf39e04ee533f874ed82e24e5">spdk_nvmf_qpair_disconnect</a> (struct spdk_nvmf_qpair *qpair, nvmf_qpair_disconnect_cb cb_fn, void *ctx)</td></tr>
<tr class="memdesc:afa33cb1cf39e04ee533f874ed82e24e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect an NVMe-oF qpair.  <a href="#afa33cb1cf39e04ee533f874ed82e24e5">More...</a><br /></td></tr>
<tr class="separator:afa33cb1cf39e04ee533f874ed82e24e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145a3a2e51799674837dcb1ebf9a13c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a145a3a2e51799674837dcb1ebf9a13c3">spdk_nvmf_qpair_get_peer_trid</a> (struct spdk_nvmf_qpair *qpair, struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:a145a3a2e51799674837dcb1ebf9a13c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the peer's transport ID for this queue pair.  <a href="#a145a3a2e51799674837dcb1ebf9a13c3">More...</a><br /></td></tr>
<tr class="separator:a145a3a2e51799674837dcb1ebf9a13c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad269e6b66abf6b758569453f4b6fd41a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ad269e6b66abf6b758569453f4b6fd41a">spdk_nvmf_qpair_get_local_trid</a> (struct spdk_nvmf_qpair *qpair, struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:ad269e6b66abf6b758569453f4b6fd41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local transport ID for this queue pair.  <a href="#ad269e6b66abf6b758569453f4b6fd41a">More...</a><br /></td></tr>
<tr class="separator:ad269e6b66abf6b758569453f4b6fd41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261e8613de83e1a557e95a6e06bd0a19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a261e8613de83e1a557e95a6e06bd0a19">spdk_nvmf_qpair_get_listen_trid</a> (struct spdk_nvmf_qpair *qpair, struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:a261e8613de83e1a557e95a6e06bd0a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the associated listener transport ID for this queue pair.  <a href="#a261e8613de83e1a557e95a6e06bd0a19">More...</a><br /></td></tr>
<tr class="separator:a261e8613de83e1a557e95a6e06bd0a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b7f34d31e34d784fb54b70b02bdb15"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_subsystem *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ad1b7f34d31e34d784fb54b70b02bdb15">spdk_nvmf_subsystem_create</a> (struct spdk_nvmf_tgt *tgt, const char *nqn, enum <a class="el" href="nvmf__spec_8h.html#a808272f050cc373f3a90871c1528afd4">spdk_nvmf_subtype</a> type, uint32_t num_ns)</td></tr>
<tr class="memdesc:ad1b7f34d31e34d784fb54b70b02bdb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an NVMe-oF subsystem.  <a href="#ad1b7f34d31e34d784fb54b70b02bdb15">More...</a><br /></td></tr>
<tr class="separator:ad1b7f34d31e34d784fb54b70b02bdb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1609f4c58179de803a755cc38c5c2940"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a1609f4c58179de803a755cc38c5c2940">spdk_nvmf_subsystem_destroy</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a1609f4c58179de803a755cc38c5c2940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an NVMe-oF subsystem.  <a href="#a1609f4c58179de803a755cc38c5c2940">More...</a><br /></td></tr>
<tr class="separator:a1609f4c58179de803a755cc38c5c2940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0584bea11782561b13355b89de25b6c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a0584bea11782561b13355b89de25b6c0">spdk_nvmf_subsystem_start</a> (struct spdk_nvmf_subsystem *subsystem, <a class="el" href="nvmf_8h.html#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a0584bea11782561b13355b89de25b6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition an NVMe-oF subsystem from Inactive to Active state.  <a href="#a0584bea11782561b13355b89de25b6c0">More...</a><br /></td></tr>
<tr class="separator:a0584bea11782561b13355b89de25b6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af438291b914963a6c582aad500ded6ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#af438291b914963a6c582aad500ded6ef">spdk_nvmf_subsystem_stop</a> (struct spdk_nvmf_subsystem *subsystem, <a class="el" href="nvmf_8h.html#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:af438291b914963a6c582aad500ded6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition an NVMe-oF subsystem from Active to Inactive state.  <a href="#af438291b914963a6c582aad500ded6ef">More...</a><br /></td></tr>
<tr class="separator:af438291b914963a6c582aad500ded6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8b1ca226480e9582975bd03d3b232d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a7a8b1ca226480e9582975bd03d3b232d">spdk_nvmf_subsystem_pause</a> (struct spdk_nvmf_subsystem *subsystem, <a class="el" href="nvmf_8h.html#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:a7a8b1ca226480e9582975bd03d3b232d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition an NVMe-oF subsystem from Active to Paused state.  <a href="#a7a8b1ca226480e9582975bd03d3b232d">More...</a><br /></td></tr>
<tr class="separator:a7a8b1ca226480e9582975bd03d3b232d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac21e50a3e893cf2629955dd553e9e32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#aac21e50a3e893cf2629955dd553e9e32">spdk_nvmf_subsystem_resume</a> (struct spdk_nvmf_subsystem *subsystem, <a class="el" href="nvmf_8h.html#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aac21e50a3e893cf2629955dd553e9e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition an NVMe-oF subsystem from Paused to Active state.  <a href="#aac21e50a3e893cf2629955dd553e9e32">More...</a><br /></td></tr>
<tr class="separator:aac21e50a3e893cf2629955dd553e9e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae62b7fa6ac05a6ad022007f60068d16"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_subsystem *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#aae62b7fa6ac05a6ad022007f60068d16">spdk_nvmf_tgt_find_subsystem</a> (struct spdk_nvmf_tgt *tgt, const char *subnqn)</td></tr>
<tr class="memdesc:aae62b7fa6ac05a6ad022007f60068d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the target for a subsystem with the given NQN.  <a href="#aae62b7fa6ac05a6ad022007f60068d16">More...</a><br /></td></tr>
<tr class="separator:aae62b7fa6ac05a6ad022007f60068d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad345ad71bb7813f2f65b09875b688917"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_subsystem *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ad345ad71bb7813f2f65b09875b688917">spdk_nvmf_subsystem_get_first</a> (struct spdk_nvmf_tgt *tgt)</td></tr>
<tr class="memdesc:ad345ad71bb7813f2f65b09875b688917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin iterating over all known subsystems.  <a href="#ad345ad71bb7813f2f65b09875b688917">More...</a><br /></td></tr>
<tr class="separator:ad345ad71bb7813f2f65b09875b688917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4f438960707410f3a85258137cf9d3"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_subsystem *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a8f4f438960707410f3a85258137cf9d3">spdk_nvmf_subsystem_get_next</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a8f4f438960707410f3a85258137cf9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continue iterating over all known subsystems.  <a href="#a8f4f438960707410f3a85258137cf9d3">More...</a><br /></td></tr>
<tr class="separator:a8f4f438960707410f3a85258137cf9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b3442b7eb75c234c3e3090d2b5add3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a19b3442b7eb75c234c3e3090d2b5add3">spdk_nvmf_subsystem_add_host</a> (struct spdk_nvmf_subsystem *subsystem, const char *hostnqn)</td></tr>
<tr class="memdesc:a19b3442b7eb75c234c3e3090d2b5add3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow the given host NQN to connect to the given subsystem.  <a href="#a19b3442b7eb75c234c3e3090d2b5add3">More...</a><br /></td></tr>
<tr class="separator:a19b3442b7eb75c234c3e3090d2b5add3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028b2b8739dfdd896414b5c2fb84faf6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a028b2b8739dfdd896414b5c2fb84faf6">spdk_nvmf_subsystem_remove_host</a> (struct spdk_nvmf_subsystem *subsystem, const char *hostnqn)</td></tr>
<tr class="memdesc:a028b2b8739dfdd896414b5c2fb84faf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given host NQN from the allowed hosts whitelist.  <a href="#a028b2b8739dfdd896414b5c2fb84faf6">More...</a><br /></td></tr>
<tr class="separator:a028b2b8739dfdd896414b5c2fb84faf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6453b746f3c470e00e23fa4a194cfbd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ad6453b746f3c470e00e23fa4a194cfbd">spdk_nvmf_subsystem_set_allow_any_host</a> (struct spdk_nvmf_subsystem *subsystem, bool allow_any_host)</td></tr>
<tr class="memdesc:ad6453b746f3c470e00e23fa4a194cfbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether a subsystem should allow any host or only hosts in the allowed list.  <a href="#ad6453b746f3c470e00e23fa4a194cfbd">More...</a><br /></td></tr>
<tr class="separator:ad6453b746f3c470e00e23fa4a194cfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc793839e2268a097f97962e79e4a1ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#abc793839e2268a097f97962e79e4a1ef">spdk_nvmf_subsystem_get_allow_any_host</a> (const struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:abc793839e2268a097f97962e79e4a1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a subsystem should allow any host or only hosts in the allowed list.  <a href="#abc793839e2268a097f97962e79e4a1ef">More...</a><br /></td></tr>
<tr class="separator:abc793839e2268a097f97962e79e4a1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8ded88254cb17d8ee5c378f0e35a25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a5f8ded88254cb17d8ee5c378f0e35a25">spdk_nvmf_subsystem_host_allowed</a> (struct spdk_nvmf_subsystem *subsystem, const char *hostnqn)</td></tr>
<tr class="memdesc:a5f8ded88254cb17d8ee5c378f0e35a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given host is allowed to connect to the subsystem.  <a href="#a5f8ded88254cb17d8ee5c378f0e35a25">More...</a><br /></td></tr>
<tr class="separator:a5f8ded88254cb17d8ee5c378f0e35a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40147e6c89b37d85b2cce4cdb05ce787"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_host *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a40147e6c89b37d85b2cce4cdb05ce787">spdk_nvmf_subsystem_get_first_host</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a40147e6c89b37d85b2cce4cdb05ce787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first allowed host in a subsystem.  <a href="#a40147e6c89b37d85b2cce4cdb05ce787">More...</a><br /></td></tr>
<tr class="separator:a40147e6c89b37d85b2cce4cdb05ce787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5265a9a3d6338c43d9fa03afd1fa9b12"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_host *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a5265a9a3d6338c43d9fa03afd1fa9b12">spdk_nvmf_subsystem_get_next_host</a> (struct spdk_nvmf_subsystem *subsystem, struct spdk_nvmf_host *prev_host)</td></tr>
<tr class="memdesc:a5265a9a3d6338c43d9fa03afd1fa9b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next allowed host in a subsystem.  <a href="#a5265a9a3d6338c43d9fa03afd1fa9b12">More...</a><br /></td></tr>
<tr class="separator:a5265a9a3d6338c43d9fa03afd1fa9b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec4ed75ff9a25a5477d40f43a430677"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#acec4ed75ff9a25a5477d40f43a430677">spdk_nvmf_host_get_nqn</a> (struct spdk_nvmf_host *host)</td></tr>
<tr class="memdesc:acec4ed75ff9a25a5477d40f43a430677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a host's NQN.  <a href="#acec4ed75ff9a25a5477d40f43a430677">More...</a><br /></td></tr>
<tr class="separator:acec4ed75ff9a25a5477d40f43a430677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46521b556107a0ab58998adfeee8795f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a46521b556107a0ab58998adfeee8795f">spdk_nvmf_subsystem_add_listener</a> (struct spdk_nvmf_subsystem *subsystem, struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:a46521b556107a0ab58998adfeee8795f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept new connections on the address provided.  <a href="#a46521b556107a0ab58998adfeee8795f">More...</a><br /></td></tr>
<tr class="separator:a46521b556107a0ab58998adfeee8795f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77830eafd0e5bdf209be8d9c196fc11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#af77830eafd0e5bdf209be8d9c196fc11">spdk_nvmf_subsystem_remove_listener</a> (struct spdk_nvmf_subsystem *subsystem, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:af77830eafd0e5bdf209be8d9c196fc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop accepting new connections on the address provided.  <a href="#af77830eafd0e5bdf209be8d9c196fc11">More...</a><br /></td></tr>
<tr class="separator:af77830eafd0e5bdf209be8d9c196fc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcef3c424a983337eaa28ff71e03e2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#aafcef3c424a983337eaa28ff71e03e2e">spdk_nvmf_subsystem_listener_allowed</a> (struct spdk_nvmf_subsystem *subsystem, struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid)</td></tr>
<tr class="memdesc:aafcef3c424a983337eaa28ff71e03e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if connections originated from the given address are allowed to connect to the subsystem.  <a href="#aafcef3c424a983337eaa28ff71e03e2e">More...</a><br /></td></tr>
<tr class="separator:aafcef3c424a983337eaa28ff71e03e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bccfb86fd4d727c2943ab810d5d862"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_listener *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ab1bccfb86fd4d727c2943ab810d5d862">spdk_nvmf_subsystem_get_first_listener</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:ab1bccfb86fd4d727c2943ab810d5d862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first allowed listen address in the subsystem.  <a href="#ab1bccfb86fd4d727c2943ab810d5d862">More...</a><br /></td></tr>
<tr class="separator:ab1bccfb86fd4d727c2943ab810d5d862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1230525414309c87409b28484bdf964"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_listener *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ae1230525414309c87409b28484bdf964">spdk_nvmf_subsystem_get_next_listener</a> (struct spdk_nvmf_subsystem *subsystem, struct spdk_nvmf_listener *prev_listener)</td></tr>
<tr class="memdesc:ae1230525414309c87409b28484bdf964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next allowed listen address in a subsystem.  <a href="#ae1230525414309c87409b28484bdf964">More...</a><br /></td></tr>
<tr class="separator:ae1230525414309c87409b28484bdf964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d20b0173b3c6047ad15d5972af867c5"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a6d20b0173b3c6047ad15d5972af867c5">spdk_nvmf_listener_get_trid</a> (struct spdk_nvmf_listener *listener)</td></tr>
<tr class="memdesc:a6d20b0173b3c6047ad15d5972af867c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a listen address' transport ID.  <a href="#a6d20b0173b3c6047ad15d5972af867c5">More...</a><br /></td></tr>
<tr class="separator:a6d20b0173b3c6047ad15d5972af867c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5747c07b3d4ce75b4825597ecf32fde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ad5747c07b3d4ce75b4825597ecf32fde">spdk_nvmf_subsystem_allow_any_listener</a> (struct spdk_nvmf_subsystem *subsystem, bool allow_any_listener)</td></tr>
<tr class="memdesc:ad5747c07b3d4ce75b4825597ecf32fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether a subsystem should allow any listen address or only addresses in the allowed list.  <a href="#ad5747c07b3d4ce75b4825597ecf32fde">More...</a><br /></td></tr>
<tr class="separator:ad5747c07b3d4ce75b4825597ecf32fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb0340cf28f2f072bb3fa26c43870ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#afcb0340cf28f2f072bb3fa26c43870ab">spdk_nvmf_subsytem_any_listener_allowed</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:afcb0340cf28f2f072bb3fa26c43870ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a subsystem allows any listen address or only addresses in the allowed list.  <a href="#afcb0340cf28f2f072bb3fa26c43870ab">More...</a><br /></td></tr>
<tr class="separator:afcb0340cf28f2f072bb3fa26c43870ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97d60b3fba2761118d21e411a08e542"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#aa97d60b3fba2761118d21e411a08e542">spdk_nvmf_ns_opts_get_defaults</a> (struct <a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:aa97d60b3fba2761118d21e411a08e542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default namespace creation options.  <a href="#aa97d60b3fba2761118d21e411a08e542">More...</a><br /></td></tr>
<tr class="separator:aa97d60b3fba2761118d21e411a08e542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b63417dea01e5a4fe15a4f3322c63c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a81b63417dea01e5a4fe15a4f3322c63c">spdk_nvmf_subsystem_add_ns</a> (struct spdk_nvmf_subsystem *subsystem, struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *bdev, const struct <a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a> *opts, size_t opts_size, const char *ptpl_file)</td></tr>
<tr class="memdesc:a81b63417dea01e5a4fe15a4f3322c63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a namespace to a subsytem.  <a href="#a81b63417dea01e5a4fe15a4f3322c63c">More...</a><br /></td></tr>
<tr class="separator:a81b63417dea01e5a4fe15a4f3322c63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10ac07a403de72643a5e9801e9fec0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#aa10ac07a403de72643a5e9801e9fec0b">spdk_nvmf_subsystem_remove_ns</a> (struct spdk_nvmf_subsystem *subsystem, uint32_t nsid)</td></tr>
<tr class="memdesc:aa10ac07a403de72643a5e9801e9fec0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a namespace from a subsytem.  <a href="#aa10ac07a403de72643a5e9801e9fec0b">More...</a><br /></td></tr>
<tr class="separator:aa10ac07a403de72643a5e9801e9fec0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab797c6df2dc8fab9833de1711b6fe7f4"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_ns *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ab797c6df2dc8fab9833de1711b6fe7f4">spdk_nvmf_subsystem_get_first_ns</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:ab797c6df2dc8fab9833de1711b6fe7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first allocated namespace in a subsystem.  <a href="#ab797c6df2dc8fab9833de1711b6fe7f4">More...</a><br /></td></tr>
<tr class="separator:ab797c6df2dc8fab9833de1711b6fe7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2d718965cc1e681bb1cc081a377882"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_ns *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a7c2d718965cc1e681bb1cc081a377882">spdk_nvmf_subsystem_get_next_ns</a> (struct spdk_nvmf_subsystem *subsystem, struct spdk_nvmf_ns *prev_ns)</td></tr>
<tr class="memdesc:a7c2d718965cc1e681bb1cc081a377882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next allocated namespace in a subsystem.  <a href="#a7c2d718965cc1e681bb1cc081a377882">More...</a><br /></td></tr>
<tr class="separator:a7c2d718965cc1e681bb1cc081a377882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c4e50d11e12f45d171fe952fcedb03"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_ns *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a36c4e50d11e12f45d171fe952fcedb03">spdk_nvmf_subsystem_get_ns</a> (struct spdk_nvmf_subsystem *subsystem, uint32_t nsid)</td></tr>
<tr class="memdesc:a36c4e50d11e12f45d171fe952fcedb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a namespace in a subsystem by NSID.  <a href="#a36c4e50d11e12f45d171fe952fcedb03">More...</a><br /></td></tr>
<tr class="separator:a36c4e50d11e12f45d171fe952fcedb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414b91bad7200ab931f14a06585ccc74"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a414b91bad7200ab931f14a06585ccc74">spdk_nvmf_subsystem_get_max_namespaces</a> (const struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a414b91bad7200ab931f14a06585ccc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of namespaces allowed in a subsystem.  <a href="#a414b91bad7200ab931f14a06585ccc74">More...</a><br /></td></tr>
<tr class="separator:a414b91bad7200ab931f14a06585ccc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcd2be73f2653c6c14141c4cb481fe2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#afdcd2be73f2653c6c14141c4cb481fe2">spdk_nvmf_ns_get_id</a> (const struct spdk_nvmf_ns *ns)</td></tr>
<tr class="memdesc:afdcd2be73f2653c6c14141c4cb481fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a namespace's NSID.  <a href="#afdcd2be73f2653c6c14141c4cb481fe2">More...</a><br /></td></tr>
<tr class="separator:afdcd2be73f2653c6c14141c4cb481fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3575fee4a9db1b3c8bacbac8b605358"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#af3575fee4a9db1b3c8bacbac8b605358">spdk_nvmf_ns_get_bdev</a> (struct spdk_nvmf_ns *ns)</td></tr>
<tr class="memdesc:af3575fee4a9db1b3c8bacbac8b605358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a namespace's associated bdev.  <a href="#af3575fee4a9db1b3c8bacbac8b605358">More...</a><br /></td></tr>
<tr class="separator:af3575fee4a9db1b3c8bacbac8b605358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af133c734616e019eecb372ce7b096ff5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#af133c734616e019eecb372ce7b096ff5">spdk_nvmf_ns_get_opts</a> (const struct spdk_nvmf_ns *ns, struct <a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a> *opts, size_t opts_size)</td></tr>
<tr class="memdesc:af133c734616e019eecb372ce7b096ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the options specified for a namespace.  <a href="#af133c734616e019eecb372ce7b096ff5">More...</a><br /></td></tr>
<tr class="separator:af133c734616e019eecb372ce7b096ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdd9c023f1a7b6dd5e5f00da4f07cb7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a4cdd9c023f1a7b6dd5e5f00da4f07cb7">spdk_nvmf_subsystem_get_sn</a> (const struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a4cdd9c023f1a7b6dd5e5f00da4f07cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the serial number of the specified subsystem.  <a href="#a4cdd9c023f1a7b6dd5e5f00da4f07cb7">More...</a><br /></td></tr>
<tr class="separator:a4cdd9c023f1a7b6dd5e5f00da4f07cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb053c9573460d29898b184957ce05fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#abb053c9573460d29898b184957ce05fd">spdk_nvmf_subsystem_set_sn</a> (struct spdk_nvmf_subsystem *subsystem, const char *sn)</td></tr>
<tr class="memdesc:abb053c9573460d29898b184957ce05fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the serial number for the specified subsystem.  <a href="#abb053c9573460d29898b184957ce05fd">More...</a><br /></td></tr>
<tr class="separator:abb053c9573460d29898b184957ce05fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802a4bacfab2f4e57fbc12cef490dfda"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a802a4bacfab2f4e57fbc12cef490dfda">spdk_nvmf_subsystem_get_mn</a> (const struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a802a4bacfab2f4e57fbc12cef490dfda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the model number of the specified subsystem.  <a href="#a802a4bacfab2f4e57fbc12cef490dfda">More...</a><br /></td></tr>
<tr class="separator:a802a4bacfab2f4e57fbc12cef490dfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270a2bbd77c6b97116c7e61b4f1a56ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a270a2bbd77c6b97116c7e61b4f1a56ce">spdk_nvmf_subsystem_set_mn</a> (struct spdk_nvmf_subsystem *subsystem, const char *mn)</td></tr>
<tr class="memdesc:a270a2bbd77c6b97116c7e61b4f1a56ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the model number for the specified subsystem.  <a href="#a270a2bbd77c6b97116c7e61b4f1a56ce">More...</a><br /></td></tr>
<tr class="separator:a270a2bbd77c6b97116c7e61b4f1a56ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16fd259d209106b82a506a306c2b87a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#af16fd259d209106b82a506a306c2b87a">spdk_nvmf_subsystem_get_nqn</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:af16fd259d209106b82a506a306c2b87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NQN of the specified subsystem.  <a href="#af16fd259d209106b82a506a306c2b87a">More...</a><br /></td></tr>
<tr class="separator:af16fd259d209106b82a506a306c2b87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fbe4ab1d90cda9a1f3fcbf2cb857d"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="nvmf__spec_8h.html#a808272f050cc373f3a90871c1528afd4">spdk_nvmf_subtype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a0f3fbe4ab1d90cda9a1f3fcbf2cb857d">spdk_nvmf_subsystem_get_type</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:a0f3fbe4ab1d90cda9a1f3fcbf2cb857d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the specified subsystem.  <a href="#a0f3fbe4ab1d90cda9a1f3fcbf2cb857d">More...</a><br /></td></tr>
<tr class="separator:a0f3fbe4ab1d90cda9a1f3fcbf2cb857d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfae99734ec18b90dbb6ef39d1b73860"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#acfae99734ec18b90dbb6ef39d1b73860">spdk_nvmf_subsystem_get_max_nsid</a> (struct spdk_nvmf_subsystem *subsystem)</td></tr>
<tr class="memdesc:acfae99734ec18b90dbb6ef39d1b73860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum namespace id of the specified subsystem.  <a href="#acfae99734ec18b90dbb6ef39d1b73860">More...</a><br /></td></tr>
<tr class="separator:acfae99734ec18b90dbb6ef39d1b73860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c84fb153ce57c567e2b4c79400442f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a7c84fb153ce57c567e2b4c79400442f6">spdk_nvmf_transport_opts_init</a> (const char *transport_name, struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a> *opts)</td></tr>
<tr class="memdesc:a7c84fb153ce57c567e2b4c79400442f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize transport options.  <a href="#a7c84fb153ce57c567e2b4c79400442f6">More...</a><br /></td></tr>
<tr class="separator:a7c84fb153ce57c567e2b4c79400442f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141be89e55c37dc017ddeb2494f508c7"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_transport *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a141be89e55c37dc017ddeb2494f508c7">spdk_nvmf_transport_create</a> (const char *transport_name, struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a> *opts)</td></tr>
<tr class="memdesc:a141be89e55c37dc017ddeb2494f508c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a protocol transport.  <a href="#a141be89e55c37dc017ddeb2494f508c7">More...</a><br /></td></tr>
<tr class="separator:a141be89e55c37dc017ddeb2494f508c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d5e7bc8701baac2be7858b34fa7baf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ab3d5e7bc8701baac2be7858b34fa7baf">spdk_nvmf_transport_destroy</a> (struct spdk_nvmf_transport *transport)</td></tr>
<tr class="memdesc:ab3d5e7bc8701baac2be7858b34fa7baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a protocol transport.  <a href="#ab3d5e7bc8701baac2be7858b34fa7baf">More...</a><br /></td></tr>
<tr class="separator:ab3d5e7bc8701baac2be7858b34fa7baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0eb8f58d51231f6fcaa1179e12128a6"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_transport *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ad0eb8f58d51231f6fcaa1179e12128a6">spdk_nvmf_tgt_get_transport</a> (struct spdk_nvmf_tgt *tgt, const char *transport_name)</td></tr>
<tr class="memdesc:ad0eb8f58d51231f6fcaa1179e12128a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an existing transport from the target.  <a href="#ad0eb8f58d51231f6fcaa1179e12128a6">More...</a><br /></td></tr>
<tr class="separator:ad0eb8f58d51231f6fcaa1179e12128a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aeaade30bb4e457f5c35e2f3649d097"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_transport *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a1aeaade30bb4e457f5c35e2f3649d097">spdk_nvmf_transport_get_first</a> (struct spdk_nvmf_tgt *tgt)</td></tr>
<tr class="memdesc:a1aeaade30bb4e457f5c35e2f3649d097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first transport registered with the given target.  <a href="#a1aeaade30bb4e457f5c35e2f3649d097">More...</a><br /></td></tr>
<tr class="separator:a1aeaade30bb4e457f5c35e2f3649d097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1316a2fe3bd765d755de1df15add5cc"><td class="memItemLeft" align="right" valign="top">struct spdk_nvmf_transport *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#aa1316a2fe3bd765d755de1df15add5cc">spdk_nvmf_transport_get_next</a> (struct spdk_nvmf_transport *transport)</td></tr>
<tr class="memdesc:aa1316a2fe3bd765d755de1df15add5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next transport in a target's list.  <a href="#aa1316a2fe3bd765d755de1df15add5cc">More...</a><br /></td></tr>
<tr class="separator:aa1316a2fe3bd765d755de1df15add5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31057e91a342d9e799254ee66e3533ba"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a31057e91a342d9e799254ee66e3533ba">spdk_nvmf_get_transport_opts</a> (struct spdk_nvmf_transport *transport)</td></tr>
<tr class="memdesc:a31057e91a342d9e799254ee66e3533ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the opts for a given transport.  <a href="#a31057e91a342d9e799254ee66e3533ba">More...</a><br /></td></tr>
<tr class="separator:a31057e91a342d9e799254ee66e3533ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63937e4be5fad005cfe7ce15cf60a198"><td class="memItemLeft" align="right" valign="top">spdk_nvme_transport_type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a63937e4be5fad005cfe7ce15cf60a198">spdk_nvmf_get_transport_type</a> (struct spdk_nvmf_transport *transport)</td></tr>
<tr class="memdesc:a63937e4be5fad005cfe7ce15cf60a198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transport type for a given transport.  <a href="#a63937e4be5fad005cfe7ce15cf60a198">More...</a><br /></td></tr>
<tr class="separator:a63937e4be5fad005cfe7ce15cf60a198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c4b952d4313986bb0771b6c03e6f9e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ac5c4b952d4313986bb0771b6c03e6f9e">spdk_nvmf_get_transport_name</a> (struct spdk_nvmf_transport *transport)</td></tr>
<tr class="memdesc:ac5c4b952d4313986bb0771b6c03e6f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transport name for a given transport.  <a href="#ac5c4b952d4313986bb0771b6c03e6f9e">More...</a><br /></td></tr>
<tr class="separator:ac5c4b952d4313986bb0771b6c03e6f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac996bda413ddfc830c6f46aab4fd181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#aac996bda413ddfc830c6f46aab4fd181">spdk_nvmf_tgt_add_transport</a> (struct spdk_nvmf_tgt *tgt, struct spdk_nvmf_transport *transport, <a class="el" href="nvmf_8h.html#a53086e85e4a7103ab2b714483b4f2aec">spdk_nvmf_tgt_add_transport_done_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:aac996bda413ddfc830c6f46aab4fd181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a transport to a target.  <a href="#aac996bda413ddfc830c6f46aab4fd181">More...</a><br /></td></tr>
<tr class="separator:aac996bda413ddfc830c6f46aab4fd181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa43090f9acc81ff2a5936c9cf783ef3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#afa43090f9acc81ff2a5936c9cf783ef3">spdk_nvmf_transport_listen</a> (struct spdk_nvmf_transport *transport, const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *trid, <a class="el" href="nvmf_8h.html#a854e30bf69f07bb06b2cbcdd08ca7eba">spdk_nvmf_tgt_listen_done_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="memdesc:afa43090f9acc81ff2a5936c9cf783ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add listener to transport and begin accepting new connections.  <a href="#afa43090f9acc81ff2a5936c9cf783ef3">More...</a><br /></td></tr>
<tr class="separator:afa43090f9acc81ff2a5936c9cf783ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056f7ac8ac8f7b34366650cb1a2bb940"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a056f7ac8ac8f7b34366650cb1a2bb940">spdk_nvmf_tgt_transport_write_config_json</a> (struct spdk_json_write_ctx *w, struct spdk_nvmf_tgt *tgt)</td></tr>
<tr class="memdesc:a056f7ac8ac8f7b34366650cb1a2bb940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write NVMe-oF target's transport configurations into provided JSON context.  <a href="#a056f7ac8ac8f7b34366650cb1a2bb940">More...</a><br /></td></tr>
<tr class="separator:a056f7ac8ac8f7b34366650cb1a2bb940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e59ef25ba7e6a45ab1d613c006f1bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ae4e59ef25ba7e6a45ab1d613c006f1bb">spdk_nvmf_transport_poll_group_get_stat</a> (struct spdk_nvmf_tgt *tgt, struct spdk_nvmf_transport *transport, struct <a class="el" href="structspdk__nvmf__transport__poll__group__stat.html">spdk_nvmf_transport_poll_group_stat</a> **stat)</td></tr>
<tr class="memdesc:ae4e59ef25ba7e6a45ab1d613c006f1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current transport poll group statistics.  <a href="#ae4e59ef25ba7e6a45ab1d613c006f1bb">More...</a><br /></td></tr>
<tr class="separator:ae4e59ef25ba7e6a45ab1d613c006f1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03fc0bf9946107905bf8148495966f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ab03fc0bf9946107905bf8148495966f9">spdk_nvmf_transport_poll_group_free_stat</a> (struct spdk_nvmf_transport *transport, struct <a class="el" href="structspdk__nvmf__transport__poll__group__stat.html">spdk_nvmf_transport_poll_group_stat</a> *stat)</td></tr>
<tr class="memdesc:ab03fc0bf9946107905bf8148495966f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free statistics memory previously allocated with <a class="el" href="nvmf_8h.html#ae4e59ef25ba7e6a45ab1d613c006f1bb" title="Get current transport poll group statistics. ">spdk_nvmf_transport_poll_group_get_stat()</a>.  <a href="#ab03fc0bf9946107905bf8148495966f9">More...</a><br /></td></tr>
<tr class="separator:ab03fc0bf9946107905bf8148495966f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae1cb4c373e0dd8146b81b5ba57ff0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#a9ae1cb4c373e0dd8146b81b5ba57ff0b">spdk_nvmf_rdma_init_hooks</a> (struct <a class="el" href="structspdk__nvme__rdma__hooks.html">spdk_nvme_rdma_hooks</a> *hooks)</td></tr>
<tr class="memdesc:a9ae1cb4c373e0dd8146b81b5ba57ff0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global hooks for the RDMA transport, if necessary.  <a href="#a9ae1cb4c373e0dd8146b81b5ba57ff0b">More...</a><br /></td></tr>
<tr class="separator:a9ae1cb4c373e0dd8146b81b5ba57ff0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53a8667860940846986a85db26a7236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nvmf_8h.html#ab53a8667860940846986a85db26a7236">spdk_nvmf_transport_register</a> (const struct <a class="el" href="structspdk__nvmf__transport__ops.html">spdk_nvmf_transport_ops</a> *ops)</td></tr>
<tr class="memdesc:ab53a8667860940846986a85db26a7236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the operations for a given transport type.  <a href="#ab53a8667860940846986a85db26a7236">More...</a><br /></td></tr>
<tr class="separator:ab53a8667860940846986a85db26a7236"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>NVMe over Fabrics target public API. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="abeebe98da8b8183865537af9d2fd42f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeebe98da8b8183865537af9d2fd42f6">&#9670;&nbsp;</a></span>SPDK_NVMF_TRANSPORT_REGISTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPDK_NVMF_TRANSPORT_REGISTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">transport_ops&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __attribute__((constructor)) spdk_nvmf_transport_register_##name(<span class="keywordtype">void</span>) \</div><div class="line">{ \</div><div class="line">        spdk_nvmf_transport_register(transport_ops); \</div><div class="line">}\</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa999ebee65c92711a5dce79d06cf81c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa999ebee65c92711a5dce79d06cf81c2">&#9670;&nbsp;</a></span>new_qpair_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* new_qpair_fn) (struct spdk_nvmf_qpair *qpair, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called for each newly discovered qpair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The newly discovered qpair. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>A context argument passed to this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec7dc3c1e2f740c1cbffa028ad5c5bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7dc3c1e2f740c1cbffa028ad5c5bff">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_state_change_done</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvmf_subsystem_state_change_done) (struct spdk_nvmf_subsystem *subsystem, void *cb_arg, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called once the subsystem has changed state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsytem</td><td>NVMe-oF subsystem that has changed state. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to callback function. </td></tr>
    <tr><td class="paramname">status</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53086e85e4a7103ab2b714483b4f2aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53086e85e4a7103ab2b714483b4f2aec">&#9670;&nbsp;</a></span>spdk_nvmf_tgt_add_transport_done_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvmf_tgt_add_transport_done_fn) (void *cb_arg, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called once transport add is complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb_arg</td><td>Callback argument passed to this function. </td></tr>
    <tr><td class="paramname">status</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a854e30bf69f07bb06b2cbcdd08ca7eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854e30bf69f07bb06b2cbcdd08ca7eba">&#9670;&nbsp;</a></span>spdk_nvmf_tgt_listen_done_fn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spdk_nvmf_tgt_listen_done_fn) (void *ctx, int status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to be called once the target is listening. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>Context argument passed to this function. </td></tr>
    <tr><td class="paramname">status</td><td>0 if it completed successfully, or negative errno if it failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a306b55570dbe1da898083657d382f6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306b55570dbe1da898083657d382f6f5">&#9670;&nbsp;</a></span>spdk_nvmf_get_first_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_tgt* spdk_nvmf_get_first_tgt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pointer to the first NVMe-oF target. </p>
<p>Combined with spdk_nvmf_get_next_tgt to iterate over all available targets.</p>
<dl class="section return"><dt>Returns</dt><dd>The first NVMe-oF target. </dd></dl>

</div>
</div>
<a id="a1565a46b36efef782d8cee2f8c6489e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1565a46b36efef782d8cee2f8c6489e8">&#9670;&nbsp;</a></span>spdk_nvmf_get_next_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_tgt* spdk_nvmf_get_next_tgt </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>prev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the pointer to the first NVMe-oF target. </p>
<p>Combined with spdk_nvmf_get_first_tgt to iterate over all available targets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev</td><td>A pointer to the last NVMe-oF target.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first NVMe-oF target. </dd></dl>

</div>
</div>
<a id="a744188acd6e709ed4bc3f7f98a2230f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744188acd6e709ed4bc3f7f98a2230f8">&#9670;&nbsp;</a></span>spdk_nvmf_get_optimal_poll_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_poll_group* spdk_nvmf_get_optimal_poll_group </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get optimal nvmf poll group for the qpair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>Requested qpair</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a poll group on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a43ac2675a2d592cc584ee403b8bb324a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ac2675a2d592cc584ee403b8bb324a">&#9670;&nbsp;</a></span>spdk_nvmf_get_tgt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_tgt* spdk_nvmf_get_tgt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to an NVMe-oF target. </p>
<p>In order to support some legacy applications and RPC methods that may rely on the concept that there is only one target, the name parameter can be passed as NULL. If there is only one available target, that target will be returned. Otherwise, name is a required parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name provided when the target was created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The target with the given name, or NULL if no match was found. </dd></dl>

</div>
</div>
<a id="ac5c4b952d4313986bb0771b6c03e6f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c4b952d4313986bb0771b6c03e6f9e">&#9670;&nbsp;</a></span>spdk_nvmf_get_transport_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvmf_get_transport_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_transport *&#160;</td>
          <td class="paramname"><em>transport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transport name for a given transport. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The transport to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transport name for the given transport </dd></dl>

</div>
</div>
<a id="a31057e91a342d9e799254ee66e3533ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31057e91a342d9e799254ee66e3533ba">&#9670;&nbsp;</a></span>spdk_nvmf_get_transport_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a>* spdk_nvmf_get_transport_opts </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_transport *&#160;</td>
          <td class="paramname"><em>transport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the opts for a given transport. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The transport to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The opts associated with the given transport </dd></dl>

</div>
</div>
<a id="a63937e4be5fad005cfe7ce15cf60a198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63937e4be5fad005cfe7ce15cf60a198">&#9670;&nbsp;</a></span>spdk_nvmf_get_transport_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spdk_nvme_transport_type_t spdk_nvmf_get_transport_type </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_transport *&#160;</td>
          <td class="paramname"><em>transport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transport type for a given transport. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The transport to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transport type for the given transport </dd></dl>

</div>
</div>
<a id="acec4ed75ff9a25a5477d40f43a430677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec4ed75ff9a25a5477d40f43a430677">&#9670;&nbsp;</a></span>spdk_nvmf_host_get_nqn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvmf_host_get_nqn </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_host *&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a host's NQN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Host to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NQN of host. </dd></dl>

</div>
</div>
<a id="a6d20b0173b3c6047ad15d5972af867c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d20b0173b3c6047ad15d5972af867c5">&#9670;&nbsp;</a></span>spdk_nvmf_listener_get_trid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a>* spdk_nvmf_listener_get_trid </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_listener *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a listen address' transport ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>This listener.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transport ID for this listener. </dd></dl>

</div>
</div>
<a id="af3575fee4a9db1b3c8bacbac8b605358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3575fee4a9db1b3c8bacbac8b605358">&#9670;&nbsp;</a></span>spdk_nvmf_ns_get_bdev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a>* spdk_nvmf_ns_get_bdev </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a namespace's associated bdev. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>backing bdev of ns. </dd></dl>

</div>
</div>
<a id="afdcd2be73f2653c6c14141c4cb481fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcd2be73f2653c6c14141c4cb481fe2">&#9670;&nbsp;</a></span>spdk_nvmf_ns_get_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvmf_ns_get_id </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_ns *&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a namespace's NSID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NSID of ns. </dd></dl>

</div>
</div>
<a id="af133c734616e019eecb372ce7b096ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af133c734616e019eecb372ce7b096ff5">&#9670;&nbsp;</a></span>spdk_nvmf_ns_get_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_ns_get_opts </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_ns *&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>opts_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the options specified for a namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns</td><td>Namespace to query. </td></tr>
    <tr><td class="paramname">opts</td><td>Output parameter for options. </td></tr>
    <tr><td class="paramname">opts_size</td><td>sizeof(*opts) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa97d60b3fba2761118d21e411a08e542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97d60b3fba2761118d21e411a08e542">&#9670;&nbsp;</a></span>spdk_nvmf_ns_opts_get_defaults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_ns_opts_get_defaults </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>opts_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get default namespace creation options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Namespace options to fill with defaults. </td></tr>
    <tr><td class="paramname">opts_size</td><td>sizeof(struct spdk_nvmf_ns_opts) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37eea41a3c3856e0ea2cd383af20183d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37eea41a3c3856e0ea2cd383af20183d">&#9670;&nbsp;</a></span>spdk_nvmf_poll_group_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_poll_group_add </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_poll_group *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvmf_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the given qpair to the poll group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The group to add qpair to. </td></tr>
    <tr><td class="paramname">qpair</td><td>The qpair to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a3b1de2ab69c992ce2c732c354a08238f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1de2ab69c992ce2c732c354a08238f">&#9670;&nbsp;</a></span>spdk_nvmf_poll_group_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_poll_group* spdk_nvmf_poll_group_create </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a poll group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The target to create a poll group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a poll group on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="aa38d9ac50a79883df08d7faf3a647018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38d9ac50a79883df08d7faf3a647018">&#9670;&nbsp;</a></span>spdk_nvmf_poll_group_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_poll_group_destroy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_poll_group *&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a poll group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>The poll group to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5d5611a2cd71a7d71a08c990cbd29e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d5611a2cd71a7d71a08c990cbd29e7">&#9670;&nbsp;</a></span>spdk_nvmf_poll_group_get_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_poll_group_get_stat </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__poll__group__stat.html">spdk_nvmf_poll_group_stat</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current poll group statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The NVMf target. </td></tr>
    <tr><td class="paramname">stat</td><td>Pointer to allocated statistics structure to fill with values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success. </dd>
<dd>
-EINVAL if either group or stat is NULL. </dd></dl>

</div>
</div>
<a id="afa33cb1cf39e04ee533f874ed82e24e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa33cb1cf39e04ee533f874ed82e24e5">&#9670;&nbsp;</a></span>spdk_nvmf_qpair_disconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_qpair_disconnect </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nvmf_qpair_disconnect_cb&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect an NVMe-oF qpair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The NVMe-oF qpair to disconnect. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>The function to call upon completion of the disconnect. </td></tr>
    <tr><td class="paramname">ctx</td><td>The context to pass to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success. </dd>
<dd>
-ENOMEM if the function specific context could not be allocated. </dd></dl>

</div>
</div>
<a id="a261e8613de83e1a557e95a6e06bd0a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261e8613de83e1a557e95a6e06bd0a19">&#9670;&nbsp;</a></span>spdk_nvmf_qpair_get_listen_trid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_qpair_get_listen_trid </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the associated listener transport ID for this queue pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The NVMe-oF qpair </td></tr>
    <tr><td class="paramname">trid</td><td>Output parameter that will contain the transport id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success. </dd>
<dd>
-EINVAL if the qpair is not connected. </dd></dl>

</div>
</div>
<a id="ad269e6b66abf6b758569453f4b6fd41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad269e6b66abf6b758569453f4b6fd41a">&#9670;&nbsp;</a></span>spdk_nvmf_qpair_get_local_trid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_qpair_get_local_trid </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local transport ID for this queue pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The NVMe-oF qpair </td></tr>
    <tr><td class="paramname">trid</td><td>Output parameter that will contain the transport id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success. </dd>
<dd>
-EINVAL if the qpair is not connected. </dd></dl>

</div>
</div>
<a id="a145a3a2e51799674837dcb1ebf9a13c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145a3a2e51799674837dcb1ebf9a13c3">&#9670;&nbsp;</a></span>spdk_nvmf_qpair_get_peer_trid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_qpair_get_peer_trid </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_qpair *&#160;</td>
          <td class="paramname"><em>qpair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the peer's transport ID for this queue pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qpair</td><td>The NVMe-oF qpair </td></tr>
    <tr><td class="paramname">trid</td><td>Output parameter that will contain the transport id.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success. </dd>
<dd>
-EINVAL if the qpair is not connected. </dd></dl>

</div>
</div>
<a id="a9ae1cb4c373e0dd8146b81b5ba57ff0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae1cb4c373e0dd8146b81b5ba57ff0b">&#9670;&nbsp;</a></span>spdk_nvmf_rdma_init_hooks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_rdma_init_hooks </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__rdma__hooks.html">spdk_nvme_rdma_hooks</a> *&#160;</td>
          <td class="paramname"><em>hooks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the global hooks for the RDMA transport, if necessary. </p>
<p>This call is optional and must be performed prior to probing for any devices. By default, the RDMA transport will use the ibverbs library to create protection domains and register memory. This is a mechanism to subvert that and use an existing registration.</p>
<p>This function may only be called one time per process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hooks</td><td>for initializing global hooks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19b3442b7eb75c234c3e3090d2b5add3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b3442b7eb75c234c3e3090d2b5add3">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_add_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_add_host </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostnqn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow the given host NQN to connect to the given subsystem. </p>
<p>May only be performed on subsystems in the PAUSED or INACTIVE states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to add host to. </td></tr>
    <tr><td class="paramname">hostnqn</td><td>The NQN for the host.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="a46521b556107a0ab58998adfeee8795f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46521b556107a0ab58998adfeee8795f">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_add_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_add_listener </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept new connections on the address provided. </p>
<p>May only be performed on subsystems in the PAUSED or INACTIVE states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to add listener to. </td></tr>
    <tr><td class="paramname">trid</td><td>The address to accept connections from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="a81b63417dea01e5a4fe15a4f3322c63c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b63417dea01e5a4fe15a4f3322c63c">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_add_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvmf_subsystem_add_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__bdev.html">spdk_bdev</a> *&#160;</td>
          <td class="paramname"><em>bdev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvmf__ns__opts.html">spdk_nvmf_ns_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>opts_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ptpl_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a namespace to a subsytem. </p>
<p>May only be performed on subsystems in the PAUSED or INACTIVE states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to add namespace to. </td></tr>
    <tr><td class="paramname">bdev</td><td>Block device to add as a namespace. </td></tr>
    <tr><td class="paramname">opts</td><td>Namespace options, or NULL to use defaults. </td></tr>
    <tr><td class="paramname">opts_size</td><td>sizeof(*opts) </td></tr>
    <tr><td class="paramname">ptpl_file</td><td>Persist through power loss file path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>newly added NSID on success, or 0 on failure. </dd></dl>

</div>
</div>
<a id="ad5747c07b3d4ce75b4825597ecf32fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5747c07b3d4ce75b4825597ecf32fde">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_allow_any_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_subsystem_allow_any_listener </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_any_listener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether a subsystem should allow any listen address or only addresses in the allowed list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to allow dynamic listener assignment. </td></tr>
    <tr><td class="paramname">allow_any_listener</td><td>true to allow dynamic listener assignment for this subsystem, or false to enforce the whitelist configured during subsystem setup. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1b7f34d31e34d784fb54b70b02bdb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b7f34d31e34d784fb54b70b02bdb15">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_subsystem* spdk_nvmf_subsystem_create </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nqn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="nvmf__spec_8h.html#a808272f050cc373f3a90871c1528afd4">spdk_nvmf_subtype</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_ns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an NVMe-oF subsystem. </p>
<p>Subsystems are in one of three states: Inactive, Active, Paused. This state affects which operations may be performed on the subsystem. Upon creation, the subsystem will be in the Inactive state and may be activated by calling <a class="el" href="nvmf_8h.html#a0584bea11782561b13355b89de25b6c0" title="Transition an NVMe-oF subsystem from Inactive to Active state. ">spdk_nvmf_subsystem_start()</a>. No I/O will be processed in the Inactive or Paused states, but changes to the state of the subsystem may be made.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target that will own this subsystem. </td></tr>
    <tr><td class="paramname">nqn</td><td>The NVMe qualified name of this subsystem. </td></tr>
    <tr><td class="paramname">type</td><td>Whether this subsystem is an I/O subsystem or a Discovery subsystem. </td></tr>
    <tr><td class="paramname">num_ns</td><td>The number of namespaces this subsystem contains.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a NVMe-oF subsystem on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a1609f4c58179de803a755cc38c5c2940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1609f4c58179de803a755cc38c5c2940">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_subsystem_destroy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an NVMe-oF subsystem. </p>
<p>A subsystem may only be destroyed when in the Inactive state. See <a class="el" href="nvmf_8h.html#af438291b914963a6c582aad500ded6ef" title="Transition an NVMe-oF subsystem from Active to Inactive state. ">spdk_nvmf_subsystem_stop()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>The NVMe-oF subsystem to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc793839e2268a097f97962e79e4a1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc793839e2268a097f97962e79e4a1ef">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_allow_any_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvmf_subsystem_get_allow_any_host </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a subsystem should allow any host or only hosts in the allowed list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any host is allowed to connect to this subsystem, or false if connecting hosts must be in the whitelist configured with <a class="el" href="nvmf_8h.html#a19b3442b7eb75c234c3e3090d2b5add3" title="Allow the given host NQN to connect to the given subsystem. ">spdk_nvmf_subsystem_add_host()</a>. </dd></dl>

</div>
</div>
<a id="ad345ad71bb7813f2f65b09875b688917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad345ad71bb7813f2f65b09875b688917">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_subsystem* spdk_nvmf_subsystem_get_first </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin iterating over all known subsystems. </p>
<p>If no subsystems are present, return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target to iterate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the first NVMe-oF subsystem on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a40147e6c89b37d85b2cce4cdb05ce787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40147e6c89b37d85b2cce4cdb05ce787">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_first_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_host* spdk_nvmf_subsystem_get_first_host </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first allowed host in a subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first allowed host in this subsystem, or NULL if none allowed. </dd></dl>

</div>
</div>
<a id="ab1bccfb86fd4d727c2943ab810d5d862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1bccfb86fd4d727c2943ab810d5d862">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_first_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_listener* spdk_nvmf_subsystem_get_first_listener </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first allowed listen address in the subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first allowed listen address in this subsystem, or NULL if none allowed. </dd></dl>

</div>
</div>
<a id="ab797c6df2dc8fab9833de1711b6fe7f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab797c6df2dc8fab9833de1711b6fe7f4">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_first_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_ns* spdk_nvmf_subsystem_get_first_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first allocated namespace in a subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first allocated namespace in this subsystem, or NULL if this subsystem has no namespaces. </dd></dl>

</div>
</div>
<a id="a414b91bad7200ab931f14a06585ccc74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414b91bad7200ab931f14a06585ccc74">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_max_namespaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvmf_subsystem_get_max_namespaces </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum number of namespaces allowed in a subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of namespaces allowed in the subsystem, or 0 for unlimited. </dd></dl>

</div>
</div>
<a id="acfae99734ec18b90dbb6ef39d1b73860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfae99734ec18b90dbb6ef39d1b73860">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_max_nsid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t spdk_nvmf_subsystem_get_max_nsid </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get maximum namespace id of the specified subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum namespace id </dd></dl>

</div>
</div>
<a id="a802a4bacfab2f4e57fbc12cef490dfda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802a4bacfab2f4e57fbc12cef490dfda">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_mn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvmf_subsystem_get_mn </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the model number of the specified subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>model number of the specified subsystem. </dd></dl>

</div>
</div>
<a id="a8f4f438960707410f3a85258137cf9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4f438960707410f3a85258137cf9d3">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_subsystem* spdk_nvmf_subsystem_get_next </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Continue iterating over all known subsystems. </p>
<p>If no additional subsystems, return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Previous subsystem returned from <a class="el" href="nvmf_8h.html#ad345ad71bb7813f2f65b09875b688917">spdk_nvmf_subsystem_get_first</a> or <a class="el" href="nvmf_8h.html#a8f4f438960707410f3a85258137cf9d3">spdk_nvmf_subsystem_get_next</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the next NVMe-oF subsystem on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a5265a9a3d6338c43d9fa03afd1fa9b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5265a9a3d6338c43d9fa03afd1fa9b12">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_next_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_host* spdk_nvmf_subsystem_get_next_host </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvmf_host *&#160;</td>
          <td class="paramname"><em>prev_host</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next allowed host in a subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query. </td></tr>
    <tr><td class="paramname">prev_host</td><td>Previous host returned from this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next allowed host in this subsystem, or NULL if prev_host was the last host. </dd></dl>

</div>
</div>
<a id="ae1230525414309c87409b28484bdf964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1230525414309c87409b28484bdf964">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_next_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_listener* spdk_nvmf_subsystem_get_next_listener </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvmf_listener *&#160;</td>
          <td class="paramname"><em>prev_listener</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next allowed listen address in a subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query. </td></tr>
    <tr><td class="paramname">prev_listener</td><td>Previous listen address for this subsystem.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next allowed listen address in this subsystem, or NULL if prev_listener was the last address. </dd></dl>

</div>
</div>
<a id="a7c2d718965cc1e681bb1cc081a377882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2d718965cc1e681bb1cc081a377882">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_next_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_ns* spdk_nvmf_subsystem_get_next_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvmf_ns *&#160;</td>
          <td class="paramname"><em>prev_ns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next allocated namespace in a subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query. </td></tr>
    <tr><td class="paramname">prev_ns</td><td>Previous ns returned from this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>next allocated namespace in this subsystem, or NULL if prev_ns was the last namespace. </dd></dl>

</div>
</div>
<a id="af16fd259d209106b82a506a306c2b87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16fd259d209106b82a506a306c2b87a">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_nqn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvmf_subsystem_get_nqn </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the NQN of the specified subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NQN of the specified subsystem. </dd></dl>

</div>
</div>
<a id="a36c4e50d11e12f45d171fe952fcedb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c4e50d11e12f45d171fe952fcedb03">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_ns* spdk_nvmf_subsystem_get_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a namespace in a subsystem by NSID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to search. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace ID to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>namespace matching nsid, or NULL if nsid was not found. </dd></dl>

</div>
</div>
<a id="a4cdd9c023f1a7b6dd5e5f00da4f07cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdd9c023f1a7b6dd5e5f00da4f07cb7">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_sn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvmf_subsystem_get_sn </td>
          <td>(</td>
          <td class="paramtype">const struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the serial number of the specified subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>serial number of the specified subsystem. </dd></dl>

</div>
</div>
<a id="a0f3fbe4ab1d90cda9a1f3fcbf2cb857d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3fbe4ab1d90cda9a1f3fcbf2cb857d">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="nvmf__spec_8h.html#a808272f050cc373f3a90871c1528afd4">spdk_nvmf_subtype</a> spdk_nvmf_subsystem_get_type </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of the specified subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type of the specified subsystem. </dd></dl>

</div>
</div>
<a id="a5f8ded88254cb17d8ee5c378f0e35a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8ded88254cb17d8ee5c378f0e35a25">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_host_allowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvmf_subsystem_host_allowed </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostnqn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the given host is allowed to connect to the subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>The subsystem to query. </td></tr>
    <tr><td class="paramname">hostnqn</td><td>The NQN of the host.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if allowed, false if not. </dd></dl>

</div>
</div>
<a id="aafcef3c424a983337eaa28ff71e03e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcef3c424a983337eaa28ff71e03e2e">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_listener_allowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvmf_subsystem_listener_allowed </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if connections originated from the given address are allowed to connect to the subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>The subsystem to query. </td></tr>
    <tr><td class="paramname">trid</td><td>The listen address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if allowed, or false if not. </dd></dl>

</div>
</div>
<a id="a7a8b1ca226480e9582975bd03d3b232d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8b1ca226480e9582975bd03d3b232d">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_pause </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvmf_8h.html#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition an NVMe-oF subsystem from Active to Paused state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>The NVMe-oF subsystem. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A function that will be called once the subsystem has changed state. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno on failure. The callback provided will only be called on success. </dd></dl>

</div>
</div>
<a id="a028b2b8739dfdd896414b5c2fb84faf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028b2b8739dfdd896414b5c2fb84faf6">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_remove_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_remove_host </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostnqn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the given host NQN from the allowed hosts whitelist. </p>
<p>May only be performed on subsystems in the PAUSED or INACTIVE states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to remove host from. </td></tr>
    <tr><td class="paramname">hostnqn</td><td>The NQN for the host.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="af77830eafd0e5bdf209be8d9c196fc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77830eafd0e5bdf209be8d9c196fc11">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_remove_listener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_remove_listener </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop accepting new connections on the address provided. </p>
<p>May only be performed on subsystems in the PAUSED or INACTIVE states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to remove listener from. </td></tr>
    <tr><td class="paramname">trid</td><td>The address to no longer accept connections from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="aa10ac07a403de72643a5e9801e9fec0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10ac07a403de72643a5e9801e9fec0b">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_remove_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_remove_ns </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nsid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a namespace from a subsytem. </p>
<p>May only be performed on subsystems in the PAUSED or INACTIVE states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem the namespace belong to. </td></tr>
    <tr><td class="paramname">nsid</td><td>Namespace ID to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="aac21e50a3e893cf2629955dd553e9e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac21e50a3e893cf2629955dd553e9e32">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_resume </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvmf_8h.html#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition an NVMe-oF subsystem from Paused to Active state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>The NVMe-oF subsystem. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A function that will be called once the subsystem has changed state. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno on failure. The callback provided will only be called on success. </dd></dl>

</div>
</div>
<a id="ad6453b746f3c470e00e23fa4a194cfbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6453b746f3c470e00e23fa4a194cfbd">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_set_allow_any_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_set_allow_any_host </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_any_host</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether a subsystem should allow any host or only hosts in the allowed list. </p>
<p>May only be performed on subsystems in the PAUSED or INACTIVE states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to modify. </td></tr>
    <tr><td class="paramname">allow_any_host</td><td>true to allow any host to connect to this subsystem, or false to enforce the whitelist configured with <a class="el" href="nvmf_8h.html#a19b3442b7eb75c234c3e3090d2b5add3" title="Allow the given host NQN to connect to the given subsystem. ">spdk_nvmf_subsystem_add_host()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno value on failure. </dd></dl>

</div>
</div>
<a id="a270a2bbd77c6b97116c7e61b4f1a56ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270a2bbd77c6b97116c7e61b4f1a56ce">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_set_mn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_set_mn </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the model number for the specified subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to set for. </td></tr>
    <tr><td class="paramname">mn</td><td>model number to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="abb053c9573460d29898b184957ce05fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb053c9573460d29898b184957ce05fd">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_set_sn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_set_sn </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the serial number for the specified subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to set for. </td></tr>
    <tr><td class="paramname">sn</td><td>serial number to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a0584bea11782561b13355b89de25b6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0584bea11782561b13355b89de25b6c0">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_start </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvmf_8h.html#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition an NVMe-oF subsystem from Inactive to Active state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>The NVMe-oF subsystem. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A function that will be called once the subsystem has changed state. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno on failure. The callback provided will only be called on success. </dd></dl>

</div>
</div>
<a id="af438291b914963a6c582aad500ded6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af438291b914963a6c582aad500ded6ef">&#9670;&nbsp;</a></span>spdk_nvmf_subsystem_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_subsystem_stop </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvmf_8h.html#aec7dc3c1e2f740c1cbffa028ad5c5bff">spdk_nvmf_subsystem_state_change_done</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transition an NVMe-oF subsystem from Active to Inactive state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>The NVMe-oF subsystem. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A function that will be called once the subsystem has changed state. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, or negated errno on failure. The callback provided will only be called on success. </dd></dl>

</div>
</div>
<a id="afcb0340cf28f2f072bb3fa26c43870ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb0340cf28f2f072bb3fa26c43870ab">&#9670;&nbsp;</a></span>spdk_nvmf_subsytem_any_listener_allowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvmf_subsytem_any_listener_allowed </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_subsystem *&#160;</td>
          <td class="paramname"><em>subsystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a subsystem allows any listen address or only addresses in the allowed list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Subsystem to query.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this subsystem allows dynamic management of listen address list, or false if only allows addresses in the whitelist configured during subsystem setup. </dd></dl>

</div>
</div>
<a id="aa39b568e5ae11462a3e0aef59f8e9fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39b568e5ae11462a3e0aef59f8e9fd3">&#9670;&nbsp;</a></span>spdk_nvmf_tgt_accept()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_tgt_accept </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvmf_8h.html#aa999ebee65c92711a5dce79d06cf81c2">new_qpair_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Poll the target for incoming connections. </p>
<p>The new_qpair_fn cb_fn will be called for each newly discovered qpair. The user is expected to add that qpair to a poll group to establish the connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The target associated with the listen address. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>Called for each newly discovered qpair. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>A context argument passed to cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac996bda413ddfc830c6f46aab4fd181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac996bda413ddfc830c6f46aab4fd181">&#9670;&nbsp;</a></span>spdk_nvmf_tgt_add_transport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_tgt_add_transport </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvmf_transport *&#160;</td>
          <td class="paramname"><em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvmf_8h.html#a53086e85e4a7103ab2b714483b4f2aec">spdk_nvmf_tgt_add_transport_done_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a transport to a target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target </td></tr>
    <tr><td class="paramname">transport</td><td>The transport to add </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A callback that will be called once the transport is created </td></tr>
    <tr><td class="paramname">cb_arg</td><td>A context argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. The callback status argument will be 0 on success or a negated errno on failure. </dd></dl>

</div>
</div>
<a id="a16bd65e94dea554b50bd7169850c567d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bd65e94dea554b50bd7169850c567d">&#9670;&nbsp;</a></span>spdk_nvmf_tgt_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_tgt* spdk_nvmf_tgt_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__target__opts.html">spdk_nvmf_target_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an NVMe-oF target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>a pointer to an <a class="el" href="structspdk__nvmf__target__opts.html">spdk_nvmf_target_opts</a> structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a NVMe-oF target on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a21638f4d81002e93d410cd0d267f608c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21638f4d81002e93d410cd0d267f608c">&#9670;&nbsp;</a></span>spdk_nvmf_tgt_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_tgt_destroy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spdk_nvmf_tgt_destroy_done_fn&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an NVMe-oF target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The target to destroy. This releases all resources. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A callback that will be called once the target is destroyed </td></tr>
    <tr><td class="paramname">cb_arg</td><td>A context argument passed to cb_fn. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae62b7fa6ac05a6ad022007f60068d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae62b7fa6ac05a6ad022007f60068d16">&#9670;&nbsp;</a></span>spdk_nvmf_tgt_find_subsystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_subsystem* spdk_nvmf_tgt_find_subsystem </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subnqn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the target for a subsystem with the given NQN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target to search from. </td></tr>
    <tr><td class="paramname">subnqn</td><td>NQN of the subsystem.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the NVMe-oF subsystem on success, or NULL on failure. </dd></dl>

</div>
</div>
<a id="a4b6882b7cc35f2fe656c8a8c08f9af5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6882b7cc35f2fe656c8a8c08f9af5a">&#9670;&nbsp;</a></span>spdk_nvmf_tgt_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* spdk_nvmf_tgt_get_name </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of an NVMe-oF target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The target from which to get the name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the target as a null terminated string. </dd></dl>

</div>
</div>
<a id="ad0eb8f58d51231f6fcaa1179e12128a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0eb8f58d51231f6fcaa1179e12128a6">&#9670;&nbsp;</a></span>spdk_nvmf_tgt_get_transport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_transport* spdk_nvmf_tgt_get_transport </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>transport_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an existing transport from the target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target </td></tr>
    <tr><td class="paramname">transport_name</td><td>The name of the transport type to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transport or NULL if not found </dd></dl>

</div>
</div>
<a id="a2c31e57f4634daadf4238bf213a989d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c31e57f4634daadf4238bf213a989d6">&#9670;&nbsp;</a></span>spdk_nvmf_tgt_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_tgt_listen </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvmf_8h.html#a854e30bf69f07bb06b2cbcdd08ca7eba">spdk_nvmf_tgt_listen_done_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begin accepting new connections at the address provided. </p>
<p>The connections will be matched with a subsystem, which may or may not allow the connection based on a subsystem-specific whitelist. See <a class="el" href="nvmf_8h.html#a19b3442b7eb75c234c3e3090d2b5add3" title="Allow the given host NQN to connect to the given subsystem. ">spdk_nvmf_subsystem_add_host()</a> and <a class="el" href="nvmf_8h.html#a46521b556107a0ab58998adfeee8795f" title="Accept new connections on the address provided. ">spdk_nvmf_subsystem_add_listener()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The target associated with this listen address. </td></tr>
    <tr><td class="paramname">trid</td><td>The address to listen at. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A callback that will be called once the target is listening </td></tr>
    <tr><td class="paramname">cb_arg</td><td>A context argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void. The callback status argument will be 0 on success or a negated errno on failure. </dd></dl>

</div>
</div>
<a id="a056f7ac8ac8f7b34366650cb1a2bb940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056f7ac8ac8f7b34366650cb1a2bb940">&#9670;&nbsp;</a></span>spdk_nvmf_tgt_transport_write_config_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_tgt_transport_write_config_json </td>
          <td>(</td>
          <td class="paramtype">struct spdk_json_write_ctx *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write NVMe-oF target's transport configurations into provided JSON context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>JSON write context </td></tr>
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2aad508811686a6d16f3bfd221ba99a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aad508811686a6d16f3bfd221ba99a9">&#9670;&nbsp;</a></span>spdk_nvmf_tgt_write_config_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_tgt_write_config_json </td>
          <td>(</td>
          <td class="paramtype">struct spdk_json_write_ctx *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write NVMe-oF target configuration into provided JSON context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>JSON write context </td></tr>
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a141be89e55c37dc017ddeb2494f508c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141be89e55c37dc017ddeb2494f508c7">&#9670;&nbsp;</a></span>spdk_nvmf_transport_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_transport* spdk_nvmf_transport_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>transport_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a protocol transport. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport_name</td><td>The transport type to create </td></tr>
    <tr><td class="paramname">opts</td><td>The transport options (e.g. max_io_size)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new transport or NULL if create fails </dd></dl>

</div>
</div>
<a id="ab3d5e7bc8701baac2be7858b34fa7baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d5e7bc8701baac2be7858b34fa7baf">&#9670;&nbsp;</a></span>spdk_nvmf_transport_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_transport_destroy </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_transport *&#160;</td>
          <td class="paramname"><em>transport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a protocol transport. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The transport to destory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a1aeaade30bb4e457f5c35e2f3649d097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aeaade30bb4e457f5c35e2f3649d097">&#9670;&nbsp;</a></span>spdk_nvmf_transport_get_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_transport* spdk_nvmf_transport_get_first </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first transport registered with the given target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The NVMe-oF target</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first transport registered on the target </dd></dl>

</div>
</div>
<a id="aa1316a2fe3bd765d755de1df15add5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1316a2fe3bd765d755de1df15add5cc">&#9670;&nbsp;</a></span>spdk_nvmf_transport_get_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct spdk_nvmf_transport* spdk_nvmf_transport_get_next </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_transport *&#160;</td>
          <td class="paramname"><em>transport</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next transport in a target's list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>A handle to a transport object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next transport associated with the NVMe-oF target </dd></dl>

</div>
</div>
<a id="afa43090f9acc81ff2a5936c9cf783ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa43090f9acc81ff2a5936c9cf783ef3">&#9670;&nbsp;</a></span>spdk_nvmf_transport_listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_transport_listen </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_transport *&#160;</td>
          <td class="paramname"><em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvme__transport__id.html">spdk_nvme_transport_id</a> *&#160;</td>
          <td class="paramname"><em>trid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="nvmf_8h.html#a854e30bf69f07bb06b2cbcdd08ca7eba">spdk_nvmf_tgt_listen_done_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add listener to transport and begin accepting new connections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The transport to add listener to </td></tr>
    <tr><td class="paramname">trid</td><td>Address to listen at </td></tr>
    <tr><td class="paramname">cb_fn</td><td>A callback that will be called once the listener is created </td></tr>
    <tr><td class="paramname">cb_arg</td><td>A context argument passed to cb_fn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int. 0 if it completed successfully, or negative errno if it failed. </dd></dl>

</div>
</div>
<a id="a7c84fb153ce57c567e2b4c79400442f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c84fb153ce57c567e2b4c79400442f6">&#9670;&nbsp;</a></span>spdk_nvmf_transport_opts_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool spdk_nvmf_transport_opts_init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>transport_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport__opts.html">spdk_nvmf_transport_opts</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize transport options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport_name</td><td>The transport type to create </td></tr>
    <tr><td class="paramname">opts</td><td>The transport options (e.g. max_io_size)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool. true if successful, false if transport type not found. </dd></dl>

</div>
</div>
<a id="ab03fc0bf9946107905bf8148495966f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03fc0bf9946107905bf8148495966f9">&#9670;&nbsp;</a></span>spdk_nvmf_transport_poll_group_free_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_transport_poll_group_free_stat </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_transport *&#160;</td>
          <td class="paramname"><em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport__poll__group__stat.html">spdk_nvmf_transport_poll_group_stat</a> *&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free statistics memory previously allocated with <a class="el" href="nvmf_8h.html#ae4e59ef25ba7e6a45ab1d613c006f1bb" title="Get current transport poll group statistics. ">spdk_nvmf_transport_poll_group_get_stat()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transport</td><td>The NVMf transport. </td></tr>
    <tr><td class="paramname">stat</td><td>Pointer to transport poll group statistics structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4e59ef25ba7e6a45ab1d613c006f1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e59ef25ba7e6a45ab1d613c006f1bb">&#9670;&nbsp;</a></span>spdk_nvmf_transport_poll_group_get_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spdk_nvmf_transport_poll_group_get_stat </td>
          <td>(</td>
          <td class="paramtype">struct spdk_nvmf_tgt *&#160;</td>
          <td class="paramname"><em>tgt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct spdk_nvmf_transport *&#160;</td>
          <td class="paramname"><em>transport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspdk__nvmf__transport__poll__group__stat.html">spdk_nvmf_transport_poll_group_stat</a> **&#160;</td>
          <td class="paramname"><em>stat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current transport poll group statistics. </p>
<p>This function allocates memory for statistics and returns it in <code>stat</code> parameter. Caller must free this memory with <a class="el" href="nvmf_8h.html#ab03fc0bf9946107905bf8148495966f9" title="Free statistics memory previously allocated with spdk_nvmf_transport_poll_group_get_stat(). ">spdk_nvmf_transport_poll_group_free_stat()</a> when it is not needed anymore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tgt</td><td>The NVMf target. </td></tr>
    <tr><td class="paramname">transport</td><td>The NVMf transport. </td></tr>
    <tr><td class="paramname">stat</td><td>Output parameter that will contain pointer to allocated statistics structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 upon success. </dd>
<dd>
-ENOTSUP if transport does not support statistics. </dd>
<dd>
-EINVAL if any of parameters is NULL. </dd>
<dd>
-ENOENT if transport poll group is not found. </dd>
<dd>
-ENOMEM if memory allocation failed. </dd></dl>

</div>
</div>
<a id="ab53a8667860940846986a85db26a7236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53a8667860940846986a85db26a7236">&#9670;&nbsp;</a></span>spdk_nvmf_transport_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spdk_nvmf_transport_register </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structspdk__nvmf__transport__ops.html">spdk_nvmf_transport_ops</a> *&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register the operations for a given transport type. </p>
<p>This function should be invoked by referencing the macro SPDK_NVMF_TRANSPORT_REGISTER macro in the transport's .c file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>The operations associated with an NVMe-oF transport. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
</div>
