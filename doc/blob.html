<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="generator" content="Doxygen 1.9.1" />
  <title>SPDK: Blobstore Programmer&#39;s Guide</title>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  <script type="text/javascript" src="../js/doxyboot.js"></script>
  <script type="text/javascript" src="./navtree.js"></script>
  <link href="../css/bootstrap.min.css" rel="stylesheet" type="text/css">
  <link href="../css/spdk.css" rel="stylesheet" type="text/css">
</head>
<body>
  <nav class="navbar navbar-expand-md navbar-dark bg-dark px-2">
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="/" aria-label="SPDK">
      <img src="/img/spdk.svg"  width="36" height="36" alt="Storage Performance Development Kit" />
    </a>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <div class="navbar-nav me-auto">
        <a class="nav-link header-link active" href="../doc/">Documentation</a>
        <a class="nav-link header-link" href="../development/">Development</a>
        <a class="nav-link header-link" href="../community/">Community</a>
        <a class="nav-link header-link" href="../blog/">Blog</a>
      </div>
      <div class="navbar-nav ms-auto me-3">
        <a class="nav-link header-link" href="https://github.com/spdk/spdk">
          <svg xmlns="http://www.w3.org/2000/svg" class="navbar-nav-svg"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
        </a>
      </div>
    </div>
  </nav>
  <div class="container-fluid doc">
      <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('blob.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Blobstore Programmer's Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_blob"></a> </p>
<h1><a class="anchor" id="blob_pg_toc"></a>
In this document</h1>
<ul>
<li><a class="el" href="blob.html#blob_pg_audience">Target Audience</a></li>
<li><a class="el" href="blob.html#blob_pg_intro">Introduction</a></li>
<li><a class="el" href="blob.html#blob_pg_theory">Theory of Operation</a></li>
<li><a class="el" href="blob.html#blob_pg_design">Design Considerations</a></li>
<li><a class="el" href="blob.html#blob_pg_examples">Examples</a></li>
<li><a class="el" href="blob.html#blob_pg_config">Configuration</a></li>
<li><a class="el" href="blob.html#blob_pg_component">Component Detail</a></li>
</ul>
<h1><a class="anchor" id="blob_pg_audience"></a>
Target Audience</h1>
<p>The programmer's guide is intended for developers authoring applications that utilize the SPDK Blobstore. It is intended to supplement the source code in providing an overall understanding of how to integrate Blobstore into an application as well as provide some high level insight into how Blobstore works behind the scenes. It is not intended to serve as a design document or an API reference and in some cases source code snippets and high level sequences will be discussed; for the latest source code reference refer to the <a href="https://github.com/spdk">repo</a>.</p>
<h1><a class="anchor" id="blob_pg_intro"></a>
Introduction</h1>
<p>Blobstore is a persistent, power-fail safe block allocator designed to be used as the local storage system backing a higher level storage service, typically in lieu of a traditional filesystem. These higher level services can be local databases or key/value stores (MySQL, RocksDB), they can be dedicated appliances (SAN, NAS), or distributed storage systems (ex. Ceph, Cassandra). It is not designed to be a general purpose filesystem, however, and it is intentionally not POSIX compliant. To avoid confusion, we avoid references to files or objects instead using the term 'blob'. The Blobstore is designed to allow asynchronous, uncached, parallel reads and writes to groups of blocks on a block device called 'blobs'. Blobs are typically large, measured in at least hundreds of kilobytes, and are always a multiple of the underlying block size.</p>
<p>The Blobstore is designed primarily to run on "next generation" media, which means the device supports fast random reads and writes, with no required background garbage collection. However, in practice the design will run well on NAND too.</p>
<h1><a class="anchor" id="blob_pg_theory"></a>
Theory of Operation</h1>
<h2>Abstractions</h2>
<p>The Blobstore defines a hierarchy of storage abstractions as follows.</p>
<ul>
<li><b>Logical Block</b>: Logical blocks are exposed by the disk itself, which are numbered from 0 to N, where N is the number of blocks in the disk. A logical block is typically either 512B or 4KiB.</li>
<li><b>Page</b>: A page is defined to be a fixed number of logical blocks defined at Blobstore creation time. The logical blocks that compose a page are always contiguous. Pages are also numbered from the beginning of the disk such that the first page worth of blocks is page 0, the second page is page 1, etc. A page is typically 4KiB in size, so this is either 8 or 1 logical blocks in practice. The SSD must be able to perform atomic reads and writes of at least the page size.</li>
<li><b>Cluster</b>: A cluster is a fixed number of pages defined at Blobstore creation time. The pages that compose a cluster are always contiguous. Clusters are also numbered from the beginning of the disk, where cluster 0 is the first cluster worth of pages, cluster 1 is the second grouping of pages, etc. A cluster is typically 1MiB in size, or 256 pages.</li>
<li><b>Blob</b>: A blob is an ordered list of clusters. Blobs are manipulated (created, sized, deleted, etc.) by the application and persist across power failures and reboots. Applications use a Blobstore provided identifier to access a particular blob. Blobs are read and written in units of pages by specifying an offset from the start of the blob. Applications can also store metadata in the form of key/value pairs with each blob which we'll refer to as xattrs (extended attributes).</li>
<li><b>Blobstore</b>: An SSD which has been initialized by a Blobstore-based application is referred to as "a Blobstore." A Blobstore owns the entire underlying device which is made up of a private Blobstore metadata region and the collection of blobs as managed by the application.</li>
</ul>
<div class="fragment"><div class="line">+-----------------------------------------------------------------+</div>
<div class="line">|                              Blob                               |</div>
<div class="line">| +-----------------------------+ +-----------------------------+ |</div>
<div class="line">| |           Cluster           | |           Cluster           | |</div>
<div class="line">| | +----+ +----+ +----+ +----+ | | +----+ +----+ +----+ +----+ | |</div>
<div class="line">| | |Page| |Page| |Page| |Page| | | |Page| |Page| |Page| |Page| | |</div>
<div class="line">| | +----+ +----+ +----+ +----+ | | +----+ +----+ +----+ +----+ | |</div>
<div class="line">| +-----------------------------+ +-----------------------------+ |</div>
<div class="line">+-----------------------------------------------------------------+</div>
</div><!-- fragment --><h2>Atomicity</h2>
<p>For all Blobstore operations regarding atomicity, there is a dependency on the underlying device to guarantee atomic operations of at least one page size. Atomicity here can refer to multiple operations:</p>
<ul>
<li><b>Data Writes</b>: For the case of data writes, the unit of atomicity is one page. Therefore if a write operation of greater than one page is underway and the system suffers a power failure, the data on media will be consistent at a page size granularity (if a single page were in the middle of being updated when power was lost, the data at that page location will be as it was prior to the start of the write operation following power restoration.)</li>
<li><b>Blob Metadata Updates</b>: Each blob has its own set of metadata (xattrs, size, etc). For performance reasons, a copy of this metadata is kept in RAM and only synchronized with the on-disk version when the application makes an explicit call to do so, or when the Blobstore is unloaded. Therefore, setting of an xattr, for example is not consistent until the call to synchronize it (covered later) which is, however, performed atomically.</li>
<li><b>Blobstore Metadata Updates</b>: Blobstore itself has its own metadata which, like per blob metadata, has a copy in both RAM and on-disk. Unlike the per blob metadata, however, the Blobstore metadata region is not made consistent via a blob synchronization call, it is only synchronized when the Blobstore is properly unloaded via API. Therefore, if the Blobstore metadata is updated (blob creation, deletion, resize, etc.) and not unloaded properly, it will need to perform some extra steps the next time it is loaded which will take a bit more time than it would have if shutdown cleanly, but there will be no inconsistencies.</li>
</ul>
<h2>Callbacks</h2>
<p>Blobstore is callback driven; in the event that any Blobstore API is unable to make forward progress it will not block but instead return control at that point and make a call to the callback function provided in the API, along with arguments, when the original call is completed. The callback will be made on the same thread that the call was made from, more on threads later. Some API, however, offer no callback arguments; in these cases the calls are fully synchronous. Examples of asynchronous calls that utilize callbacks include those that involve disk IO, for example, where some amount of polling is required before the IO is completed.</p>
<h2>Backend Support</h2>
<p>Blobstore requires a backing storage device that can be integrated using the <code>bdev</code> layer, or by directly integrating a device driver to Blobstore. The blobstore performs operations on a backing block device by calling function pointers supplied to it at initialization time. For convenience, an implementation of these function pointers that route I/O to the bdev layer is available in <code>bdev_blob.c</code>. Alternatively, for example, the SPDK NVMe driver may be directly integrated bypassing a small amount of <code>bdev</code> layer overhead. These options will be discussed further in the upcoming section on examples.</p>
<h2>Metadata Operations</h2>
<p>Because Blobstore is designed to be lock-free, metadata operations need to be isolated to a single thread to avoid taking locks on in memory data structures that maintain data on the layout of definitions of blobs (along with other data). In Blobstore this is implemented as <code>the metadata thread</code> and is defined to be the thread on which the application makes metadata related calls on. It is up to the application to setup a separate thread to make these calls on and to assure that it does not mix relevant IO operations with metadata operations even if they are on separate threads. This will be discussed further in the Design Considerations section.</p>
<h2>Threads</h2>
<p>An application using Blobstore with the SPDK NVMe driver, for example, can support a variety of thread scenarios. The simplest would be a single threaded application where the application, the Blobstore code and the NVMe driver share a single core. In this case, the single thread would be used to submit both metadata operations as well as IO operations and it would be up to the application to assure that only one metadata operation is issued at a time and not intermingled with affected IO operations.</p>
<h2>Channels</h2>
<p>Channels are an SPDK-wide abstraction and with Blobstore the best way to think about them is that they are required in order to do IO. The application will perform IO to the channel and channels are best thought of as being associated 1:1 with a thread.</p>
<p>With external snapshots (see <a class="el" href="blob.html#blob_pg_esnap_and_esnap_clone">External Snapshots and Esnap Clones</a>), a read from a blob may lead to reading from the device containing the blobstore or an external snapshot device. To support this, each blobstore IO channel maintains a tree of channels to be used when reading from external snapshot devices.</p>
<h2>Blob Identifiers</h2>
<p>When an application creates a blob, it does not provide a name as is the case with many other similar storage systems, instead it is returned a unique identifier by the Blobstore that it needs to use on subsequent APIs to perform operations on the Blobstore.</p>
<h1><a class="anchor" id="blob_pg_design"></a>
Design Considerations</h1>
<h2>Initialization Options</h2>
<p>When the Blobstore is initialized, there are multiple configuration options to consider. The options and their defaults are:</p>
<ul>
<li><b>Cluster Size</b>: By default, this value is 1MB. The cluster size is required to be a multiple of page size and should be selected based on the application’s usage model in terms of allocation. Recall that blobs are made up of clusters so when a blob is allocated/deallocated or changes in size, disk LBAs will be manipulated in groups of cluster size. If the application is expecting to deal with mainly very large (always multiple GB) blobs then it may make sense to change the cluster size to 1GB for example.</li>
<li><b>Number of Metadata Pages</b>: By default, Blobstore will assume there can be as many clusters as there are metadata pages which is the worst case scenario in terms of metadata usage and can be overridden here however the space efficiency is not significant.</li>
<li><b>Maximum Simultaneous Metadata Operations</b>: Determines how many internally pre-allocated memory structures are set aside for performing metadata operations. It is unlikely that changes to this value (default 32) would be desirable.</li>
<li><b>Maximum Simultaneous Operations Per Channel</b>: Determines how many internally pre-allocated memory structures are set aside for channel operations. Changes to this value would be application dependent and best determined by both a knowledge of the typical usage model, an understanding of the types of SSDs being used and empirical data. The default is 512.</li>
<li><b>Blobstore Type</b>: This field is a character array to be used by applications that need to identify whether the Blobstore found here is appropriate to claim or not. The default is NULL and unless the application is being deployed in an environment where multiple applications using the same disks are at risk of inadvertently using the wrong Blobstore, there is no need to set this value. It can, however, be set to any valid set of characters.</li>
<li><b>External Snapshot Device Creation Callback</b>: If the blobstore supports external snapshots this function will be called as a blob that clones an external snapshot (an "esnap clone") is opened so that the blobstore consumer can load the external snapshot and register a blobstore device that will satisfy read requests. See <a class="el" href="blob.html#blob_pg_esnap_and_esnap_clone">External Snapshots and Esnap Clones</a>.</li>
</ul>
<h2>Sub-page Sized Operations</h2>
<p>Blobstore is only capable of doing page sized read/write operations. If the application requires finer granularity it will have to accommodate that itself.</p>
<h2>Threads</h2>
<p>As mentioned earlier, Blobstore can share a single thread with an application or the application can define any number of threads, within resource constraints, that makes sense. The basic considerations that must be followed are:</p>
<ul>
<li>Metadata operations (API with MD in the name) should be isolated from each other as there is no internal locking on the memory structures affected by these API.</li>
<li>Metadata operations should be isolated from conflicting IO operations (an example of a conflicting IO would be one that is reading/writing to an area of a blob that a metadata operation is deallocating).</li>
<li>Asynchronous callbacks will always take place on the calling thread.</li>
<li>No assumptions about IO ordering can be made regardless of how many or which threads were involved in the issuing.</li>
</ul>
<h2>Data Buffer Memory</h2>
<p>As with all SPDK based applications, Blobstore requires memory used for data buffers to be allocated with SPDK API.</p>
<h2>Error Handling</h2>
<p>Asynchronous Blobstore callbacks all include an error number that should be checked; non-zero values indicate an error. Synchronous calls will typically return an error value if applicable.</p>
<h2>Asynchronous API</h2>
<p>Asynchronous callbacks will return control not immediately, but at the point in execution where no more forward progress can be made without blocking. Therefore, no assumptions can be made about the progress of an asynchronous call until the callback has completed.</p>
<h2>Xattrs</h2>
<p>Setting and removing of xattrs in Blobstore is a metadata operation, xattrs are stored in per blob metadata. Therefore, xattrs are not persisted until a blob synchronization call is made and completed. Having a step process for persisting per blob metadata allows for applications to perform batches of xattr updates, for example, with only one more expensive call to synchronize and persist the values.</p>
<h2>Synchronizing Metadata</h2>
<p>As described earlier, there are two types of metadata in Blobstore, per blob and one global metadata for the Blobstore itself. Only the per blob metadata can be explicitly synchronized via API. The global metadata will be inconsistent during run-time and only synchronized on proper shutdown. The implication, however, of an improper shutdown is only a performance penalty on the next startup as the global metadata will need to be rebuilt based on a parsing of the per blob metadata. For consistent start times, it is important to always close down the Blobstore properly via API.</p>
<h2>Iterating Blobs</h2>
<p>Multiple examples of how to iterate through the blobs are included in the sample code and tools. Worthy to note, however, if walking through the existing blobs via the iter API, if your application finds the blob its looking for it will either need to explicitly close it (because was opened internally by the Blobstore) or complete walking the full list.</p>
<h2>The Super Blob</h2>
<p>The super blob is simply a single blob ID that can be stored as part of the global metadata to act as sort of a "root" blob. The application may choose to use this blob to store any information that it needs or finds relevant in understanding any kind of structure for what is on the Blobstore.</p>
<h1><a class="anchor" id="blob_pg_examples"></a>
Examples</h1>
<p>There are multiple examples of Blobstore usage in the <a href="https://github.com/spdk/spdk">repo</a>:</p>
<ul>
<li><b>Hello World</b>: Actually named <code>hello_blob.c</code> this is a very basic example of a single threaded application that does nothing more than demonstrate the very basic API. Although Blobstore is optimized for NVMe, this example uses a RAM disk (malloc) back-end so that it can be executed easily in any development environment. The malloc back-end is a <code>bdev</code> module thus this example uses not only the SPDK Framework but the <code>bdev</code> layer as well.</li>
<li><b>CLI</b>: The <code>blobcli.c</code> example is command line utility intended to not only serve as example code but as a test and development tool for Blobstore itself. It is also a simple single threaded application that relies on both the SPDK Framework and the <code>bdev</code> layer but offers multiple modes of operation to accomplish some real-world tasks. In command mode, it accepts single-shot commands which can be a little time consuming if there are many commands to get through as each one will take a few seconds waiting for DPDK initialization. It therefore has a shell mode that allows the developer to get to a <code>blob&gt;</code> prompt and then very quickly interact with Blobstore with simple commands that include the ability to import/export blobs from/to regular files. Lastly there is a scripting mode to automate a series of tasks, again, handy for development and/or test type activities.</li>
</ul>
<h1><a class="anchor" id="blob_pg_config"></a>
Configuration</h1>
<p>Blobstore configuration options are described in the initialization options section under <a class="el" href="blob.html#blob_pg_design">Design Considerations</a>.</p>
<h1><a class="anchor" id="blob_pg_component"></a>
Component Detail</h1>
<p>The information in this section is not necessarily relevant to designing an application for use with Blobstore, but understanding a little more about the internals may be interesting and is also included here for those wanting to contribute to the Blobstore effort itself.</p>
<h2>Media Format</h2>
<p>The Blobstore owns the entire storage device. The device is divided into clusters starting from the beginning, such that cluster 0 begins at the first logical block.</p>
<div class="fragment"><div class="line">LBA 0                                   LBA N</div>
<div class="line">+-----------+-----------+-----+-----------+</div>
<div class="line">| Cluster 0 | Cluster 1 | ... | Cluster N |</div>
<div class="line">+-----------+-----------+-----+-----------+</div>
</div><!-- fragment --><p>Cluster 0 is special and has the following format, where page 0 is the first page of the cluster:</p>
<div class="fragment"><div class="line">+--------+-------------------+</div>
<div class="line">| Page 0 | Page 1 ... Page N |</div>
<div class="line">+--------+-------------------+</div>
<div class="line">| Super  |  Metadata Region  |</div>
<div class="line">| Block  |                   |</div>
<div class="line">+--------+-------------------+</div>
</div><!-- fragment --><p>The super block is a single page located at the beginning of the partition. It contains basic information about the Blobstore. The metadata region is the remainder of cluster 0 and may extend to additional clusters. Refer to the latest source code for complete structural details of the super block and metadata region.</p>
<p>Each blob is allocated a non-contiguous set of pages inside the metadata region for its metadata. These pages form a linked list. The first page in the list will be written in place on update, while all other pages will be written to fresh locations. This requires the backing device to support an atomic write size greater than or equal to the page size to guarantee that the operation is atomic. See the section on atomicity for details.</p>
<h2><a class="anchor" id="blob_pg_cluster_layout"></a>
Blob cluster layout</h2>
<p>Each blob is an ordered list of clusters, where starting LBA of a cluster is called extent. A blob can be thin provisioned, resulting in no extent for some of the clusters. When first write operation occurs to the unallocated cluster - new extent is chosen. This information is stored in RAM and on-disk.</p>
<p>There are two extent representations on-disk, dependent on <code>use_extent_table</code> (default:true) opts used when creating a blob.</p>
<ul>
<li><b>use_extent_table=true</b>: EXTENT_PAGE descriptor is not part of linked list of pages. It contains extents that are not run-length encoded. Each extent page is referenced by EXTENT_TABLE descriptor, which is serialized as part of linked list of pages. Extent table is run-length encoding all unallocated extent pages. Every new cluster allocation updates a single extent page, in case when extent page was previously allocated. Otherwise additionally incurs serializing whole linked list of pages for the blob.</li>
<li><b>use_extent_table=false</b>: EXTENT_RLE descriptor is serialized as part of linked list of pages. Extents pointing to contiguous LBA are run-length encoded, including unallocated extents represented by 0. Every new cluster allocation incurs serializing whole linked list of pages for the blob.</li>
</ul>
<h2>Thin Blobs, Snapshots, and Clones</h2>
<p>Each in-use cluster is allocated to blobstore metadata or to a particular blob. Once a cluster is allocated to a blob it is considered owned by that blob and that particular blob's metadata maintains a reference to the cluster as a record of ownership. Cluster ownership is transferred during snapshot operations described later in <a class="el" href="blob.html#blob_pg_snapshots">Snapshots and Clones</a>.</p>
<p>Through the use of thin provisioning, snapshots, and/or clones, a blob may be backed by clusters it owns, clusters owned by another blob, or by a zeroes device. The behavior of reads and writes depend on whether the operation targets blocks that are backed by a cluster owned by the blob or not.</p>
<ul>
<li><b>read from blocks on an owned cluster</b>: The read is serviced by reading directly from the appropriate cluster.</li>
<li><b>read from other blocks</b>: The read is passed on to the blob's <em>back device</em> and the back device services the read. The back device may be another blob or it may be a zeroes device.</li>
<li><b>write to blocks on an owned cluster</b>: The write is serviced by writing directly to the appropriate cluster.</li>
<li><b>write to thin provisioned cluster</b>: If the back device is the zeroes device and no cluster is allocated to the blob the process described in <a class="el" href="blob.html#blob_pg_thin_provisioning">Thin Provisioning</a> is followed.</li>
<li><b>write to other blocks</b>: A copy-on-write operation is triggered. See <a class="el" href="blob.html#blob_pg_copy_on_write">Copy-on-write</a> for details.</li>
</ul>
<p>External snapshots allow some external data source to act as a snapshot. This allows clones to be created of data that resides outside of the blobstore containing the clone.</p>
<h3><a class="anchor" id="blob_pg_thin_provisioning"></a>
Thin Provisioning</h3>
<p>As mentioned in <a class="el" href="blob.html#blob_pg_cluster_layout">Blob cluster layout</a>, a blob may be thin provisioned. A thin provisioned blob starts out with no allocated clusters. Clusters are allocated as writes occur. A thin provisioned blob's back device is a <em>zeroes device</em>. A read from a zeroes device fills the read buffer with zeroes.</p>
<p>When a thin provisioned volume writes to a block that does not have an allocated cluster, the following steps are performed:</p>
<ol type="1">
<li>Allocate a cluster.</li>
<li>Update blob metadata.</li>
<li>Perform the write.</li>
</ol>
<h3><a class="anchor" id="blob_pg_snapshots"></a>
Snapshots and Clones</h3>
<p>A snapshot is a read-only blob that may have clones. A snapshot may itself be a clone of one other blob. While the interface gives the illusion of being able to create many snapshots of a blob, under the covers this results in a chain of snapshots that are clones of the previous snapshot.</p>
<p>When blob1 is snapshotted, a new read-only blob is created and blob1 becomes a clone of this new blob. That is:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Step   </th><th class="markdownTableHeadNone">Action   </th><th class="markdownTableHeadNone">State    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Create blob1   </td><td class="markdownTableBodyNone"><code>blob1 (rw)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">Create snapshot blob2 of blob1   </td><td class="markdownTableBodyNone"><code>blob1 (rw) --&gt; blob2 (ro)</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2a   </td><td class="markdownTableBodyNone">Write to blob1   </td><td class="markdownTableBodyNone"><code>blob1 (rw) --&gt; blob2 (ro)</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">Create snapshot blob3 of blob1   </td><td class="markdownTableBodyNone"><code>blob1 (rw) --&gt; blob3 (ro) ---&gt; blob2 (ro)</code>   </td></tr>
</table>
<p>Supposing blob1 was not thin provisioned, step 1 would have allocated clusters needed to perform a full write of blob1. As blob2 is created in step 2, the ownership of all of blob1's clusters is transferred to blob2 and blob2 becomes blob1's back device. During step2a, the writes to blob1 cause one or more clusters to be allocated to blob1. When blob3 is created in step 3, the clusters allocated in step 2a are given to blob3, blob3's back device becomes blob2, and blob1's back device becomes blob3.</p>
<p>It is important to understand the chain above when considering strategies to use a golden image from which many clones are made. The IO path is more efficient if one snapshot is cloned many times than it is to create a new snapshot for every clone. The following illustrates the difference.</p>
<p>Using a single snapshot means the data originally referenced by the golden image is always one hop away.</p>
<div class="fragment"><div class="line">create golden                           golden --&gt; golden-snap</div>
<div class="line">snapshot golden as golden-snap                     ^ ^ ^</div>
<div class="line">clone golden-snap as clone1              clone1 ---+ | |</div>
<div class="line">clone golden-snap as clone2              clone2 -----+ |</div>
<div class="line">clone golden-snap as clone3              clone3 -------+</div>
</div><!-- fragment --><p>Using a snapshot per clone means that the chain of back devices grows with every new snapshot and clone pair. Reading a block from clone3 may result in a read from clone3's back device (snap3), from clone2's back device (snap2), then finally clone1's back device (snap1, the current owner of the blocks originally allocated to golden).</p>
<div class="fragment"><div class="line">create golden</div>
<div class="line">snapshot golden as snap1                golden --&gt; snap3 -----&gt; snap2 ----&gt; snap1</div>
<div class="line">clone snap1 as clone1                   clone3----/   clone2 --/  clone1 --/</div>
<div class="line">snapshot golden as snap2</div>
<div class="line">clone snap2 as clone2</div>
<div class="line">snapshot golden as snap3</div>
<div class="line">clone snap3 as clone3</div>
</div><!-- fragment --><p>A snapshot with no more than one clone can be deleted. When a snapshot with one clone is deleted, the clone becomes a regular blob. The clusters owned by the snapshot are transferred to the clone or freed, depending on whether the clone already owns a cluster for a particular block range.</p>
<p>Removal of the last clone leaves the snapshot in place. This snapshot continues to be read-only and can serve as the snapshot for future clones.</p>
<h3>Inflating and Decoupling Clones</h3>
<p>A clone can remove its dependence on a snapshot with the following operations:</p>
<ol type="1">
<li>Inflate the clone. Clusters backed by any snapshot or a zeroes device are copied into newly allocated clusters. The blob becomes a thick provisioned blob.</li>
<li>Decouple the clone. Clusters backed by the first back device snapshot are copied into newly allocated clusters. If the clone's back device snapshot was itself a clone of another snapshot, the clone remains a clone but is now a clone of a different snapshot.</li>
<li>Remove the snapshot. This is only possible if the snapshot has one clone. The end result is usually the same as decoupling but ownership of clusters is transferred from the snapshot rather than being copied. If the snapshot that was deleted was itself a clone of another snapshot, the clone remains a clone, but is now a clone of a different snapshot.</li>
</ol>
<h3><a class="anchor" id="blob_pg_esnap_and_esnap_clone"></a>
External Snapshots and Esnap Clones</h3>
<p>A blobstore that is loaded with the <code>esnap_bs_dev_create</code> callback defined will support external snapshots (esnaps). An external snapshot is not useful on its own: it needs to be cloned by a blob. A clone of an external snapshot is referred to as an <em>esnap clone</em>. An esnap clone supports IO and other operations just like any other clone.</p>
<p>An esnap clone can be recognized in various ways:</p>
<ul>
<li><b>On disk</b>: the blob metadata has the <code>SPDK_BLOB_EXTERNAL_SNAPSHOT</code> (0x8) bit is set in <code>invalid_flags</code> and an internal XATTR with name <code>BLOB_EXTERNAL_SNAPSHOT_ID</code> ("EXTSNAP") exists.</li>
<li><b>In memory</b>: The <code>spdk_blob</code> structure contains the metadata read from disk, <code>blob-&gt;parent_id</code> is set to <code>SPDK_BLOBID_EXTERNAL_SNAPSHOT</code>, and <code>blob-&gt;back_bs_dev</code> references a blobstore device which is not a blob in the same blobstore nor a zeroes device.</li>
</ul>
<h3><a class="anchor" id="blob_shallow_copy"></a>
Shallow Copy</h3>
<p>A read only blob can be copied over a blob store device in a way that only clusters allocated to the blob will be written on the device. This device must have a size equal or greater than blob's size and blob store's block size must be an integer multiple of device's block size. This functionality can be used to recreate the entire snapshot stack of a blob into a different blob store.</p>
<h3><a class="anchor" id="blob_reparent"></a>
Change the parent of a blob</h3>
<p>We can change the parent of a thin provisioned blob, making the blob a clone of a snapshot of the same blobstore or a clone of an external snapshot. The previous parent of the blob can be a snapshot, an external snapshot or none.</p>
<p>If the new parent of the blob is a snapshot of the same blobstore, blob and snapshot must have the same number of clusters.</p>
<p>If the new parent of the blob is an external snapshot, the size of the esnap must be an integer multiple of blob's cluster size.</p>
<h3><a class="anchor" id="blob_pg_copy_on_write"></a>
Copy-on-write</h3>
<p>A copy-on-write operation is somewhat expensive, with the cost being proportional to the cluster size. Typical copy-on-write involves the following steps:</p>
<ol type="1">
<li>Allocate a cluster.</li>
<li>Allocate a cluster-sized buffer into which data can be read.</li>
<li>Trigger a full-cluster read from the back device into the cluster-sized buffer.</li>
<li>Write from the cluster-sized buffer into the newly allocated cluster.</li>
<li>Update the blob's on-disk metadata to record ownership of the newly allocated cluster. This involves at least one page-sized write.</li>
<li>Write the new data to the just allocated and copied cluster.</li>
</ol>
<p>If the source cluster is backed by a zeroes device, steps 2 through 4 are skipped. Alternatively, if the blobstore resides on a device that can perform the copy on its own, steps 2 through 4 are offloaded to the device. Neither of these optimizations are available when the back device is an external snapshot.</p>
<h2>Sequences and Batches</h2>
<p>Internally Blobstore uses the concepts of sequences and batches to submit IO to the underlying device in either a serial fashion or in parallel, respectively. Both are defined using the following structure:</p>
<div class="fragment"><div class="line">struct spdk_bs_request_set;</div>
</div><!-- fragment --><p>These requests sets are basically bookkeeping mechanisms to help Blobstore efficiently deal with related groups of IO. They are an internal construct only and are pre-allocated on a per channel basis (channels were discussed earlier). They are removed from a channel associated linked list when the set (sequence or batch) is started and then returned to the list when completed.</p>
<p>Each request set maintains a reference to a <code>channel</code> and a <code>back_channel</code>. The <code>channel</code> is used for performing IO on the blobstore device. The <code>back_channel</code> is used for performing IO on the blob's back device, <code>blob-&gt;back_bs_dev</code>. For blobs that are not esnap clones, <code>channel</code> and <code>back_channel</code> reference an IO channel used with the device that contains the blobstore. For blobs that are esnap clones, <code>channel</code> is the same as with any other blob and <code>back_channel</code> is an IO channel for the external snapshot device.</p>
<h2>Key Internal Structures</h2>
<p><code>blobstore.h</code> contains many of the key structures for the internal workings of Blobstore. Only a few notable ones are reviewed here. Note that <code>blobstore.h</code> is an internal header file, the header file for Blobstore that defines the public API is <code><a class="el" href="blob_8h.html" title="Blob Storage System.">blob.h</a></code>.</p>
<div class="fragment"><div class="line">struct spdk_blob</div>
</div><!-- fragment --><p> This is an in-memory data structure that contains key elements like the blob identifier, its current state and two copies of the mutable metadata for the blob; one copy is the current metadata and the other is the last copy written to disk.</p>
<div class="fragment"><div class="line">struct spdk_blob_mut_data</div>
</div><!-- fragment --><p> This is a per blob structure, included the <code>struct spdk_blob</code> struct that actually defines the blob itself. It has the specific information on size and makeup of the blob (ie how many clusters are allocated for this blob and which ones.)</p>
<div class="fragment"><div class="line">struct spdk_blob_store</div>
</div><!-- fragment --><p> This is the main in-memory structure for the entire Blobstore. It defines the global on disk metadata region and maintains information relevant to the entire system - initialization options such as cluster size, etc.</p>
<div class="fragment"><div class="line">struct spdk_bs_super_block</div>
</div><!-- fragment --><p> The super block is an on-disk structure that contains all of the relevant information that's in the in-memory Blobstore structure just discussed along with other elements one would expect to see here such as signature, version, checksum, etc.</p>
<h2>Code Layout and Common Conventions</h2>
<p>In general, <code>Blobstore.c</code> is laid out with groups of related functions blocked together with descriptive comments. For example,</p>
<div class="fragment"><div class="line">/* START spdk_bs_md_delete_blob */</div>
<div class="line">&lt; relevant functions to accomplish the deletion of a blob &gt;</div>
<div class="line">/* END spdk_bs_md_delete_blob */</div>
</div><!-- fragment --><p>And for the most part the following conventions are followed throughout:</p>
<ul>
<li>functions beginning with an underscore are called internally only</li>
<li>functions or variables with the letters <code>cpl</code> are related to set or callback completions </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<ul>
        <li class="footer">Generated by
        <a href="http://www.doxygen.org/index.html">doxygen</a> 1.9.1 </li>
</ul>
</div>
</div>
</body>
</html>
