<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- For Mobile Devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Type" content="text/xhtml; charset=utf-8">
  <meta name="generator" content="Doxygen 1.8.13">
  <title>SPDK: Blobstore</title>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,900" type="text/css">
  <link href="../css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="tabs.css" type="text/css">
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class="container-fluid">
  <div id="top">  <!-- do not remove this div, it is closed by doxygen! -->
    <div class="row no-gutters">
      <div class="col-sm-12">
        <section id="nav">
          <div class="navbar navbar-default navbar-static-top banner-tabs">
            <ul class="nav navbar-nav">
              <li role="presentation">
                <a href="http://www.spdk.io/">
                  <i class="glyphicon glyphicon-home"></i>
                  <span class="box-name">home</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/releases/">
                  <i class="glyphicon glyphicon-download-alt"></i>
                  <span class="box-name">download</span>
                </a>
              </li>
              <li class="active" role="presentation">
                <a href="index.html">
                  <i class="glyphicon glyphicon-book"></i>
                  <span class="box-name">documentation</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/development/">
                  <i class="glyphicon glyphicon-wrench"></i>
                  <span class="box-name">development</span>
                </a>
              </li>
              <li role="presentation">
                <a href="https://ci.spdk.io/">
                  <i class="glyphicon glyphicon-ok"></i>
                  <span class="box-name">CI status</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/community/">
                  <i class="glyphicon glyphicon-envelope"></i>
                  <span class="box-name">community</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/blog/">
                  <i class="glyphicon glyphicon-comment"></i>
                  <span class="box-name">Blog</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/roadmap/">
                  <i class="glyphicon glyphicon-map-marker"></i>
                  <span class="box-name">Roadmap</span>
                </a>
              </li>
              <li role="presentation">
                <a href="http://www.spdk.io/news/">
                  <i class="glyphicon glyphicon-bullhorn"></i>
                  <span class="box-name">News</span>
                </a>
              </li>
            </ul>
          </div>
        </section>
      </div>
    </div>
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('blob.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Blobstore </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction</h2>
<p>The blobstore is a persistent, power-fail safe block allocator designed to be used as the local storage system backing a higher level storage service, typically in lieu of a traditional filesystem. These higher level services can be local databases or key/value stores (MySQL, RocksDB), they can be dedicated appliances (SAN, NAS), or distributed storage systems (ex. Ceph, Cassandra). It is not designed to be a general purpose filesystem, however, and it is intentionally not POSIX compliant. To avoid confusion, no reference to files or objects will be made at all, instead using the term 'blob'. The blobstore is designed to allow asynchronous, uncached, parallel reads and writes to groups of blocks on a block device called 'blobs'. Blobs are typically large, measured in at least hundreds of kilobytes, and are always a multiple of the underlying block size.</p>
<p>The blobstore is designed primarily to run on "next generation" media, which means the device supports fast random reads <em>and</em> writes, with no required background garbage collection. However, in practice the design will run well on NAND too. Absolutely no attempt will be made to make this efficient on spinning media.</p>
<h2>Design Goals</h2>
<p>The blobstore is intended to solve a number of problems that local databases have when using traditional POSIX filesystems. These databases are assumed to 'own' the entire storage device, to not need to track access times, and to require only a very simple directory hierarchy. These assumptions allow significant design optimizations over a traditional POSIX filesystem and block stack.</p>
<p>Asynchronous I/O can be an order of magnitude or more faster than synchronous I/O, and so solutions like <a href="https://git.fedorahosted.org/cgit/libaio.git/">libaio</a> have become popular. However, libaio is <a href="http://www.scylladb.com/2016/02/09/qualifying-filesystems/">not actually asynchronous</a> in all cases. The blobstore will provide truly asynchronous operations in all cases without any hidden locks or stalls.</p>
<p>With the advent of NVMe, storage devices now have a hardware interface that allows for highly parallel I/O submission from many threads with no locks. Unfortunately, placement of data on a device requires some central coordination to avoid conflicts. The blobstore will separate operations that require coordination from operations that do not, and allow users to explictly associate I/O with channels. Operations on different channels happen in parallel, all the way down to the hardware, with no locks or coordination.</p>
<p>As media access latency improves, strategies for in-memory caching are changing and often the kernel page cache is a bottleneck. Many databases have moved to opening files only in O_DIRECT mode, avoiding the page cache entirely, and writing their own caching layer. With the introduction of next generation media and its additional expected latency reductions, this strategy will become far more prevalent. To support this, the blobstore will perform no in-memory caching of data at all, essentially making all blob operations conceptually equivalent to O_DIRECT. This means the blobstore has similar restrictions to O_DIRECT where data can only be read or written in units of pages (4KiB), although memory alignment requirements are much less strict than O_DIRECT (the pages can even be composed of scattered buffers). We fully expect that DRAM caching will remain critical to performance, but leave the specifics of the cache design to higher layers.</p>
<p>Storage devices pull data from host memory using a DMA engine, and those DMA engines operate on physical addresses and often introduce alignment restrictions. Further, to avoid data corruption, the data must not be paged out by the operating system while it is being transferred to disk. Traditionally, operating systems solve this problem either by copying user data into special kernel buffers that were allocated for this purpose and the I/O operations are performed to/from there, or taking locks to mark all user pages as locked and unmovable. Historically, the time to perform the copy or locking was inconsequential relative to the I/O time at the storage device, but that is simply no longer the case. The blobstore will instead provide zero copy, lockless read and write access to the device. To do this, memory to be used for blob data must be registered with the blobstore up front, preferably at application start and out of the I/O path, so that it can be pinned, the physical addresses can be determined, and the alignment requirements can be verified.</p>
<p>Hardware devices are necessarily limited to some maximum queue depth. For NVMe devices that can be quite large (the spec allows up to 64k!), but is typically much smaller (128 - 1024 per queue). Under heavy load, databases may generate enough requests to exceed the hardware queue depth, which requires queueing in software. For operating systems this is often done in the generic block layer and may cause unexpected stalls or require locks. The blobstore will avoid this by simply failing requests with an appropriate error code when the queue is full. This allows the blobstore to easily stick to its commitment to never block, but may require the user to provide their own queueing layer.</p>
<h2>The Basics</h2>
<p>The blobstore defines a hierarchy of three units of disk space. The smallest are the <em>logical blocks</em> exposed by the disk itself, which are numbered from 0 to N, where N is the number of blocks in the disk. A logical block is typically either 512B or 4KiB.</p>
<p>The blobstore defines a <em>page</em> to be a fixed number of logical blocks defined at blobstore creation time. The logical blocks that compose a page are contiguous. Pages are also numbered from the beginning of the disk such that the first page worth of blocks is page 0, the second page is page 1, etc. A page is typically 4KiB in size, so this is either 8 or 1 logical blocks in practice. The device must be able to perform atomic reads and writes of at least the page size.</p>
<p>The largest unit is a <em>cluster</em>, which is a fixed number of pages defined at blobstore creation time. The pages that compose a cluster are contiguous. Clusters are also numbered from the beginning of the disk, where cluster 0 is the first cluster worth of pages, cluster 1 is the second grouping of pages, etc. A cluster is typically 1MiB in size, or 256 pages.</p>
<p>On top of these three basic units, the blobstore defines three primitives. The most fundamental is the blob, where a blob is an ordered list of clusters plus an identifier. Blobs persist across power failures and reboots. The set of all blobs described by shared metadata is called the blobstore. I/O operations on blobs are submitted through a channel. Channels are tied to threads, but multiple threads can simultaneously submit I/O operations to the same blob on their own channels.</p>
<p>Blobs are read and written in units of pages by specifying an offset in the virtual blob address space. This offset is translated by first determining which cluster(s) are being accessed, and then translating to a set of logical blocks. This translation is done trivially using only basic math - there is no mapping data structure. Unlike read and write, blobs are resized in units of clusters.</p>
<p>Blobs are described by their metadata which consists of a discontiguous set of pages stored in a reserved region on the disk. Each page of metadata is referred to as a <em>metadata page</em>. Blobs do not share metadata pages with other blobs, and in fact the design relies on the backing storage device supporting an atomic write unit greater than or equal to the page size. Most devices backed by NAND and next generation media support this atomic write capability, but often magnetic media does not.</p>
<p>The metadata region is fixed in size and defined upon creation of the blobstore. The size is configurable, but by default one page is allocated for each cluster. For 1MiB clusters and 4KiB pages, that results in 0.4% metadata overhead.</p>
<h2>Conventions</h2>
<p>Data formats on the device are specified in <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">Backus-Naur Form</a>. All data is stored on media in little-endian format. Unspecified data must be zeroed.</p>
<h2>Media Format</h2>
<p>The blobstore owns the entire storage device. The device is divided into clusters starting from the beginning, such that cluster 0 begins at the first logical block. </p><pre class="fragment">LBA 0                                   LBA N
+-----------+-----------+-----+-----------+
| Cluster 0 | Cluster 1 | ... | Cluster N |
+-----------+-----------+-----+-----------+
</pre><p>Or in formal notation: </p><pre class="fragment">&lt;media-format&gt; ::= &lt;cluster0&gt; &lt;cluster&gt;*
</pre><p>Cluster 0 is special and has the following format, where page 0 is the first page of the cluster: </p><pre class="fragment">+--------+-------------------+
| Page 0 | Page 1 ... Page N |
+--------+-------------------+
| Super  |  Metadata Region  |
| Block  |                   |
+--------+-------------------+
</pre><p>Or formally: </p><pre class="fragment">&lt;cluster0&gt; ::= &lt;super-block&gt; &lt;metadata-region&gt;
</pre><p>The super block is a single page located at the beginning of the partition. It contains basic information about the blobstore. The metadata region is the remainder of cluster 0 and may extend to additional clusters. </p><pre class="fragment">&lt;super-block&gt; ::= &lt;sb-version&gt; &lt;sb-len&gt; &lt;sb-super-blob&gt; &lt;sb-params&gt;
                  &lt;sb-metadata-start&gt; &lt;sb-metadata-len&gt;
                  &lt;sb-blobid-start&gt; &lt;sb-blobid-len&gt; &lt;crc&gt;
&lt;sb-version&gt; ::= u32
&lt;sb-len&gt; ::= u32 # Length of this super block, in bytes. Starts from the
                 # beginning of this structure.
&lt;sb-super-blob&gt; ::= u64 # Special blobid set by the user that indicates where
                        # their starting metadata resides.

&lt;sb-md-start&gt; ::= u64 # Metadata start location, in pages
&lt;sb-md-len&gt; ::= u64 # Metadata length, in pages
&lt;sb-blobid-start&gt; ::= u32 # Start of bitmask of valid blobids (in pages)
&lt;sb-blobid-len&gt; ::= u32 # Lenget of bitmask of valid blobids (in pages)
&lt;crc&gt; ::= u32 # Crc for super block
</pre><p>The <code>&lt;sb-params&gt;</code> data contains parameters specified by the user when the blob store was initially formatted. </p><pre class="fragment">&lt;sb-params&gt; ::= &lt;sb-page-size&gt; &lt;sb-cluster-size&gt; &lt;sb-bs-type&gt;
&lt;sb-page-size&gt; ::= u32 # page size, in bytes.
                       # Must be a multiple of the logical block size.
                       # The implementation today requires this to be 4KiB.
&lt;sb-cluster-size&gt; ::= u32 # Cluster size, in bytes.
                          # Must be a multiple of the page size.
&lt;sb-bs-type&gt; ::= char[16] # Blobstore type
</pre><p>Each blob is allocated a non-contiguous set of pages inside the metadata region for its metadata. These pages form a linked list. The first page in the list will be written in place on update, while all other pages will be written to fresh locations. This requires the backing device to support an atomic write size greater than or equal to the page size to guarantee that the operation is atomic. See the section on atomicity for details.</p>
<p>Each page is defined as: </p><pre class="fragment">&lt;metadata-page&gt; ::= &lt;blob-id&gt; &lt;blob-sequence-num&gt; &lt;blob-descriptor&gt;*
                    &lt;blob-next&gt; &lt;blob-crc&gt;
&lt;blob-id&gt; ::= u64 # The blob guid
&lt;blob-sequence-num&gt; ::= u32 # The sequence number of this page in the linked
                            # list.

&lt;blob-descriptor&gt; ::= &lt;blob-descriptor-type&gt; &lt;blob-descriptor-length&gt;
                        &lt;blob-descriptor-data&gt;
&lt;blob-descriptor-type&gt; ::= u8 # 0 means padding, 1 means "extent", 2 means
                              # xattr, 3 means flags. The type
                              # describes how to interpret the descriptor data.
&lt;blob-descriptor-length&gt; ::= u32 # Length of the entire descriptor

&lt;blob-descriptor-data-padding&gt; ::= u8

&lt;blob-descriptor-data-extent&gt; ::= &lt;extent-cluster-id&gt; &lt;extent-cluster-count&gt;
&lt;extent-cluster-id&gt; ::= u32 # The cluster id where this extent starts
&lt;extent-cluster-count&gt; ::= u32 # The number of clusters in this extent

&lt;blob-descriptor-data-xattr&gt; ::= &lt;xattr-name-length&gt; &lt;xattr-value-length&gt;
                                 &lt;xattr-name&gt; &lt;xattr-value&gt;
&lt;xattr-name-length&gt; ::= u16
&lt;xattr-value-length&gt; ::= u16
&lt;xattr-name&gt; ::= u8*
&lt;xattr-value&gt; ::= u8*

&lt;blob-descriptor-data-flags&gt; ::= &lt;flags-invalid&gt; &lt;flags-data-ro&gt; &lt;flags-md-ro&gt;

&lt;flags-invalid&gt; ::= u64
&lt;flags-data-ro&gt; ::= u64
&lt;flags-md-ro&gt; ::= u64

&lt;blob-next&gt; ::= u32 # The offset into the metadata region that contains the
                    # next page of metadata. 0 means no next page.
&lt;blob-crc&gt; ::= u32 # CRC of the entire page
</pre><p>Descriptors cannot span metadata pages.</p>
<h2>Atomicity</h2>
<p>Metadata in the blobstore is cached and must be explicitly synced by the user. Data is not cached, however, so when a write completes the data can be considered durable if the metadata is synchronized. Metadata does not often change, and in fact only must be synchronized after these explicit operations:</p>
<ul>
<li>resize</li>
<li>set xattr</li>
<li>remove xattr</li>
</ul>
<p>Any other operation will not dirty the metadata. Further, the metadata for each blob is independent of all of the others, so a synchronization operation is only needed on the specific blob that is dirty.</p>
<p>The metadata consists of a linked list of pages. Updates to the metadata are done by first writing page 2 through N to a new location, writing page 1 in place to atomically update the chain, and then erasing the remainder of the old chain. The vast majority of the time, blobs consist of just a single metadata page and so this operation is very efficient. For this scheme to work the write to the first page must be atomic, which requires hardware support from the backing device. For most, if not all, NVMe SSDs, an atomic write unit of 4KiB can be expected. Devices specify their atomic write unit in their NVMe identify data - specifically in the AWUN field. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
</div>
