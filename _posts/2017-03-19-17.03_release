---
layout: post
title:  "SPDK 17.03 Release: VM Optimization & Blobstore"
author: Jonathan Stern
categories: release
---

The SPDK team is excited to announce two new ingredients that will fundamentally change how people access fast storage media and unlock a far broader set of use cases for the SPDK ingredients. Until now, users of SPDK needed significant expertise: knowledge of file system design, system architecture, device drivers, threading models, and more. The early adopters of SPDK were (and are!) incredibly technically savvy. However, the team found two ways to expose the latency and efficiency advantages of the underlying SPDK components without complex integration and, like the other SPDK components, these new ingredients can be extended to add storage services though a built-in API, allowing storage builders to create innovative, full-featured solutions.

The first new component, the SPDK vhost-scsi target, gives unmodified QEMU guest VMs access to the SPDK I/O stack (when paired with appropriate patches in the QEMU host, targeted for the QEMU 2.10 release). This will have three major effects on systems running QEMU/KVM:
1. Applications in VMs doing a lot of I/O will notice a performance increase, especially for small-block I/O, by eliminating a substantial amount of software latency from each I/O.  
2. Simultaneously, systems using SPDK will improve VM density on systems with substantial demand for I/O (e.g. systems using multiple NVMe SSDs). By reducing the compute overhead of the I/O stack, CPU cycles are freed to allow more I/O-hungry applications to be packed into the same system, improving utilization of both SSD and compute resources. 
3. Finally, shifting the bottleneck out of the I/O stack will improve the economics of cloud-scale deployment of next-generation high performance NVMe-media like Intel Optane(tm). By providing applications a low-latency, high-consistency path to access the media, the full value of Optane can be seen and fully exploited at application level. 

While the implications of using the native SPDK I/O stack ingredients are intriguing, they're only the beginning of the story. SPDK provides an abstraction layer for additional block services to be added to the framework. What do we mean by services? Replication, caching, de-duplication, encryption... you know, everything that block storage devices do beyond reading and writing blocks. We expect to see storage innovators building services and integrating them at the SPDK level, invisible to the apps in the VMs above. 

The second major ingredient released in 17.03 is the SPDK blobstore. The vast majority of applications use a file semantic to interact with the storage media -- open("file.name") -- but far fewer applications use ALL of the features of modern file systems. Indeed, some applications like databases deliberately *avoid* using many of the capabilities of the file system -- users & permissions, compression, replication settings, etc are concepts that exist at the application (and not the file system) level. For many applications, a "file" is simply some space on a persistent device with a unique file name, able to be created, read, written, and removed. For applications with simple file semantics (containers, VMs, databases, etc), the SPDK blob store provides the simplicity of an I/O path with minimal overhead. 

The blobstore and related components answer the question that SPDK users have been asking since the first days: "So, what kind of file system do you use with SPDK?" As it turns out, you don't use a file system, at least not what anyone traditionally associates with a file system.  Rather, the SPDK team has created a power-fail-safe block allocator for objects of some size ("blobs"), and called this thing a "blobstore." Then they layered a very lightweight page caching, prefetching, and naming layer on top ("blobFS"). These constitute the very minimal subset of true file system The architects of SPDK crafted the blobstore and blobFS with a clear understanding of the mechanics of the NAND and solid-state media in general, so the blobstore is able to unleash the maximum potential of both current and next-generation SSDs without compromising latency or media durability. Like the rest of the SPDK stack, it was created from scratch to run in user space without any locks, ensuring scalability as applications using it span multiple cores.

To prove the value of the blobstore, SPDK integrated with RocksDB. RocksDB, for those unfamiliar, is a very popular key-value store with a modular, pluggable back end. With early code in hand, the team used RocksDB during development to test the blobstore and blobFS implementations. The team were interested in a few metrics, but key among them was insertion throughput (how many keys-value pairs can be created per second) and random read latency, crucially the outlier or tail latency (p99.99). Details to follow in a later posts!

While we are very excited about the arrival of these new SPDK components, we must take a moment to set expectations. *This code is brand new and subject to change:* APIs for the new components are still taking their final form as the broader community looks at them through the lens of specific applications and expertise. The best way to stay in sync going forward is to participate: on the mailing list, at SPDK Meetups, or directly with other contributors via Github. Together, we'll build the framework for tomorrow's storage! 
